+++
date = '2025-11-14T8:00:00+01:00'
draft = false
title = 'Claude Code åˆ†æ 04ï¼šå·¥å…·ä¸æ‰§è¡Œå¼•æ“'
tags = ['Agent']
+++

# ğŸ› ï¸ å·¥å…·ä¸æ‰§è¡Œå¼•æ“

```mermaid
graph LR
    subgraph "å·¥å…·ç”Ÿå‘½å‘¨æœŸ"
        LLM[LLM å†³ç­–] --> ToolUse[ToolUseBlock]
        ToolUse --> Validation{è¾“å…¥éªŒè¯}
        Validation -->|é€šè¿‡| Permission{æƒé™æ£€æŸ¥}
        Validation -->|å¤±è´¥| ErrorResult[é”™è¯¯ç»“æœ]

        Permission -->|å…è®¸| Execute["Tool.call()"]
        Permission -->|æ‹’ç»| ErrorResult
        Permission -->|è¯¢é—®| UserPrompt[ç”¨æˆ·å¯¹è¯æ¡†]

        UserPrompt -->|å…è®¸| Execute
        UserPrompt -->|æ‹’ç»| ErrorResult

        Execute --> Progress[äº§å‡ºè¿›åº¦]
        Progress --> Progress
        Progress --> Result[äº§å‡ºç»“æœ]

        Result --> Transform[mapToolResult]
        Transform --> ToolResultBlock
        ErrorResult --> ToolResultBlock

        ToolResultBlock --> LLM
    end

```

## å·¥å…·æ‰§è¡Œç®¡é“ï¼šå…¨ç¨‹å¼‚æ­¥ç”Ÿæˆå™¨

Claude Code å·¥å…·ç³»ç»Ÿæœ€è¿·äººçš„æ–¹é¢æ˜¯åœ¨æ•´ä¸ªæ‰§è¡Œç®¡é“ä¸­ä½¿ç”¨å¼‚æ­¥ç”Ÿæˆå™¨ã€‚è¿™å…è®¸åœ¨ä¿æŒæ¸…æ™°çš„é”™è¯¯è¾¹ç•Œçš„åŒæ—¶æµå¼ä¼ è¾“è¿›åº¦æ›´æ–°ï¼š

```typescript
// æ ¸å¿ƒå·¥å…·æ‰§è¡Œå‡½æ•°ï¼ˆé‡æ„ç‰ˆï¼‰
async function* executeTool(
  toolUse: ToolUseBlock,
  toolDef: ToolDefinition,
  context: ToolUseContext,
  permissionFn: PermissionGranter,
  assistantMessage: CliMessage
): AsyncGenerator<CliMessage, void, void> {
  // é˜¶æ®µ 1ï¼šä½¿ç”¨ Zod è¿›è¡Œè¾“å…¥éªŒè¯
  const validationStart = performance.now();
  const validation = toolDef.inputSchema.safeParse(toolUse.input);

  if (!validation.success) {
    // ä¸º LLM æ¶ˆè´¹æ ¼å¼åŒ– Zod é”™è¯¯
    const errorMessage = formatZodError(validation.error);
    yield createToolResultMessage({
      tool_use_id: toolUse.id,
      content: [{
        type: 'text',
        text: `Input validation failed:\\n${errorMessage}`
      }],
      is_error: true
    });
    return;
  }

  // é˜¶æ®µ 2ï¼šæƒé™æ£€æŸ¥
  const permissionResult = await checkToolPermission(
    toolDef,
    validation.data,
    context.getToolPermissionContext(),
    permissionFn
  );

  if (permissionResult.behavior === 'deny') {
    yield createToolResultMessage({
      tool_use_id: toolUse.id,
      content: [{
        type: 'text',
        text: `Permission denied: ${permissionResult.message}`
      }],
      is_error: true
    });
    return;
  }

  if (permissionResult.behavior === 'ask') {
    // ä¸ºæƒé™å¯¹è¯æ¡†äº§å‡º UI äº‹ä»¶
    yield {
      type: 'permission_request',
      toolName: toolDef.name,
      input: validation.data,
      suggestions: permissionResult.ruleSuggestions
    };

    // ç­‰å¾…ç”¨æˆ·å†³ç­–ï¼ˆç”±å¤–å±‚å¾ªç¯å¤„ç†ï¼‰
    const decision = await permissionFn(
      toolDef,
      validation.data,
      permissionResult
    );

    if (!decision.allowed) {
      yield createToolResultMessage({
        tool_use_id: toolUse.id,
        content: [{
          type: 'text',
          text: 'Tool execution cancelled by user'
        }],
        is_error: true
      });
      return;
    }
  }

  // é˜¶æ®µ 3ï¼šå¸¦è¿›åº¦è·Ÿè¸ªçš„å·¥å…·æ‰§è¡Œ
  try {
    const executeStart = performance.now();
    let progressCount = 0;
    let finalResult = null;

    // è°ƒç”¨å·¥å…·çš„å¼‚æ­¥ç”Ÿæˆå™¨
    for await (const output of toolDef.call(
      validation.data,
      context,
      undefined, // mcpContext - æŒ‰è¦æ±‚è·³è¿‡
      assistantMessage
    )) {
      if (output.type === 'progress') {
        progressCount++;
        yield {
          type: 'progress',
          uuid: `progress-${toolUse.id}-${progressCount}`,
          timestamp: new Date().toISOString(),
          progress: {
            toolUseID: toolUse.id,
            data: output.data
          }
        };
      } else if (output.type === 'result') {
        finalResult = output.data;
      }
    }

    // é˜¶æ®µ 4ï¼šç»“æœè½¬æ¢
    if (finalResult !== null) {
      const content = toolDef.mapToolResultToToolResultBlockParam(
        finalResult,
        toolUse.id
      );

      yield createToolResultMessage({
        tool_use_id: toolUse.id,
        content: Array.isArray(content) ? content : [content],
        is_error: false,
        executionTime: performance.now() - executeStart
      });
    }
  } catch (error) {
    // å¸¦ä¸°å¯Œä¸Šä¸‹æ–‡çš„é”™è¯¯å¤„ç†
    yield createToolResultMessage({
      tool_use_id: toolUse.id,
      content: formatToolError(error, toolDef),
      is_error: true
    });
  }
}

```

**æ€§èƒ½ç‰¹å¾**ï¼š
- è¾“å…¥éªŒè¯ï¼šO(n)ï¼Œå…¶ä¸­ n æ˜¯è¾“å…¥å¤æ‚åº¦ï¼Œé€šå¸¸ <1ms
- æƒé™æ£€æŸ¥ï¼šO(è§„åˆ™æ•°) + æ½œåœ¨çš„ç”¨æˆ·äº¤äº’æ—¶é—´
- å·¥å…·æ‰§è¡Œï¼šæ ¹æ®å·¥å…·å·®å¼‚å¾ˆå¤§ï¼ˆ10ms åˆ° 30sï¼‰
- ç»“æœè½¬æ¢ï¼šO(è¾“å‡ºå¤§å°)ï¼Œé€šå¸¸ <5ms

## Shell è§£æå™¨ï¼šClaude Code çš„ç§˜å¯†æ­¦å™¨

æœ€å…·åˆ›æ–°æ€§çš„ç»„ä»¶ä¹‹ä¸€æ˜¯è‡ªå®šä¹‰ shell è§£æå™¨ï¼Œå®ƒä½¿å¾—èƒ½å¤Ÿé€šè¿‡ shell å‘½ä»¤ä¼ é€’ JavaScript å¯¹è±¡ï¼š

```typescript
// Shell è§£æå™¨å®ç°ï¼ˆä»åç¼–è¯‘ä¸­é‡æ„ï¼‰
class ShellParser {
  private static OPERATORS = /(\\|\\||&&|;;|\\|&|\\||<|>|>>|&|\\(|\\))/;
  private static SINGLE_QUOTE = /^'([^']*)'$/;
  private static DOUBLE_QUOTE = /^"([^"\\]*(\\.[^"\\]*)*)"$/;

  // é­”æ³•ï¼šç”¨äºå¯¹è±¡åµŒå…¥çš„éšæœºå“¨å…µå€¼
  private static SENTINEL = crypto.randomBytes(16).toString('hex');

  static parse(
    command: string,
    env: Record<string, any>,
    opts?: (token: string) => any
  ): ParsedCommand {
    // é˜¶æ®µ 1ï¼šå¸¦å¯¹è±¡åºåˆ—åŒ–çš„å˜é‡å±•å¼€
    const expandedCommand = this.expandVariables(command, env);

    // é˜¶æ®µ 2ï¼šæ ‡è®°åŒ–
    const tokens = this.tokenize(expandedCommand);

    // é˜¶æ®µ 3ï¼šå¦‚æœæä¾›äº† optsï¼Œåˆ™å¯¹è±¡å†æ°´åŒ–
    if (opts && typeof opts === 'function') {
      return tokens.map(token => {
        if (this.isSerializedObject(token)) {
          return this.deserializeObject(token);
        }
        return token;
      });
    }

    return tokens;
  }

  private static expandVariables(
    command: string,
    env: Record<string, any>
  ): string {
    return command.replace(
      /\$\{?(\w+)\}?/g,
      (match, varName) => {
        const value = env[varName];

        // åˆ›æ–°ä¹‹å¤„ï¼šä½¿ç”¨å“¨å…µåºåˆ—åŒ–å¯¹è±¡
        if (typeof value === 'object' && value !== null) {
          return this.SENTINEL + JSON.stringify(value) + this.SENTINEL;
        }

        return String(value || '');
      }
    );
  }

  private static tokenize(command: string): string[] {
    const tokens: string[] = [];
    let current = '';
    let inSingleQuote = false;
    let inDoubleQuote = false;
    let escape = false;

    for (let i = 0; i < command.length; i++) {
      const char = command[i];
      const next = command[i + 1];

      // å¤„ç†å¼•å·å’Œè½¬ä¹‰
      if (!escape) {
        if (char === "'" && !inDoubleQuote) {
          inSingleQuote = !inSingleQuote;
          current += char;
          continue;
        }
        if (char === '"' && !inSingleQuote) {
          inDoubleQuote = !inDoubleQuote;
          current += char;
          continue;
        }
        if (char === '\\') {
          escape = true;
          current += char;
          continue;
        }
      } else {
        escape = false;
        current += char;
        continue;
      }

      // ä¸åœ¨å¼•å·ä¸­æ—¶å¤„ç†è¿ç®—ç¬¦
      if (!inSingleQuote && !inDoubleQuote) {
        const remaining = command.slice(i);
        const operatorMatch = remaining.match(/^(\\|\\||&&|;;|\\|&|\\||<|>|>>|&|\\(|\\))/);

        if (operatorMatch) {
          if (current) {
            tokens.push(current);
            current = '';
          }
          tokens.push(operatorMatch[1]);
          i += operatorMatch[1].length - 1;
          continue;
        }

        // å¤„ç†ç©ºç™½
        if (/\s/.test(char)) {
          if (current) {
            tokens.push(current);
            current = '';
          }
          continue;
        }
      }

      current += char;
    }

    if (current) {
      tokens.push(current);
    }

    return tokens;
  }

  private static isSerializedObject(token: string): boolean {
    return token.startsWith(this.SENTINEL) &&
           token.endsWith(this.SENTINEL);
  }

  private static deserializeObject(token: string): any {
    const json = token.slice(
      this.SENTINEL.length,
      -this.SENTINEL.length
    );

    try {
      return JSON.parse(json);
    } catch {
      return token; // å›é€€åˆ°å­—ç¬¦ä¸²
    }
  }
}

```

æ­¤è§£æå™¨ä½¿å¾—å¦‚ä¸‹å‘½ä»¤æˆä¸ºå¯èƒ½ï¼š

```shell
# å…¶ä¸­ $CONFIG æ˜¯ä¸€ä¸ª JavaScript å¯¹è±¡
mytool --config=$CONFIG --name="test"

# ç»è¿‡å†æ°´åŒ–è§£æåå˜æˆï¼š
['mytool', '--config', {setting: true, values: [1,2,3]}, '--name', 'test']

```

## æ ¸å¿ƒæ–‡ä»¶æ“ä½œå·¥å…·

### ReadToolï¼šå¤šæ¨¡æ€æ–‡ä»¶è¯»å–å™¨

```typescript
// ReadTool å®ç°ï¼ˆé‡æ„ç‰ˆï¼‰
const ReadToolDefinition: ToolDefinition = {
  name: 'ReadFileTool',
  description: 'å¸¦è¡Œå·è¯»å–æ–‡ä»¶å†…å®¹ï¼Œæ”¯æŒæ–‡æœ¬å’Œå›¾åƒ',

  inputSchema: z.object({
    file_path: z.string().describe('æ–‡ä»¶çš„ç»å¯¹è·¯å¾„'),
    offset: z.number().optional().describe('èµ·å§‹è¡Œå·ï¼ˆä» 1 å¼€å§‹ï¼‰'),
    limit: z.number().optional().default(2000).describe('æœ€å¤§è¯»å–è¡Œæ•°')
  }),

  async *call(input, context) {
    const { file_path, offset = 1, limit = 2000 } = input;

    // è¿›åº¦ï¼šå¼€å§‹è¯»å–
    yield {
      type: 'progress',
      toolUseID: context.currentToolUseId,
      data: { status: `Reading ${path.basename(file_path)}...` }
    };

    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    const stats = await fs.stat(file_path).catch(() => null);
    if (!stats) {
      throw new Error(`File not found: ${file_path}`);
    }

    // æ£€æµ‹æ–‡ä»¶ç±»å‹
    const mimeType = await detectMimeType(file_path);

    if (mimeType.startsWith('image/')) {
      // å¤„ç†å›¾åƒæ–‡ä»¶
      const imageData = await this.readImage(file_path, context);
      yield { type: 'result', data: imageData };
      return;
    }

    if (file_path.endsWith('.ipynb')) {
      // å¤„ç† Jupyter notebooks
      const notebookData = await this.readNotebook(file_path, offset, limit);
      yield { type: 'result', data: notebookData };
      return;
    }

    // ä½¿ç”¨æµå¼å¤„ç†æ–‡æœ¬æ–‡ä»¶
    const content = await this.readTextFile(file_path, offset, limit);

    // æ›´æ–°æ–‡ä»¶ç¼“å­˜
    context.readFileState.set(file_path, {
      content: content.fullContent,
      timestamp: stats.mtimeMs
    });

    yield { type: 'result', data: content };
  },

  async readTextFile(filePath: string, offset: number, limit: number) {
    const stream = createReadStream(filePath, { encoding: 'utf8' });
    const lines: string[] = [];
    let lineNumber = 0;
    let truncated = false;

    for await (const chunk of stream) {
      const chunkLines = chunk.split('\\n');

      for (const line of chunkLines) {
        lineNumber++;

        if (lineNumber >= offset && lines.length < limit) {
          // æˆªæ–­é•¿è¡Œ
          const truncatedLine = line.length > 2000
            ? line.substring(0, 2000) + '... (truncated)'
            : line;

          // ä½¿ç”¨è¡Œå·æ ¼å¼åŒ–ï¼ˆcat -n é£æ ¼ï¼‰
          lines.push(`${lineNumber}\\t${truncatedLine}`);
        }

        if (lines.length >= limit) {
          truncated = true;
          stream.destroy();
          break;
        }
      }
    }

    return {
      formattedContent: lines.join('\\n'),
      fullContent: await fs.readFile(filePath, 'utf8'),
      lineCount: lineNumber,
      truncated
    };
  },

  async readImage(filePath: string, context: ToolUseContext) {
    const buffer = await fs.readFile(filePath);
    const metadata = await sharp(buffer).metadata();

    // å¦‚æœå¤ªå¤§åˆ™è°ƒæ•´å¤§å°
    let processedBuffer = buffer;
    if (metadata.width > 1024 || metadata.height > 1024) {
      processedBuffer = await sharp(buffer)
        .resize(1024, 1024, {
          fit: 'inside',
          withoutEnlargement: true
        })
        .toBuffer();
    }

    return {
      type: 'image',
      mimeType: `image/${metadata.format}`,
      base64: processedBuffer.toString('base64'),
      dimensions: {
        original: { width: metadata.width, height: metadata.height },
        processed: { width: 1024, height: 1024 }
      }
    };
  },

  mapToolResultToToolResultBlockParam(result, toolUseId) {
    if (result.type === 'image') {
      return [{
        type: 'image',
        source: {
          type: 'base64',
          media_type: result.mimeType,
          data: result.base64
        }
      }];
    }

    // ç©ºæ–‡ä»¶å¤„ç†
    if (!result.formattedContent || result.formattedContent.trim() === '') {
      return [{
        type: 'text',
        text: '<system-reminder>Warning: the file exists but the contents are empty.</system-reminder>'
      }];
    }

    // æ­£å¸¸æ–‡æœ¬ç»“æœ
    return [{
      type: 'text',
      text: result.formattedContent +
            (result.truncated ? '\\n... (content truncated)' : '')
    }];
  },

  isReadOnly: true
};

```

**æ€§èƒ½æ¦‚å†µ**ï¼š

| æ–‡ä»¶å¤§å° | è¯»å–æ—¶é—´ | å†…å­˜ä½¿ç”¨ | ç“¶é¢ˆ |
|---------|---------|---------|------|
| <1MB | <10ms | O(file) | ç£ç›˜ I/O |
| 1-10MB | 10-50ms | O(file) | å†…å­˜åˆ†é… |
| 10-100MB | 50-500ms | O(limit) | è¡Œå¤„ç† |
| >100MB | 500ms+ | O(limit) | æµå¼åˆ†å— |

### EditToolï¼šç²¾ç¡®æ–‡ä»¶ä¿®æ”¹

```typescript
// EditTool å®ç°ï¼Œå¸¦éªŒè¯ç®¡é“
const EditToolDefinition: ToolDefinition = {
  name: 'EditFileTool',
  description: 'åœ¨æ–‡ä»¶ä¸­æ‰§è¡Œç²¾ç¡®çš„å­—ç¬¦ä¸²æ›¿æ¢å¹¶è¿›è¡ŒéªŒè¯',

  inputSchema: z.object({
    file_path: z.string(),
    old_string: z.string().min(1),
    new_string: z.string(),
    expected_replacements: z.number().optional().default(1)
  }),

  async *call(input, context) {
    const { file_path, old_string, new_string, expected_replacements } = input;

    // éªŒè¯ 1ï¼šæ–‡ä»¶å·²è¢«è¯»å–
    const cachedFile = context.readFileState.get(file_path);
    if (!cachedFile) {
      throw new Error('File must be read with ReadFileTool before editing');
    }

    // éªŒè¯ 2ï¼šæ–‡ä»¶æœªè¢«å¤–éƒ¨æ›´æ”¹
    const currentStats = await fs.stat(file_path);
    if (currentStats.mtimeMs !== cachedFile.timestamp) {
      throw new Error('File has been modified externally since last read');
    }

    // éªŒè¯ 3ï¼šæ— æ“ä½œæ£€æŸ¥
    if (old_string === new_string) {
      throw new Error('old_string and new_string cannot be identical');
    }

    yield {
      type: 'progress',
      toolUseID: context.currentToolUseId,
      data: { status: 'Validating edit...' }
    };

    // è®¡æ•°å‡ºç°æ¬¡æ•°
    const occurrences = this.countOccurrences(
      cachedFile.content,
      old_string
    );

    if (occurrences === 0) {
      throw new Error(`old_string not found in file`);
    }

    if (occurrences !== expected_replacements) {
      throw new Error(
        `Expected ${expected_replacements} replacements but found ${occurrences}`
      );
    }

    // æ‰§è¡Œæ›¿æ¢
    const newContent = this.performReplacement(
      cachedFile.content,
      old_string,
      new_string,
      expected_replacements
    );

    // ç”Ÿæˆå·®å¼‚é¢„è§ˆ
    const diff = this.generateDiff(
      cachedFile.content,
      newContent,
      file_path
    );

    yield {
      type: 'progress',
      toolUseID: context.currentToolUseId,
      data: {
        status: 'Applying edit...',
        preview: diff
      }
    };

    // å†™å…¥æ–‡ä»¶
    await this.writeFileWithBackup(file_path, newContent);

    // æ›´æ–°ç¼“å­˜
    context.readFileState.set(file_path, {
      content: newContent,
      timestamp: Date.now()
    });

    // ç”Ÿæˆç»“æœç‰‡æ®µ
    const snippet = this.getContextSnippet(
      newContent,
      new_string,
      5 // ä¸Šä¸‹æ–‡è¡Œæ•°
    );

    yield {
      type: 'result',
      data: {
        success: true,
        diff,
        snippet,
        replacements: expected_replacements
      }
    };
  },

  countOccurrences(content: string, searchString: string): number {
    // è½¬ä¹‰ç‰¹æ®Šæ­£åˆ™å­—ç¬¦
    const escaped = searchString.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(escaped, 'g');
    return (content.match(regex) || []).length;
  },

  performReplacement(
    content: string,
    oldString: string,
    newString: string,
    limit: number
  ): string {
    // æ›¿æ¢æœŸé—´å¯¹æŸäº›å­—ç¬¦çš„ç‰¹æ®Šå¤„ç†
    const tempOld = oldString.replace(/\$/g, '$$$$');
    const tempNew = newString.replace(/\$/g, '$$$$');

    let result = content;
    let count = 0;
    let lastIndex = 0;

    while (count < limit) {
      const index = result.indexOf(oldString, lastIndex);
      if (index === -1) break;

      result = result.slice(0, index) +
               newString +
               result.slice(index + oldString.length);

      lastIndex = index + newString.length;
      count++;
    }

    return result;
  },

  mapToolResultToToolResultBlockParam(result, toolUseId) {
    return [{
      type: 'text',
      text: `Successfully edited file. ${result.replacements} replacement(s) made.\\n\\n` +
            `Preview of changes:\\n${result.snippet}`
    }];
  },

  isReadOnly: false
};

```

### MultiEditToolï¼šåŸå­æ€§é¡ºåºç¼–è¾‘

```typescript
// MultiEditTool - å¤æ‚çš„é¡ºåºç¼–è¾‘ç¼–æ’
const MultiEditToolDefinition: ToolDefinition = {
  name: 'MultiEditFileTool',
  description: 'åŸå­æ€§åœ°å¯¹æ–‡ä»¶åº”ç”¨å¤šä¸ªç¼–è¾‘',

  inputSchema: z.object({
    file_path: z.string(),
    edits: z.array(z.object({
      old_string: z.string(),
      new_string: z.string(),
      expected_replacements: z.number().optional().default(1)
    })).min(1)
  }),

  async *call(input, context) {
    const { file_path, edits } = input;

    // åŠ è½½æ–‡ä»¶å†…å®¹
    const cachedFile = context.readFileState.get(file_path);
    if (!cachedFile) {
      throw new Error('File must be read before editing');
    }

    yield {
      type: 'progress',
      toolUseID: context.currentToolUseId,
      data: {
        status: `Planning ${edits.length} edits...`,
        editCount: edits.length
      }
    };

    // æ¨¡æ‹Ÿæ‰€æœ‰ç¼–è¾‘ä»¥æ£€æŸ¥å†²çª
    let workingContent = cachedFile.content;
    const editResults = [];

    for (let i = 0; i < edits.length; i++) {
      const edit = edits[i];

      yield {
        type: 'progress',
        toolUseID: context.currentToolUseId,
        data: {
          status: `Validating edit ${i + 1}/${edits.length}`,
          currentEdit: i + 1
        }
      };

      // æ£€æŸ¥æ­¤ç¼–è¾‘æ˜¯å¦æœ‰æ•ˆ
      const occurrences = this.countOccurrences(
        workingContent,
        edit.old_string
      );

      if (occurrences === 0) {
        throw new Error(
          `Edit ${i + 1}: old_string not found. ` +
          `This may be due to previous edits modifying the text.`
        );
      }

      if (occurrences !== edit.expected_replacements) {
        throw new Error(
          `Edit ${i + 1}: Expected ${edit.expected_replacements} ` +
          `replacements but found ${occurrences}`
        );
      }

      // å°†ç¼–è¾‘åº”ç”¨åˆ°å·¥ä½œå‰¯æœ¬
      workingContent = this.performReplacement(
        workingContent,
        edit.old_string,
        edit.new_string,
        edit.expected_replacements
      );

      editResults.push({
        index: i + 1,
        summary: this.summarizeEdit(edit)
      });
    }

    // æ‰€æœ‰ç¼–è¾‘å·²éªŒè¯ - ç°åœ¨åŸå­æ€§åº”ç”¨
    yield {
      type: 'progress',
      toolUseID: context.currentToolUseId,
      data: { status: 'Applying all edits...' }
    };

    await this.writeFileWithBackup(file_path, workingContent);

    // æ›´æ–°ç¼“å­˜
    context.readFileState.set(file_path, {
      content: workingContent,
      timestamp: Date.now()
    });

    yield {
      type: 'result',
      data: {
        success: true,
        editsApplied: editResults,
        finalContent: this.getFileSnippet(workingContent)
      }
    };
  },

  // ç¼–è¾‘åºåˆ—çš„å†²çªæ£€æµ‹
  detectEditConflicts(edits: EditSequence[]): ConflictReport {
    const conflicts = [];

    for (let i = 0; i < edits.length - 1; i++) {
      for (let j = i + 1; j < edits.length; j++) {
        // æ£€æŸ¥ç¼–è¾‘ j çš„ old_string æ˜¯å¦åŒ…å«ç¼–è¾‘ i çš„ new_string
        if (edits[j].old_string.includes(edits[i].new_string)) {
          conflicts.push({
            edit1: i,
            edit2: j,
            type: 'dependency',
            message: `Edit ${j+1} depends on result of edit ${i+1}`
          });
        }

        // æ£€æŸ¥é‡å åŒºåŸŸ
        if (this.editsOverlap(edits[i], edits[j])) {
          conflicts.push({
            edit1: i,
            edit2: j,
            type: 'overlap',
            message: `Edits ${i+1} and ${j+1} may affect same region`
          });
        }
      }
    }

    return conflicts;
  },

  isReadOnly: false
};

```

## BashToolï¼šæƒåŠ›ä¸è´£ä»»

BashTool å¯èƒ½æ˜¯æœ€å¤æ‚çš„å·¥å…·ï¼Œå®ç°äº†å¤šä¸ªå®‰å…¨å±‚ï¼š

```typescript
// BashTool å®ç°ï¼Œæ”¯æŒæ²™ç›’
const BashToolDefinition: ToolDefinition = {
  name: 'BashTool',
  description: 'ä½¿ç”¨æµå¼è¾“å‡ºæ‰§è¡Œ shell å‘½ä»¤',

  inputSchema: z.object({
    command: z.string(),
    timeout: z.number().optional().default(30000),
    description: z.string().optional(),
    sandbox: z.boolean().optional(),
    shellExecutable: z.string().optional()
  }),

  // å‘½ä»¤çš„å¤æ‚æƒé™æ£€æŸ¥
  async checkPermissions(input, context, permContext) {
    const { command, sandbox } = input;

    // æå–å‘½ä»¤ç»„ä»¶
    const parsed = ShellParser.parse(command, process.env);
    const baseCommand = parsed[0];

    // ç¦æ­¢å‘½ä»¤æ£€æŸ¥
    const FORBIDDEN = ['find', 'grep', 'cat', 'head', 'tail', 'ls'];
    if (FORBIDDEN.includes(baseCommand) && !permContext.mode.includes('bypass')) {
      return {
        behavior: 'deny',
        message: `Use dedicated tools instead of ${baseCommand}`
      };
    }

    // å±é™©å‘½ä»¤éœ€è¦æ˜ç¡®æƒé™
    const DANGEROUS = ['rm', 'dd', 'mkfs', 'fdisk', 'kill'];
    if (DANGEROUS.some(cmd => command.includes(cmd))) {
      return {
        behavior: 'ask',
        message: 'This command could be dangerous',
        ruleSuggestions: [`BashTool(${baseCommand}/*)`]
      };
    }

    // æ²™ç›’æ¨¡å¼åˆ†æ
    if (sandbox === true) {
      // åœ¨æ²™ç›’ä¸­å¯ç”¨çš„å‘½ä»¤
      const SANDBOX_SAFE = ['echo', 'pwd', 'env', 'date', 'which'];
      if (SANDBOX_SAFE.includes(baseCommand)) {
        return { behavior: 'allow' };
      }
    }

    // é»˜è®¤æƒé™æ£€æŸ¥
    return await super.checkPermissions(input, context, permContext);
  },

  async *call(input, context) {
    const { command, timeout, sandbox = false } = input;

    yield {
      type: 'progress',
      toolUseID: context.currentToolUseId,
      data: {
        status: 'Preparing command execution...',
        command: command.substring(0, 100),
        sandbox
      }
    };

    // å‡†å¤‡æ‰§è¡Œç¯å¢ƒ
    const execOptions = {
      cwd: context.cwd,
      env: { ...process.env, CLAUDE_CODE: 'true' },
      timeout,
      maxBuffer: 10 * 1024 * 1024, // 10MB
      killSignal: 'SIGTERM'
    };

    if (sandbox && process.platform === 'darwin') {
      // macOS sandbox-exec
      const profile = this.generateSandboxProfile();
      const sandboxedCommand = `sandbox-exec -p '${profile}' ${command}`;
      return yield* this.executeCommand(sandboxedCommand, execOptions, context);
    }

    yield* this.executeCommand(command, execOptions, context);
  },

  async *executeCommand(command, options, context) {
    const startTime = Date.now();
    const child = spawn('bash', ['-c', command], options);

    let stdout = '';
    let stderr = '';
    let outputSize = 0;
    const MAX_OUTPUT = 1024 * 1024; // 1MB é™åˆ¶

    // æµå¼ä¼ è¾“ stdout
    child.stdout.on('data', (chunk) => {
      const text = chunk.toString();
      stdout += text;
      outputSize += chunk.length;

      if (outputSize < MAX_OUTPUT) {
        // ä½¿ç”¨æµå¼è¾“å‡ºäº§å‡ºè¿›åº¦
        context.yieldProgress({
          type: 'stdout',
          data: text,
          partial: true
        });
      }
    });

    // æµå¼ä¼ è¾“ stderr
    child.stderr.on('data', (chunk) => {
      const text = chunk.toString();
      stderr += text;
      outputSize += chunk.length;

      if (outputSize < MAX_OUTPUT) {
        context.yieldProgress({
          type: 'stderr',
          data: text,
          partial: true
        });
      }
    });

    // å¤„ç†è¿›ç¨‹å®Œæˆ
    const result = await new Promise((resolve, reject) => {
      child.on('error', reject);

      child.on('exit', (code, signal) => {
        resolve({
          exitCode: code,
          signal,
          stdout: stdout.substring(0, MAX_OUTPUT),
          stderr: stderr.substring(0, MAX_OUTPUT),
          truncated: outputSize > MAX_OUTPUT,
          duration: Date.now() - startTime
        });
      });

      // å¤„ç†ä¸­æ­¢ä¿¡å·
      context.abortController.signal.addEventListener('abort', () => {
        child.kill('SIGTERM');
      });
    });

    yield {
      type: 'result',
      data: result
    };
  },

  generateSandboxProfile(): string {
    // macOS çš„é™åˆ¶æ€§æ²™ç›’é…ç½®
    return `
      (version 1)
      (deny default)
      (allow process-exec (literal "/bin/bash"))
      (allow process-exec (literal "/usr/bin/env"))
      (allow file-read*)
      (deny file-write*)
      (deny network*)
      (allow sysctl-read)
    `;
  },

  // Git å·¥ä½œæµè‡ªåŠ¨åŒ–
  async *handleGitCommit(args, context) {
    // é˜¶æ®µ 1ï¼šå¹¶è¡Œä¿¡æ¯æ”¶é›†
    const [status, diff, log] = await Promise.all([
      this.runCommand('git status --porcelain'),
      this.runCommand('git diff --cached'),
      this.runCommand('git log -5 --oneline')
    ]);

    yield {
      type: 'progress',
      toolUseID: context.currentToolUseId,
      data: {
        status: 'Analyzing changes...',
        files: status.split('\\n').length - 1
      }
    };

    // é˜¶æ®µ 2ï¼šç”Ÿæˆæäº¤æ¶ˆæ¯
    const commitAnalysis = await this.analyzeChangesForCommit(
      status,
      diff,
      context
    );

    // é˜¶æ®µ 3ï¼šä½¿ç”¨ HEREDOC æ‰§è¡Œæäº¤
    const commitCommand = `git commit -m "$(cat <<'EOF'
${commitAnalysis.message}

Co-authored-by: Claude <claude@anthropic.com>
EOF
)"`;

    yield* this.executeCommand(commitCommand, {}, context);
  },

  mapToolResultToToolResultBlockParam(result, toolUseId) {
    const output = [];

    if (result.stdout) {
      output.push(`stdout:\\n${result.stdout}`);
    }

    if (result.stderr) {
      output.push(`stderr:\\n${result.stderr}`);
    }

    output.push(`Exit code: ${result.exitCode}`);

    if (result.truncated) {
      output.push('\\n(Output truncated due to size limits)');
    }

    return [{
      type: 'text',
      text: output.join('\\n\\n')
    }];
  },

  isReadOnly: false
};

```

**æ²™ç›’æ¨¡å¼å†³ç­–æ ‘**ï¼š

```plain text
å‘½ä»¤åˆ†æ
â”œâ”€ æ˜¯å¦ä¸ºè¯»å–æ“ä½œï¼Ÿ(ls, cat, grep)
â”‚  â””â”€ æ˜¯ â†’ sandbox=true âœ“
â”œâ”€ æ˜¯å¦éœ€è¦ç½‘ç»œï¼Ÿ(curl, wget, git)
â”‚  â””â”€ æ˜¯ â†’ sandbox=false âœ“
â”œâ”€ æ˜¯å¦å†™å…¥æ–‡ä»¶ï¼Ÿ(touch, echo >)
â”‚  â””â”€ æ˜¯ â†’ sandbox=false âœ“
â”œâ”€ æ˜¯å¦ä¸ºæ„å»ºå‘½ä»¤ï¼Ÿ(npm, make, cargo)
â”‚  â””â”€ æ˜¯ â†’ sandbox=false âœ“
â””â”€ é»˜è®¤ â†’ sandbox=true (å®‰å…¨é»˜è®¤å€¼)

```

## æœç´¢ä¸å‘ç°å·¥å…·

### GrepToolï¼šé«˜æ€§èƒ½å†…å®¹æœç´¢

```typescript
// GrepTool å¸¦ä¼˜åŒ–ç­–ç•¥
const GrepToolDefinition: ToolDefinition = {
  name: 'GrepTool',
  description: 'è·¨æ–‡ä»¶å¿«é€Ÿæ­£åˆ™è¡¨è¾¾å¼æœç´¢',

  inputSchema: z.object({
    regex: z.string(),
    path: z.string().optional().default('.'),
    include_pattern: z.string().optional()
  }),

  async *call(input, context) {
    const { regex, path, include_pattern } = input;

    // éªŒè¯æ­£åˆ™è¡¨è¾¾å¼
    try {
      new RegExp(regex);
    } catch (e) {
      throw new Error(`Invalid regex: ${e.message}`);
    }

    yield {
      type: 'progress',
      toolUseID: context.currentToolUseId,
      data: { status: 'Searching files...' }
    };

    // ä½¿ç”¨ ripgrep ä»¥è·å¾—æ€§èƒ½
    const rgCommand = this.buildRipgrepCommand(regex, path, include_pattern);
    const matches = await this.executeRipgrep(rgCommand);

    // æŒ‰æ–‡ä»¶åˆ†ç»„å¹¶é™åˆ¶ç»“æœ
    const fileGroups = this.groupMatchesByFile(matches);
    const topFiles = this.selectTopFiles(fileGroups, 20); // å‰ 20 ä¸ªæ–‡ä»¶

    yield {
      type: 'result',
      data: {
        matchCount: matches.length,
        fileCount: fileGroups.size,
        files: topFiles
      }
    };
  },

  buildRipgrepCommand(regex: string, path: string, includePattern?: string): string {
    const args = [
      'rg',
      '--files-with-matches',
      '--sort=modified',
      '--max-count=10', // é™åˆ¶æ¯ä¸ªæ–‡ä»¶çš„åŒ¹é…æ•°
      '-e', regex,
      path
    ];

    if (includePattern) {
      args.push('--glob', includePattern);
    }

    // å¿½ç•¥å¸¸è§éæ–‡æœ¬æ–‡ä»¶
    const ignorePatterns = [
      '*.jpg', '*.png', '*.gif',
      '*.mp4', '*.mov',
      '*.zip', '*.tar', '*.gz',
      'node_modules', '.git'
    ];

    ignorePatterns.forEach(pattern => {
      args.push('--glob', `!${pattern}`);
    });

    return args.join(' ');
  },

  isReadOnly: true
};

```

### AgentToolï¼šåˆ†å±‚ä»»åŠ¡åˆ†è§£

```typescript
// AgentTool - æœ€å¤æ‚çš„å·¥å…·
const AgentToolDefinition: ToolDefinition = {
  name: 'AgentTool',
  description: 'å¯åŠ¨å­ä»£ç†æ‰§è¡Œå¤æ‚ä»»åŠ¡',

  inputSchema: z.object({
    description: z.string().min(3).max(100),
    prompt: z.string().min(10),
    parallelTasksCount: z.number().optional().default(1).max(5),
    model: z.string().optional()
  }),

  async *call(input, context, mcpContext, assistantMessage) {
    const { prompt, parallelTasksCount, model } = input;

    yield {
      type: 'progress',
      toolUseID: context.currentToolUseId,
      data: {
        status: 'Analyzing task complexity...',
        parallel: parallelTasksCount > 1
      }
    };

    // å‡†å¤‡å­ä»£ç†é…ç½®
    const subAgentConfig = {
      tools: this.filterToolsForSubAgent(context.options.tools),
      model: model || 'claude-3-haiku-20240307', // é»˜è®¤å¿«é€Ÿæ¨¡å‹
      maxTokens: this.calculateTokenBudget(prompt),
      systemPrompt: this.buildSubAgentPrompt(prompt)
    };

    // æ‰§è¡Œå­ä»£ç†
    const results = await this.executeSubAgents(
      prompt,
      parallelTasksCount,
      subAgentConfig,
      context
    );

    // æŠ¥å‘Šè¿›åº¦
    for (const result of results) {
      yield {
        type: 'progress',
        toolUseID: context.currentToolUseId,
        data: {
          status: `Sub-agent ${result.index} complete`,
          tokensUsed: result.usage.total_tokens
        }
      };
    }

    // ç»¼åˆé˜¶æ®µ
    if (results.length > 1) {
      yield {
        type: 'progress',
        toolUseID: context.currentToolUseId,
        data: { status: 'Synthesizing results...' }
      };

      const synthesized = await this.synthesizeResults(
        results,
        prompt,
        context
      );

      yield { type: 'result', data: synthesized };
    } else {
      yield { type: 'result', data: results[0].content };
    }
  },

  filterToolsForSubAgent(allTools: ToolDefinition[]): ToolDefinition[] {
    // é˜²æ­¢æ— é™é€’å½’
    return allTools.filter(tool =>
      tool.name !== 'AgentTool' &&
      tool.name !== 'UpdateTodoTool' // å­ä»£ç†ä¸ç®¡ç†å¾…åŠäº‹é¡¹
    );
  },

  async executeSubAgents(
    prompt: string,
    count: number,
    config: SubAgentConfig,
    context: ToolUseContext
  ): Promise<SubAgentResult[]> {
    // å¦‚æœå¹¶è¡Œåˆ™æ‹†åˆ†ä»»åŠ¡
    const subtasks = count > 1
      ? this.splitTask(prompt, count)
      : [prompt];

    // åˆ›å»ºé“¾æ¥åˆ°çˆ¶çº§çš„ä¸­æ­¢æ§åˆ¶å™¨
    const subControllers = subtasks.map(() =>
      this.createLinkedAbortController(context.abortController)
    );

    // ä½¿ç”¨å¹¶å‘é™åˆ¶å¹¶è¡Œæ‰§è¡Œ
    const executions = subtasks.map((task, index) =>
      this.runSubAgent({
        task,
        index,
        config,
        controller: subControllers[index],
        sharedState: {
          readFileState: context.readFileState, // å…±äº«ç¼“å­˜
          permissionContext: context.getToolPermissionContext()
        }
      })
    );

    // ä½¿ç”¨ parallelMap è¿›è¡Œå—æ§å¹¶å‘
    const results = [];
    for await (const result of parallelMap(executions, 5)) {
      results.push(result);
    }

    return results;
  },

  async synthesizeResults(
    results: SubAgentResult[],
    originalPrompt: string,
    context: ToolUseContext
  ): Promise<string> {
    const synthesisPrompt = `
æ‚¨æ˜¯ä¸€ä¸ªç»¼åˆä»£ç†ã€‚å¤šä¸ªå­ä»£ç†å·²å®Œæˆè°ƒæŸ¥ã€‚
å°†ä»–ä»¬çš„å‘ç°ç»¼åˆæˆå•ä¸€ã€è¿è´¯çš„å“åº”ã€‚

åŸå§‹ä»»åŠ¡ï¼š${originalPrompt}

${results.map((r, i) => `
å­ä»£ç† ${i + 1} å‘ç°ï¼š
${r.content}

ä½¿ç”¨çš„ Tokenï¼š${r.usage.total_tokens}
ä½¿ç”¨çš„å·¥å…·ï¼š${r.toolsUsed.join(', ') || 'None'}
`).join('\\n---\\n')}

æä¾›ä¸€ä¸ªç»“åˆæ‰€æœ‰å‘ç°çš„ç»Ÿä¸€å“åº”ã€‚
    `.trim();

    // ä½¿ç”¨å¿«é€Ÿæ¨¡å‹è¿›è¡Œç»¼åˆ
    const synthesizer = new SubAgentExecutor({
      prompt: synthesisPrompt,
      model: 'claude-3-haiku-20240307',
      isSynthesis: true,
      maxTokens: 2000
    });

    return synthesizer.execute();
  },

  calculateTokenBudget(prompt: string): number {
    // å¯å‘å¼ï¼šæ›´é•¿çš„æç¤ºè·å¾—æ›´å¤š token
    const baseTokens = 2000;
    const promptComplexity = prompt.split(' ').length;
    const multiplier = Math.min(promptComplexity / 50, 3);

    return Math.floor(baseTokens * multiplier);
  },

  mapToolResultToToolResultBlockParam(result, toolUseId) {
    return [{
      type: 'text',
      text: result // å·²ç”±ç»¼åˆæ ¼å¼åŒ–
    }];
  },

  isReadOnly: true // å­ä»£ç†ç»§æ‰¿çˆ¶çº§æƒé™
};

```

## å·¥å…·é€‰æ‹©ä¸ LLM å·¥ç¨‹

LLM æ¥æ”¶æœ‰å…³å·¥å…·ä½¿ç”¨çš„è¯¦ç»†è¯´æ˜ï¼š

```typescript
// å·¥å…·æŒ‡ä»¤ç¼–è¯‘å™¨ï¼ˆé‡æ„ç‰ˆï¼‰
class ToolInstructionCompiler {
  static compileSystemPrompt(tools: ToolDefinition[]): string {
    return `
## å¯ç”¨å·¥å…·

æ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å·¥å…·ï¼š

${tools.map(tool => `
### ${tool.name}
${tool.description}

${tool.prompt || ''}

è¾“å…¥æ¶æ„ï¼š
\`\`\`json
${JSON.stringify(tool.inputJSONSchema || zodToJsonSchema(tool.inputSchema), null, 2)}
\`\`\`

${this.getToolSpecificInstructions(tool)}
`).join('\\n---\\n')}

## å·¥å…·ä½¿ç”¨æŒ‡å—

1. **æ‰¹å¤„ç†**ï¼šæ‚¨å¯ä»¥åœ¨å•ä¸ªå“åº”ä¸­è°ƒç”¨å¤šä¸ªå·¥å…·ã€‚å½“è¯·æ±‚å¤šæ¡ç‹¬ç«‹ä¿¡æ¯æ—¶ï¼Œå°†æ‚¨çš„å·¥å…·è°ƒç”¨æ‰¹å¤„ç†åœ¨ä¸€èµ·ã€‚

2. **å…ˆè¯»åå†™**ï¼šåœ¨ä½¿ç”¨ EditFileTool æˆ– WriteFileTool ä¹‹å‰ï¼Œå§‹ç»ˆä½¿ç”¨ ReadFileToolã€‚

3. **ä¼˜å…ˆä½¿ç”¨ä¸“ç”¨å·¥å…·**ï¼š
   - ä½¿ç”¨ GrepTool è€Œä¸æ˜¯ BashTool é…åˆ grep
   - ä½¿ç”¨ ReadFileTool è€Œä¸æ˜¯ BashTool é…åˆ cat
   - ä½¿ç”¨ GlobTool è€Œä¸æ˜¯ BashTool é…åˆ find

4. **å®‰å…¨ç¬¬ä¸€**ï¼š
   - æœªç»ç”¨æˆ·æ˜ç¡®è¯·æ±‚ï¼Œåˆ‡å‹¿ä½¿ç”¨ BashTool æ‰§è¡Œç ´åæ€§å‘½ä»¤
   - å°½å¯èƒ½ä¸º BashTool ä½¿ç”¨ sandbox=true
   - éªŒè¯è·¯å¾„åœ¨é¡¹ç›®è¾¹ç•Œå†…

5. **è¿›åº¦é€šä¿¡**ï¼š
   - å·¥å…·æ‰§è¡Œå¯èƒ½éœ€è¦æ—¶é—´
   - ç”¨æˆ·çœ‹åˆ°è¿›åº¦æ›´æ–°
   - å¯¹é•¿æ—¶é—´è¿è¡Œçš„å·¥å…·ä¿æŒè€å¿ƒ

6. **é”™è¯¯å¤„ç†**ï¼š
   - å·¥å…·å¯èƒ½ä¼šå¤±è´¥ - å‡†å¤‡å¤‡ç”¨æ–¹æ¡ˆ
   - ä»”ç»†é˜…è¯»é”™è¯¯æ¶ˆæ¯
   - æ ¹æ®é”™è¯¯è¯¦æƒ…å»ºè®®ä¿®å¤
    `.trim();
  }

  static getToolSpecificInstructions(tool: ToolDefinition): string {
    const instructions = {
      'BashTool': `
å…³é”®ï¼š
- ç¦æ­¢å‘½ä»¤ï¼šfind, grep, cat, head, tail, lsï¼ˆä½¿ç”¨ä¸“ç”¨å·¥å…·ï¼‰
- å§‹ç»ˆä½¿ç”¨ ripgrep (rg) è€Œä¸æ˜¯ grep
- å¯¹äº git æ“ä½œï¼Œéµå¾ªç»“æ„åŒ–å·¥ä½œæµ
- ä»…åœ¨å¿…è¦æ—¶è®¾ç½® sandbox=false
      `,

      'EditFileTool': `
å…³é”®ï¼š
- old_string ä¸å¾—åŒ…å«æ¥è‡ª ReadFileTool çš„è¡Œå·å‰ç¼€
- ä¿ç•™ç²¾ç¡®çš„ç¼©è¿›å’Œç©ºç™½
- éªŒè¯ expected_replacements ä¸å®é™…å‡ºç°æ¬¡æ•°åŒ¹é…
      `,

      'AgentTool': `
ä½•æ—¶ä½¿ç”¨ï¼š
- è·¨å¤šä¸ªæ–‡ä»¶çš„å¤æ‚æœç´¢
- éœ€è¦å¤šä¸ªæ­¥éª¤çš„ä»»åŠ¡
- å¼€æ”¾å¼è°ƒæŸ¥

ä½•æ—¶ä¸ä½¿ç”¨ï¼š
- ç®€å•çš„æ–‡ä»¶è¯»å–ï¼ˆä½¿ç”¨ ReadFileToolï¼‰
- ç‰¹å®šæ¨¡å¼æœç´¢ï¼ˆä½¿ç”¨ GrepToolï¼‰
      `,

      'UpdateTodoTool': `
å§‹ç»ˆåœ¨ä»¥ä¸‹æƒ…å†µä½¿ç”¨æ­¤å·¥å…·ï¼š
- å¼€å§‹å¤æ‚ä»»åŠ¡ï¼ˆ3+ æ­¥éª¤ï¼‰
- ç”¨æˆ·æä¾›å¤šä¸ªä»»åŠ¡
- å®Œæˆä»»ä½•ä»»åŠ¡

å®Œæˆä»»åŠ¡åç«‹å³æ ‡è®°ä¸ºå®Œæˆã€‚
ä¸€æ¬¡åªæœ‰ä¸€ä¸ªä»»åŠ¡å¤„äº in_progress çŠ¶æ€ã€‚
      `
    };

    return instructions[tool.name] || '';
  }
}

```

## æ€§èƒ½ä¸å®‰å…¨æ¨¡å¼

### å·¥å…·æ€§èƒ½ç‰¹å¾

| å·¥å…· | å»¶è¿Ÿ | å†…å­˜ | CPU | I/O | å¯å¹¶è¡ŒåŒ– |
|-----|-----|------|-----|-----|---------|
| ReadTool | 10-50ms | O(file) | ä½ | é«˜ | âœ“ |
| EditTool | 20-100ms | O(file) | ä½ | ä¸­ | âœ— |
| MultiEditTool | 50-500ms | O(file) | ä¸­ | ä¸­ | âœ— |
| WriteTool | 10-50ms | O(content) | ä½ | é«˜ | âœ— |
| BashTool | 50ms-30s | å¯å˜ | å¯å˜ | å¯å˜ | âœ—* |
| GrepTool | 100-500ms | O(matches) | é«˜ | é«˜ | âœ“ |
| GlobTool | 50-200ms | O(files) | ä½ | ä¸­ | âœ“ |
| AgentTool | 2-20s | O(tasks) | ä½ | ä½ | âœ“ |
| WebFetchTool | 500-3000ms | O(page) | ä½ | ä½ | âœ“ |

*BashTool å¹¶è¡Œæ‰§è¡Œä»…å¯¹åªè¯»å‘½ä»¤å®‰å…¨

### å†…å­˜ç®¡ç†ç­–ç•¥

```typescript
// å·¥å…·å†…å­˜ä¼˜åŒ–æ¨¡å¼
class ToolMemoryManager {
  // æ¨¡å¼ 1ï¼šæµå¼å¤„ç†å¤§æ–‡ä»¶
  static async *streamLargeFile(path: string, chunkSize = 64 * 1024) {
    const stream = createReadStream(path, {
      highWaterMark: chunkSize
    });

    for await (const chunk of stream) {
      yield chunk;

      // åœ¨åˆ†å—ä¹‹é—´å…è®¸ GC
      if (global.gc) global.gc();
    }
  }

  // æ¨¡å¼ 2ï¼šæ–‡ä»¶ç¼“å­˜çš„å¼±å¼•ç”¨
  private static fileCache = new Map<string, WeakRef<FileContent>>();

  static cacheFile(path: string, content: FileContent) {
    const ref = new WeakRef(content);
    this.fileCache.set(path, ref);

    // æ³¨å†Œæ¸…ç†
    this.registry.register(content, path);
  }

  // æ¨¡å¼ 3ï¼šç»“æœå¤§å°é™åˆ¶
  static truncateResult(result: string, maxSize = 100_000): string {
    if (result.length <= maxSize) return result;

    return result.substring(0, maxSize) +
           `\\n... (truncated ${result.length - maxSize} characters)`;
  }
}

```

### è·¯å¾„å®‰å…¨å®ç°

```typescript
// æ‰€æœ‰æ–‡ä»¶æ“ä½œçš„è·¯å¾„éªŒè¯
class PathSecurityValidator {
  static isPathSafe(
    requestedPath: string,
    context: ToolUseContext
  ): boolean {
    const resolved = path.resolve(requestedPath);

    // æ£€æŸ¥ä¸»å·¥ä½œç›®å½•
    const cwd = context.options.cwd || process.cwd();
    if (resolved.startsWith(cwd)) {
      return true;
    }

    // æ£€æŸ¥é¢å¤–å…è®¸çš„ç›®å½•
    const additionalDirs = context
      .getToolPermissionContext()
      .additionalWorkingDirectories;

    for (const dir of additionalDirs) {
      if (resolved.startsWith(dir)) {
        return true;
      }
    }

    // æ£€æŸ¥æ‹’ç»æ¨¡å¼
    const DENIED_PATHS = [
      '/etc/passwd',
      '/etc/shadow',
      '~/.ssh/id_rsa',
      '/System', // macOS
      '/Windows/System32' // Windows
    ];

    return !DENIED_PATHS.some(denied =>
      resolved.includes(denied)
    );
  }
}

```
