+++
date = '2025-11-14T10:00:00+01:00'
draft = false
title = 'Claude Code åˆ†æ 02ï¼šæ•°æ®ç»“æ„'
tags = ['Agent']
+++

# ğŸ“Š æ•°æ®ç»“æ„ä¸ä¿¡æ¯æ¶æ„

```mermaid
stateDiagram-v2
    [*] --> UserInput: ç”¨æˆ·è¾“å…¥/ç²˜è´´
    UserInput --> CliMessage: CLI å¤„ç†è¾“å…¥
    CliMessage --> APIMessage: ä¸º LLM æ ¼å¼åŒ–
    APIMessage --> LLMStream: API è¯·æ±‚

    LLMStream --> StreamEvent: æœåŠ¡å™¨å‘é€æ•°æ®å—
    StreamEvent --> ContentBlockDelta: è§£æå¢é‡
    ContentBlockDelta --> AccumulatedMessage: æ„å»ºæ¶ˆæ¯

    AccumulatedMessage --> ToolUseBlock: åŒ…å«å·¥å…·è¯·æ±‚?
    ToolUseBlock --> ToolExecution: æ‰§è¡Œå·¥å…·
    ToolExecution --> ToolProgress: ç”Ÿæˆè¿›åº¦
    ToolProgress --> CliMessage: è¿›åº¦æ›´æ–°
    ToolExecution --> ToolResult: å®Œæˆæ‰§è¡Œ
    ToolResult --> ToolResultBlock: æ ¼å¼åŒ–ç»“æœ
    ToolResultBlock --> CliMessage: å·¥å…·ç»“æœæ¶ˆæ¯

    AccumulatedMessage --> CliMessage: æœ€ç»ˆåŠ©æ‰‹æ¶ˆæ¯
    CliMessage --> [*]: æ˜¾ç¤ºç»™ç”¨æˆ·

    CliMessage --> APIMessage: å¾ªç¯ç»§ç»­
```

## æµå¼çŠ¶æ€æœº: æ¶ˆæ¯å¦‚ä½•è½¬æ¢

Claude Code æ•°æ®æ¶æ„æœ€ä»¤äººç€è¿·çš„æ–¹é¢æ˜¯å®ƒå¦‚ä½•åœ¨ä¿æŒæµå¼æ€§èƒ½çš„åŒæ—¶,ç®¡ç†æ•°æ®åœ¨å¤šä¸ªè¡¨ç¤ºå½¢å¼ä¹‹é—´çš„è½¬æ¢ã€‚è®©æˆ‘ä»¬ä»æ ¸å¿ƒåˆ›æ–°å¼€å§‹:

```typescript
// åŒé‡è¡¨ç¤ºæ¶ˆæ¯ç³»ç»Ÿ (ä»åˆ†æä¸­æ¨æ–­)
interface MessageTransformPipeline {
  // é˜¶æ®µ 1: CLI å†…éƒ¨è¡¨ç¤º
  cliMessage: {
    type: "user" | "assistant" | "attachment" | "progress"
    uuid: string  // CLI ç‰¹å®šçš„è·Ÿè¸ª
    timestamp: string
    message?: APICompatibleMessage  // ä»…ç”¨äº user/assistant
    attachment?: AttachmentContent   // ä»…ç”¨äº attachment
    progress?: ProgressUpdate        // ä»…ç”¨äº progress
  }

  // é˜¶æ®µ 2: API çº¿ä¸Šæ ¼å¼
  apiMessage: {
    role: "user" | "assistant"
    content: string | ContentBlock[]
    // æ²¡æœ‰ CLI ç‰¹å®šå­—æ®µ
  }

  // é˜¶æ®µ 3: æµå¼ç´¯åŠ å™¨
  streamAccumulator: {
    partial: Partial<APIMessage>
    deltas: ContentBlockDelta[]
    buffers: Map<string, string>  // tool_use_id â†’ ç´¯ç§¯çš„ JSON
  }
}
```

**ä¸ºä»€ä¹ˆè¿™å¾ˆé‡è¦**: è¿™ç§ä¸‰é˜¶æ®µè¡¨ç¤ºå…è®¸ Claude Code åœ¨å¤„ç†å¤æ‚æµå¼åè®®çš„åŒæ—¶ä¿æŒ UI å“åº”æ€§ã€‚CLI å¯ä»¥ä½¿ç”¨ `CliMessage` å…ƒæ•°æ®æ›´æ–°è¿›åº¦æŒ‡ç¤ºå™¨,è€Œå®é™…çš„ LLM é€šä¿¡ä½¿ç”¨ç®€æ´çš„ `APIMessage` æ ¼å¼ã€‚

## ContentBlock: å¤šæ€æ„å»ºå—

åŸºäºåç¼–è¯‘åˆ†æ,Claude Code ä¸ºå†…å®¹å®ç°äº†ä¸€ä¸ªå¤æ‚çš„ç±»å‹ç³»ç»Ÿ:

```typescript
// ContentBlock å¯è¾¨è¯†è”åˆç±»å‹ (é‡æ„)
type ContentBlock =
  | TextBlock
  | ImageBlock
  | ToolUseBlock
  | ToolResultBlock
  | ThinkingBlock
  | DocumentBlock      // å¹³å°ç‰¹å®š
  | VideoBlock         // å¹³å°ç‰¹å®š
  | GuardContentBlock  // å¹³å°ç‰¹å®š
  | ReasoningBlock     // å¹³å°ç‰¹å®š
  | CachePointBlock    // å¹³å°ç‰¹å®š

// åŸºäºæ¨æ–­ä½¿ç”¨çš„æ€§èƒ½æ³¨è§£
interface ContentBlockMetrics {
  TextBlock: {
    memorySize: "O(text.length)",
    parseTime: "O(1)",
    serializeTime: "O(n)",
    streamable: true
  },
  ImageBlock: {
    memorySize: "O(1) + external",  // å¼•ç”¨åˆ° base64/S3
    parseTime: "O(1)",
    serializeTime: "O(size)" | "O(1) for S3",
    streamable: false
  },
  ToolUseBlock: {
    memorySize: "O(JSON.stringify(input).length)",
    parseTime: "O(n) for JSON parse",
    serializeTime: "O(n)",
    streamable: true  // JSON å¯ä»¥æµå¼ä¼ è¾“
  }
}
```

### æµå¼ JSON æŒ‘æˆ˜

Claude Code æœ€å·§å¦™çš„åˆ›æ–°ä¹‹ä¸€æ˜¯å¤„ç†å·¥å…·è¾“å…¥çš„æµå¼ JSON:

```typescript
// æ¨æ–­çš„æµå¼ JSON è§£æå™¨å®ç°
class StreamingToolInputParser {
  private buffer: string = '';
  private depth: number = 0;
  private inString: boolean = false;
  private escape: boolean = false;

  addChunk(chunk: string): ParseResult {
    this.buffer += chunk;

    // è·Ÿè¸ª JSON ç»“æ„æ·±åº¦
    for (const char of chunk) {
      if (!this.inString) {
        if (char === '{' || char === '[') this.depth++;
        else if (char === '}' || char === ']') this.depth--;
      }

      // è·Ÿè¸ªå­—ç¬¦ä¸²è¾¹ç•Œ
      if (char === '"' && !this.escape) {
        this.inString = !this.inString;
      }
      this.escape = (char === '\\' && !this.escape);
    }

    // åœ¨æ·±åº¦ä¸º 0 æ—¶å°è¯•è§£æ
    if (this.depth === 0 && this.buffer.length > 0) {
      try {
        return { complete: true, value: JSON.parse(this.buffer) };
      } catch (e) {
        // å°è¯•è‡ªåŠ¨å…³é—­æœªé—­åˆçš„å­—ç¬¦ä¸²
        if (this.inString) {
          try {
            return {
              complete: true,
              value: JSON.parse(this.buffer + '"'),
              repaired: true
            };
          } catch {}
        }
        return { complete: false, error: e };
      }
    }

    return { complete: false };
  }
}
```

è¿™ä¸ªè§£æå™¨å¯ä»¥å¤„ç†æ¥è‡ª LLM çš„å¢é‡ JSON å—,ä¸€æ—¦ç»“æ„çœ‹èµ·æ¥å®Œæ•´å°±å°è¯•è§£æã€‚

## æ¶ˆæ¯ç”Ÿå‘½å‘¨æœŸ: ä»ç”¨æˆ·è¾“å…¥åˆ° LLM å†è¿”å›

```mermaid
graph TB
    subgraph "è¾“å…¥å¤„ç†"
        UserText[ç”¨æˆ·æ–‡æœ¬è¾“å…¥]
        SlashCmd["/å‘½ä»¤"]
        BashCmd[!shell å‘½ä»¤]
        MemoryCmd[#è®°å¿†ç¬”è®°]
        PastedContent[ç²˜è´´çš„å›¾ç‰‡/æ–‡æœ¬]

        UserText --> NormalMessage[åˆ›å»ºç”¨æˆ· CliMessage]
        SlashCmd --> CommandProcessor[å¤„ç†å‘½ä»¤]
        BashCmd --> SyntheticTool[åˆæˆ BashTool æ¶ˆæ¯]
        MemoryCmd --> MemoryUpdate[æ›´æ–° CLAUDE.md]
        PastedContent --> ContentDetection{æ£€æµ‹ç±»å‹}

        ContentDetection -->|å›¾ç‰‡| ImageBlock[åˆ›å»º ImageBlock]
        ContentDetection -->|æ–‡æœ¬| TextBlock[åˆ›å»º TextBlock]
    end

    subgraph "æ¶ˆæ¯è½¬æ¢"
        NormalMessage --> StripMetadata[ç§»é™¤ CLI å­—æ®µ]
        SyntheticTool --> StripMetadata
        ImageBlock --> StripMetadata
        TextBlock --> StripMetadata

        StripMetadata --> APIMessage[æ¸…æ´çš„ API æ¶ˆæ¯]
        APIMessage --> TokenCount{è®¡æ•° Token}

        TokenCount -->|è¶…è¿‡é™åˆ¶| Compact[å‹ç¼©è¿‡ç¨‹]
        TokenCount -->|æœªè¶…é™åˆ¶| Send[å‘é€åˆ° LLM]

        Compact --> SummaryMessage[æ‘˜è¦æ¶ˆæ¯]
        SummaryMessage --> Send
    end
```

### CliMessage ç»“æ„: ä¸æ­¢è¡¨é¢æ‰€è§

`CliMessage` ç±»å‹å……å½“åº”ç”¨ç¨‹åºçš„ä¸­æ¢ç¥ç»ç³»ç»Ÿ:

```typescript
interface CliMessage {
  type: "user" | "assistant" | "attachment" | "progress"
  uuid: string
  timestamp: string

  // ä»…ç”¨äº user/assistant æ¶ˆæ¯
  message?: {
    role: "user" | "assistant"
    id?: string                    // LLM æä¾›çš„ ID
    model?: string                 // å“ªä¸ªæ¨¡å‹å“åº”
    stop_reason?: StopReason       // ä¸ºä»€ä¹ˆåœæ­¢ç”Ÿæˆ
    stop_sequence?: string         // å‘½ä¸­çš„ç‰¹å®šåœæ­¢åºåˆ—
    usage?: TokenUsage             // è¯¦ç»†çš„ token è®¡æ•°
    content: string | ContentBlock[]
  }

  // CLI ç‰¹å®šçš„å…ƒæ•°æ®
  costUSD?: number               // è®¡ç®—çš„æˆæœ¬
  durationMs?: number            // API è°ƒç”¨æŒç»­æ—¶é—´
  requestId?: string             // ç”¨äºè°ƒè¯•
  isApiErrorMessage?: boolean    // é”™è¯¯æ˜¾ç¤ºæ ‡å¿—
  isMeta?: boolean              // ç³»ç»Ÿç”Ÿæˆçš„æ¶ˆæ¯

  // ç±»å‹ç‰¹å®šå­—æ®µ
  attachment?: AttachmentContent
  progress?: {
    toolUseID: string
    parentToolUseID?: string   // ç”¨äº AgentTool å­å·¥å…·
    data: any                  // å·¥å…·ç‰¹å®šçš„è¿›åº¦
  }
}

// æ€§èƒ½ç‰¹æ€§
interface CliMessagePerformance {
  creation: "O(1)",
  serialization: "O(content size)",
  memoryRetention: "å¤§å†…å®¹ä½¿ç”¨å¼±å¼•ç”¨",
  garbageCollection: "ä»å†å²æ•°ç»„ä¸­ç§»é™¤æ—¶ç¬¦åˆå›æ”¶æ¡ä»¶"
}
```

### å˜å¼‚ç‚¹å’ŒçŠ¶æ€è½¬æ¢

Claude Code ä»”ç»†æ§åˆ¶æ•°æ®ç»“æ„å¯ä»¥è¢«ä¿®æ”¹çš„ä½ç½®:

```typescript
// æ¨æ–­çš„å˜å¼‚æ§åˆ¶æ¨¡å¼
class MessageMutationControl {
  // å˜å¼‚ç‚¹ 1: æµå¼ç´¯ç§¯
  static accumulateStreamDelta(
    message: Partial<CliMessage>,
    delta: ContentBlockDelta
  ): void {
    if (delta.type === 'text_delta') {
      const lastBlock = message.content[message.content.length - 1];
      if (lastBlock.type === 'text') {
        lastBlock.text += delta.text;  // å˜å¼‚
      }
    }
  }

  // å˜å¼‚ç‚¹ 2: å·¥å…·ç»“æœæ³¨å…¥
  static injectToolResult(
    history: CliMessage[],
    toolResult: ToolResultBlock
  ): void {
    const newMessage: CliMessage = {
      type: 'user',
      isMeta: true,  // ç³»ç»Ÿç”Ÿæˆ
      message: {
        role: 'user',
        content: [toolResult]
      },
      // ... å…¶ä»–å­—æ®µ
    };
    history.push(newMessage);  // å˜å¼‚
  }

  // å˜å¼‚ç‚¹ 3: æˆæœ¬è®¡ç®—
  static updateCostMetadata(
    message: CliMessage,
    usage: TokenUsage
  ): void {
    message.costUSD = calculateCost(usage, message.model);  // å˜å¼‚
    message.durationMs = Date.now() - parseISO(message.timestamp);  // å˜å¼‚
  }
}
```

## ç³»ç»Ÿæç¤º: åŠ¨æ€ä¸Šä¸‹æ–‡ç»„è£…

å¯èƒ½æœ€å¤æ‚çš„æ•°æ®ç»“æ„æ˜¯åŠ¨æ€ç»„è£…çš„ç³»ç»Ÿæç¤º:

```typescript
// ç³»ç»Ÿæç¤ºç»„è£…æµæ°´çº¿ (é‡æ„)
interface SystemPromptPipeline {
  sources: {
    baseInstructions: string        // é™æ€åŸºç¡€
    claudeMdContent: ClaudeMdLayer[] // åˆ†å±‚çš„
    gitContext: GitContextData       // å®æ—¶
    directoryStructure: TreeData     // ç¼“å­˜/æ–°é²œ
    toolDefinitions: ToolSpec[]      // å¯ç”¨å·¥å…·
    modelAdaptations: ModelSpecificPrompt // æ¯ä¸ªæ¨¡å‹
  }

  assembly: {
    order: ['base', 'model', 'claude.md', 'git', 'files', 'tools'],
    separators: Map<string, string>,  // éƒ¨åˆ†åˆ†éš”ç¬¦
    sizeLimit: number,                // Token é¢„ç®—
    prioritization: 'recency' | 'relevance'
  }
}

// GitContext ç»“æ„æ­ç¤ºäº†å®æ—¶æ„ŸçŸ¥
interface GitContextData {
  currentBranch: string
  status: {
    modified: string[]
    untracked: string[]
    staged: string[]
  }
  recentCommits: Array<{
    hash: string
    message: string
    author: string
    timestamp: string
  }>
  uncommittedDiff?: string  // æ˜‚è´µ,æœ‰æ¡ä»¶
}
```

### å†…å­˜å¸ƒå±€: CLAUDE.md åˆ†å±‚åŠ è½½

```plain text
é¡¹ç›®æ ¹ç›®å½•
â”œâ”€â”€ .claude/
â”‚   â”œâ”€â”€ CLAUDE.md (æœ¬åœ° - æœ€é«˜ä¼˜å…ˆçº§)
â”‚   â””â”€â”€ settings.json
â”œâ”€â”€ ~/
â”‚   â””â”€â”€ .claude/
â”‚       â””â”€â”€ CLAUDE.md (ç”¨æˆ· - ç¬¬äºŒä¼˜å…ˆçº§)
â”œâ”€â”€ <project-root>/
â”‚   â””â”€â”€ .claude/
â”‚       â””â”€â”€ CLAUDE.md (é¡¹ç›® - ç¬¬ä¸‰ä¼˜å…ˆçº§)
â””â”€â”€ /etc/claude-code/
    â””â”€â”€ CLAUDE.md (æ‰˜ç®¡ - æœ€ä½ä¼˜å…ˆçº§)
```

åŠ è½½æœºåˆ¶å®ç°äº†é«˜æ•ˆçš„åˆå¹¶ç­–ç•¥:

```typescript
// æ¨æ–­çš„ CLAUDE.md åŠ è½½ç®—æ³•
class ClaudeMdLoader {
  private cache = new Map<string, {content: string, mtime: number}>();

  async loadMerged(): Promise<string> {
    const layers = [
      '/etc/claude-code/CLAUDE.md',      // æ‰˜ç®¡
      '~/.claude/CLAUDE.md',              // ç”¨æˆ·
      '<project>/.claude/CLAUDE.md',      // é¡¹ç›®
      '.claude/CLAUDE.md'                 // æœ¬åœ°
    ];

    const contents = await Promise.all(
      layers.map(path => this.loadWithCache(path))
    );

    // ä½¿ç”¨è¦†ç›–è¯­ä¹‰åˆå¹¶
    return this.mergeWithOverrides(contents);
  }

  private mergeWithOverrides(contents: string[]): string {
    // åé¢çš„å±‚è¦†ç›–å‰é¢çš„å±‚
    // @override æŒ‡ä»¤ç”¨äºæ˜¾å¼è¦†ç›–
    // @append æŒ‡ä»¤ç”¨äºæ·»åŠ 
    // é»˜è®¤: ç”¨åˆ†éš”ç¬¦è¿æ¥
  }
}
```

## å·¥å…·ç›¸å…³çš„æ•°æ®ç»“æ„

### ToolDefinition: å®Œæ•´çš„å·¥å…·æ¥å£

```typescript
interface ToolDefinition {
  // æ ‡è¯†
  name: string
  description: string
  prompt?: string  // é¢å¤–çš„ LLM æŒ‡ä»¤

  // æ¨¡å¼ (åŒé‡è¡¨ç¤º)
  inputSchema: ZodSchema          // è¿è¡Œæ—¶éªŒè¯
  inputJSONSchema?: JSONSchema    // LLM é€šä¿¡

  // æ‰§è¡Œ
  call: AsyncGenerator<ToolProgress | ToolResult, void, void>

  // æƒé™
  checkPermissions?: (
    input: any,
    context: ToolUseContext,
    permContext: ToolPermissionContext
  ) => Promise<PermissionDecision>

  // è¾“å‡ºæ ¼å¼åŒ–
  mapToolResultToToolResultBlockParam: (
    result: any,
    toolUseId: string
  ) => ContentBlock | ContentBlock[]

  // å…ƒæ•°æ®
  isReadOnly: boolean
  isMcp?: boolean
  isEnabled?: (config: any) => boolean
  getPath?: (input: any) => string | undefined

  // UI
  renderToolUseMessage?: (input: any) => ReactElement
}

// å·¥å…·å®šä¹‰çš„å†…å­˜ç‰¹æ€§
interface ToolDefinitionMemory {
  staticSize: "æ¯ä¸ªå·¥å…·çº¦ 2KB",
  zodSchema: "å»¶è¿Ÿç¼–è¯‘,å·²ç¼“å­˜",
  jsonSchema: "ç”Ÿæˆä¸€æ¬¡,è®°å¿†åŒ–",
  closures: "ä¿ç•™ä¸Šä¸‹æ–‡å¼•ç”¨"
}
```

### æ‰§è¡Œä¸Šä¸‹æ–‡: å·¥å…·éœ€è¦çš„ä¸€åˆ‡

```typescript
interface ToolUseContext {
  // å–æ¶ˆ
  abortController: AbortController

  // æ–‡ä»¶çŠ¶æ€è·Ÿè¸ª
  readFileState: Map<string, {
    content: string
    timestamp: number  // mtime
  }>

  // æƒé™è§£æ
  getToolPermissionContext: () => ToolPermissionContext

  // é€‰é¡¹åŒ…
  options: {
    tools: ToolDefinition[]
    mainLoopModel: string
    debug?: boolean
    verbose?: boolean
    isNonInteractiveSession?: boolean
    maxThinkingTokens?: number
  }

  // MCP è¿æ¥
  mcpClients?: McpClient[]
}

// æƒé™ä¸Šä¸‹æ–‡æ­ç¤ºäº†å¤æ‚çš„å®‰å…¨æ¨¡å‹
interface ToolPermissionContext {
  mode: "default" | "acceptEdits" | "bypassPermissions"

  additionalWorkingDirectories: Set<string>

  // åˆ†å±‚è§„åˆ™ç³»ç»Ÿ
  alwaysAllowRules: Record<PermissionRuleScope, string[]>
  alwaysDenyRules: Record<PermissionRuleScope, string[]>
}

type PermissionRuleScope =
  | "cliArg"         // æœ€é«˜ä¼˜å…ˆçº§
  | "localSettings"
  | "projectSettings"
  | "policySettings"
  | "userSettings"   // æœ€ä½ä¼˜å…ˆçº§
```

## MCP åè®®ç»“æ„

å¤šäº‘/è¿›ç¨‹åè®®æ­ç¤ºäº†å¤æ‚çš„ RPC ç³»ç»Ÿ:

```typescript
// JSON-RPC 2.0 åŠå…¶æ‰©å±•
interface McpMessage {
  jsonrpc: "2.0"
  id?: string | number  // é€šçŸ¥å¯é€‰
}

interface McpRequest extends McpMessage {
  method: string
  params?: unknown
}

interface McpResponse extends McpMessage {
  id: string | number  // å“åº”å¿…éœ€
  result?: unknown
  error?: {
    code: number
    message: string
    data?: unknown
  }
}

// èƒ½åŠ›åå•†ç»“æ„
interface McpCapabilities {
  experimental?: Record<string, any>

  // åŠŸèƒ½æ ‡å¿—
  roots?: boolean      // å·¥ä½œåŒºæ ¹ç›®å½•
  sampling?: boolean   // LLM é‡‡æ ·å§”æ‰˜
  prompts?: boolean    // åŠ¨æ€æç¤º
  resources?: boolean  // èµ„æºæœåŠ¡
  tools?: boolean      // å·¥å…·æš´éœ²
  logging?: boolean    // æ—¥å¿—è½¬å‘
}

// MCP æœåŠ¡å™¨å‘é€çš„å·¥å…·è§„èŒƒ
interface McpToolSpec {
  name: string
  description?: string
  inputSchema: JSONSchema  // å§‹ç»ˆæ˜¯ JSON Schema

  // MCP ç‰¹å®šå…ƒæ•°æ®
  isReadOnly?: boolean
  requiresConfirmation?: boolean
  timeout?: number
  maxRetries?: number
}
```

### MCP çŠ¶æ€æœº

```mermaid
stateDiagram-v2
    [*] --> Disconnected
    Disconnected --> Connecting: connect()
    Connecting --> Initializing: ä¼ è¾“å°±ç»ª
    Initializing --> Ready: èƒ½åŠ›å·²äº¤æ¢

    Ready --> Ready: è¯·æ±‚/å“åº”
    Ready --> Ready: é€šçŸ¥

    Ready --> Closing: close()
    Connecting --> Failed: é”™è¯¯
    Initializing --> Failed: åå•†å¤±è´¥

    Closing --> Disconnected: å·²å…³é—­
    Failed --> Disconnected: é‡ç½®
```

## ä¼šè¯çŠ¶æ€: å…¨å±€å†…å­˜

```typescript
interface SessionState {
  // æ ‡è¯†
  sessionId: string  // UUID v4
  originalCwd: string
  cwd: string  // å¯ä»¥é€šè¿‡ bash cd æ”¹å˜

  // æˆæœ¬è·Ÿè¸ª (å¯å˜ç´¯åŠ å™¨)
  totalCostUSD: number
  totalAPIDuration: number
  modelTokens: Record<string, {
    inputTokens: number
    outputTokens: number
    cacheReadInputTokens: number
    cacheCreationInputTokens: number
  }>

  // æ¨¡å‹é€‰æ‹©
  mainLoopModelOverride?: string
  initialMainLoopModel?: string

  // æ´»åŠ¨æŒ‡æ ‡
  sessionCounter: number
  locCounter: number      // ä»£ç è¡Œæ•°
  prCounter: number       // Pull requests
  commitCounter: number   // Git commits

  // çŠ¶æ€æ ‡å¿—
  lastInteractionTime: number
  hasUnknownModelCost: boolean
  maxRateLimitFallbackActive: boolean

  // å¯ç”¨æ¨¡å‹
  modelStrings: string[]
}

// ä¼šè¯çŠ¶æ€è®¿é—®æ¨¡å¼ (æ¨æ–­)
class SessionManager {
  private static state: SessionState;  // å•ä¾‹

  static update<K extends keyof SessionState>(
    key: K,
    value: SessionState[K]
  ): void {
    this.state[key] = value;
    this.persistToDisk();  // å¼‚æ­¥,éé˜»å¡
  }

  static increment(metric: keyof SessionState): void {
    if (typeof this.state[metric] === 'number') {
      this.state[metric]++;
    }
  }
}
```

## åŒå‘æµå¼å®ç°

å¹³å°çº§æµå¼æ­ç¤ºäº†å¤æ‚çš„åè®®:

```typescript
// åŒå‘æµå¼æœ‰æ•ˆè½½è·ç»“æ„
interface BidirectionalStreamingProtocol {
  // å®¢æˆ·ç«¯ â†’ æœåŠ¡å™¨
  clientPayload: {
    bytes: string  // Base64 ç¼–ç 
    encoding: 'base64'

    // è§£ç çš„å†…å®¹ç±»å‹
    contentTypes:
      | ContinuedUserInput
      | ToolResultBlock
      | ConversationTurnInput
  }

  // æœåŠ¡å™¨ â†’ å®¢æˆ·ç«¯
  serverPayload: {
    bytes: string  // Base64 ç¼–ç 
    encoding: 'base64'

    // è§£ç çš„äº‹ä»¶ç±»å‹
    eventTypes:
      | ContentBlockDeltaEvent
      | ToolUseRequestEvent
      | ErrorEvent
      | MetadataEvent
  }
}

// åŒå‘æµçš„æµå¼çŠ¶æ€æœº
class BidirectionalStreamManager {
  private encoder = new TextEncoder();
  private decoder = new TextDecoder();
  private buffer = new Uint8Array(65536);  // 64KB ç¼“å†²åŒº

  async *processStream(stream: ReadableStream) {
    const reader = stream.getReader();
    let partial = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      // è§£ç å¹¶æŒ‰æ¢è¡Œç¬¦åˆ†å‰² (SSE æ ¼å¼)
      partial += this.decoder.decode(value, { stream: true });
      const lines = partial.split('\n');
      partial = lines.pop() || '';

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const payload = JSON.parse(line.slice(6));
          yield this.decodePayload(payload);
        }
      }
    }
  }

  private decodePayload(payload: any) {
    const bytes = Buffer.from(payload.bytes, 'base64');
    // æ ¹æ®åè®®ç¼“å†²åŒºæˆ– JSON è¿›ä¸€æ­¥è§£ç 
    return JSON.parse(bytes.toString());
  }
}
```

## æ•°æ®ç»“æ„ä¸­çš„æ€§èƒ½ä¼˜åŒ–

### 1. **å¸¸è§å€¼çš„å­—ç¬¦ä¸²é©»ç•™**

```typescript
// æ¨æ–­çš„å­—ç¬¦ä¸²é©»ç•™æ¨¡å¼
class StringIntern {
  private static pool = new Map<string, string>();

  static intern(str: string): string {
    if (!this.pool.has(str)) {
      this.pool.set(str, str);
    }
    return this.pool.get(str)!;
  }
}

// åœ¨æ¶ˆæ¯å¤„ç†ä¸­çš„ä½¿ç”¨
message.type = StringIntern.intern(rawType);  // 'user', 'assistant' ç­‰
message.stop_reason = StringIntern.intern(reason);  // 'end_turn', 'tool_use' ç­‰
```

### 2. **å»¶è¿Ÿå†…å®¹å—è§£æ**

```typescript
// å†…å®¹å—å¯èƒ½ä½¿ç”¨å»¶è¿Ÿè§£æä»¥æé«˜æ€§èƒ½
class LazyContentBlock {
  private _raw: string;
  private _parsed?: any;

  constructor(raw: string) {
    this._raw = raw;
  }

  get content() {
    if (!this._parsed) {
      this._parsed = this.parse(this._raw);
    }
    return this._parsed;
  }

  private parse(raw: string): any {
    // ä»…åœ¨è®¿é—®æ—¶è¿›è¡Œæ˜‚è´µçš„è§£æ
    return JSON.parse(raw);
  }
}
```

### 3. **ReadFileState å¼±å¼•ç”¨**

```typescript
// å…·æœ‰è‡ªåŠ¨å†…å­˜ç®¡ç†çš„æ–‡ä»¶ç¼“å­˜
class ReadFileState {
  private cache = new Map<string, WeakRef<FileContent>>();
  private registry = new FinalizationRegistry((path: string) => {
    this.cache.delete(path);
  });

  set(path: string, content: FileContent) {
    const ref = new WeakRef(content);
    this.cache.set(path, ref);
    this.registry.register(content, path);
  }

  get(path: string): FileContent | undefined {
    const ref = this.cache.get(path);
    if (ref) {
      const content = ref.deref();
      if (!content) {
        this.cache.delete(path);
      }
      return content;
    }
  }
}
```
