+++
date = '2025-09-19T8:00:00+08:00'
draft = false
title = 'Redis Bitmap'
tags = ['Redis']
+++

## Bitmap 位图
Redis 的位图 bitmap 是由多个二进制位组成的数组,
数组中的每个二进制都有与之对应的偏移量(索引),
用户通过这些偏移量可以对位图中指定的一个或多个二进制位进行操作.

Redis 为位图提供了一系列操作命令, 通过这些命令, 用户可以:
- 设置或获取索引位上的二进制值
- 统计位图中有多少个二进制位被设置成了1
- 查找位图中, 第一个被设置为指定值的二进制位, 并返回其偏移量
- 对一个或多个位图执行逻辑并、逻辑或、逻辑异或以及逻辑非运算
- 将指定类型的整数存储到位图中

### SETBIT: 设置二进制位的值
```Redis
SETBIT bitmap offset value
```
为位图指定偏移量上的二进制位设置值, 该命令会返回二进制位被设置之前的旧值作为结果.  

当执行 SETBIT 时, 如果位图不存在, 或者位图当前的大小无法满足用户想要执行的设置操作, 那么 Redis 将对被设置的位图进行扩展, 使得位图可以满足用户的设置请求. 由于位图的扩展以字节为单位, 所以扩展后的位图包含的二进制数量可能会比用户要求的稍多一些. 且在扩展的同时, 会将未设置的二进制位初始化为 0.

与一些可以使用负数的 Redis 命令不同, SETBIT 命令只能使用正数偏移量, 尝试输入负数作为偏移量将引发一个错误

- 复杂度: O(1)

### GETBIT: 获取二进制位的值
```Redis
GETBIT bitmap offset
```
与 SETBIT 命令一样, GETBIT 命令也只能接受正数作为偏移量.  
对于偏移量超过位图索引的命令, GETBIT 命令将返回 0 作为结果.

- 复杂度: O(1)

### BITOCUNT: 统计被设置的二进制数量
```Redis
BITCOUNT key
```
对于值为 10010100 的位图 bitmap001, 可以通过执行以下命令来统计有多少个二进制位被设置成了1:
```Redis
BITCOUNT bitmap001
(integer) 3 -- 这个位图有 3 个二进制位为 1
```

此外, 还可以只统计位图指定直接范围内的二进制位
```Redis
BITCOUNT bitmap [start end]
```
start 参数和 end 参数与本章之前介绍的 SETBIT 命令和 GETBIT 命令的 offset 参数并不相同,
这两个参数用来指定**字节**偏移量而不是二进制位偏移量.

例如通过以下命令计算位图 bitmap003 中第一个字节中 有多少个 1:
```Redis
BITCOUNT bitmap003 0 0
```

BITCOUNT 命令的 start 参数和 end 参数的值不久可以是正数, 还可以是负数:
```Redis
BITCOUNT bitmap003 -1 -1
```
上面命令统计位图 bitmap003 最后一个字节中 1 的数量.

- 复杂度: O(N)


### 示例: 用户行为记录器
为了分析用户行为并借此改善服务质量, 很多网站都会记录用户在网站的一举一动.
为此, 可以使用集和 Set 或者 HyperLogLog 来记录所有执行了指定行为的用户, 但这种做法有两种缺陷:
- 如果使用集和来记录执行了指定行为的用户, 那么集和体积会随着用户数量的增大而变大, 从而消耗大量内存
- 如果使用 HyperLogLog 可以节约大量内存, 但由于其只是一个概率算法, 因此只能给出一个估算值. 并无法准确判断某个用户是否执行了这些指定行为, 这对精确分析算法带来了麻烦.

为了尽可能节约内存, 并精确记录每个用户是否执行了指定行为, 可以使用以下方法:
- 对于每项行为, 一个用户要么执行了该行为, 要么没有执行该行为. 因此可以通过一个二进制位来记录.
- 通过将用户 ID 与位图中的二进制偏移量一一映射, 可以使用一个位图来记录所有执行了指定行为的用户: 比如偏移量为 10086 的二进制位就负责记录 ID 位 10086 的用户信息, 而偏移量位 12345 的二进制位则负责记录 ID 位 12345 的用户信息.
- 每当用户执行指定行为时, 调用 SETBIT 命令, 将用户在位图中对应的二进制位的值设置为 1
- 通过调用 GETBIT 命令并判断用户对应的二进制的值是否位1, 可以知道用户是否执行了指定行为
- 通过对位图执行 BITCOUNT 命令, 可以知道多少用户执行了指定行为

```Python
from redis import Redis


def make_action_key(action):
    return "action_reorder::" + action

class ActionRecorder:
    def __init__(self, client, action):
        self.client= client
        self.bitmap = make_action_key(action)

    def perform_by(self, user_id):
        """记录执行了指定行为的用户"""
        self.client.setbit(self.bitmap, user_id)

    def is_performed_by(self, user_id):
        """检查用户是否执行了指定行为"""
        return self.client.getbit(self.bitmap, user_id)

    def count_performed(self):
        """返回执行了指定行为的用户人数"""
        return self.client.bitcount(self.bitmap)

client = Redis()
login_action = ActionRecorder(client, "login")

# 对以登陆用户进行记录
login_action.perform_by(10086)
login_action.perform_by(255255)
login_action.perform_by(987654321)

# ID 为 10086 的用户登陆了
print(login_action.is_performed_by(10086))
# ID 为 555 的用户没有登陆
print(login_action.is_performed_by(555))

# 统计用户执行了登陆操作
print(login_action.count_performed())
```


### BITPOS: 查找第一个指定的二进制值
```Redis
BITPOS bitmap value
```

例如, 通过下面命令, 可以知道位图 bitmap003 第一个被设置为 1 的二进制位所在的偏移量(索引):
```Redis
BITPOS bitmap003 1
(integer) 0 -- 位图第一个被设置位 1 的二进制位的偏移量是 0
```

默认情况下, BITPOS 会查找所有二进制位, 在有需要的情况下, 用户也可以通过可选的 start 参数和 end 参数, 让 BITPOS 命令只在指定**字节**范围内的二进制位中进行查找:
```Redis
BITPOS bitmap value [start end]
```
返回结果为查找到位的整体偏移量, 而不是在 start 和 end 内的偏移量.

和 BITCOUNT 命令以, BITPOS 命令的 start 和 end 参数也可以是负数.

比如, 下面代码就展示了如何在位图 bitmap003 的倒数第一个字节中, 查找第一个值位 0 的二进制位:
```Redis
BITPOS bitmap003 0 -1 -1
(integer) 17
```

当用户尝试对一个不存在的位图或者一个唯有位都位 0 的位图, 执行查找值位 1 的二进制位时, BITPOS 命令将返回 -1 作为结果:
```Redis
BITPOS not-exists-bitmap 1 -- 在不存在的位图中查找
(integer) -1

BITPOS all-0-bitmap 1 -- 在一个所有位都被设置为 0 的位图查找
(integer) -1
```

- 复杂度: O(N), 其中 N 为查找涉及的字节数量


### BITOP: 执行二进制位运算
用户可以通过 BITOP 命令, 对一个或多个位图执行指定的二进制位运算, 并将运算结果存储到指定的键中
```Redis
BITOP operation result_key bitmap [bitmap ...]
```
其中, operation 参数值可以是 AND, OR, XOR, NOT 中的任意一个,
这 4 个值分别对应逻辑并、逻辑或、逻辑异或和逻辑非4种运算,
其中 AND, OR, XOR 这 3 种运算允许用户使用任意数量的位图作为输入, 而 NOT 只允许一个位图作为输入.
BITOP 命令这将计算结果存储到指定键中后, 会返回被存储位图的字节长度.

例如, 通过以下命令, 对位图 bitmap001, bitmap002, bitmap003 执行逻辑并运算, 然后将结果存储到键 and_result 中:
```
BITOP ADD and_result bitmap001 bitmap002 bitmap003
(integer) 3 -- 运算结果 and_result 位图的长度为 3 字节
```
当 BITOP 命令在对两个长度不同的位图执行运算时, 会将长度较短的那个位图中不存在的二进制位看作 0.

- 复杂度: O(N), 其中 N 位计算涉及的字节总数量


### BITFIELD: 在位图中存储整数值
BITFIELD 命令允许用户在位图中的任意区域 field 存储指定长度的整数值, 并对这些整数值执行加法或减法操作.  
BITFIELD 命令支持 SET, GET, INCRBY, OVERFLOW 这 4 个子命令, 接下来将分别介绍这些子命令.

- 根据偏移量对区域进行设置
  ```Redis
  BITFIELD bitmap SET type offset value
  ```
  通过 SET 子命令, 在位图的指定偏移量 offset 上设置一个 type 类型的整数值 value. 其中:  
  - offset 参数用于指定设置的起始偏移量. 这个偏移量从 0 开始计算, 偏移量为 0 表示设置从位图的第 1 个二进制开始
  - type 参数用于指定被设置值的类型, 这个参数需要以 i 或 u 为前缀, 后跟被设置值的位长度
  - value 参数用于指定被设置的整数值, 这个值的类型应该和 type 参数指定的类型一致. 如果给定值的长度超过了 type 指定的类型, 那么将根据 type 参数指定的类型阶段给定值

  举个例子, 下面命令, 从偏移量 0 开始, 这只一个8位长的无符号整数值 198
  ```Redis
  BITFIELD bitmap SET u8 0 198
  (integer) 0
  ```
  从结果可以知道, 该位图之前存储的结果为 0.  
  BITFIELD 命令允许用户在一次调用中执行多个子命令
  ```Redis
  BITFIELD bitmap SET u8 0 123 SET i23 20 10086

  1) (integer) 198

  2) (integer) 0
  ```

  除了上面介绍的基本功能, 还有一下方法可以实现, 这里不再介绍

  - 执行加法或减法操作
  - 处理溢出
  - 字符串命令对位图进行操作
