+++
date = '2025-08-20T8:00:00+08:00'
draft = true
title = 'A Program is not a PROCESS'
tags = ['OS']
+++

程序是一系列**指令**, 以及 CPU 要完成特定任务的**数据** ≈ 可执行文件

要加载程序, 首先要被加载到内存中, 当加载到内存中时, 包含可执行代码的部分被称为**文本段**, **全局变量**和**常量值**这类数据被加载到数据段, 还需要额外的内存空间来存放运行是生成的所有数据, 例如用户输入, 临时结果或变量(堆和栈)

- TEXT: 文本段, 不会变化
- DATA: 数据段, 大小不会改变, 但是内容可能发生改变
- HEAP: 堆
- STACK: 栈

以上部分构成了进程的内存布局

假设现在用记事本打开两个不同的文本文件, 则会有两个窗口, 显示不同的文本内容, 这时候就产生了两个进程, 这两个进程的文本段相同, 其他部分不同.

程序本身不是一个进程, 程序本身是一个被动的实体, 进程则是一个主动的实体, 尽管两个进程可能与同一个程序相关联, 但仍然被认为是两个独立的执行序列.

对于 c、c++、rust、go 这类编译型语言而言, 编译的结果是一个可执行文件, 即程序本身

但是对于 python、javascript 这类解释型语言而不是这样

例如, python 实际上有一个解释器, 其代码是一个文本文件不是一个程序. 这种情况下计算机运行的实际上是 python 解释器, 而不是 python 代码, 创建一个解释器进程后, 会像其他进程一样创建内存区域, 在文本段运行的也不是我们编写的代码, 而是解释器代码. 源代码由进程加载到数据段中(例如堆)

进程非正式的定义为正在执行的程序, 这意味着进程和程序是不同的两个概念.

当程序被打开时, 可执行文件被加载到内存中, 这时程序就变成了进程.
这个进程的执行可能需要额外的内存来存储用户输入和临时结果, 操作系统负责分配这部分内存, 即虚拟地址空间 (ADDRESS SPACE).

现在假设有一个单核CPU的机器, 运行多个进程:
当进程1运行中, 某时刻发生中断, CPU 中寄存器和程序计数器等信息被存入进程控制块中(Process Control Block, PCB), 然后会将CPU中的值清空, 然后加载进程2的信息, 这种行为被称为上下文切换(context switch)
