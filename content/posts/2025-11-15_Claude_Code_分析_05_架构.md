+++
date = '2025-11-14T13:00:00+01:00'
draft = false
title = 'Claude Code åˆ†æ 05ï¼šæ¶æ„'
categories = ['Blog']
tags = ['Agent']
+++

# ğŸ—ï¸ æ¶æ„ï¼šå¼•æ“å®¤

```mermaid
graph TB
    subgraph "æ ¸å¿ƒï¼štt æ§åˆ¶å¾ªç¯"
        Start([ç”¨æˆ·è¾“å…¥]) --> Init[åˆå§‹åŒ–å›åˆ]
        Init --> Compact{éœ€è¦å‹ç¼©?}
        Compact -->|æ˜¯| CompactLLM[LLM æ‘˜è¦]
        CompactLLM --> Assembly
        Compact -->|å¦| Assembly[ç»„è£…ä¸Šä¸‹æ–‡]

        Assembly --> Stream[æµå¼ä¼ è¾“åˆ° LLM]
        Stream --> Process[å¤„ç†äº‹ä»¶]
        Process --> Tools{å·¥å…·è¯·æ±‚?}

        Tools -->|æ˜¯| Execute[æ‰§è¡Œå·¥å…·]
        Execute --> Recurse[é€’å½’ tt]
        Recurse --> Init

        Tools -->|å¦| End([å®Œæˆ])
    end

    style Init fill:#e1f5fe
    style Stream fill:#fff3e0
    style Execute fill:#e8f5e9
    style Recurse fill:#fce4ec

```

## `tt` æ§åˆ¶å¾ªç¯ï¼šè·³åŠ¨çš„å¿ƒè„

æ•´ä¸ª Claude Code ç³»ç»Ÿå›´ç»•ç€ä¸€ä¸ªåä¸º `tt` çš„å¼‚æ­¥ç”Ÿæˆå™¨å‡½æ•°å±•å¼€ã€‚è¿™ä¸ªå‡½æ•°åè°ƒç€æ¯ä¸€æ¬¡äº¤äº’ï¼Œä»ç”¨æˆ·è¾“å…¥åˆ° LLM é€šä¿¡å†åˆ°å·¥å…·æ‰§è¡Œã€‚è®©æˆ‘ä»¬æ¥å‰–æè¿™ä¸ªå“è¶Šçš„å·¥ç¨‹è®¾è®¡ï¼š

```typescript
// ä»£ç åº“ä¸­å®é™…çš„ tt å‡½æ•°ç­¾å
async function* tt(
  currentMessages: CliMessage[],         // å®Œæ•´çš„å¯¹è¯å†å²
  baseSystemPromptString: string,        // é™æ€ç³»ç»ŸæŒ‡ä»¤
  currentGitContext: GitContext,         // å®æ—¶ git çŠ¶æ€
  currentClaudeMdContents: ClaudeMdContent[], // é¡¹ç›®ä¸Šä¸‹æ–‡
  permissionGranterFn: PermissionGranter, // æƒé™å›è°ƒ
  toolUseContext: ToolUseContext,         // å…±äº«æ‰§è¡Œä¸Šä¸‹æ–‡
  activeStreamingToolUse?: ToolUseBlock,  // æ¢å¤æµå¼ä¼ è¾“çŠ¶æ€
  loopState: {
    turnId: string,        // æ­¤å›åˆçš„ UUID
    turnCounter: number,   // é€’å½’æ·±åº¦è¿½è¸ªå™¨
    compacted?: boolean,   // å†å²å‹ç¼©æ ‡å¿—
    isResuming?: boolean   // ä»ä¿å­˜çŠ¶æ€æ¢å¤
  }
): AsyncGenerator<CliMessage, void, void>

```

è¿™ä¸ªç­¾åæ­ç¤ºäº†å…¶å¤æ‚çš„çŠ¶æ€ç®¡ç†ã€‚è¯¥å‡½æ•°äº§å‡º `CliMessage` å¯¹è±¡æ¥é©±åŠ¨ UI æ›´æ–°ï¼ŒåŒæ—¶ç»´æŠ¤å¯¹è¯æµç¨‹ã€‚è®©æˆ‘ä»¬æ£€æŸ¥æ¯ä¸ªé˜¶æ®µï¼š

### é˜¶æ®µ 1ï¼šå›åˆåˆå§‹åŒ–ä¸ä¸Šä¸‹æ–‡å‡†å¤‡

```typescript
{
  // å‘ UI å‘å‡ºä¿¡å·è¡¨ç¤ºå¤„ç†å·²å¼€å§‹
  yield {
    type: "ui_state_update",
    uuid: `uistate-${loopState.turnId}-${Date.now()}`,
    timestamp: new Date().toISOString(),
    data: { status: "thinking", turnId: loopState.turnId }
  };

  // æ£€æŸ¥ä¸Šä¸‹æ–‡çª—å£å‹åŠ›
  let messagesForLlm = currentMessages;
  let wasCompactedThisIteration = false;

  if (await shouldAutoCompact(currentMessages)) {
    yield {
      type: "ui_notification",
      data: { message: "Context is large, attempting to compact..." }
    };

    try {
      const compactionResult = await compactAndStoreConversation(
        currentMessages,
        toolUseContext,
        true
      );
      messagesForLlm = compactionResult.messagesAfterCompacting;
      wasCompactedThisIteration = true;
      loopState.compacted = true;

      yield createSystemNotificationMessage(
        `Conversation history automatically compacted. Summary: ${
          compactionResult.summaryMessage.message.content[0].text
        }`
      );
    } catch (compactionError) {
      yield createSystemErrorMessage(
        `Failed to compact conversation: ${compactionError.message}`
      );
    }
  }
}

```

**é˜¶æ®µ 1 çš„æ€§èƒ½æ¦‚å†µ**ï¼š

| æ“ä½œ       | å…¸å‹æŒç»­æ—¶é—´ | å¤æ‚åº¦        |
| ---------- | ------------ | ------------- |
| Token è®¡æ•° | 10-50ms      | O(n) æ¶ˆæ¯æ•°   |
| å‹ç¼©å†³ç­–   | <1ms         | O(1)          |
| LLM æ‘˜è¦   | 2000-3000ms  | ä¸€æ¬¡ LLM è°ƒç”¨ |
| æ¶ˆæ¯é‡å»º   | 5-10ms       | O(n) æ¶ˆæ¯æ•°   |

### é˜¶æ®µ 2ï¼šåŠ¨æ€ç³»ç»Ÿæç¤ºç»„è£…

ç³»ç»Ÿæç¤ºä¸æ˜¯é™æ€çš„â€”â€”å®ƒåœ¨æ¯ä¸ªå›åˆéƒ½ä¼šé‡æ–°ç»„è£…ï¼š

```typescript
{
  // å¹¶è¡Œè·å–æ‰€æœ‰ä¸Šä¸‹æ–‡æº
  const [toolSpecs, dirStructure] = await Promise.all([
    // å°†å·¥å…·å®šä¹‰è½¬æ¢ä¸º LLM å…¼å®¹çš„è§„æ ¼
    Promise.all(
      toolUseContext.options.tools
        .filter((tool) => (tool.isEnabled ? tool.isEnabled() : true))
        .map(async (tool) =>
          convertToolDefinitionToToolSpecification(tool, toolUseContext),
        ),
    ),
    // è·å–å½“å‰ç›®å½•ç»“æ„
    getDirectoryStructureSnapshot(toolUseContext),
  ]);

  // ç»„è£…å®Œæ•´çš„ç³»ç»Ÿæç¤º
  const systemPromptForLlm = assembleSystemPrompt(
    baseSystemPromptString, // æ ¸å¿ƒæŒ‡ä»¤
    currentClaudeMdContents, // é¡¹ç›®ç‰¹å®šä¸Šä¸‹æ–‡
    currentGitContext, // Git çŠ¶æ€/åˆ†æ”¯/æäº¤
    dirStructure, // æ–‡ä»¶æ ‘
    toolSpecs, // å¯ç”¨å·¥å…·
  );

  // å‡†å¤‡å¸¦ç¼“å­˜æ§åˆ¶çš„æ¶ˆæ¯
  const apiMessages = prepareMessagesForApi(
    messagesForLlm,
    true, // applyEphemeralCacheControl
  );
}
```

ç»„è£…è¿‡ç¨‹éµå¾ªä¸¥æ ¼çš„ä¼˜å…ˆçº§é¡ºåºï¼š

```plain text
ä¼˜å…ˆçº§ 1: åŸºç¡€æŒ‡ä»¤ (~2KB)
    â†“
ä¼˜å…ˆçº§ 2: æ¨¡å‹ç‰¹å®šé€‚é… (~500B)
    â†“
ä¼˜å…ˆçº§ 3: CLAUDE.md å†…å®¹ (å¯å˜ï¼Œé€šå¸¸ 5-50KB)
    â†“
ä¼˜å…ˆçº§ 4: Git ä¸Šä¸‹æ–‡ (~1-5KB)
    â†“
ä¼˜å…ˆçº§ 5: ç›®å½•ç»“æ„ (æˆªæ–­ä»¥é€‚é…)
    â†“
ä¼˜å…ˆçº§ 6: å·¥å…·è§„æ ¼ (~10-20KB)

```

### é˜¶æ®µ 3ï¼šLLM æµå¼ä¼ è¾“åˆå§‹åŒ–

```typescript
{
  // åˆå§‹åŒ–æµå¼è°ƒç”¨
  const llmStream = callLlmStreamApi(
    apiMessages,
    systemPromptForLlm,
    toolSpecificationsForLlm,
    toolUseContext.options.mainLoopModel,
    toolUseContext.abortController.signal,
  );

  // åˆå§‹åŒ–æµå¼å“åº”çš„ç´¯åŠ å™¨
  let accumulatedAssistantMessage: Partial<CliMessage> & {
    message: Partial<ApiMessage> & { content: ContentBlock[] };
  } = {
    type: "assistant",
    uuid: `assistant-${loopState.turnId}-${loopState.turnCounter}-${Date.now()}`,
    timestamp: new Date().toISOString(),
    message: { role: "assistant", content: [] },
  };

  let currentToolUsesFromLlm: ToolUseBlock[] = [];
  let currentThinkingContent: string = "";
  let currentToolInputJsonBuffer: string = "";
}
```

### é˜¶æ®µ 4ï¼šæµå¼äº‹ä»¶å¤„ç†çŠ¶æ€æœº

è¿™æ˜¯é­”æ³•å‘ç”Ÿçš„åœ°æ–¹â€”â€”å®æ—¶å¤„ç†æµå¼äº‹ä»¶ï¼š

```typescript
{
  for await (const streamEvent of llmStream) {
    // ä¸­æ­¢æ£€æŸ¥
    if (toolUseContext.abortController.signal.aborted) {
      yield createSystemNotificationMessage("LLM stream processing aborted by user.");
      return;
    }

    switch (streamEvent.type) {
      case "message_start":
        accumulatedAssistantMessage.message.id = streamEvent.message.id;
        accumulatedAssistantMessage.message.model = streamEvent.message.model;
        accumulatedAssistantMessage.message.usage = streamEvent.message.usage;
        yield {
          type: "ui_state_update",
          data: {
            status: "assistant_responding",
            model: streamEvent.message.model
          }
        };
        break;

      case "content_block_start":
        const newBlockPlaceholder = { ...streamEvent.content_block };

        // æ ¹æ®å—ç±»å‹åˆå§‹åŒ–ç©ºå†…å®¹
        if (streamEvent.content_block.type === "thinking") {
          currentThinkingContent = "";
          newBlockPlaceholder.thinking = "";
        } else if (streamEvent.content_block.type === "tool_use") {
          currentToolInputJsonBuffer = "";
          newBlockPlaceholder.input = "";
        } else if (streamEvent.content_block.type === "text") {
          newBlockPlaceholder.text = "";
        }

        accumulatedAssistantMessage.message.content.push(newBlockPlaceholder);
        break;

      case "content_block_delta":
        const lastBlockIndex = accumulatedAssistantMessage.message.content.length - 1;
        if (lastBlockIndex < 0) continue;

        const currentBlock = accumulatedAssistantMessage.message.content[lastBlockIndex];

        if (streamEvent.delta.type === "text_delta" && currentBlock.type === "text") {
          currentBlock.text += streamEvent.delta.text;
          yield {
            type: "ui_text_delta",
            data: {
              textDelta: streamEvent.delta.text,
              blockIndex: lastBlockIndex
            }
          };
        } else if (streamEvent.delta.type === "input_json_delta" && currentBlock.type === "tool_use") {
          currentToolInputJsonBuffer += streamEvent.delta.partial_json;
          currentBlock.input = currentToolInputJsonBuffer;

          // å°è¯•è§£æä¸å®Œæ•´çš„ JSON è¿›è¡Œé¢„è§ˆ
          const parseAttempt = tryParsePartialJson(currentToolInputJsonBuffer);
          if (parseAttempt.complete) {
            yield {
              type: "ui_tool_preview",
              data: {
                toolId: currentBlock.id,
                preview: parseAttempt.value
              }
            };
          }
        }
        break;

      case "content_block_stop":
        const completedBlock = accumulatedAssistantMessage.message.content[streamEvent.index];

        if (completedBlock.type === "tool_use") {
          try {
            const parsedInput = JSON.parse(currentToolInputJsonBuffer);
            completedBlock.input = parsedInput;
            currentToolUsesFromLlm.push({
              type: "tool_use",
              id: completedBlock.id,
              name: completedBlock.name,
              input: parsedInput
            });
          } catch (e) {
            // å¤„ç†æ¥è‡ª LLM çš„æ ¼å¼é”™è¯¯çš„ JSON
            completedBlock.input = {
              error: "Invalid JSON input from LLM",
              raw_json_string: currentToolInputJsonBuffer,
              parse_error: e.message
            };
          }
          currentToolInputJsonBuffer = "";
        }

        yield {
          type: "ui_content_block_complete",
          data: { block: completedBlock, blockIndex: streamEvent.index }
        };
        break;

      case "message_stop":
        // LLM ç”Ÿæˆå®Œæˆ
        const finalAssistantMessage = finalizeCliMessage(
          accumulatedAssistantMessage,
          loopState.turnId,
          loopState.turnCounter
        );
        yield finalAssistantMessage;

        // ç§»åŠ¨åˆ°é˜¶æ®µ 5 æˆ– 6...
        break;
    }
  }
}

```

**æµå¼å¤„ç†æ€§èƒ½**ï¼š

- é¦–ä¸ª token å»¶è¿Ÿï¼š300-800msï¼ˆå› æ¨¡å‹è€Œå¼‚ï¼‰
- Token ååé‡ï¼š50-100 tokens/ç§’
- UI æ›´æ–°é¢‘ç‡ï¼šæ–‡æœ¬æ¯ä¸ª token æ›´æ–°ï¼Œå·¥å…·è¾“å…¥æ‰¹é‡æ›´æ–°
- å†…å­˜ä½¿ç”¨ï¼šæ— è®ºå“åº”é•¿åº¦å¦‚ä½•ä¿æŒæ’å®š

### é˜¶æ®µ 5ï¼šå·¥å…·æ‰§è¡Œç¼–æ’

å½“ LLM è¯·æ±‚ä½¿ç”¨å·¥å…·æ—¶ï¼Œæ¶æ„è½¬å…¥æ‰§è¡Œæ¨¡å¼ï¼š

```typescript
{
  if (finalAssistantMessage.message.stop_reason === "tool_use" &&
      currentToolUsesFromLlm.length > 0) {

    yield { type: "ui_state_update", data: { status: "executing_tools" } };
    let toolResultMessages: CliMessage[] = [];

    // ä½¿ç”¨æ™ºèƒ½æ‰¹å¤„ç†å¤„ç†å·¥å…·
    for await (const toolOutcomeMessage of processToolCallsInParallelBatches(
      currentToolUsesFromLlm,
      finalAssistantMessage,
      permissionGranterFn,
      toolUseContext
    )) {
      yield toolOutcomeMessage;

      if (toolOutcomeMessage.type === 'user' && toolOutcomeMessage.isMeta) {
        toolResultMessages.push(toolOutcomeMessage);
      }
    }

    // æ£€æŸ¥å·¥å…·æ‰§è¡ŒæœŸé—´æ˜¯å¦ä¸­æ­¢
    if (toolUseContext.abortController.signal.aborted) {
      yield createSystemNotificationMessage("Tool execution aborted by user.");
      return;
    }

    // å¯¹ç»“æœæ’åºä»¥åŒ¹é… LLM çš„è¯·æ±‚é¡ºåº
    const sortedToolResultMessages = sortToolResultsByOriginalRequestOrder(
      toolResultMessages,
      currentToolUsesFromLlm
    );

    // é˜¶æ®µ 6ï¼šä½¿ç”¨ç»“æœé€’å½’
    yield* tt(
      [...messagesForLlm, finalAssistantMessage, ...sortedToolResultMessages],
      baseSystemPromptString,
      currentGitContext,
      currentClaudeMdContents,
      permissionGranterFn,
      toolUseContext,
      undefined,
      { ...loopState, turnCounter: loopState.turnCounter + 1 }
    );
    return;
  }
}

```

### é˜¶æ®µ 6ï¼šé€’å½’æ§åˆ¶

`tt` å‡½æ•°æ˜¯å°¾é€’å½’çš„ï¼Œå…è®¸æ— é™çš„å¯¹è¯æ·±åº¦ï¼ˆå—å®‰å…¨æªæ–½é™åˆ¶ï¼‰ï¼š

```typescript
// é€’å½’å®‰å…¨æªæ–½
if (loopState.turnCounter >= 10) {
  yield createSystemMessage(
    "Maximum conversation depth reached. Please start a new query.",
  );
  return;
}

// é€’å½’å‰çš„å†…å­˜å‹åŠ›æ£€æŸ¥
const estimatedMemory = estimateConversationMemory(messagesForLlm);
if (estimatedMemory > MEMORY_THRESHOLD) {
  // ç»§ç»­å‰å¼ºåˆ¶å‹ç¼©
  const compacted = await forceCompaction(messagesForLlm);
  messagesForLlm = compacted;
}
```

## åˆ†å±‚æ¶æ„

Claude Code å®ç°äº†ä¸€ä¸ªæ¸…æ™°çš„åˆ†å±‚æ¶æ„ï¼Œå…¶ä¸­æ¯å±‚éƒ½æœ‰æ˜ç¡®çš„èŒè´£ï¼š

```mermaid
graph TD
    subgraph "å±‚ 1: ç”¨æˆ·ç•Œé¢"
        React[React ç»„ä»¶]
        Ink[Ink æ¸²æŸ“å™¨]
        Yoga[Yoga å¸ƒå±€å¼•æ“]

        React --> Ink
        Ink --> Yoga
    end

    subgraph "å±‚ 2: Agent æ ¸å¿ƒ"
        TT[tt æ§åˆ¶å¾ªç¯]
        Context[ä¸Šä¸‹æ–‡ç»„è£…]
        Permission[æƒé™ç³»ç»Ÿ]
        State[ä¼šè¯çŠ¶æ€]

        TT --> Context
        TT --> Permission
        TT --> State
    end

    subgraph "å±‚ 3: LLM äº¤äº’"
        Stream[æµå¤„ç†å™¨]
        Retry[é‡è¯•é€»è¾‘]
        Token[Token è®¡æ•°å™¨]

        Stream --> Retry
        Stream --> Token
    end

    subgraph "å±‚ 4: å·¥å…·ç³»ç»Ÿ"
        Executor[å·¥å…·æ‰§è¡Œå™¨]
        Validator[è¾“å…¥éªŒè¯å™¨]
        Sandbox[æ²™ç®±ç®¡ç†å™¨]

        Executor --> Validator
        Executor --> Sandbox
    end

    subgraph "å±‚ 5: åŸºç¡€è®¾æ–½"
        FS[æ–‡ä»¶ç³»ç»Ÿ]
        Process[è¿›ç¨‹ç®¡ç†å™¨]
        Network[ç½‘ç»œå®¢æˆ·ç«¯]
        Telemetry[é¥æµ‹]
    end

    React -.-> TT
    TT -.-> Stream
    TT -.-> Executor
    Executor -.-> FS
    Executor -.-> Process
    Stream -.-> Network
    TT -.-> Telemetry

```

### å±‚é—´é€šä¿¡æ¨¡å¼

å±‚ä¹‹é—´çš„é€šä¿¡éµå¾ªä¸¥æ ¼çš„æ¨¡å¼ï¼š

1. **å‘ä¸‹é€šä¿¡**ï¼šç›´æ¥å‡½æ•°è°ƒç”¨
2. **å‘ä¸Šé€šä¿¡**ï¼šäº‹ä»¶å’Œå›è°ƒ
3. **è·¨å±‚é€šä¿¡**ï¼šå…±äº«ä¸Šä¸‹æ–‡å¯¹è±¡

```typescript
// ç¤ºä¾‹ï¼šUI åˆ° Agent æ ¸å¿ƒé€šä¿¡
class UIToAgentBridge {
  async handleUserInput(input: string) {
    // å‘ä¸‹ï¼šç›´æ¥è°ƒç”¨
    const action = await pd(input, this.context);

    // æ ¹æ®æ“ä½œç±»å‹å¤„ç†
    switch (action.type) {
      case 'normal_prompt':
        // å¯åŠ¨æ–°çš„ tt å¾ªç¯è¿­ä»£
        for await (const message of tt(...)) {
          // å‘ä¸Šï¼šäº§å‡ºäº‹ä»¶
          this.uiRenderer.handleMessage(message);
        }
        break;
    }
  }
}

// ç¤ºä¾‹ï¼šå·¥å…·é€šè¿‡è¿›åº¦å‘ UI é€šä¿¡
class ToolToUIBridge {
  async *executeWithProgress(tool: ToolDefinition, input: any) {
    // å·¥å…·äº§å‡ºè¿›åº¦
    for await (const event of tool.call(input, this.context)) {
      if (event.type === 'progress') {
        // è½¬æ¢ä¸º UI äº‹ä»¶
        yield {
          type: 'ui_progress',
          toolName: tool.name,
          progress: event.data
        };
      }
    }
  }
}

```

## äº‹ä»¶é©±åŠ¨ä¸æµå¼æ¶æ„

æ•´ä¸ªç³»ç»Ÿå»ºç«‹åœ¨æµå¼åŸè¯­ä¹‹ä¸Šï¼š

### æµå¼åå‹ç®¡ç†

```typescript
class StreamBackpressureController {
  private queue: StreamEvent[] = [];
  private processing = false;
  private pressure = {
    high: 1000, // å¼€å§‹ä¸¢å¼ƒéå…³é”®äº‹ä»¶
    critical: 5000, // é™¤é”™è¯¯å¤–ä¸¢å¼ƒæ‰€æœ‰å†…å®¹
  };

  async handleEvent(event: StreamEvent) {
    this.queue.push(event);

    // åº”ç”¨åå‹ç­–ç•¥
    if (this.queue.length > this.pressure.critical) {
      // åªä¿ç•™å…³é”®äº‹ä»¶
      this.queue = this.queue.filter(
        (e) => e.type === "error" || e.type === "message_stop",
      );
    } else if (this.queue.length > this.pressure.high) {
      // ä¸¢å¼ƒæ–‡æœ¬å¢é‡ï¼Œä¿ç•™ç»“æ„
      this.queue = this.queue.filter(
        (e) =>
          e.type !== "content_block_delta" || e.delta.type !== "text_delta",
      );
    }

    if (!this.processing) {
      await this.processQueue();
    }
  }

  private async processQueue() {
    this.processing = true;

    while (this.queue.length > 0) {
      const batch = this.queue.splice(0, 100); // æ‰¹é‡å¤„ç†
      await this.processBatch(batch);

      // è®©å‡ºç»™äº‹ä»¶å¾ªç¯
      await new Promise((resolve) => setImmediate(resolve));
    }

    this.processing = false;
  }
}
```

### è¿›åº¦äº‹ä»¶èšåˆ

å¤šä¸ªå¹¶å‘æ“ä½œéœ€è¦åè°ƒçš„è¿›åº¦æŠ¥å‘Šï¼š

```typescript
class ProgressAggregator {
  private progressStreams = new Map<string, AsyncIterator<ProgressEvent>>();

  async *aggregateProgress(
    operations: Array<{ id: string; operation: AsyncIterator<any> }>,
  ): AsyncGenerator<AggregatedProgress> {
    // å¯åŠ¨æ‰€æœ‰æ“ä½œ
    for (const { id, operation } of operations) {
      this.progressStreams.set(id, operation);
    }

    // è½®è¯¢æ‰€æœ‰æµ
    while (this.progressStreams.size > 0) {
      const promises = Array.from(this.progressStreams.entries()).map(
        async ([id, stream]) => {
          const { value, done } = await stream.next();
          return { id, value, done };
        },
      );

      // ç«äº‰ä¸‹ä¸€ä¸ªäº‹ä»¶
      const result = await Promise.race(promises);

      if (result.done) {
        this.progressStreams.delete(result.id);
      } else if (result.value.type === "progress") {
        yield {
          type: "aggregated_progress",
          source: result.id,
          progress: result.value,
        };
      }
    }
  }
}
```

## çŠ¶æ€ç®¡ç†æ¶æ„

Claude Code ä½¿ç”¨å®ç”¨çš„çŠ¶æ€ç®¡ç†æ–¹æ³•ï¼š

### å…¨å±€ä¼šè¯çŠ¶æ€

```typescript
// å¸¦ç›´æ¥å˜æ›´çš„å•ä¾‹ä¼šè¯çŠ¶æ€
class SessionState {
  private static instance: SessionState;

  // æ ¸å¿ƒçŠ¶æ€
  sessionId: string = crypto.randomUUID();
  cwd: string = process.cwd();
  totalCostUSD: number = 0;
  totalAPIDuration: number = 0;

  // æ¨¡å‹ä½¿ç”¨è¿½è¸ª
  modelTokens: Record<
    string,
    {
      inputTokens: number;
      outputTokens: number;
      cacheReadInputTokens: number;
      cacheCreationInputTokens: number;
    }
  > = {};

  // ç›´æ¥å˜æ›´æ–¹æ³•
  incrementCost(amount: number) {
    this.totalCostUSD += amount;
    this.persistToDisk(); // å¼‚æ­¥ï¼Œéé˜»å¡
  }

  updateTokenUsage(model: string, usage: TokenUsage) {
    if (!this.modelTokens[model]) {
      this.modelTokens[model] = {
        inputTokens: 0,
        outputTokens: 0,
        cacheReadInputTokens: 0,
        cacheCreationInputTokens: 0,
      };
    }

    const tokens = this.modelTokens[model];
    tokens.inputTokens += usage.input_tokens || 0;
    tokens.outputTokens += usage.output_tokens || 0;
    tokens.cacheReadInputTokens += usage.cache_read_input_tokens || 0;
    tokens.cacheCreationInputTokens += usage.cache_creation_input_tokens || 0;
  }

  private async persistToDisk() {
    // é˜²æŠ–å†™å…¥ä»¥é¿å…è¿‡å¤š I/O
    clearTimeout(this.persistTimer);
    this.persistTimer = setTimeout(async () => {
      await fs.writeFile(".claude/session.json", JSON.stringify(this, null, 2));
    }, 1000);
  }
}
```

### ä½¿ç”¨å¼±å¼•ç”¨çš„æ–‡ä»¶çŠ¶æ€

```typescript
class ReadFileState {
  private cache = new Map<string, WeakRef<FileContent>>();
  private registry = new FinalizationRegistry((path: string) => {
    // å½“ FileContent è¢«åƒåœ¾å›æ”¶æ—¶æ¸…ç†
    this.cache.delete(path);
  });

  set(path: string, content: FileContent) {
    const ref = new WeakRef(content);
    this.cache.set(path, ref);
    this.registry.register(content, path);
  }

  get(path: string): FileContent | undefined {
    const ref = this.cache.get(path);
    if (ref) {
      const content = ref.deref();
      if (!content) {
        // å†…å®¹å·²è¢«åƒåœ¾å›æ”¶
        this.cache.delete(path);
        return undefined;
      }
      return content;
    }
  }

  checkFreshness(path: string): "fresh" | "stale" | "unknown" {
    const cached = this.get(path);
    if (!cached) return "unknown";

    const stats = fs.statSync(path);
    if (stats.mtimeMs !== cached.timestamp) {
      return "stale";
    }

    return "fresh";
  }
}
```

## å®‰å…¨æ¶æ„

å®‰å…¨æ€§é€šè¿‡å¤šä¸ªç‹¬ç«‹å±‚å®ç°ï¼š

### ç¬¬ 1 å±‚ï¼šæƒé™ç³»ç»Ÿ

```typescript
class PermissionEvaluator {
  private ruleCache = new Map<string, CompiledRule>();

  async evaluate(
    tool: ToolDefinition,
    input: any,
    context: ToolPermissionContext,
  ): Promise<PermissionDecision> {
    // ä¼˜å…ˆçº§é¡ºåºè¯„ä¼°
    const scopes: PermissionRuleScope[] = [
      "cliArg", // æœ€é«˜ï¼šå‘½ä»¤è¡Œ
      "localSettings", // é¡¹ç›®ç‰¹å®šè¦†ç›–
      "projectSettings", // å…±äº«é¡¹ç›®è§„åˆ™
      "policySettings", // ç»„ç»‡ç­–ç•¥
      "userSettings", // æœ€ä½ï¼šç”¨æˆ·åå¥½
    ];

    for (const scope of scopes) {
      const decision = await this.evaluateScope(tool, input, context, scope);

      if (decision.behavior !== "continue") {
        return decision;
      }
    }

    // æ— åŒ¹é…è§„åˆ™ - è¯¢é—®ç”¨æˆ·
    return {
      behavior: "ask",
      suggestions: this.generateSuggestions(tool, input),
    };
  }

  private compileRule(rule: string): CompiledRule {
    if (this.ruleCache.has(rule)) {
      return this.ruleCache.get(rule)!;
    }

    // è§£æè§„åˆ™è¯­æ³•ï¼šToolName(glob/pattern)
    const match = rule.match(/^(\w+)(?:\((.+)\))?$/);
    if (!match) throw new Error(`Invalid rule: ${rule}`);

    const [, toolPattern, pathPattern] = match;

    const compiled = {
      toolMatcher: new RegExp(`^${toolPattern.replace("*", ".*")}$`),
      pathMatcher: pathPattern ? picomatch(pathPattern) : null,
    };

    this.ruleCache.set(rule, compiled);
    return compiled;
  }
}
```

### ç¬¬ 2 å±‚ï¼šæ²™ç®±æ¶æ„

```typescript
// macOS æ²™ç®±å®ç°
class MacOSSandboxManager {
  generateProfile(command: string, restrictions: SandboxRestrictions): string {
    const profile = `
(version 1)
(deny default)

; Base permissions
(allow process-exec (literal "/bin/bash"))
(allow process-exec (literal "/usr/bin/env"))

; File system access
${restrictions.allowRead ? "(allow file-read*)" : "(deny file-read*)"}
${restrictions.allowWrite ? "(allow file-write*)" : "(deny file-write*)"}

; Network access
${
  restrictions.allowNetwork
    ? `
(allow network-outbound)
(allow network-inbound)
`
    : `
(deny network*)
`
}

; System operations
(allow sysctl-read)
(allow mach-lookup)

; Temporary files
(allow file-write* (subpath "/tmp"))
(allow file-write* (subpath "/var/tmp"))
    `.trim();

    return profile;
  }

  async executeSandboxed(
    command: string,
    profile: string,
  ): Promise<ExecutionResult> {
    // å°†é…ç½®æ–‡ä»¶å†™å…¥ä¸´æ—¶æ–‡ä»¶
    const profilePath = await this.writeTemporaryProfile(profile);

    try {
      // ä½¿ç”¨ sandbox-exec æ‰§è¡Œ
      const result = await exec(`sandbox-exec -p '${profilePath}' ${command}`);

      return result;
    } finally {
      // æ¸…ç†
      await fs.unlink(profilePath);
    }
  }
}
```

### ç¬¬ 3 å±‚ï¼šè·¯å¾„éªŒè¯

```typescript
class PathValidator {
  private boundaries: Set<string>;
  private deniedPatterns: RegExp[];

  constructor(context: SecurityContext) {
    this.boundaries = new Set([
      context.projectRoot,
      ...context.additionalWorkingDirectories,
    ]);

    this.deniedPatterns = [
      /\/\.(ssh|gnupg)\//, // SSH/GPG å¯†é’¥
      /\/(etc|sys|proc)\//, // ç³»ç»Ÿç›®å½•
      /\.pem$|\.key$/, // ç§é’¥
      /\.(env|envrc)$/, // ç¯å¢ƒæ–‡ä»¶
    ];
  }

  validate(requestedPath: string): ValidationResult {
    const absolute = path.resolve(requestedPath);

    // æ£€æŸ¥è¾¹ç•Œ
    const inBoundary = Array.from(this.boundaries).some((boundary) =>
      absolute.startsWith(boundary),
    );

    if (!inBoundary) {
      return {
        allowed: false,
        reason: "Path outside allowed directories",
      };
    }

    // æ£€æŸ¥æ‹’ç»æ¨¡å¼
    for (const pattern of this.deniedPatterns) {
      if (pattern.test(absolute)) {
        return {
          allowed: false,
          reason: `Path matches denied pattern: ${pattern}`,
        };
      }
    }

    return { allowed: true };
  }
}
```

## æ€§èƒ½æ¶æ„

### ANRï¼ˆåº”ç”¨ç¨‹åºæ— å“åº”ï¼‰æ£€æµ‹

ANR ç³»ç»Ÿä½¿ç”¨å·¥ä½œçº¿ç¨‹æ¥ç›‘æ§ä¸»äº‹ä»¶å¾ªç¯ï¼š

```typescript
// å·¥ä½œçº¿ç¨‹è„šæœ¬ï¼ˆåµŒå…¥ä¸º base64ï¼‰
const anrWorkerScript = `
const { parentPort } = require('worker_threads');

let config = { anrThreshold: 5000, captureStackTrace: false };
let lastPing = Date.now();
let anrTimer = null;

function checkANR() {
  const elapsed = Date.now() - lastPing;

  if (elapsed > config.anrThreshold) {
    // ä¸»çº¿ç¨‹æ— å“åº”
    parentPort.postMessage({
      type: 'anr',
      payload: {
        elapsed,
        stackTrace: config.captureStackTrace
          ? captureMainThreadStack()
          : null
      }
    });
  }

  // å®‰æ’ä¸‹æ¬¡æ£€æŸ¥
  anrTimer = setTimeout(checkANR, 100);
}

async function captureMainThreadStack() {
  // å¦‚æœå¯ç”¨ï¼Œä½¿ç”¨æ£€æŸ¥å™¨åè®®
  try {
    const { Session } = require('inspector');
    const session = new Session();
    session.connect();

    const { result } = await session.post('Debugger.enable');
    const stack = await session.post('Debugger.getStackTrace');

    session.disconnect();
    return stack;
  } catch (e) {
    return null;
  }
}

parentPort.on('message', (msg) => {
  if (msg.type === 'config') {
    config = msg.payload;
    lastPing = Date.now();
    checkANR(); // å¼€å§‹ç›‘æ§
  } else if (msg.type === 'ping') {
    lastPing = Date.now();
  }
});
`;

// ä¸»çº¿ç¨‹ ANR é›†æˆ
class ANRMonitor {
  private worker: Worker;
  private pingInterval: NodeJS.Timer;

  constructor(options: ANROptions = {}) {
    // ä»åµŒå…¥è„šæœ¬åˆ›å»ºå·¥ä½œçº¿ç¨‹
    this.worker = new Worker(anrWorkerScript, { eval: true });

    // é…ç½®å·¥ä½œçº¿ç¨‹
    this.worker.postMessage({
      type: "config",
      payload: {
        anrThreshold: options.threshold || 5000,
        captureStackTrace: options.captureStackTrace !== false,
      },
    });

    // å¯åŠ¨å¿ƒè·³
    this.pingInterval = setInterval(() => {
      this.worker.postMessage({ type: "ping" });
    }, options.pollInterval || 50);

    // å¤„ç† ANR æ£€æµ‹
    this.worker.on("message", (msg) => {
      if (msg.type === "anr") {
        this.handleANR(msg.payload);
      }
    });
  }

  private handleANR(data: ANRData) {
    // è®°å½•åˆ°é¥æµ‹
    Sentry.captureException(
      new Error(`Application not responding for ${data.elapsed}ms`),
      {
        extra: {
          stackTrace: data.stackTrace,
          eventLoopDelay: this.getEventLoopDelay(),
        },
      },
    );
  }
}
```

### æˆ˜ç•¥ç¼“å­˜å±‚

```typescript
class CacheArchitecture {
  // L1: å†…å­˜ç¼“å­˜
  private schemaCache = new LRUCache<string, JSONSchema>(100);
  private patternCache = new LRUCache<string, CompiledPattern>(500);
  private gitContextCache = new TTLCache<string, GitContext>(30_000); // 30s TTL

  // L2: å¼±å¼•ç”¨ç¼“å­˜
  private fileContentCache = new WeakRefCache<FileContent>();

  // L3: ç£ç›˜ç¼“å­˜
  private diskCache = new DiskCache(".claude/cache");

  async get<T>(
    key: string,
    generator: () => Promise<T>,
    options: CacheOptions = {},
  ): Promise<T> {
    // æ£€æŸ¥ L1
    if (this.schemaCache.has(key)) {
      return this.schemaCache.get(key) as T;
    }

    // æ£€æŸ¥ L2
    const weakRef = this.fileContentCache.get(key);
    if (weakRef) {
      return weakRef as T;
    }

    // æ£€æŸ¥ L3
    if (options.persistent) {
      const diskValue = await this.diskCache.get(key);
      if (diskValue) {
        return diskValue;
      }
    }

    // ç”Ÿæˆå¹¶ç¼“å­˜
    const value = await generator();

    // å­˜å‚¨åœ¨é€‚å½“çš„ç¼“å­˜ä¸­
    if (options.weak) {
      this.fileContentCache.set(key, value);
    } else if (options.persistent) {
      await this.diskCache.set(key, value, options.ttl);
    } else {
      this.schemaCache.set(key, value as any);
    }

    return value;
  }
}
```

## é¥æµ‹ä¸å¯è§‚æµ‹æ€§è®¾è®¡

ä¸‰æ”¯æŸ±æ–¹æ³•æä¾›å…¨é¢çš„å¯è§æ€§ï¼š

### æ”¯æŸ± 1ï¼šé”™è¯¯è¿½è¸ªï¼ˆSentryï¼‰

```typescript
class ErrorBoundary {
  static wrap<T extends (...args: any[]) => any>(
    fn: T,
    context: ErrorContext
  ): T {
    return (async (...args: Parameters<T>) => {
      const span = Sentry.startTransaction({
        name: context.operation,
        op: context.category
      });

      try {
        const result = await fn(...args);
        span.setStatus('ok');
        return result;
      } catch (error) {
        span.setStatus('internal_error');

        Sentry.captureException(error, {
          contexts: {
            operation: context,
            state: this.captureState()
          },
          fingerprint: this.generateFingerprint(error, context)
        });

        throw error;
      } finally {
        span.finish();
      }
    }) as T;
  }

  private static captureState() {
    return {
      sessionId: SessionState.instance.sessionId,
      conversationDepth: /* current depth */,
      activeTools: /* currently executing */,
      memoryUsage: process.memoryUsage(),
      eventLoopDelay: this.getEventLoopDelay()
    };
  }
}

```

### æ”¯æŸ± 2ï¼šæŒ‡æ ‡ï¼ˆOpenTelemetryï¼‰

```typescript
class MetricsCollector {
  private meters = {
    api: meter.createCounter('api_calls_total'),
    tokens: meter.createHistogram('token_usage'),
    tools: meter.createHistogram('tool_execution_duration'),
    streaming: meter.createHistogram('streaming_latency')
  };

  recordApiCall(result: ApiCallResult) {
    this.meters.api.add(1, {
      model: result.model,
      status: result.status,
      provider: result.provider
    });

    this.meters.tokens.record(result.totalTokens, {
      model: result.model,
      type: 'total'
    });
  }

  recordToolExecution(tool: string, duration: number, success: boolean) {
    this.meters.tools.record(duration, {
      tool,
      success: String(success),
      concurrent: /* was parallel? */
    });
  }
}

```

### æ”¯æŸ± 3ï¼šåŠŸèƒ½æ ‡å¿—ï¼ˆStatsigï¼‰

```typescript
class FeatureManager {
  async checkGate(gate: string, context?: FeatureContext): Promise<boolean> {
    return statsig.checkGate(gate, {
      userID: SessionState.instance.sessionId,
      custom: {
        model: context?.model,
        toolsEnabled: context?.tools,
        platform: process.platform,
      },
    });
  }

  async getConfig<T>(config: string, defaultValue: T): Promise<T> {
    const dynamicConfig = statsig.getConfig(config);
    return dynamicConfig.get("value", defaultValue);
  }
}
```

## èµ„æºç®¡ç†

### è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†

```typescript
class ProcessManager {
  private processes = new Map<string, ChildProcess>();
  private limits = {
    maxProcesses: 10,
    maxMemoryPerProcess: 512 * 1024 * 1024, // 512MB
    maxTotalMemory: 2 * 1024 * 1024 * 1024, // 2GB
  };

  async spawn(
    id: string,
    command: string,
    options: SpawnOptions,
  ): Promise<ManagedProcess> {
    // æ£€æŸ¥é™åˆ¶
    if (this.processes.size >= this.limits.maxProcesses) {
      await this.killOldestProcess();
    }

    const child = spawn("bash", ["-c", command], {
      ...options,
      // èµ„æºé™åˆ¶
      env: {
        ...options.env,
        NODE_OPTIONS: `--max-old-space-size=${this.limits.maxMemoryPerProcess / 1024 / 1024}`,
      },
    });

    // ç›‘æ§èµ„æº
    const monitor = setInterval(() => {
      this.checkProcessHealth(id, child);
    }, 1000);

    this.processes.set(id, child);

    return new ManagedProcess(child, monitor);
  }

  private async checkProcessHealth(id: string, proc: ChildProcess) {
    try {
      const usage = await pidusage(proc.pid);

      if (usage.memory > this.limits.maxMemoryPerProcess) {
        console.warn(`Process ${id} exceeding memory limit`);
        proc.kill("SIGTERM");
      }
    } catch (e) {
      // è¿›ç¨‹å¯èƒ½å·²é€€å‡º
      this.processes.delete(id);
    }
  }
}
```

### ç½‘ç»œè¿æ¥æ± 

```typescript
class NetworkPool {
  private pools = new Map<string, ConnectionPool>();

  getPool(provider: string): ConnectionPool {
    if (!this.pools.has(provider)) {
      this.pools.set(
        provider,
        new ConnectionPool({
          maxConnections: provider === "anthropic" ? 10 : 5,
          maxIdleTime: 30_000,
          keepAlive: true,
        }),
      );
    }

    return this.pools.get(provider)!;
  }

  async request(provider: string, options: RequestOptions): Promise<Response> {
    const pool = this.getPool(provider);
    const connection = await pool.acquire();

    try {
      return await connection.request(options);
    } finally {
      pool.release(connection);
    }
  }
}
```

---

_æ­¤æ¶æ„åˆ†æåŸºäºé€†å‘å·¥ç¨‹å’Œåç¼–è¯‘ã€‚å®é™…å®ç°å¯èƒ½æœ‰æ‰€ä¸åŒã€‚æ‰€å‘ˆç°çš„æ¨¡å¼ä»£è¡¨åŸºäºå¯è§‚å¯Ÿè¡Œä¸ºå’Œé«˜æ€§èƒ½ Node.js åº”ç”¨ç¨‹åºå¸¸è§å®è·µæ¨æ–­çš„æ¶æ„å†³ç­–ã€‚_
