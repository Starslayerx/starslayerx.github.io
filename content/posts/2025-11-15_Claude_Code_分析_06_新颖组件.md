+++
date = '2025-11-14T14:00:00+01:00'
draft = false
title = 'Claude Code 分析 06：新颖组件'
tags = ['Agent']
+++

# ✨ 新颖组件：定义 Claude Code 的创新

```mermaid
graph TB
    subgraph "流式处理挑战"
        PartialJSON[部分 JSON 流]
        PartialXML[部分 XML 流]
        Progress[并发进度]

        PartialJSON --> Parser1[流式 JSON 解析器]
        PartialXML --> Parser2[自定义 XML 解析器]
        Progress --> Aggregator[进度聚合器]
    end

    subgraph "数据挑战"
        LargeObjects[大型对象]
        Circular[循环引用]
        TypedData[特殊类型]

        LargeObjects --> Normalizer[normalizeToSize]
        Circular --> Normalizer
        TypedData --> Normalizer
    end

    subgraph "LLM 挑战"
        Errors[工具错误]
        Context[动态上下文]
        Synthesis[多结果合成]

        Errors --> Formatter[错误格式化器]
        Context --> Assembler[上下文组装器]
        Synthesis --> Synthesizer[AgentTool 合成器]
    end

```

## 流式 JSON 解析器：处理 LLM 的部分思考

当 LLM 流式传输工具使用请求时，它不会一次性发送完整的 JSON。相反，你可能会收到这样的片段：

```plain text
{"file_path": "/src/
{"file_path": "/src/main.
{"file_path": "/src/main.ts", "old_str
{"file_path": "/src/main.ts", "old_string": "console.log('hell

```

流式 JSON 解析器优雅地解决了这个问题：

```typescript
class StreamingToolInputParser {
  private buffer: string = '';
  private state = {
    depth: 0,           // {} 或 [] 的嵌套层级
    inString: boolean,  // 当前是否在字符串内？
    escape: boolean,    // 前一个字符是反斜杠？
    stringChar: '"' | "'" | null,  // 哪个引号开始了当前字符串
  };

  addChunk(chunk: string): ParseResult {
    this.buffer += chunk;

    // 逐字符更新解析器状态
    for (let i = 0; i < chunk.length; i++) {
      const char = chunk[i];
      const prevChar = i > 0 ? chunk[i-1] : this.buffer[this.buffer.length - chunk.length - 1];

      // 处理转义序列
      if (this.escape) {
        this.escape = false;
        continue;
      }

      if (char === '\\\\' && this.state.inString) {
        this.escape = true;
        continue;
      }

      // 字符串边界检测
      if (!this.state.inString && (char === '"' || char === "'")) {
        this.state.inString = true;
        this.state.stringChar = char;
      } else if (this.state.inString && char === this.state.stringChar) {
        this.state.inString = false;
        this.state.stringChar = null;
      }

      // 在字符串外跟踪嵌套深度
      if (!this.state.inString) {
        if (char === '{' || char === '[') {
          this.state.depth++;
        } else if (char === '}' || char === ']') {
          this.state.depth--;

          // 当我们返回到深度 0 时尝试解析
          if (this.state.depth === 0) {
            return this.tryParse();
          }
        }
      }
    }

    // 即使没有达到深度 0 也可能是完整的（格式错误的 JSON）
    if (this.buffer.length > 10000) { // 安全限制
      return this.tryParseWithRecovery();
    }

    return { complete: false };
  }

  private tryParse(): ParseResult {
    try {
      const parsed = JSON.parse(this.buffer);
      return { complete: true, value: parsed };
    } catch (e) {
      return { complete: false, partial: this.buffer };
    }
  }

  private tryParseWithRecovery(): ParseResult {
    let attemptBuffer = this.buffer;

    // 恢复策略 1：关闭未闭合的字符串
    if (this.state.inString && this.state.stringChar) {
      attemptBuffer += this.state.stringChar;

      // 尝试关闭所有未闭合的结构
      attemptBuffer += '}'.repeat(Math.max(0, this.state.depth));
      attemptBuffer += ']'.repeat(
        Math.max(0, (attemptBuffer.match(/\[/g) || []).length -
                    (attemptBuffer.match(/\]/g) || []).length)
      );
    }

    // 恢复策略 2：基于结构分析自动关闭
    const braceBalance = (attemptBuffer.match(/{/g) || []).length -
                        (attemptBuffer.match(/}/g) || []).length;
    const bracketBalance = (attemptBuffer.match(/\[/g) || []).length -
                          (attemptBuffer.match(/\]/g) || []).length;

    attemptBuffer += '}'.repeat(Math.max(0, braceBalance));
    attemptBuffer += ']'.repeat(Math.max(0, bracketBalance));

    try {
      const parsed = JSON.parse(attemptBuffer);
      return {
        complete: true,
        value: parsed,
        wasRepaired: true,
        repairs: {
          closedStrings: this.state.inString,
          addedBraces: braceBalance,
          addedBrackets: bracketBalance
        }
      };
    } catch (e) {
      // 恢复策略 3：提取我们能提取的内容
      const partialResult = this.extractPartialData(this.buffer);
      return {
        complete: false,
        partial: partialResult,
        error: e.message
      };
    }
  }

  private extractPartialData(buffer: string): any {
    // 尝试提取完整的键值对
    const result: any = {};
    const keyValuePattern = /"(\w+)":\s*("([^"\\]*(\\.[^"\\]*)*)"|true|false|null|\d+)/g;

    let match;
    while ((match = keyValuePattern.exec(buffer)) !== null) {
      const [, key, value] = match;
      try {
        result[key] = JSON.parse(value);
      } catch {
        result[key] = value; // 如果解析失败则存储为字符串
      }
    }

    return Object.keys(result).length > 0 ? result : null;
  }
}

```

**为什么这是创新的**：
- 传统的 JSON 解析器在不完整的输入上会失败
- 这个解析器提供渐进式解析，并产生有意义的部分结果
- 恢复策略处理常见的 LLM 流式问题
- 使响应式 UI 能够在工具输入流式传输时显示它们

**性能特征**：

| 输入大小 | 解析时间 | 内存 | 成功率 |
|---------|---------|------|--------|
| <1KB | <0.1ms | O(n) | 100% |
| 1-10KB | 0.1-1ms | O(n) | 99.9% |
| 10-100KB | 1-10ms | O(n) | 99.5% |
| >100KB | 10-50ms | O(n) | 98%（含恢复） |

## `normalizeToSize` 算法：智能数据截断

当向 LLM 或遥测服务发送数据时，大小限制至关重要。`normalizeToSize` 算法智能地减少对象大小，同时保留结构：

```typescript
class DataNormalizer {
  static normalizeToSize(
    obj: any,
    maxDepth: number = 3,
    maxSizeInBytes: number = 100_000
  ): any {
    // 首先尝试完整深度
    let normalized = this.normalize(obj, maxDepth);
    let size = this.estimateSize(normalized);

    // 迭代减少深度直到大小适合
    while (size > maxSizeInBytes && maxDepth > 0) {
      maxDepth--;
      normalized = this.normalize(obj, maxDepth);
      size = this.estimateSize(normalized);
    }

    return normalized;
  }

  private static normalize(
    obj: any,
    maxDepth: number,
    currentDepth: number = 0,
    visited = new WeakSet()
  ): any {
    // 处理原始类型
    if (obj === null) return '[null]';
    if (obj === undefined) return '[undefined]';
    if (typeof obj === 'number' && isNaN(obj)) return '[NaN]';
    if (typeof obj === 'bigint') return `[BigInt: ${obj}n]`;

    // 处理函数和符号
    if (typeof obj === 'function') {
      return `[Function: ${obj.name || 'anonymous'}]`;
    }
    if (typeof obj === 'symbol') {
      return `[Symbol: ${obj.description || 'Symbol'}]`;
    }

    // 原始类型直接传递
    if (['string', 'number', 'boolean'].includes(typeof obj)) {
      return obj;
    }

    // 达到深度限制
    if (currentDepth >= maxDepth) {
      if (Array.isArray(obj)) return `[Array(${obj.length})]`;
      if (obj.constructor?.name) {
        return `[${obj.constructor.name}]`;
      }
      return '[Object]';
    }

    // 循环引用检测
    if (visited.has(obj)) {
      return '[Circular]';
    }
    visited.add(obj);

    // 已知类型的特殊处理
    if (this.isReactElement(obj)) {
      return `[React.${obj.type?.name || obj.type || 'Element'}]`;
    }

    if (this.isVueComponent(obj)) {
      return `[Vue.${obj.$options?.name || 'Component'}]`;
    }

    if (obj instanceof Error) {
      return {
        name: obj.name,
        message: obj.message,
        stack: this.truncateStack(obj.stack)
      };
    }

    if (obj instanceof Date) {
      return obj.toISOString();
    }

    if (obj instanceof RegExp) {
      return obj.toString();
    }

    // 处理 DOM 元素
    if (this.isDOMElement(obj)) {
      return `[${obj.tagName}${obj.id ? '#' + obj.id : ''}]`;
    }

    // 处理 toJSON 方法
    if (typeof obj.toJSON === 'function') {
      try {
        return this.normalize(
          obj.toJSON(),
          maxDepth,
          currentDepth,
          visited
        );
      } catch {
        return '[Object with toJSON error]';
      }
    }

    // 数组
    if (Array.isArray(obj)) {
      const result = [];
      const maxItems = 100; // 限制数组大小

      for (let i = 0; i < Math.min(obj.length, maxItems); i++) {
        result.push(
          this.normalize(obj[i], maxDepth, currentDepth + 1, visited)
        );
      }

      if (obj.length > maxItems) {
        result.push(`... ${obj.length - maxItems} more items`);
      }

      return result;
    }

    // 对象
    const result: any = {};
    const keys = Object.keys(obj);
    const maxProps = 50; // 限制对象属性

    // 遵守 Sentry 指令
    if (obj.__sentry_skip_normalization__) {
      return obj;
    }

    const effectiveMaxDepth =
      obj.__sentry_override_normalization_depth__ || maxDepth;

    for (let i = 0; i < Math.min(keys.length, maxProps); i++) {
      const key = keys[i];
      try {
        result[key] = this.normalize(
          obj[key],
          effectiveMaxDepth,
          currentDepth + 1,
          visited
        );
      } catch {
        result[key] = '[Error accessing property]';
      }
    }

    if (keys.length > maxProps) {
      result['...'] = `${keys.length - maxProps} more properties`;
    }

    return result;
  }

  private static estimateSize(obj: any): number {
    // 快速估算而不需要完整序列化
    const sample = JSON.stringify(obj).substring(0, 1000);
    const avgCharSize = new Blob([sample]).size / sample.length;

    const fullLength = this.estimateJsonLength(obj);
    return Math.ceil(fullLength * avgCharSize);
  }

  private static estimateJsonLength(obj: any, visited = new WeakSet()): number {
    if (obj === null || obj === undefined) return 4; // "null"
    if (typeof obj === 'boolean') return obj ? 4 : 5; // "true" : "false"
    if (typeof obj === 'number') return String(obj).length;
    if (typeof obj === 'string') return obj.length + 2; // 引号

    if (visited.has(obj)) return 12; // "[Circular]"
    visited.add(obj);

    if (Array.isArray(obj)) {
      let length = 2; // []
      for (const item of obj) {
        length += this.estimateJsonLength(item, visited) + 1; // 逗号
      }
      return length;
    }

    if (typeof obj === 'object') {
      let length = 2; // {}
      for (const key in obj) {
        length += key.length + 3; // "key":
        length += this.estimateJsonLength(obj[key], visited) + 1; // 逗号
      }
      return length;
    }

    return 10; // 默认估算
  }
}

```

**为什么这是创新的**：
- 基于实际字节大小的迭代深度减少
- 针对特殊对象的类型感知字符串化
- 尊重框架特定的对象（React、Vue）
- 使用 WeakSet 进行循环检测的内存高效方案
- 在约束内尽可能保留信息

**使用场景**：

```typescript
// LLM 上下文准备
const context = normalizeToSize(
  largeProjectState,
  10,     // 从深度 10 开始
  50_000  // 上下文的 50KB 限制
);

// 遥测错误报告
const errorContext = normalizeToSize(
  applicationState,
  5,       // 合理的深度
  10_000   // 错误报告的 10KB
);

```

## AgentTool 合成：编排多个视角

AgentTool 不仅仅是运行子代理——它智能地组合它们的结果：

```typescript
class AgentToolSynthesizer {
  static async synthesizeResults(
    results: SubAgentResult[],
    originalTask: string,
    context: ToolUseContext
  ): Promise<string> {
    // 单个结果 - 不需要合成
    if (results.length === 1) {
      return results[0].content;
    }

    // 准备合成上下文
    const synthesisData = this.prepareSynthesisData(results);

    // 计算合成的 token 预算
    const tokenBudget = this.calculateSynthesisTokenBudget(
      results,
      originalTask
    );

    // 构建合成提示
    const synthesisPrompt = this.buildSynthesisPrompt(
      originalTask,
      synthesisData,
      tokenBudget
    );

    // 使用快速模型进行合成
    const synthesizer = new SubAgentExecutor({
      prompt: synthesisPrompt,
      model: 'claude-3-haiku-20240307',
      maxTokens: tokenBudget.output,
      isSynthesis: true,
      temperature: 0.3 // 较低的温度用于事实合成
    });

    return synthesizer.execute();
  }

  private static prepareSynthesisData(
    results: SubAgentResult[]
  ): SynthesisData {
    // 从每个结果中提取关键信息
    const data = results.map((result, index) => ({
      agentId: index + 1,
      content: result.content,
      keyFindings: this.extractKeyFindings(result.content),
      toolsUsed: result.toolsUsed,
      confidence: this.assessConfidence(result),
      tokensUsed: result.usage.total_tokens,
      uniqueInsights: []
    }));

    // 识别代理之间的独特见解
    this.identifyUniqueInsights(data);

    // 找到共识和分歧
    const consensus = this.findConsensus(data);
    const conflicts = this.findConflicts(data);

    return {
      agents: data,
      consensus,
      conflicts,
      coverageMap: this.buildCoverageMap(data)
    };
  }

  private static buildSynthesisPrompt(
    originalTask: string,
    data: SynthesisData,
    tokenBudget: TokenBudget
  ): string {
    return `You are a synthesis agent tasked with combining findings from ${data.agents.length} independent investigations.

## Original Task
${originalTask}

## Investigation Results

${data.agents.map(agent => `
### Agent ${agent.agentId} Findings
**Tools Used**: ${agent.toolsUsed.join(', ') || 'None'}
**Confidence**: ${agent.confidence}/5
**Token Efficiency**: ${agent.tokensUsed} tokens

${agent.content}

**Key Points**:
${agent.keyFindings.map(f => `- ${f}`).join('\n')}
`).join('\n---\n')}

## Consensus Points
${data.consensus.map(c => `- ${c.point} (agreed by ${c.agentIds.join(', ')})`).join('\n')}

## Conflicting Information
${data.conflicts.map(c => `- ${c.description}`).join('\n') || 'No conflicts found.'}

## Coverage Analysis
${this.formatCoverageMap(data.coverageMap)}

## Your Task
Synthesize these findings into a single, comprehensive response that:
1. Presents a unified view of the findings
2. Highlights areas of agreement
3. Notes any contradictions or uncertainties
4. Provides the most complete answer to the original task

Keep your response under ${tokenBudget.output} tokens.
Focus on actionable insights and concrete findings.
`;
  }

  private static extractKeyFindings(content: string): string[] {
    // 使用启发式方法提取关键点
    const findings: string[] = [];

    // 查找项目符号点
    const bulletPoints = content.match(/^[\s-*•]+(.+)$/gm) || [];
    findings.push(...bulletPoints.map(b => b.trim()));

    // 查找编号列表
    const numberedItems = content.match(/^\d+\.\s+(.+)$/gm) || [];
    findings.push(...numberedItems.map(n => n.replace(/^\d+\.\s+/, '')));

    // 查找结论标记
    const conclusions = content.match(
      /(?:concluded?|found|discovered|determined):\s*(.+?)(?:\.|$)/gi
    ) || [];
    findings.push(...conclusions);

    // 限制并去重
    return [...new Set(findings)].slice(0, 5);
  }

  private static assessConfidence(result: SubAgentResult): number {
    let confidence = 3; // 基线

    // 更多工具使用提高置信度
    if (result.toolsUsed.length > 3) confidence++;
    if (result.toolsUsed.length > 5) confidence++;

    // 错误降低置信度
    if (result.hadErrors) confidence--;

    // 基于结果模式的置信度
    if (result.content.includes('unable to') ||
        result.content.includes('could not find')) {
      confidence--;
    }

    if (result.content.includes('successfully') ||
        result.content.includes('confirmed')) {
      confidence++;
    }

    return Math.max(1, Math.min(5, confidence));
  }

  private static identifyUniqueInsights(data: AgentData[]): void {
    // 构建见解的频率映射
    const insightFrequency = new Map<string, number>();

    for (const agent of data) {
      for (const finding of agent.keyFindings) {
        const normalized = this.normalizeInsight(finding);
        insightFrequency.set(
          normalized,
          (insightFrequency.get(normalized) || 0) + 1
        );
      }
    }

    // 标记独特的见解
    for (const agent of data) {
      agent.uniqueInsights = agent.keyFindings.filter(finding => {
        const normalized = this.normalizeInsight(finding);
        return insightFrequency.get(normalized) === 1;
      });
    }
  }
}

```

**为什么这是创新的**：
- 超越简单的连接，实现智能合成
- 跨代理提取和比较关键发现
- 识别共识和冲突
- 使用专用的合成模型以提高效率
- 保留独特见解同时消除冗余

## 错误格式化管道：使失败可操作

错误需要为 LLM 和人类以不同方式格式化：

```typescript
class ErrorFormatter {
  static formatToolErrorContent(
    error: any,
    tool: ToolDefinition,
    context?: ErrorContext
  ): ContentBlock[] {
    const errorType = this.classifyError(error);
    const formatter = this.formatters[errorType] || this.defaultFormatter;

    return formatter(error, tool, context);
  }

  private static formatters = {
    shell: (error: ShellError, tool: ToolDefinition): ContentBlock[] => {
      const blocks: ContentBlock[] = [];

      // 主要错误消息
      blocks.push({
        type: 'text',
        text: `Tool '${tool.name}' failed with exit code ${error.exitCode}`
      });

      // 如果存在，包含 stdout
      if (error.stdout && error.stdout.trim()) {
        blocks.push({
          type: 'text',
          text: `stdout:\n\`\`\`\n${this.truncateOutput(error.stdout)}\n\`\`\``
        });
      }

      // 如果存在，包含 stderr
      if (error.stderr && error.stderr.trim()) {
        blocks.push({
          type: 'text',
          text: `stderr:\n\`\`\`\n${this.truncateOutput(error.stderr)}\n\`\`\``
        });
      }

      // 添加上下文提示
      const hints = this.generateShellErrorHints(error);
      if (hints.length > 0) {
        blocks.push({
          type: 'text',
          text: `\nPossible issues:\n${hints.map(h => `- ${h}`).join('\n')}`
        });
      }

      // 建议替代方案
      const suggestions = this.generateShellSuggestions(error);
      if (suggestions.length > 0) {
        blocks.push({
          type: 'text',
          text: `\nSuggestions:\n${suggestions.map(s => `- ${s}`).join('\n')}`
        });
      }

      return blocks;
    },

    validation: (error: ZodError, tool: ToolDefinition): ContentBlock[] => {
      const issues = error.issues.map(issue => {
        const path = issue.path.join('.');
        const fieldName = path || 'input';

        // 基于错误类型的格式化
        switch (issue.code) {
          case 'invalid_type':
            return `- ${fieldName}: Expected ${issue.expected}, received ${issue.received}`;

          case 'too_small':
            if (issue.type === 'string') {
              return `- ${fieldName}: Must be at least ${issue.minimum} characters`;
            } else if (issue.type === 'array') {
              return `- ${fieldName}: Must have at least ${issue.minimum} items`;
            }
            return `- ${fieldName}: Value too small`;

          case 'too_big':
            if (issue.type === 'string') {
              return `- ${fieldName}: Must be at most ${issue.maximum} characters`;
            }
            return `- ${fieldName}: Value too large`;

          case 'invalid_enum_value':
            return `- ${fieldName}: Must be one of: ${issue.options.join(', ')}`;

          case 'custom':
            return `- ${fieldName}: ${issue.message}`;

          default:
            return `- ${fieldName}: ${issue.message}`;
        }
      });

      return [{
        type: 'text',
        text: `Tool '${tool.name}' input validation failed:\n${issues.join('\n')}\n\nPlease check your input parameters and try again.`
      }];
    },

    permission: (error: PermissionError, tool: ToolDefinition): ContentBlock[] => {
      const blocks: ContentBlock[] = [];

      blocks.push({
        type: 'text',
        text: `Permission denied for ${tool.name}`
      });

      if (error.reason) {
        blocks.push({
          type: 'text',
          text: `Reason: ${error.reason}`
        });
      }

      if (error.rule) {
        blocks.push({
          type: 'text',
          text: `Denied by rule: ${error.rule.scope}:${error.rule.pattern}`
        });
      }

      // 提供可操作的指导
      if (error.suggestions && error.suggestions.length > 0) {
        blocks.push({
          type: 'text',
          text: `\nTo proceed, you could:\n${error.suggestions.map(s => `- ${s}`).join('\n')}`
        });
      } else {
        blocks.push({
          type: 'text',
          text: '\nThis operation requires explicit user permission. Please ask the user if they want to proceed.'
        });
      }

      return blocks;
    },

    filesystem: (error: FileSystemError, tool: ToolDefinition): ContentBlock[] => {
      const blocks: ContentBlock[] = [];

      blocks.push({
        type: 'text',
        text: `File system error in ${tool.name}: ${error.code}`
      });

      // 基于错误代码的具体指导
      const guidance = {
        'ENOENT': 'File or directory not found. Check the path exists.',
        'EACCES': 'Permission denied. The file may be read-only or require elevated permissions.',
        'EEXIST': 'File already exists. Consider using a different name or checking before creating.',
        'EISDIR': 'Expected a file but found a directory.',
        'ENOTDIR': 'Expected a directory but found a file.',
        'EMFILE': 'Too many open files. Some file handles may need to be closed.',
        'ENOSPC': 'No space left on device.',
        'EROFS': 'Read-only file system.'
      };

      if (guidance[error.code]) {
        blocks.push({
          type: 'text',
          text: guidance[error.code]
        });
      }

      if (error.path) {
        blocks.push({
          type: 'text',
          text: `Path: ${error.path}`
        });
      }

      return blocks;
    }
  };

  private static generateShellErrorHints(error: ShellError): string[] {
    const hints: string[] = [];

    // 命令未找到
    if (error.stderr?.includes('command not found') ||
        error.stderr?.includes('not found')) {
      hints.push('The command may not be installed or not in PATH');

      // 建议常见的替代方案
      const command = error.command.split(' ')[0];
      const alternatives = {
        'python': 'Try python3 instead',
        'pip': 'Try pip3 instead',
        'node': 'Node.js may not be installed',
        'npm': 'npm may not be installed'
      };

      if (alternatives[command]) {
        hints.push(alternatives[command]);
      }
    }

    // 权限被拒绝
    if (error.stderr?.includes('Permission denied') ||
        error.stderr?.includes('Operation not permitted')) {
      hints.push('Try running with different permissions or in a different directory');
      hints.push('Check if the file/directory has the correct ownership');
    }

    // 网络错误
    if (error.stderr?.includes('Could not resolve host') ||
        error.stderr?.includes('Connection refused')) {
      hints.push('Network connectivity issue detected');
      hints.push('Check if you need to set sandbox=false for network access');
    }

    return hints;
  }

  private static truncateOutput(output: string, maxLength: number = 1000): string {
    if (output.length <= maxLength) return output;

    // 尝试在换行符处截断
    const truncatePoint = output.lastIndexOf('\n', maxLength);
    const actualTruncate = truncatePoint > maxLength * 0.8 ? truncatePoint : maxLength;

    return output.substring(0, actualTruncate) +
           `\n... (${output.length - actualTruncate} characters truncated)`;
  }
}

```

**为什么这是创新的**：
- 为 LLM 理解定制的错误消息
- 包含可操作的建议
- 保留关键的调试信息（stdout/stderr）
- 提供上下文感知的提示
- 将 Zod 验证错误格式化为自然语言

## 动态上下文组装：智能优先级排序

上下文组装系统超越了简单的连接：

```typescript
class DynamicContextAssembler {
  private static readonly CONTEXT_PRIORITIES = {
    baseInstructions: 1,
    modelAdaptations: 2,
    claudeMdContent: 3,
    gitContext: 4,
    directoryStructure: 5,
    toolSpecifications: 6,
    activeSelections: 3.5, // 在 CLAUDE.md 和 git 之间
    recentErrors: 2.5      // 错误上下文的高优先级
  };

  static async assembleSystemPrompt(
    components: ContextComponents,
    tokenBudget: number,
    model: string
  ): Promise<string | ContentBlock[]> {
    // 阶段 1：收集所有带有元数据的组件
    const sections = await this.gatherSections(components, model);

    // 阶段 2：计算 token 成本
    const tokenizedSections = await this.tokenizeSections(sections);

    // 阶段 3：智能截断
    const selectedSections = this.selectSections(
      tokenizedSections,
      tokenBudget
    );

    // 阶段 4：格式化并组合
    return this.formatSystemPrompt(selectedSections);
  }

  private static async gatherSections(
    components: ContextComponents,
    model: string
  ): Promise<ContextSection[]> {
    const sections: ContextSection[] = [];

    // 基础说明（始终包含）
    sections.push({
      priority: this.CONTEXT_PRIORITIES.baseInstructions,
      content: components.baseInstructions,
      required: true,
      type: 'base'
    });

    // 模型特定的适配
    const modelAdaptations = await this.getModelAdaptations(model);
    sections.push({
      priority: this.CONTEXT_PRIORITIES.modelAdaptations,
      content: modelAdaptations,
      required: true,
      type: 'model'
    });

    // 具有分层加载的 CLAUDE.md
    const claudeMdContent = await this.loadClaudeMdHierarchy();
    sections.push({
      priority: this.CONTEXT_PRIORITIES.claudeMdContent,
      content: this.formatClaudeMd(claudeMdContent),
      required: false,
      type: 'claudemd',
      metadata: {
        sources: claudeMdContent.map(c => c.source),
        totalSize: claudeMdContent.reduce((sum, c) => sum + c.content.length, 0)
      }
    });

    // 带有智能摘要的 Git 上下文
    const gitContext = await this.getGitContext();
    sections.push({
      priority: this.CONTEXT_PRIORITIES.gitContext,
      content: this.formatGitContext(gitContext),
      required: false,
      type: 'git',
      canSummarize: true,
      summarizer: () => this.summarizeGitContext(gitContext)
    });

    // 带有深度控制的目录结构
    const dirStructure = await this.getDirectoryStructure();
    sections.push({
      priority: this.CONTEXT_PRIORITIES.directoryStructure,
      content: dirStructure.full,
      required: false,
      type: 'directory',
      alternatives: [
        { depth: 3, content: dirStructure.depth3 },
        { depth: 2, content: dirStructure.depth2 },
        { depth: 1, content: dirStructure.depth1 }
      ]
    });

    // 工具规范
    const toolSpecs = await this.formatToolSpecifications(components.tools);
    sections.push({
      priority: this.CONTEXT_PRIORITIES.toolSpecifications,
      content: toolSpecs.full,
      required: true, // 工具必须包含
      type: 'tools',
      alternatives: [
        { level: 'minimal', content: toolSpecs.minimal },
        { level: 'names-only', content: toolSpecs.namesOnly }
      ]
    });

    return sections;
  }

  private static async loadClaudeMdHierarchy(): Promise<ClaudeMdContent[]> {
    const sources = [
      { path: '/etc/claude-code/CLAUDE.md', scope: 'managed' },
      { path: '~/.claude/CLAUDE.md', scope: 'user' },
      { path: '.claude/CLAUDE.md', scope: 'project' },
      { path: '.claude/CLAUDE.local.md', scope: 'local' }
    ];

    const contents: ClaudeMdContent[] = [];

    for (const source of sources) {
      try {
        const content = await fs.readFile(source.path, 'utf8');
        const processed = await this.processClaudeMd(content, source.scope);
        contents.push(processed);
      } catch {
        // 文件不存在，跳过
      }
    }

    return this.mergeClaudeMdContents(contents);
  }

  private static async processClaudeMd(
    content: string,
    scope: string
  ): Promise<ClaudeMdContent> {
    // 处理 @mentions 以进行包含
    const processed = await this.resolveMentions(content);

    // 提取指令
    const directives = this.extractDirectives(processed);

    return {
      scope,
      content: processed,
      directives,
      source: scope
    };
  }

  private static mergeClaudeMdContents(
    contents: ClaudeMdContent[]
  ): ClaudeMdContent[] {
    const merged: ClaudeMdContent[] = [];
    const overrides = new Map<string, string>();

    // 以相反的顺序处理（本地覆盖受管理的）
    for (let i = contents.length - 1; i >= 0; i--) {
      const content = contents[i];

      // 处理 @override 指令
      for (const directive of content.directives) {
        if (directive.type === 'override') {
          overrides.set(directive.key, content.scope);
        }
      }

      // 如果未被覆盖，包含内容
      const isOverridden = Array.from(overrides.entries()).some(
        ([key, scope]) =>
          content.content.includes(key) && scope !== content.scope
      );

      if (!isOverridden) {
        merged.unshift(content);
      }
    }

    return merged;
  }

  private static selectSections(
    sections: TokenizedSection[],
    budget: number
  ): TokenizedSection[] {
    // 按优先级排序
    const sorted = [...sections].sort((a, b) => a.priority - b.priority);

    const selected: TokenizedSection[] = [];
    let usedTokens = 0;

    // 第一遍：包含所有必需的部分
    for (const section of sorted) {
      if (section.required) {
        selected.push(section);
        usedTokens += section.tokenCount;
      }
    }

    // 第二遍：按优先级包含可选部分
    for (const section of sorted) {
      if (!section.required && usedTokens + section.tokenCount <= budget) {
        selected.push(section);
        usedTokens += section.tokenCount;
      } else if (!section.required && section.alternatives) {
        // 尝试替代方案
        for (const alt of section.alternatives) {
          if (usedTokens + alt.tokenCount <= budget) {
            selected.push({
              ...section,
              content: alt.content,
              tokenCount: alt.tokenCount
            });
            usedTokens += alt.tokenCount;
            break;
          }
        }
      }
    }

    return selected;
  }
}

```

**为什么这是创新的**：
- 基于优先级的截断保留最重要的上下文
- 具有覆盖语义的分层 CLAUDE.md 加载
- 动态替代方案（例如，目录深度减少）
- 模型特定的提示适配
- 智能摘要回退

## 内存管理模式：保持精简

Claude Code 实现了复杂的内存管理：

```typescript
class MemoryManager {
  // 模式 1：大对象的弱引用
  private static fileCache = new Map<string, WeakRef<FileContent>>();
  private static registry = new FinalizationRegistry((key: string) => {
    console.debug(`Garbage collected: ${key}`);
    this.fileCache.delete(key);
  });

  static cacheFile(path: string, content: FileContent) {
    // 存储弱引用
    const ref = new WeakRef(content);
    this.fileCache.set(path, ref);

    // 注册清理通知
    this.registry.register(content, path);
  }

  static getFile(path: string): FileContent | null {
    const ref = this.fileCache.get(path);
    if (!ref) return null;

    const content = ref.deref();
    if (!content) {
      // 已被垃圾回收
      this.fileCache.delete(path);
      return null;
    }

    return content;
  }

  // 模式 2：带反压的流式处理
  static async *streamLargeFile(
    path: string,
    options: StreamOptions = {}
  ): AsyncGenerator<Buffer> {
    const highWaterMark = options.chunkSize || 64 * 1024; // 64KB 块
    const stream = createReadStream(path, { highWaterMark });

    let totalRead = 0;
    let isPaused = false;

    for await (const chunk of stream) {
      totalRead += chunk.length;

      // 检查内存压力
      const memUsage = process.memoryUsage();
      if (memUsage.heapUsed / memUsage.heapTotal > 0.9) {
        if (!isPaused) {
          console.warn('High memory pressure, pausing stream');
          stream.pause();
          isPaused = true;

          // 如果可用，强制垃圾回收
          if (global.gc) {
            global.gc();
          }

          // 等待内存释放
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      } else if (isPaused) {
        stream.resume();
        isPaused = false;
      }

      yield chunk;

      // 定期让步给事件循环
      if (totalRead % (1024 * 1024) === 0) { // 每 MB
        await new Promise(resolve => setImmediate(resolve));
      }
    }
  }

  // 模式 3：频繁分配的对象池
  static bufferPool = new BufferPool({
    size: 100,
    bufferSize: 64 * 1024
  });

  // 模式 4：内存压力检测
  static monitorMemoryPressure() {
    setInterval(() => {
      const usage = process.memoryUsage();
      const heapPercent = usage.heapUsed / usage.heapTotal;
      const rssGB = usage.rss / 1024 / 1024 / 1024;

      if (heapPercent > 0.85) {
        console.warn(`High heap usage: ${(heapPercent * 100).toFixed(1)}%`);

        // 触发清理操作
        this.performMemoryCleanup();
      }

      if (rssGB > 2) {
        console.warn(`High RSS memory: ${rssGB.toFixed(2)}GB`);
      }
    }, 5000);
  }

  private static performMemoryCleanup() {
    // 清除非必要的缓存
    if (this.patternCache) {
      this.patternCache.clear();
    }

    // 如果需要，压缩对话
    if (ConversationManager.shouldCompact()) {
      ConversationManager.triggerCompaction();
    }

    // 如果可用，强制 GC
    if (global.gc) {
      const before = process.memoryUsage().heapUsed;
      global.gc();
      const after = process.memoryUsage().heapUsed;
      console.debug(`GC freed ${((before - after) / 1024 / 1024).toFixed(1)}MB`);
    }
  }
}

// 缓冲池实现
class BufferPool {
  private available: Buffer[] = [];
  private inUse = new WeakMap<Buffer, boolean>();

  constructor(private config: BufferPoolConfig) {
    // 预分配缓冲区
    for (let i = 0; i < config.size; i++) {
      this.available.push(Buffer.allocUnsafe(config.bufferSize));
    }
  }

  acquire(): Buffer {
    let buffer = this.available.pop();

    if (!buffer) {
      // 池耗尽，分配新的
      console.warn('Buffer pool exhausted, allocating new buffer');
      buffer = Buffer.allocUnsafe(this.config.bufferSize);
    }

    this.inUse.set(buffer, true);
    return buffer;
  }

  release(buffer: Buffer) {
    if (!this.inUse.has(buffer)) {
      throw new Error('Buffer not from this pool');
    }

    this.inUse.delete(buffer);

    // 为安全起见清除缓冲区内容
    buffer.fill(0);

    if (this.available.length < this.config.size) {
      this.available.push(buffer);
    }
  }
}

```

**为什么这是创新的**：
- 弱引用允许大型缓存文件的自动清理
- 带反压的流式处理防止内存耗尽
- 缓冲池减少分配开销
- 主动的内存压力监控和响应

## 权限规则编译：快速安全决策

权限系统编译规则以进行高效评估：

```typescript
class PermissionRuleCompiler {
  private compiledRules = new Map<string, CompiledRule>();

  compile(rule: string): CompiledRule {
    // 检查缓存
    if (this.compiledRules.has(rule)) {
      return this.compiledRules.get(rule)!;
    }

    // 解析规则语法
    const parsed = this.parseRule(rule);
    const compiled = this.compileRule(parsed);

    this.compiledRules.set(rule, compiled);
    return compiled;
  }

  private parseRule(rule: string): ParsedRule {
    // 规则格式：
    // - ToolName
    // - ToolName(path/pattern)
    // - ToolName(path/pattern, condition)
    // - @tag:ToolName

    const patterns = {
      simple: /^(\w+)$/,
      withPath: /^(\w+)\(([^,)]+)\)$/,
      withCondition: /^(\w+)\(([^,]+),\s*(.+)\)$/,
      tagged: /^@(\w+):(.+)$/
    };

    // 首先尝试标记格式
    const taggedMatch = rule.match(patterns.tagged);
    if (taggedMatch) {
      const [, tag, rest] = taggedMatch;
      const innerRule = this.parseRule(rest);
      return { ...innerRule, tags: [tag] };
    }

    // 尝试带条件
    const conditionMatch = rule.match(patterns.withCondition);
    if (conditionMatch) {
      const [, tool, path, condition] = conditionMatch;
      return {
        tool,
        path,
        condition: this.parseCondition(condition),
        tags: []
      };
    }

    // 尝试带路径
    const pathMatch = rule.match(patterns.withPath);
    if (pathMatch) {
      const [, tool, path] = pathMatch;
      return { tool, path, tags: [] };
    }

    // 简单的工具名称
    const simpleMatch = rule.match(patterns.simple);
    if (simpleMatch) {
      return { tool: simpleMatch[1], tags: [] };
    }

    throw new Error(`Invalid rule syntax: ${rule}`);
  }

  private compileRule(parsed: ParsedRule): CompiledRule {
    const compiled: CompiledRule = {
      original: parsed,
      matchers: {},
      evaluate: null as any // 将在下面设置
    };

    // 编译工具匹配器
    if (parsed.tool.includes('*')) {
      // 工具名称中的通配符
      const regex = new RegExp(
        '^' + parsed.tool.replace(/\*/g, '.*') + '$'
      );
      compiled.matchers.tool = (tool: string) => regex.test(tool);
    } else {
      // 精确匹配
      compiled.matchers.tool = (tool: string) => tool === parsed.tool;
    }

    // 编译路径匹配器
    if (parsed.path) {
      if (parsed.path.includes('*') || parsed.path.includes('?')) {
        // Glob 模式
        const matcher = picomatch(parsed.path);
        compiled.matchers.path = (path: string) => matcher(path);
      } else {
        // 精确或前缀匹配
        compiled.matchers.path = (path: string) => {
          const normalizedRule = path.resolve(parsed.path);
          const normalizedInput = path.resolve(path);

          if (normalizedRule.endsWith('/')) {
            // 目录前缀
            return normalizedInput.startsWith(normalizedRule);
          } else {
            // 精确匹配
            return normalizedInput === normalizedRule;
          }
        };
      }
    }

    // 编译条件
    if (parsed.condition) {
      compiled.matchers.condition = this.compileCondition(parsed.condition);
    }

    // 创建优化的评估器
    compiled.evaluate = this.createEvaluator(compiled);

    return compiled;
  }

  private createEvaluator(rule: CompiledRule): RuleEvaluator {
    // 生成优化的评估函数
    const checks: string[] = [];

    if (rule.matchers.tool) {
      checks.push('if (!matchers.tool(input.tool)) return false;');
    }

    if (rule.matchers.path) {
      checks.push('if (input.path && !matchers.path(input.path)) return false;');
    }

    if (rule.matchers.condition) {
      checks.push('if (!matchers.condition(input, context)) return false;');
    }

    checks.push('return true;');

    // 创建具有最小开销的函数
    const fn = new Function(
      'matchers',
      'input',
      'context',
      checks.join('\n')
    );

    return (input: RuleInput, context: RuleContext) => {
      return fn(rule.matchers, input, context);
    };
  }

  evaluateRules(
    rules: string[],
    input: RuleInput,
    context: RuleContext
  ): RuleMatch | null {
    // 按顺序编译和评估规则
    for (const ruleStr of rules) {
      const rule = this.compile(ruleStr);

      if (rule.evaluate(input, context)) {
        return {
          matched: true,
          rule: ruleStr,
          compiled: rule
        };
      }
    }

    return null;
  }
}

```

**为什么这是创新的**：
- 规则的 JIT 编译以提高性能
- 支持带条件的复杂规则语法
- 编译规则的缓存
- 优化的评估器生成

## 进度聚合：协调并行操作

当多个工具并行运行时，它们的进度需要协调：

```typescript
class ProgressAggregator {
  private streams = new Map<string, ProgressStream>();
  private subscribers = new Set<ProgressSubscriber>();
  private buffer = new RingBuffer<AggregatedProgress>(1000);

  async *aggregate(
    operations: ToolOperation[]
  ): AsyncGenerator<AggregatedProgress> {
    // 启动所有操作
    const startTime = Date.now();

    for (const op of operations) {
      const stream = this.createProgressStream(op);
      this.streams.set(op.id, stream);

      // 在后台启动操作
      this.runOperation(op, stream);
    }

    // 产生聚合的进度
    while (this.streams.size > 0) {
      const event = await this.getNextEvent();

      if (!event) continue;

      const aggregated: AggregatedProgress = {
        type: 'aggregated_progress',
        timestamp: Date.now(),
        elapsed: Date.now() - startTime,
        source: event.source,
        event: event,

        // 总体统计
        statistics: {
          total: operations.length,
          completed: this.countCompleted(),
          failed: this.countFailed(),
          inProgress: this.streams.size,

          // 按工具分解
          byTool: this.getToolStatistics(),

          // 性能指标
          avgDuration: this.getAverageDuration(),
          throughput: this.getThroughput()
        },

        // 可视化进度表示
        visualization: this.createVisualization()
      };

      // 用于 UI 节流的缓冲
      this.buffer.push(aggregated);

      // 基于节流策略的产出
      if (this.shouldYield(aggregated)) {
        yield aggregated;
      }
    }

    // 最终摘要
    yield this.createFinalSummary(operations, startTime);
  }

  private async getNextEvent(): Promise<ProgressEvent | null> {
    if (this.streams.size === 0) return null;

    // 创建所有活动流的竞争
    const promises = Array.from(this.streams.entries()).map(
      async ([id, stream]) => {
        const event = await stream.next();
        return { id, event };
      }
    );

    try {
      // 与超时竞争以防止挂起
      const result = await Promise.race([
        ...promises,
        this.timeout(100).then(() => ({ id: 'timeout', event: null }))
      ]);

      if (result.id === 'timeout') {
        return null;
      }

      if (result.event?.done) {
        this.streams.delete(result.id);
      }

      return result.event?.value || null;
    } catch (error) {
      // 优雅地处理流错误
      console.error('Progress stream error:', error);
      return null;
    }
  }

  private shouldYield(event: AggregatedProgress): boolean {
    // 节流逻辑
    const now = Date.now();

    // 总是产出完成事件
    if (event.event.type === 'complete' || event.event.type === 'error') {
      return true;
    }

    // 节流进度更新
    const lastYield = this.lastYieldTime.get(event.source) || 0;
    const timeSinceLastYield = now - lastYield;

    // 基于操作数量的动态节流
    const throttleMs = Math.min(50 * this.streams.size, 500);

    if (timeSinceLastYield >= throttleMs) {
      this.lastYieldTime.set(event.source, now);
      return true;
    }

    return false;
  }

  private createVisualization(): ProgressVisualization {
    const bars = Array.from(this.streams.entries()).map(([id, stream]) => {
      const state = stream.getState();
      const percentage = state.progress || 0;
      const barLength = 20;
      const filled = Math.floor(percentage * barLength / 100);

      return {
        id,
        tool: state.tool,
        bar: '█'.repeat(filled) + '░'.repeat(barLength - filled),
        percentage,
        status: state.status,
        eta: state.eta
      };
    });

    return {
      type: 'bars',
      bars,
      summary: this.createSummaryLine()
    };
  }
}

```

**为什么这是创新的**：
- 协调多个并发操作的进度
- 基于操作计数的动态节流
- 丰富的统计和可视化
- 优雅地处理流错误
- 用于 UI 节流的环形缓冲区

---

*这项分析展示了使 Claude Code 卓越的创新组件。这些不仅仅是优化——它们是专门为 LLM 集成开发环境的挑战而设计的基本架构创新。*
