{"categories":[],"pages":[],"posts":[{"link":"/posts/documenting-rest-apis-with-openapi/","text":"本章介绍如何使用 OpenAPI 来为 API 编写文档. OpenAPI 是描述 RESTful API 最流行的标准, 拥有丰富的生态系统, 可以用于测试、验证和可视化 API. 大多数编程语言都支持 OpenAPI 规范的库.\nOpenAPI 使用 JSON Schema 来描述 API 的结构和模型, 因此首先介绍 JSON Schema 的工作原理. JSON Schema 是一种用于定义 JSON 文档结构的规范, 包括文档中值的类型和格式.\nUsing JSON Schema to model data 使用 JSON Schema 对数据建模\nJSON Schema 是一种规范标准, 用于定义 JSON 文档的结构及其属性的类型和格式. JSON Schema 规范通常定义一个具有特定属性或特性的对象, 由键值对的关联数组表示, 如下面这样:\nJSON Collapse Copy { \u0026#34;status\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } Click to expand and view more 在 JSON Schema 规范中, 每个属性都以键值对的形式出现, 其中值是该属性的描述符 一个属性最基本的描述符就是 type, 上面例子中, 指定类型为字符串 JSON Schema 支持以下基本数据类型:\nstring: 字符串 number: 整数和十进制数 object: 关联数组 (类似py中的字典) array: 其他数据类型的集合 boolean: 真或假 null: 未初始化的数据 定义一个 object 的例子\nJSON Collapse Copy { \u0026#34;order\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;product\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;size\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;quantity\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;intger\u0026#34; } } } } Click to expand and view more 由于 order 是一个 object, 故 order 属性有 properties. 每个 property 都有自己的类型.\n一个符合规则的 JSON 文档例子如下\nJSON Collapse Copy { \u0026#34;order\u0026#34;: { \u0026#34;product\u0026#34;: \u0026#34;coffee\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;big\u0026#34;, \u0026#34;quantity\u0026#34;: 1, } } Click to expand and view more 属性 property 也可以代表一个项目的数组.\norder 对象代表一个对象的数组, 使用 items 关键字来定义数组中的元素.\nJSON Collapse Copy { \u0026#34;order\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;product\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;size\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;quantity\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } } } } } Click to expand and view more 在上面例子中, order 属性是一个数组 array. 数组类型需要在模式 schema 中有一个额外的属性, 那就是 items 属性, 其定义了数组中包含的每个元素的类型. 这种情况下, 数组中的每个元素都是一个对象, 代表订单中的一个项目.\n一个对象可以包含任意数量的嵌套对象, 但是, 嵌套太多时, 缩进会变得很大, 导致规范难以阅读.\n为了避免这个问题, JSON Schema 允许单独定义每个对象, 并使用 JSON 指针 (JSON pointers) 来引用它们.\nJSON pointers 是一种特殊语法, 运行向统一分规范中的另一个对象定义.\n如下面代码, 可以将 order 数组中的每个项的定义提取为一个名为 OrderItemSchema 的模型. 然后使用一个 JSON 指针和特殊的 $ref 关键字来引用 OrderItemSchema\nJSON Collapse Copy { \u0026#34;OrderItemSchema\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;product\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;size\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;quantity\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } } }, \u0026#34;Order\u0026#34;: { \u0026#34;status\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;order\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#39;#/OrderItemSchema\u0026#39; } } } } Click to expand and view more JSON 指针使用特殊关键字 $ref 和 JSONPath 语法来指向 schema 中的另一个定义.\n在 JSONPath 的语法中, 文档的根(root)使用井号 # 表示, 嵌套属性的关系由斜线(slashes) / 表示. 例如, 如果响应创建 #/OrderItemSchema 模型的 size 属性的指针, 我们会使用如下的语法 #/OrderItemSchema/size.\n通过将通用的模式对象提取成壳重用的模型, 并使用 JSON 指针来引用他们, 从而对规范进行重构, 这有助于避免重复, 并报慈整洁和简洁.\n除了指定类型之外, JSON Schema 还允许指定属性的格式(foramt), 可以自定义格式, 也可以使用 JSON Schema 内置的格式.\n例如, 一个代表日期的属性, 可以使用 data 格式, 这是 JSON Schema 支持的内置格式, 代表一个 ISO 日期(如2025-05-21)\nPLAINTEXT Collapse Copy { \u0026#34;created\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;date\u0026#34; } } Click to expand and view more 除了使用 JSON, JSON Schema 实际上还可以使用 YAML 来编写, 这种格式更加常见且更容易理解. OpenAPI 规范也通常以 YAML 格式提供, 后面部分使用 YAML 格式编写.\nAnatomy of an OpenAPI specification 剖析 OpenAPI 规范\nOpenAPI 是一种用于文档化 Restful API 的标准规范格式. 它允许我们详细描述 API 的每一个元素, 包括其端点 endpoints、请求响应和有效载荷(payloads)的格式、安全方案(security schemes)等等. OpenAPI 最初于2010年以 Swagger 的名称创建, 2015年 Linux 基金会和主要公司的联盟共同赞助成立了 OpenAPI Initiative, 是一个旨在改进构建 RESTful API 的协议和标准的项目. 如今, OpenAPI 是迄今为止用于文档化 RESTful API 最流行的规范格式, 它拥有丰富的生态系统工具, 可用于 API 可视化、测试和验证.\nOpenAPI 包含了和 API 交互所需要的一切信息, 一份 OpenAPI 规范由5个部分构成:\nopenapi: 指明版本 info: API 的基本信息, 例如标题和版本 servers: 包含 API 可用的 URL 列表. 可以列出用于不同环境的多个 URL. paths: 描述 API 公开的端点, 包括预期的有效载荷(payloads)、允许的参数以及响应的格式. 这是规范中最重要的部分, 因为它代表了 API 的接口, 也是使用者为了学习如何与 API 集成会查看的部分. components: 定义了在整个规范中被引用的可重复元素. 例如模式(schemas)、参数、安全方案、请求体和响应等. 模式是对请求和响应中预期属性和类型的定义. OpenAPI 模式是使用 JSON Schema 语法定义的. Documenting the API endpoints 文档化 API 端点\nOpenAPI 的 path 部分描述了 API 接口, 它列出了 API 公开的 URL 路径, 以及实现的 HTTP 方法, 预期的请求类型和返回的响应.\n每个路径都是一个对象, 其属性为它支持的 HTTP 方法, 这里将说明 URL 路径和 HTTP 方法的文档化.\n在之前定义了如下端点:\nPOST /orders: 请求订单. 需要订单的细节信息. GET /orders: 返回订单列表. 接受 URL 查询参数, 并允许过滤结果. GET /orders/{order_id}: 返回订单细节信息 PUT /orders/{order_id}: 更新订单细节信息, 由于这是一个 PUT 端点, 要求订单的全面信息. DELETE /orders/{order_id}: 删除订单 POST /orders/{order_id}/pay: 为订单付款 POST /orders/{order_id}/cancel: 取消订单 下面是 API 订单的高层定义, 声明了 URL 和每个 URL 所实现的 HTTP 方法, 并为每个端点添加了一个操作ID(operation ID), 以便在文档其他部分引用:\nYAML Collapse Copy paths: /orders: get: operationId: createOrder /orders/{order_id}: get: operationId: getOrder put: operationId: updateOrder delete: opertaionId: deleteOrder /orders/{order_id}/pay: post: operationId: payOrder /orders/{order_id}/cancel: post: operationId: cancelOrder Click to expand and view more 现在有了端点, 还需要填充其中的细节.\n对于 GET /orders 端点, 需要描述接受它的参数 对于 POST 和 PUT 端点, 需要描述请求的有效载荷 payloads\n此外, 还需要为每个端点描述其响应 Documenting URL query parameters 文档化 URL 查询参数\nURL query parameter 允许我们过滤和排序 GET endpoint 的结果. 在本章中, 将使用 OpenAPI 定义 URL query parameters. GET /orders endpoint 允许我们使用下面的参数过滤订单:\ncancelled: 订单是否被取消, 类型 boolean limit: 表示返回给用户的订单的最大数量 合并起来使用大概下面这样:\nPLAINTEXT Collapse Copy GET /orders?cancelled=true\u0026amp;limit=5 Click to expand and view more 这个请求向服务器请求一个 5条已经取消 的订单的列表.\nPLAINTEXT Collapse Copy paths: /orders: get: parameters: - name: cancelled in: query required: false schema: type: boolean - name: limit in: query required: false schema: type: integer Click to expand and view more 定义一个参数需要一个名称 name, 这个名称就是实际 URL 中用来指引它的值. 还需要指定参数的类型, 在 OpenAPI 3.1 区分了四种类型参数: 路径参数(path parameters)、查询参数(query parameters)、头部参数(header parameters)和Cookie 参数(cookie parameters).\n头部参数是在 HTTP 头部字段中的参数, 而 Cookie 参数则放在 Cookie 有效载荷中. 路径参数是 URL 路径的一部分, 通常用于标识一个资源. 查询参数是可选参数, 允许对端点的结果进行过滤和排序.\n使用 schema 关键字参数来定义参数的类型, 并且在相关时, 也会指定参数的格式. Documenting request payloads 文档化请求载荷\n一个请求代表 client 通过 POST 或 PUT 方法向 server 发送的数据. 这节介绍 API endpoints 的 request payloads.\n例如 POST /orders 方法:\nJSON Collapse Copy { \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;cappuccinio\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;big\u0026#34;, \u0026#34;quantity\u0026#34;: 1 } ] } Click to expand and view more 这个 payload 包含一个 order 属性, 代表了一系列的物品. 每个物品被定义为下面的3个属性和约束:\nproduct: 用户订购的产品类型 size: 产品的大小. 有3种选择: small, medium 和 big quantity: 产品的数量. 可以是任何大于等于1的整数 下面展示如何为这个有效载荷 payload 定义模式\nYAML Collapse Copy paths: /orders: post: operationId: createOrder requestBody: required: true content: application/json: schema: type: object properties: order: type: array items: type: object properties: product: type: string size: type: string enum: - small - medium - big quantity: type: intger required: false default: 1 required: - product - size Click to expand and view more 通过 HTTP 方法的 requestBody 属性下的 content 属性来定义 payload, 并可以指定不同的有效载荷. 有效载荷可以指定为不同的格式, 在本例中, 只允许 JSON 格式数据, 媒体类型为 application/json.\n这里的有效载荷的模式是一个对象, 有一个属性 order, 其类型为数组, 数组中的元素的对象, 包含3个属性: product(类型为字符串), size(类型为字符串) 和 quantity(类型为整数).\n此外, 还为 size 属性定义了一个枚举(enumeration), 将可接受的值限制为 samll、medium 和 big 3种.\n最后, 还为 quantity 属性提供了默认值 1, 因为它是有效载荷中唯一非必须的字段.\nRefactoring schema definitions to avoid repetition 重构 schema 定义从而避免重复\n在本节将介绍重构模式 refactoring schemas 的策略, 以保持 API 规范的整洁和可读性.\n上面的 POST /orders 端点定义很长, 包含多层缩进, 难以阅读, 意味着会变得难以扩展和维护.\n可以将有效载荷 payload 的模式移动到 API 规范的 components 部分. 该部分用于声明在整个规范中被引用的模式, 每个模式都是一个对象, 其中键是模式的名称, 而值是属性的对象.\nYAML Collapse Copy paths: /orders: post: operatoinId: createOrder requestBody: required: true content: application/json: schema: $ref: \u0026#39;#/components/schemas/CreateOrderSchema\u0026#39; ① components: ② schemas: ③ CreateOrderSchema: type: object properties: type: array items: type: object properties: product: type: string size: type: string enum: - samll - medium - big quantity: type: intger required: false default: 1 required: - product - size Click to expand and view more 使用 JSON pointer 指向文档其他位置 schema 定义在 components 下面 每个 schema 都是一个对象, 其中 key(CreateOrderSchema) 是名称, values(CreateOrderSchema下面的所有内容) 是描述属性 properties 将 POST /orders 请求有效载荷的模式移动到 API 的 components 部分, 能使文档更具可读性. 这样得以保持 path 部分的简洁, 并专注于端点的高层细节. 只需要使用一个 JSON 指针来引用 CreateOrderSchema 模式:\nPLAINTEXT Collapse Copy #/components/schemas/CreateOrderSchema Click to expand and view more 这份规范现在已经不错了, 但是可以更好. CreateOrderSchema 有些长, 并且包含了多层嵌套定义. 如果 CreateOrderSchema 的复杂性随着时间增长, 将越来越难以维护. 可以通过下面方式重构数组中订单项的定义, 使其更加具有可读性, 这个策略运行 API 的其他部分重用订单项的模式.\nYAML Collapse Copy components: schemas: OrderItemSchema: ① type: object properties: product: type: string size: type: string enum: - small - medium - big quantity: type: integer default: 1 CreateOrderSchema: type: object properties: order: type: array items: $ref: \u0026#39;#/OrderItemSchema\u0026#39; ② Click to expand and view more OrderItemSchema: 订单中的项 CreateOrderSchema: 使用一个 JSON pointer 指向 OrderItemSchema 现在 schemas 看起来就好多了, 并且可以在 /POST /orders/{order_id} 端点中重用它.\n/orders/{order_id} 代表一个单例资源(singleton resource), 因此 URL 包含一个路径参数, 即订单ID. 在 OpenAPI 中, 路径参数使用大括号{} 表示.\nPLAINTEXT Collapse Copy paths: /orders: get: ... /orders/{order_id}: ① parameters: ② - in: path ③ name: order_id ④ required: true ⑤ schema: type: string format: uuid ⑥ put: ⑦ operationId: updateOrder requestBody: ⑧ required: true content: application/json: schema: $ref: \u0026#39;#/components/schemas/CreateOrderSchema Click to expand and view more 定义订单的资源地址 定义 URL path parameter order_id 参数是 URL 路径的一部分 参数名称 必填参数 具体参数格式(UUID) 为当前 URL 定义 PUT 方法 文档化 request body 的 PUT 端点 Documenting API responses 文档化响应体\nGET /orders/{order_id} 端点的响应类似下面这样:\nJSON Collapse Copy { \u0026#34;id\u0026#34;: \u0026#34;924721eb-a1a1-4f13-b384-37e89c0e0875\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;progress\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2022-05-01\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;cappuccino\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;small\u0026#34;, \u0026#34;quantity\u0026#34;: 1 }, { \u0026#34;product\u0026#34;: \u0026#34;croissant\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ] } Click to expand and view more 这个有效载荷展示了用户订购的产品, 下单时间以及订单状态. 类似之前 POST 和 PUT 端点定义的请求有效载荷, 因此可以重用之前的模式.\nYAML Collapse Copy components: schemas: OrderItemSchema: ... GetOrderSchema: ① type: object properties: status: type: string enum: ② - created - paid - progress - cancelled - displatched - delivered created: type: string format: date-time ③ order: type: array items: $ref: \u0026#39;#/components/schemas/OrderItemSchema\u0026#39; ④ Click to expand and view more 定义 GetOrderSchema 模式 使用枚举限制状态属性 日期格式的字符串 使用 JSON pointer 引用 OrderItemSchema 在上面的清单中, 使用一个 JSON 指针指向 GetOrderSchema. 另一种重用现有模式的方法是继承.\n在 OpenAPI 中, 可以通过一种称为模式组合(model composition) 的策略来继承和扩展一个模式, 该策略允许将不同模式的属性组合到一个单一的对象定义中. 在这种情况下, 使用特殊关键词 allOf 来表示该对象需要包含列出的所有模式中的属性.\nYAML Collapse Copy components: schemas: OrderItemSchema: ... GetOrderSchema: allOf: ① - $ref: \u0026#39;#/components/schemas/CreateOrderSchema\u0026#39; ② - type: object ③ properties: status: type: string enum: - created - paid - progress - cancelled - dispatched - delivered created: type: string format: date-time Click to expand and view more 使用 allOf 关键字继承其他 schemas 的属性 使用 JSON pointer 引用其他的 schema 使用一个新对象 GetOrderSchema 来包含特有的属性 模型组合(Model composition) 能使规范更简洁、更紧凑, 但它只在模式严格兼容的情况才有效.\n如果决定使用新的属性来扩展 CreateOrderSchema, 那么这个模式可能就不再能用于 GetOrderSchema 模型.\n从这个意义上讲, 有时候更好的做饭是寻找不同模式中的共同元素, 将其定义重构为独立的模式.\n现在有了 GET /orders/{order_id} 端点响应有效载荷的模式, 就可以完善该端点的规范了. 把端点的响应定义为对象, 其中键是响应的状态码, 并描述响应的内容类型及其模式.\nYAML Collapse Copy paths: /orders: get: ... /orders/{order_id}: parameters: - in: path name: order_id required: true schema: type: string format: uuid put: ... get: ① summary: Returns the details of a specific order ② operationId: getOrder responses: ③ \u0026#39;200\u0026#39;: ④ description: OK ⑤ content: ⑥ application/json: schema: $ref: \u0026#39;#/components/schemas/GetOrderSchema\u0026#39; ⑦ Click to expand and view more 定义 GET /order/{order_id} endpoint 为该端点提供一个描述 定义一个端点响应 每个响应都是一个对象, 其中 key 为状态码 响应的简单描述 描述响应的内容类型 使用 JSON pointer 引用 GetOrderSchema 根据上面内容可以看到, 在端点的 responses 部分定义了响应模式(schemas), 在这种情况下, 值提供了 200 (OK) 成功响应的规范, 但也可以为其他状态码编写文档.\nCreating generic responses 创建同样响应\n本节介绍如何为 API 端点添加错误响应. 错误响应更具通用性, 因此可以使用 API 规范的 components 部分来提供这些响应的通用定义, 然后在端点中使用他们.\n这里在 API 的 components 部分的 responses 标头下定义通用响应. 下面展示了一个名为 NotFound 的 404 响应通用定义. 与任何其他响应意义, 也会为其有效载荷编写文档, 本例中有效载荷由 Error 模式定义.\nPLAINTEXT Collapse Copy components: responses: ① NotFound: ② description: The specified resource was not found. ③ content: ④ application/json: schema: $ref: \u0026#39;#/components/schemas/Error\u0026#39; ⑤ schemas: OrderItemSchema: ... Error: ⑥ type: object properties: detail: type: string required: - detail Click to expand and view more 通用响应定义在 components 部分的 responses 下 为这个响应命名 描述这个响应 定义响应内容 引用 Error 模式 定义 Error 有效载荷的模式 上面这份针对 404 响应的规范可以在 /orders/{order_id} URL 路径下的所有端点规范中重复使用, 因为所有这些端点都是专门设计来针对特定资源的.\n在 OpenAPI 的 GitHub 仓库中, 有一个请求是希望允许在 URL 路径下直接包含通用响应, 但目前尚未实现\n下面定义 /orders/{order_id} 的 404 响应模式\nYAML Collapse Copy paths: ... /orders/{order_id}: parameters: - in: path name: order_id required: true schema: type: string \u0026#34;format\u0026#34;: uuid get: summary: Returns the details of a specific order operationId: getOrder responses: \u0026#39;200\u0026#39;: description: OK content: application/json: schema: $ref: \u0026#39;#/components/schemas/GetOrderSchema\u0026#39; \u0026#39;404\u0026#39;: ① $ref: \u0026#39;#/components/responses/NotFound\u0026#39; ② Click to expand and view more 定义一个 404 响应 使用 JSON 指针引用 NotFound 响应 剩下的一个端点是 GET /orders, 它返回一个订单列表, 该端点的有效载荷重用了 GetOrderSchema 来定义订单数组中的项目\nYAML Collapse Copy paths: /orders: get: ① operationId: getOrders responses: \u0026#39;200\u0026#39;: description: A JSON array of orders content: application/json: schema: type: object properties: orders: type: array ② items: $ref: \u0026#39;#/components/schemas/GetOrderSchema\u0026#39; ③ required: - order post: ... /orders/{order_id}: parameters: ... Click to expand and view more 定义 /orders URL 路径的新 GET 方法 orders 是一个数组 数组的每个项目都由 GetOrderSchema 定义 现在, API 的端点已完全文档化. 可以在端点定义中使用更多的元素, 例如 tags 和 externalDocs. 些属性并非绝对必要, 但可以帮助为 API 提供更多结构, 或使其更易于对端点进行分组.\nDefining the authentication scheme of the API 定义 API 的认证模式\n如果 API 受到到保护, API 规范必须描述用户如何进行身份认证和授权请求. API 安全定义位于规范的 components 部分, 在 securitySchema 标头下.\n通过 OpenAPI, 可以描述不同的安全方案, 例如基于 HTTP 的认证、基于密钥的认证、OAuth2 开放授权 和 OpenID Connect.\n下面描述了3种方案: 一种用于 OpenID Connect, 一种用于 OAuth2, 还有一种用于 Bearer 授权.\n这里使用 OpenID Connect 通过前端应用来授权用户访问\n对于 OpenID Connect, 必须在 openIdConnectUrl 属性下提供一个配置 URL, 该 URL 描述了后端客户端如何认证工作 对于直接的 API 集成, 提供 OAuth 的客户端凭证流(client credentials flow)\n对于 OAuth2, 必须描述可用的授权流(authentication flows), 以及客户端必须用于获取其授权令牌的 URL 和可用的作用域(scopes).\nBearer 授权告诉用户, 他们必须在 Authorization 头部中包含一个 JSON Web Token(JWT) 来授权其请求. YAML Collapse Copy components: responses: ... schemas: ... securitySchemes: ① openId: ② type: openIdConnect ③ openIdConnectUrl: https://coffeemesh-dev.eu.auth0.com/.well-known/openid-configuration ④ oauth2: ⑤ type: oauth2 ⑥ flows: ⑦ clientCredentials: ⑧ tokenUrl: https://coffeemesh-dev.eu.auth0.com/oauth/token ⑨ scopes: {} ⑩ bearerAuth: type: http scheme: bearer bearerFormat: JWT ⑪ ... security: - oauth2: - getOrders - createOrder - getOrder - updateOrder - deleteOrder - payOrder - cancelOrder - bearerAuth: - getOrders - createOrder - getOrder - updateOrder - deleteOrder - payOrder - - cancelOrder Click to expand and view more API components 部分的 securitySchemes 标头下的安全方案 为安全方案提供一个名称(可以是任何名称) 安全方案的类型 描述后端 OpenID Connect 配置的 URL 另一个安全方案的名称 该安全方案的类型 该安全方案下可用的授权流 客户端凭证流的描述 用户可以请求授权令牌的 URL 请求授权令牌时可用的作用域 Bearer 令牌的格式是 JSON Web Token (JWT) Wrapping Up JSON Schema 是一个定义 JSON 文档中属性类型和格式的规范, 它有助于以一种独立于编程语言的方式定义数据验证模型. OpenAPI 是一种用于描述 RESTful API 的标准文档格式, 它使用 JSON Schema 来描述 API 的属性. 通过使用 OpenAPI, 你可以利用围绕该标准构建的整个工具和框架生态系统, 从而使 API 集成变得更加容易. JSON pointer 允许使用 $ref 关键字来引用一个模式(schema). 利用 JSON 指针, 可以创建可重用的模式定义, 这些定义可以在 API 规范的不同部分使用, 从而保持 API 规范的整洁和易于理解. ","title":"Documenting REST APIs with OpenAPI"},{"link":"/posts/redis-list/","text":"List 列表 Redis 的列表是一种线性的有序结构, 可以按照元素被推入列表的顺序来存储元素, 这些元素即可以是文字顺序, 也可以是二进制顺序, 且元素可重复出现.\nLPUSH: 将元素推入列表左端\nPLAINTEXT Collapse Copy LPUSH list item [item item ...] Click to expand and view more LPUSH 命令会返回当前元素数量\nRPUSH: 将元素推入列表右端\nPLAINTEXT Collapse Copy RPUSH list item [item item ...] Click to expand and view more LPUSHX, RPUSHX: 只对已存在的列表执行推入操作\n上面两条命令, 在列表不存在的情况下, 会自动创建空列表, 并将元素推入列表中.\n且上面命令每次只能推入一个元素\nLPOP: 弹出列表最左端的元素, 并返回被移出的元素\nPLAINTEXT Collapse Copy POP list Click to expand and view more 空列表 POP 会返回空值 (nil)\nRPOP: 弹出列表最右端的元素\nPLAINTEXT Collapse Copy RPOP list Click to expand and view more RPOPLPUSH: 将列表右端弹出的元素推入列表左端\nPLAINTEXT Collapse Copy RPOPLPUSH source target Click to expand and view more source 和 target 可以是相同列表, 也可以是不同列表. 但不能为空列表, 否则会返回空(nil)\n示例: 先入先出队列 许多电商网站都会在节日时推出一些秒杀活动, 这些活动会放出数量有限的商品供用户抢购, 秒杀系统的一个特点就是短时间内会有大量用户进行相同的购买操作, 如果使用事务或者锁去实现秒杀程序, 那么会因为锁和事务的重试性而导致性能低下, 并且由于重试的存在, 成功购买商品的用户可能并不是最早购买操作的用户, 因此这种秒杀系统并不公平.\n解决方法之一就是把用户的购买操作都放入先进先出队列里面, 然后以队列的方式处理用户购买操作, 这样的程序就可以不使用锁或者事务实现秒杀系统, 且更加公平.\nPYTHON Collapse Copy from redis import Redis class FIFOqueue: def __init__(self, client, key): self.client = client self.key = key def enqueue(self, item): return self.client.rpush(self.key, item) def dequque(self): return self.client.lpop(self.key) client = Redis(decode_responses=True) q = FIFOqueue(client, key=\u0026#34;buy-request\u0026#34;) print(\u0026#34;Enqueue:\u0026#34;, q.enqueue(\u0026#34;peter-buy-milk\u0026#34;), \u0026#34;peter-buy-milk\u0026#34;) print(\u0026#34;Enqueue:\u0026#34;, q.enqueue(\u0026#34;john-buy-rice\u0026#34;), \u0026#34;john-buy-rice\u0026#34;) print(\u0026#34;Enqueue:\u0026#34;, q.enqueue(\u0026#34;david-buy-keyboard\u0026#34;), \u0026#34;david-buy-keyboard\u0026#34;) print(\u0026#34;Dequeue:\u0026#34;, q.dequque()) print(\u0026#34;Dequeue:\u0026#34;, q.dequque()) print(\u0026#34;Dequeeu:\u0026#34;, q.dequque()) Click to expand and view more LLEN: 获取列表长度\nPLAINTEXT Collapse Copy LLEN list Click to expand and view more LINDEX: 获取指定索引上的元素\nPLAINTEXT Collapse Copy LINDEX list index Click to expand and view more 正数索引从左端开始算, 起始为0. 负数索引从右端开始算, 起始为-1. 若索引超出范围则返回(nil).\nLRANGE: 获取给定索引范围上的元素\nPLAINTEXT Collapse Copy LRANGE list start end Click to expand and view more 可以使用 LRANGE list 0 -1 来获取列表的所有元素\n如果 start 和 end 都超出范围, 则返回空列表 nil 如果其中一个超出索引范围, 则超出范围的起始索引会被修正为0, 超出范围的结束索引会被修正为1. 示例: 分页 对于有一定规模的网站来说, 分页程序都是必不可少的; 新闻站点、博客、论坛、搜索引擎等, 都会使用分页程序将数量众多的信息分割为多个页面, 使得用户可以以页面为单位流览网站提供的信息, 并以此来控制网站每次取出的信息数量.\nPYTHON Collapse Copy from redis import Redis class Paging: def __init__(self, client, key): self.client = client self.key = key def add(self, item): self.client.rpush(self.key, item) def get_page(self, page_number, item_per_page): start_index = (page_number - 1) * item_per_page end_index = page_number * item_per_page return self.client.lrange(self.key, start_index, end_index) def size(self): return self.client.llen(self.key) client = Redis(decode_responses=True) topics = Paging(client, \u0026#34;user-topics\u0026#34;) for i in range(1, 20): topics.add(i) print(topics.get_page(1, 5)) print(topics.get_page(2, 5)) print(topics.get_page(1, 10)) print(topics.size()) Click to expand and view more LSET: 为索引设置新元素\nPLAINTEXT Collapse Copy LSET list index new_element Click to expand and view more LSET 命令在成功时返回 OK. 若索引范围错误, 返回一个错误 (error) ERR index out of range\nLINSERT: 将元素插入列表\nPLAINTEXT Collapse Copy LINSERT list BEFORE|AFTER target_element new_element Click to expand and view more 该命令第二个参数可以选用 BEFORE 或 AFTER, 用于指示命令将新元素插入目标元素的前面还是后面, 命令完成后返回列表长度.\n若用户给定的元素不存在 list 中, 则 LINSERT 命令将返回 -1 表示插入失败.\nLTRIM: 修建列表\nPLAINTEXT Collapse Copy LTRIM list start end Click to expand and view more 接受一个列表和一个索引范围, 保留范围内的元素, 删除范围外的所有元素\nLREM: 从列表移除指定元素\nPLAINTEXT Collapse Copy LREM list count element Click to expand and view more count 决定了移除元素的方式:\ncount = 0, 表示移除列表中包含的所有元素 count \u0026gt; 0, 则从左向右开始检查, 并移除最先发现的 count 个指定的元素 count \u0026lt; 0, 则从右向左开始检查, 并移除最先发现的 abs(count) 个指定的元素 示例: 代办事项 使用两个列表分别记录代办事项和已完成事项:\n当用户添加一个新的代办事项时, 程序把这个事项放入代办事项列表中 当用户完成代办事项中某个事项时, 程序把这个事项从代办列表移除, 并放入已完成事项列表中 PYTHON Collapse Copy from redis import Redis def make_todo_list_key(user_id): return user_id + \u0026#34;::todo_list\u0026#34; def make_done_list_key(user_id): return user_id + \u0026#34;::done_list\u0026#34; class TodoList: def __init__(self, client, user_id): self.client = client self.user_id = user_id self.todo_list = make_todo_list_key(self.user_id) self.done_list = make_done_list_key(self.user_id) def add(self, event): self.client.lpush(self.todo_list, event) def remove(self, event): self.client.lrem(self.todo_list, 0, event) # 移除所有元素 def done(self, event): self.remove(event) self.client.lpush(self.done_list, event) def show_todo_list(self): return self.client.lrange(self.todo_list, 0, -1) def show_done_list(self): return self.client.lrange(self.done_list, 0, -1) def clear(self): self.client.delete(make_todo_list_key(self.user_id)) self.client.delete(make_done_list_key(self.user_id)) client = Redis(decode_responses=True) todo = TodoList(client, \u0026#34;peter\u0026#39;s todo list\u0026#34;) todo.add(\u0026#34;go to sleep\u0026#34;) todo.add(\u0026#34;buy some milk\u0026#34;) print(\u0026#34;Todo list:\u0026#34;, todo.show_todo_list()) print() todo.done(\u0026#34;buy some milk\u0026#34;) print(\u0026#34;Todo list:\u0026#34;, todo.show_todo_list()) print(\u0026#34;Done list:\u0026#34;, todo.show_done_list()) todo.clear() Click to expand and view more BLPOP: 阻塞式左端弹出操作\nPLAINTEXT Collapse Copy BLPOP list [list ...] timeout Click to expand and view more BLPOP 命令是带有阻塞功能的左端弹出操作, 接受任意个列表, 以及一个秒级精度的超时时限作为参数.\n该命令会按照从左到右的顺序依次检查用户给定的列表, 并对最先遇到的非空列表执行左端元素弹出操作. 如果没有可以执行弹出操作的列表, 则会阻塞该命令, 知道某个给定列表变为非空, 又或者等待时间超出给定的时限为止.\n若成功执行弹出操作, 则返回一个包含两个元素的列表, 第一个元素记录了执行弹出操作的列表, 即元素来源列表, 第二个参数则是被弹出元素本身.\n解除阻塞状态: 如果客户端被阻塞的过程中, 有另一个客户端向导致阻塞的列表推入了新的元素, 那么该列表就会变为非空, 而被阻塞的客户端也会随着 BLOPOP 命令成功弹出列表元素而重新回到非阻塞状态. 如果在同一时间内, 有多个客户端因为同一个列表而被阻塞, 那么当导致阻塞的列表变为非空时, 服务器将按照\u0026quot;先阻塞先服务\u0026quot;的规则, 依次为被阻塞的多个客户端弹出列表元素 处理空列表: 如果向 BLPOP 命令传入列表都为空列表, 且这些列表在给定时间内都没有变成非空列表, 则会返回一个空值(nil) 列表名的作用: BLPOP 返回来源列表是为了让用户在传入多个列表的情况下, 知道被弹出的元素来源哪个列表 BRPOP: 阻塞式右端弹出操作\nPLAINTEXT Collapse Copy BRPOP list [list ...] timeout Click to expand and view more 该命令和 BLPOP 除了方向不同外, 其他都一样\nBRPOPLPUSH: 阻塞式弹出并推入操作\nPLAINTEXT Collapse Copy BRPOPLPUSH source target timeout Click to expand and view more 若 source 非空, 行为和 RPOPLPUSH 一样, 将 source 的右端弹出, 并推入 target 的左端, 返回弹出的元素\n若 source 为空, 该命令将阻塞客户端, 并等待一定的时间, 类似上面的阻塞操作\n","title":"Redis List"},{"link":"/posts/rust-alternaitve-tools/","text":"常用工具的 rust 替代品.\nIntroduction 在 Unix 生态中, 许多命令行工具都是用 C 编写的, 经过几十年的优化, 性能和稳定性都非常优秀. 然而, 近年来, Rust 以其安全性、内存管理优势和现代化开发体验, 成为系统级工具开发的理想选择.\n首先更新 cargo, 不同系统都可以使用 cargo 安装, 当然也可以使用系统的包管理器安装\nPLAINTEXT Collapse Copy rustup update stable Click to expand and view more 有需要的话修改源, 一般在 ~/.cargo/config.toml, 下面是科大源\nTOML Collapse Copy [source.crates-io] replace-with = \u0026#39;ustc\u0026#39; [source.ustc] registry = \u0026#34;sparse+https://mirrors.ustc.edu.cn/crates.io-index/\u0026#34; [registries.ustc] index = \u0026#34;sparse+https://mirrors.ustc.edu.cn/crates.io-index/\u0026#34; Click to expand and view more Filesystem \u0026amp; Archiving 文件系统与归档 exa 替代 ls: 彩色支持 Git 状态的 ls 替代品\n常用参数: -1: 一行显示一个文件 -l: 显示文件细节信息 -F: 在目录文件名末添加斜杠符号 -T: 树状显示 -R: 递归显示所有文件 --icons: 显示图标 zoxide 替代 cd: 基于访问频率的快速目录跳转工具\n常用参数: z foo # 匹配 foo 的路径 z foo bar # 匹配 foo \u0026amp; bar 的路径 z - # 回到之前目录 zi foo # fzf File \u0026amp; Text Processing 文件与文本处理 bat 替代 cat: 具备语法高亮、行号显示、Git 集成等功能, 让查看文件内容更加美观 ripgrep 替代 grep: 使用 Rust 编写的极速文本搜索工具, 支持递归搜索、正则表达式、忽略规则(.gitignore)等 fd 替代 find: 提供简单直观的语法、更快的搜索性能, 并默认支持彩色输出和忽略 .gitignore 文件 System Monitoring \u0026amp; Management 系统监控与管理 bottom 替代 top / htop: 一个现代化的系统资源监控工具, 支持 CPU、内存、磁盘、网络等多种指标显示, 并提供交互式界面 procs 替代 ps: 更人性化的进程信息显示, 支持彩色输出、树状显示、搜索与过滤 Wrapping up Rust 的安全性和高性能使其成为编写现代 Linux 工具的理想选择. 这些替代品不仅提供了更好的用户体验, 还利用 Rust 的并发优势和零成本抽象提升了性能. 其他一些 rust 工具:\nuv: python 环境管理工具 alacritty: 支持 gpu 加速的终端, 实时刷新 ","title":"Rust Alternaitve Tools"},{"link":"/posts/tokei/","text":"Tokei 介绍 Tokei是一款 Rust 编写的开源工具, 用于统计项目代码行数, 支持上百种语言, 能够扫描整个代码库, 包括:\n语言 文件数量 代码行数 注释行数 空行数 得益于 Rust 的高性能实现, Tokei 即使在超大规模代码库中也能保持极快的统计速度\n(Rust 轮子真不错)\n安装 PLAINTEXT Collapse Copy brew install tokei Click to expand and view more 或者\nPLAINTEXT Collapse Copy cargo install tokei Click to expand and view more 使用 在项目根目录执行\nPLAINTEXT Collapse Copy tokei . Click to expand and view more 输出类似下面这样\nPLAINTEXT Collapse Copy =============================================================================== Language Files Lines Code Comments Blanks =============================================================================== Dockerfile 1 25 9 8 8 Python 52 2914 2372 96 446 TOML 1 65 58 0 7 YAML 2 49 45 0 4 ------------------------------------------------------------------------------- Markdown 1 194 0 158 36 |- BASH 1 13 13 0 0 (Total) 207 13 158 36 =============================================================================== Total 57 3247 2484 262 501 =============================================================================== Click to expand and view more ","title":"Tokei"},{"link":"/posts/redis-hash/","text":"散列 Redis 散列键 hash key 会将一个键和一个散列在数据库里关联起来, 散列中可以存任意多个字段 field. 与字符串一样, 散列字段和值既可以是文本数据, 也可以是二进制数据.\nHSET: 为字段设置值\nPLAINTEXT Collapse Copy HEST hash field value Click to expand and view more 若已给定的字段是否已经存在与散列中, 该设置为一次更新操作, 覆盖旧值后返回0.\n相反, 则为一次创建操作, 命令将在散列里面关联起给定的字段和值, 然后返回1.\nHSETNX: 只在字段不存在的情况下设置值\nPLAINTEXT Collapse Copy HSETNX hash field value Click to expand and view more HSETNX 命令在字段不存在且成功设置值时, 返回1.\n字段已存在并设置值未成功时, 返回0.\nHGET: 获取字段的值\nPLAINTEXT Collapse Copy HGET hash field Click to expand and view more 若查找的不存在的散列或字段, 则会返回空(nil)\n示例: 短网址生成 为了给用户提供更多空间, 并记录用户在网站上的链接点击行为, 大部分社交网站都会将用户输入的网址转换为短网址. 当用户点击段网址时, 后台就会进行数据统计, 并引导用户跳转到原地址.\n创建短网址本质上就是, 要创建出短网址ID与目标网址之间的映射, 并让用户访问短网址时, 根据短网址的ID映射记录中找出与之相对应的目标网址.\n短网址 ID 目标网址 RqRRz8n http://redisdoc.com/geo/index.html RUwtQBx http://item.jd.com/117910607.html HINCRBY: 对字段存储的整数值执行加法或减法操作\nPLAINTEXT Collapse Copy HINCRBY hash field increment Click to expand and view more 与字符串 INCRBY 命令一样, 如果散列字段里面存储着能够被 Redis 解释为整数的数字, 那么用户就可以使用 HINCRBY 命令为该字段的值加上指定的整数增量.\n该命令执行成功后, 将返回字段当前的值为命令的结果. 若要执行减法操作, increment 传入负数即可.\nHINCRBYFLOAT: 对字段存储的数字执行浮点数加法或减法操作\nPLAINTEXT Collapse Copy HINCRBYFLOAT hash field increment Click to expand and view more HINCRBYFLOAT 不仅可以使用整数作为增量, 还可以使用浮点数作为增量. 该命令执行成功后, 返回给定字段的当前值作为结果.\n此外, 不仅存储浮点数的字段可以使用该命令, 整数字段也可以使用该命令; 若计算结果可以表示为整数, 则会使用整数表示.\nHSTRLEN: 获取字段的字节长度\nPLAINTEXT Collapse Copy HSTRLEN hash field Click to expand and view more 如果给定的字段或散列不存在, 将返回0\nHEXISTS: 检查字段是否存在\nPLAINTEXT Collapse Copy HEXISTS hash field Click to expand and view more 如果存在, 返回1, 否则返回0\nHDEL: 删除字段\nPLAINTEXT Collapse Copy HDEL hash field Click to expand and view more HLEN: 获取散列包含的字段数量\nPLAINTEXT Collapse Copy HLEN hash Click to expand and view more 若不存在返回0\nHMSET: 一次为多个字段设置值\nPLAINTEXT Collapse Copy HMSET hash field value [field value ...] Click to expand and view more 该命令成功时返回 OK, 可使用新值覆盖旧值\nHMGET: 一次获取多个字段值\nPLAINTEXT Collapse Copy HMGET hash field [field ...] Click to expand and view more 对于不存在的值, 返回 (nil)\nHKEYS, HVALS, HGETALL: 获取所有字段, 所有值, 所有字段和值\nPLAINTEXT Collapse Copy HEKYS hash HVALS hash HGETALL hash Click to expand and view more 其中, HGETALL 命令返回的结果列表中, 没两个连续的元素代表散列中的一对字段和值, 奇数位置为字段, 偶数位置为字段值.\n若散列不存在, 则返回控列表(empty array)\nRedis 散列底层为无序存储的, 因此HKEYS, HVALS 和 HGETALL 可能会得到不同的结果, 因此不应该对其返回元素顺序做任何假设.\n示例: 存储图数据 图是一直常用的数据结构, 这里使用 field=edge, value=weight 的表示法来存储图结构, 其中 edge 由 start-\u0026gt;edge 构成\nPYTHON Collapse Copy from redis import Redis def make_edge_from_vertexs(start, end): return str(start) + \u0026#34;-\u0026gt;\u0026#34; + str(end) def decompose_vertexs_from_edge_name(name): return name.split(\u0026#34;-\u0026gt;\u0026#34;) class Graph: def __init__(self, client, key): self.client = client self.key = key def add_edge(self, start, end, weight): edge = make_edge_from_vertexs(start, end) self.client.hset(self.key, edge, weight) def remove_edge(self, start, end): edge = make_edge_from_vertexs(start, end) return self.client.hdel(self.key, edge) def get_edge_weight(self, start, end): edge = make_edge_from_vertexs(start, end) return self.client.hget(self.key, edge) def has_edge(self, start, end): edge = make_edge_from_vertexs(start, end) return self.client.hexists(self.key, edge) def add_multi_edges(self, *tuples): nodes_and_weights = {} for start, end, weight in tuples: edge = make_edge_from_vertexs(start, end) nodes_and_weights[edge] = weight self.client.hset(self.key, mapping=nodes_and_weights) # hmset 在 4.0 已抛弃, 使用 .hset(mapping={...}) def get_multi_edge_weights(self, *tuples): edge_list = [] for start, end in tuples: edge = make_edge_from_vertexs(start, end) edge_list.append(edge) return self.client.hmget(self.key, edge_list) def get_all_edges(self): edges = self.client.hkeys(self.key) result = set() for edge in edges: start, end = decompose_vertexs_from_edge_name(edge) result.add((start, end)) return result def get_all_edges_with_weight(self): edges_and_weights = self.client.hgetall(self.key) result = set() for edge, weight in edges_and_weights.items(): start, end = decompose_vertexs_from_edge_name(edge) result.add((start, end, weight)) return result client = Redis(decode_responses=True) graph = Graph(client, \u0026#34;test-graph\u0026#34;) graph.add_edge(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, 30) graph.add_edge(\u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, 25) graph.add_multi_edges((\u0026#34;b\u0026#34;, \u0026#34;d\u0026#34;, 70), (\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;, 10)) print(\u0026#34;edge a-\u0026gt; b weight:\u0026#34;, graph.get_edge_weight(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)) print(\u0026#34;a-\u0026gt;b 是否存在:\u0026#34;, graph.has_edge(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)) print(\u0026#34;b-\u0026gt;a 是否存在:\u0026#34;, graph.has_edge(\u0026#34;b\u0026#34;, \u0026#34;a\u0026#34;)) print(\u0026#34;所有边:\u0026#34;, graph.get_all_edges()) print(\u0026#34;所有边和权重\u0026#34;, graph.get_all_edges_with_weight()) Click to expand and view more 这里的图数据结构提供了边和权重的功能, 可以快速检查边是否存在, 能够方便的添加和移除边, 适合存储结点较多但是边较少的稀疏图(sparse graph).\n示例: 使用散列键重新实现文章存储程序 PYTHON Collapse Copy from redis import Redis from time import time class Article: def __init__(self, client, article_id): self.client = client self.article_id = str(article_id) self.article_hash = \u0026#34;article::\u0026#34; + self.article_hash def is_exists(self): return self.client.hexists(self.article_hash) def create(self, title, content, author): if self.is_exists(): return False article_data = { \u0026#34;title\u0026#34;: title, \u0026#34;content\u0026#34;: content, \u0026#34;author\u0026#34;: author, \u0026#34;created_at\u0026#34;: time(), } return self.client.hset(self.article_hash, mapping=article_data) def get(self): article_data = self.client.hgetall(self.article_hash) article_data[\u0026#34;id\u0026#34;] = self.article_id # 添加 id 到文章数据, 方便用户操作 return article_data def update(self, title=None, content=None, author=None): if not self.is_exists(): return False article_data = {} if title is not None: article_data[\u0026#34;title\u0026#34;] = title if content is not None: article_data[\u0026#34;content\u0026#34;] = content if author is not None: article_data[\u0026#34;author\u0026#34;] = author return self.client.hset(self.article_hash, mapping=article_data) client = Redis(decode_responses=True) article = Article(client, 10086) article.create(\u0026#34;greeting\u0026#34;, \u0026#34;hello world\u0026#34;, \u0026#34;peter\u0026#34;) Click to expand and view more 字符串有 MSET, MSETNX 命令, 但是并没有为散列提供 HMSET, HMSETNX 命令, 所以创建文章之前要先通过 is_exists() 方法检查文章是否存在, 再考虑是否使用 HMSET 命令进行设置. 在使用散列存储文章数据的时候, 为了避免数据库中出现键名冲突, 需要为每个属性设置一个独一无二的键, 例如 article::10086::title 键存储 id 为10086 文章的标题. Wrapping Up string 和 hash 总结与对比\n资源占用: 字符串键在数量较多的时候, 将占用大量内存和CPU时间. 相反, 将多个数据项存储到一个散列中可以有效减少内存和CPU消耗 支持的操作: 散列键支持的所有命令, 字符串键几乎都支持, 但字符串的 SETRANGE, GETRANGE 等操作散列不支持 过期时间: 字符串键可以为每个键单独设置过期时间, 独立删除某个数据项, 而散列一但到期, 其所包含的所有字段和值都会被删除 ","title":"Redis Hash"},{"link":"/posts/http-methods-status-codes-and-payloads/","text":"本篇文章基于 REST api 介绍HTTP请求方法、HTTP响应码和API数据载荷, 是之前介绍 REST 那篇文章的延伸\nHTTP Status Codes 1xx group: Signals that an operation is in progress 2xx group: Signals that a request was successfully processed 3xx group: Signals that a resource has been moved to a new location 4xx group: Signals that someting was wrong with the request 5xx group: Signals that there was an error while processing the request 在之前文章中, 定义的 HTTP status code 如下:\nPOST /orders: 201 (Created) - 资源成功创建 GET /orders: 200 (OK) - 请求成功处理 GET /orders/{order_id}: 200 (OK) - 请求成功处理 PUT /orders/{order_id}: 200 (OK) - 资源成功更新 DELETE /orders/{order_id}: 204 (No Content) - 请求被成功处理, 但是没有响应内容, 对比其他方法, DELETE 请求不需要 payload 来删除资源 POST /orders/{order_id}/chanel: 200 (OK) - 取消成功, 由于并不创建任何资源, 故返回200 POST /orders/{orders\\id}/pay: 200 (OK) - 支付成功, 同样由于未创建资源, 返回200 上面全是成功的响应, 下面介绍错误响应\n由于用户传入畸形的数据(malformed payload)或者请求一个不存在的 endpoint, 返回4xx响应码 服务器内部产生的错误, 这类错误使用5xx响应码 Client errors in the request 这里将 malformed payload 分为两类:\npayload with invalid syntax: 服务器无法解析或理解的数据, 例如json格式不对, 少了个反括号\u0026quot;}\u0026ldquo;之类的 unprocessable entities: 指却少要求属性的数据. 例如json里面要求name属性, 但是payload没有传这个属性; 又比如传入了一个不存在的资源, 这时返回一个404, 表示找不到相关资源 还有一种常见错误是, 发送了一个不支持的 HTTP 请求, 有两种 status code:\n可以返回一个 501 (Not Implemented) 表示该方法目前还未支持, 但是未来会添加的功能 如果未来也不打算实现该方法, 则可以返回一个 405 (Method Not Allowed) 关于 身份验证(authentication) 和 授权(authorization) 相关的请求错误有以下两个:\n对于未验证的请求, 返回 401 Unauthorized 对于已验证, 但是未授权的访问, 返回 403 Forbidden Server errors in the report 第2种错误是由于服务器代码 bug 或者基础设施限制导致的, 这时返回一个 500 (Internal Server Error)\n另一种相关的错误是, 程序无法处理请求的问题, 通常使用 proxy server 或者 API gateway 来解决这个问题. 由于服务器过载或者下线维护的时候, 我们需要将当前情况告知用户.\n当服务器无法处理新请求的时候, 必须返回 503 (Service Unavailable) 状态码, 表明服务器过载或者下线维护 当服务消耗太长时间返回响应, 应返回一个 504 (Gateway Timeout) 状态码 Designing API Payloads 这部分介绍设计用户友好的 HTTP request / response payloads 的最佳实践.\npayloads 是指 client 和 server 之间传输的数据部分. API 的可用性往往依赖好的 payload 设计, 糟糕的设计会使得 API 的用户使用体验变差.\n一个 HTTP request 包含了 URL, HTTP method 和 一系列的 headers 以及一个可选的 body(payload). HTTP headers 包含了请求的元数据, 例如 encoding format.\n类似的, HTTP response 包含一个 status code, 一协力的 headers 以及一个可选的 payload.\n可以使用不同的序列化方法来表示 payloads, 例如 XML 和 JSON. 在 REST APIs, 数据通常使用 JSON document.\nHTTP 请求规范在 DELETE 和 GET 请求是否可以包含 payload 这一点上故意保持模糊, 其并未禁止使用 payload. 这使得一些 API 可以在 GET 请求中包含负载, 一个著名的例子是 Elasticsearch, 它允许客户端在 GET 请求的请求体中发送查询文档.\n对于 HTTP Response 而言, 根据 status code 的不同, 可能会包含 payload. 根据 HTTP 规范(specification), 1xx, 204(No Content) 和 304(Not Modified) 这些状态码不能包含payload, 而其他的 response 都有.\n在 REST APIs 中, 最重要的就是 4xx 和 5xx 的错误响应, 以及 2xx 的成功响应和204的异常.\nHTTP payload designing patterns 错误的响应应该包含\u0026quot;error\u0026quot;关键字, 以及具体的细节信息, 并解释错误原因.\n例如, 一个 404 Response 返回的信息应该包含下面这些\nJSON Collapse Copy { \u0026#34;error\u0026#34;: \u0026#34;Resource not found\u0026#34; } Click to expand and view more error 是比较常用的关键字, 当然你也可以使用 \u0026ldquo;detail\u0026rdquo; 和 \u0026ldquo;message\u0026rdquo; 这类关键字. 大多数的 Web 框架都有默认的错误模板, 例如 FastAPI 使用\u0026quot;detail\u0026rdquo;.\n对于成功响应的 HTTP Response 而言, 区分为3种类型: 创建资源, 更新资源 和 获取资源.\nResponse Payloads for POST requests\n使用 POST 请求来创建资源. 在 CoffeeMesh 的订单 API 中, 通过 POST /orders 端点来下单. 为了创建一个订单, 需要将购买的商品列表发送给服务器, 服务器负责为该订单分配唯一的 ID, 因此订单的 ID 必须包含在响应数据中返回. 服务器还会设置订单创建的时间以及初始状态. 这里将由服务器设置的属性称为 sever sever-side 或 read-only, 这些属性也必须包含在响应数据中. 最佳实践返回的响应是对 POST 方法的全面表示, 这个 payload 用于验证资源是否被正确创建.\nResponse payloads for PUT and PATCH requests\n要更新资源, 这里使用一个 PUT 或者 PATCH 请求. 对单个资源发送 PUT / PATCH 请求, 例如 CoffeeMesh 订单 API 中的 PUT /orders{order_id} 端点. 在这种情况下, 返回资源的完整表示也是一种良好实践, 客户端可以利用它验证更新是否已被正确处理.\nResponse payloads for GET requests\n使用 GET 方法检索资源. 例如, 在 CoffeeMesh 里面的订单 AIP 一样, 有两个 GET endpoints: GET /orders 和 GET /orders/{orders_id}.\nGET /orders 返回一个列表, 有两种设计策略:\n包含每个订单的完整信息或者包含每个订单的部分信息. 第一种方法在比较大的响应体中, 往往会导致 API 性能下降.第二种方法是包含所有订单的部分信息, 这种实践比较常见, 例如只返回每个订单的 ID 信息, 客户端需要使用 GET /orders/{orders_id} 来获取每个订单的具体信息.一般倾向于返回完整的信息, 尤其是公开发布的 APIs. 然而，如果是在开发一个内部的 API, 并且不需要详细的信息. 那么可以只提供客户端需要的信息. 更小的 payloads 处理起来更快, 能带来更好的用户体验. 但是对于单例 endpoint(GET /orders/{orders_id})应该总是返回完整的信息.\nDesigning URL query parameters 一些 API 接口会返回一个资源列表, 当一个接口返回资源列表时, 最佳实践是允许用户对结果进行筛选和分页. 例如 GET /orders 接口, 可能希望结果为最近的5个订单, 或者只列出已取消的订单. URL 查询参数能让我们实现这些目标, 他应当始终是可选的, 并且在适当的情况下, 服务器可以为其分配默认值.\n定义: URL 查询参数是 URL 中的键值对参数. 查询参数位于问号(?)自后, 通常用于筛选接口的返回结果. 可以用与号(\u0026amp;)来分隔组合多个查询参数.\n调用 GET /orders 接口并按\u0026quot;已取消\u0026quot;来筛选订单结果, 可以这样写\nPLAINTEXT Collapse Copy GET /orders?cancelled=true Click to expand and view more 链接多个参数 向 GET /orders 端点添加一个名为 limit 的查询参数以限制返回结果的数量. 如果要筛选\u0026quot;已取消\u0026quot;订单并将返回结果限制为 5 条, 可以这样请求 API\nPLAINTEXT Collapse Copy GET /orders?cancelled=true\u0026amp;limit=5 Click to expand and view more 分页 允许 API 客户端对结果进行分页也是一种常见的做法. 分页(Pagination)是指将结果切分成不同的集和, 并一次提供一个集和. 可以使用多种策略进行分页, 最常见的方法是使用 page 和 per_page 则两个参数的组合. page 代表数据的某个集和(页码), 而 per_page 则告诉每个集和中想要包含多少个项目. 服务器根据 per_page 的指来确定每一页返回多少条数据.\n在 API 中组合这两个参数, 如下所示:\nPLAINTEXT Collapse Copy GET /orders?page=1\u0026amp;per_page=10 Click to expand and view more ","title":"HTTP Methods, Status Codes and Payloads"},{"link":"/posts/redis-string/","text":"介绍Redis中的字符串键\n字符串 字符串建是 Redis 最基本的键值对类型, 这种类型的键值对会在数据库中把单独的一个值关联起来, 被关联的键和值可以为文本, 也可以是图片, 视屏, 音频等二进制数据.\nSET: 为字符串键设置值 O(1) SET key value\n```Redis SET number \u0026quot;10086\u0026quot; \u0026gt; OK SET book \u0026quot;Redis in action\u0026quot; \u0026gt; OK ``` 对于已经存在的 key, 再次赋值会覆盖原值, 若不想覆盖后面添加参数 NX, 相反, 默认 XX 允许覆盖 ```Redis SET key \u0026quot;10086\u0026quot; NX \u0026gt; (nil) SET key \u0026quot;10086\u0026quot; XX \u0026gt; OK ``` GET: 获取字符串键的值 O(1) GET key\n```Redis GET number \u0026gt; \u0026quot;10086\u0026quot; ``` 对于不存在的值, 返回空 ```Redis GET key_new \u0026gt; (nil) ``` GETSET: 获取旧值并更新值 O(1) GETSET key new_value\n```Redis GETSET key \u0026quot;123456\u0026quot; \u0026gt; \u0026quot;10086\u0026quot; ``` 示例: 缓存 对数据进行缓存是Redis最常见的用法之一, 将数据存储在内存比存储在硬盘要快得多 首先定义缓存\nPYTHON Collapse Copy class Cache: def __init__(self, client): self.client = client def set(self, key, value): self.client.set(key, value) def get(self, key): return self.client.get(key) def update(self, new_value, key): return self.client.getset(key, new_value) # 设置新值, 返回旧值 Click to expand and view more 然后缓存文本数据\nPYTHON Collapse Copy client = Redis(decode_responses=True) # 使用文本编码方式打开客户端 cache = Cache(client) cache.set(\u0026#34;web_page\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;\u0026lt;p\u0026gt;hello world\u0026lt;/p\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;) print(cache.get(\u0026#34;web_page\u0026#34;)) print(cache.update(\u0026#34;web_page\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;\u0026lt;p\u0026gt;update\u0026lt;p\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;)) print(cache.get(\u0026#34;web_page\u0026#34;)) Click to expand and view more 下面是存储一个二进制图片的缓存示例\nPYTHON Collapse Copy client = Redis() # 二进制编码打开客户端 cache = Cache(client) image = open(\u0026#34;DailyBing.jpg\u0026#34;, \u0026#34;rb\u0026#34;) # 二进制只读方式打开图片 data = image.read() # 读取文件内容 image.close() # 关闭文件 cache.set(\u0026#34;daily_bing.jpg\u0026#34;, data) # 将二进制图片缓存到键 daily_bing.jpg 中 print(cache.get(\u0026#34;daily_bing.jpg\u0026#34;)[:20]) # 读取二进制数据的前20字节 Click to expand and view more b\u0026rsquo;\\xff\\xd8\\xff\\xe0\\x00\\x10JFIF\\x00\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00'\n示例: 锁 锁是一种同步机制, 用于保证一种资源任何时候只能被一个进程使用. 一个锁的实现通常有获取 (acquire) 和释放 (relase) 这两种操作.\n获取操作用于获取资源的独占使用权, 任何时候只能有一个进程取得锁, 此时, 取得锁的进程称为锁的持有者. 释放操作用于放弃资源的独占使用权, 一般由持有者调用. PYTHON Collapse Copy from redis import Redis VALUE_OF_LOCK = \u0026#34;locking\u0026#34; class Lock: def __init__(self, client, key): self.client = client self.key = key def acquire(self): result = self.client.set(self.key, VALUE_OF_LOCK, nx=True) return result is True def relase(self): return self.client.delete(self.key) == 1 client = Redis(decode_responses=True) lock = Lock(client, \u0026#39;test-lock\u0026#39;) print(\u0026#34;第一次获取锁:\u0026#34;, lock.acquire()) print(\u0026#34;第二次获得锁:\u0026#34;, lock.acquire()) print(\u0026#34;取消锁:\u0026#34;, lock.relase()) print(\u0026#34;第三次获得锁:\u0026#34;, lock.acquire()) Click to expand and view more 第一次获取锁: True 第二次获得锁: False 取消锁: True 第三次获得锁: True\n若要设置锁的时间 SET key value NX EX time 这样是原子性语法, 删除操作对应命令是 DEL key, 返回0表示 key 不存在, 返回1~N表示删除key的数量.\nNX 确保锁只有在没有值时加锁成功, 若有值则返回 None, 通过检查 result 是否为 True 来判断是否获得了锁.\nMSET: 一次为多个字符串键设置值 O(N) MSET key value [key value \u0026hellip;]\n同 SET 命令, MSET 执行成功后返回 OK, 并且会用新值覆盖旧值. 由于执行多条 SET 命令要客户端和服务端之间多次进行网络通讯, 因此 MSET 能减少程序执行操作的时间\nMGET: 一次获取多个字符串键的值 O(N) MGET key [key \u0026hellip;]\nMSETNX: 只在键不存在的情况下, 一次为多个键设置值 MSETNX key value [key value \u0026hellip;]\n若有任意一次键存在值, 则会取消所有操作, 并返回0. 只有所有键都没有值的时候, 执行才成功, 返回1.\n示例: 存储文章信息 在构建应用程序的时候, 经常会需要批量设计和获取多项信息, 以博客为例:\n当用户注册博客时, 程序将用户名字、帐号、密码、注册时间等存储起来, 并在登陆时查取这些信息. 当编写一篇博客文章时, 就要将博客标题、内容、作者、发表时间存储起来, 并在用户阅读的时候取出这些信息. 通过 MSET、MSETNX、MGET 命令, 可以实现上面提到的这些批量设置和批量获取操作\nPYTHON Collapse Copy from redis import Redis from datetime import datetime class Article: def __init__(self, client, article_id): \u0026#34;\u0026#34;\u0026#34;根据id创建文章id\u0026#34;\u0026#34;\u0026#34; self.client = client self.id = str(article_id) self.title_key = \u0026#34;article::\u0026#34; + self.id + \u0026#34;::title\u0026#34; self.content_key = \u0026#34;article::\u0026#34; + self.id + \u0026#34;::content\u0026#34; self.author_key = \u0026#34;article::\u0026#34; + self.id + \u0026#34;author\u0026#34; self.create_at_key = \u0026#34;article::\u0026#34; + self.id + datetime.now() def create(self, title, content, author): \u0026#34;\u0026#34;\u0026#34;创建文章\u0026#34;\u0026#34;\u0026#34; article_data = { self.title_key: title, self.content_key: content, self.author_key: author, self.create_at_key: datetime.now(), } return self.client.msetnx(article_data) def get(self): \u0026#34;\u0026#34;\u0026#34;获取文章信息\u0026#34;\u0026#34;\u0026#34; result = self.client.mget( self.title_key, self.content_key, self.author_key, self.create_at_key, ) return { \u0026#34;id\u0026#34;: self.id, \u0026#34;title\u0026#34;: result[0], \u0026#34;content\u0026#34;: result[1], \u0026#34;author\u0026#34;: result[2], \u0026#34;create_at_key\u0026#34;: result[3], } def update(self, title=None, content=None, author=None): \u0026#34;\u0026#34;\u0026#34;更新文章\u0026#34;\u0026#34;\u0026#34; article_data = {} if title is not None: article_data[self.title_key] = title if content is not None: article_data[self.content_key] = content if author is not None: article_data[self.author_key] = author return self.client.mset(article_data) client = Redis(decode_responses=True) article = Article(client, 10086) # 创建文章 print(article.create(\u0026#34;message\u0026#34;, \u0026#34;hello world\u0026#34;, \u0026#34;sx\u0026#34;)) # 获取文章信息 print(article.get()) # 更新文章作者 print(article.update(author=\u0026#34;join\u0026#34;)) Click to expand and view more 上面程序使用了多个字符串键存储文章信息: article::\u0026lt;id\u0026gt;::\u0026lt;attribute\u0026gt;\nSTRLEN: 获取字符串的字节长度 O(1) STRLEN key\n对于存在的键, 返回字节长度信息. 对于不存在的键, 返回0\nGETRANGE: 获取字符串值指定索引范围上的内容 O(N) GETRANGE key start end\nREDIS Collapse Copy SET message \u0026#34;hello world\u0026#34; GETRANG message 0 4 \u0026gt; hello GETRANGE message -5 -1 \u0026gt; world Click to expand and view more SETRANGE: 修改字符串索引范围的值 O(N) SETRANGE key index subsitute\nREDIS Collapse Copy set message \u0026#34;hello world\u0026#34; SETRANGE message 6 Redis \u0026gt; (integer) 11 GET message \u0026gt; hello Redis Click to expand and view more 当用户给定的新内容比被替换内容长的时候, SETRANGE 会自动扩展被修改的字符串值\nREDIS Collapse Copy SETRANGE message 5 \u0026#34;, this is a message\u0026#34; \u0026gt; (integer) 24 GET message \u0026gt; \u0026#34;hello, this is a message\u0026#34; Click to expand and view more 当用户给出的索引长度超出被替换字符长度时, 字符串末尾到 index-1 之间部分将使用空字符串填充为0\nREDIS Collapse Copy SET greeting \u0026#34;hello\u0026#34; SETRANGE greeting 10 \u0026#34;hello\u0026#34; \u0026gt; (integer) 15 GET greeting \u0026gt; \u0026#34;hello\\x00\\x00\\x00\\x00\\x00world\u0026#34; Click to expand and view more 示例: 给文章存储程序加上文章长度计数功能和文章御览功能给 文章长度计数功能: 显示文章长度, 用于估计阅读时长 文章预览功能: 显示文章开头一部分内容, 帮助读者快速了解文章 PYTHON Collapse Copy class Article: ... def get_content_len(self): return self.client.strlen(self.content_key) def get_content_perview(self, preview_len): start_index = 0 end_index = preview_len - 1 return self.client.getrange(self.content, start_index, end_index) Click to expand and view more APPEND: 追加新内容到值的末尾 APPEND key suffix\n若用户给定的 key 不存在, 则相当于 SET key suffix\n示例: 存储日志 很多程序运行的时候会产生日志, 日志记录了程序的运行状态以及执行过的重要操作. 若每条日志存储一个键值对, 则会消耗很多资源, 且分散在数据库中, 需要额外的时间查找日志, 这里将不同日志拼接在同一个值里面.\nPYTHON Collapse Copy from redis import Redis LOG_SEPERATOR = \u0026#34;\\n\u0026#34; class Log: def __init__(self, client, key): self.client = client self.key = key def add(self, new_log): new_log += LOG_SEPERATOR self.client.append(self.key, new_log) def get_all(self): all_logs = self.client.get(self.key) if all_logs is not None: log_list = all_logs.split(LOG_SEPERATOR) log_list.remove(\u0026#34;\u0026#34;) # 删除默认多余的空字符串 return log_list else: return [] Click to expand and view more 数字值 下面介绍使用字符串键存储数字值:\n每当存储一个值到字符串键里面的时候, 有下面两种情况\nC 语言 long long int 类型的整数, 取值范围为 -2^63 ~ 2^63-1 (超出范围会被当成字符串) C 语言 long double 类型的浮点数 为了方便地处理字符串键的值, Redis 提供了一系列加法和减法操作命令, 下面介绍这些命令\nINCRBY, DECRBY: 对整数执行加法和减法操作 O(1) INCRBY key increment DECRBY key increment\n如果类型为浮点数, 使用上面方法会报错 (key的值 和 increment 都必须为整数) 当该命令遇到**不存在的键**时, 会将键的值初始化为0, 然后再执行操作 INCR, DECR: 对整数执行加1和减1操作 O(1) INCR key DECR key\nINCRBYFLOAT: 对数字值执行浮点数加减法操作 INCRBYFLOAT key increment\nINCRBYFLOAT 命令即执行加法操作, 也可以执行加法操作, 并且操作对象和 increment 都既可以为整数也可以为浮点数 虽然 Redis 没有限制字符串键存储浮点数的小数位数, 但是 INCRBYFLOAT 最多只会保留小数点后的17位数字, 超出部分将被截断 示例: ID 生成器 identifier 标识符, 经常在程序中使用, 通常以数字形式出现, 并通过递增的方法创建新的ID.\nPYTHON Collapse Copy from redis import Redis class IdGenerator: def __init__(self, client, key): self.client = client self.key = key def produce(self): \u0026#34;\u0026#34;\u0026#34;生成下一个id\u0026#34;\u0026#34;\u0026#34; return self.client.incr(self.key) def reserve(self, n): \u0026#34;\u0026#34;\u0026#34;初始化\u0026#34;\u0026#34;\u0026#34; result = self.client.set(self.key, n, nx=1) # key 不存在才行 return result is True client = Redis(decode_responses=True) id_generator = IdGenerator(client, \u0026#34;user::id\u0026#34;) print(id_generator.reserve(1000000)) # 保留100万个ID -\u0026gt; True print(id_generator.produce()) # 生成ID, 均大于100万 print(id_generator.reserve(1000)) # 已存在 -\u0026gt; False Click to expand and view more 示例: 计数器 除了ID生成器, 计数器也是常用的组件之一, 例如点赞回复数量, 播放量等.\nPYTHON Collapse Copy from redis import Redis class Counter: def __init__(self, client, key): self.client = client self.key = key def increase(self, n=1): return self.client.incr(self.key, n) def decrease(self, n=1): return self.client.decr(self.key, n) def get(self): value = self.client.get(self.key) if value in None: return 0 else: return int(value) def reset(self): old_value = self.client.getset(self.key) if old_value is None: return 0 else: return(old_value) client = Redis(decode_responses=True) counter = Counter(client, \u0026#34;counter::page_viewed\u0026#34;) print(counter.increase()) # +1 print(counter.increase()) print(counter.increase(10)) # +10 print(counter.decrease()) # -1 print(counter.decrease(5)) # -5 print(counter.reset()) # 重置计数器 print(counter.get()) # 返回计数器当前值 Click to expand and view more 注: 在 redis-py 中 INCR 和 INCRBY 都使用 .incr() 方法\n示例: 限速器 为了保障系统的安全性和性能, 并保证重要资源不被滥用, 应用程序需要对用户的行为进行限制\n防止网络爬虫: 限制每个IP地址在固定时间段内访问的页面数量 防止爆力破解: 当用户多次输入错误的密码, 会帐号进行冻结 上面机制的实现可以使用限速器, 下面是一个限速器示例代码, 该程序将操作最大可执行次数存储在一个字符串里面, 每次用户进行该操作后就将其减1\nPYTHON Collapse Copy from redis import Redis class Limter: def __init__(self, client, key): self.client = client self.key = key def set_max_execute_times(self, max_execut_time): self.client.set(self.key, max_execut_time) def still_valid_to_execute(self): num = self.client.decr(self.key) return (num \u0026gt;= 0) def remaining_execute_times(self): num = int(self.client.get(self.key)) if num \u0026lt; 0: return 0 else: return num client = Redis(decode_responses=True) limter = Limter(client, \u0026#34;wrong_password_limter\u0026#34;) print(limter.set_max_execute_times(5)) # 最多5次输入错误密码 print(limter.still_valid_to_execute()) # 前5次 True, 之后 False Click to expand and view more ","title":"Redis String"},{"link":"/posts/ieee-754-introduce/","text":"IEEE 754 标准数值类型及分类\n整数 Integer 整数是没有小数部分的值, 在计算机内通常有两种表示方式:\n有符号整数: 可以表示正数和负数, 最常用的是二补码表示. 例如 8 位二进制的范围为[-2^7, 2^7-1] 无符号整数: 仅表示非负数, 8 位二进制的范围为 [0, 2^8-1] 其中补码(Two\u0026rsquo;s Complement)用于表示负数\n正数补码与原码相同 负数的补码 = 该数绝对值的二进制取反 + 1 通过补码, 可以使得加减运算统一, 溢出检测更加简单\n浮点数 Floating-point 浮点数用于表示带小数的实数, 尤其适合科学计算和近似表示很大或很小的数值. IEEE 754 定义了浮点数的标准格式, 类似科学计数法:\nPLAINTEXT Collapse Copy value = (-1)^(sign) x mantissa x 2^(exponent) Click to expand and view more 浮点数由三部分组成:\n符号位 sign: 0/1代表正负 阶码 exponent: 通常使用偏移表示法 尾数 fraction/mantissa: 小数部分 常见浮点数类型:\n单精度 float32: 1 位符号 + 8 位阶码 + 23 位尾数 双精度 float64: 1 位符号 + 11 位阶码 + 52 位尾数 浮点数的分类 Categories 以 64 精度为例\n部分 位数 描述 符号位（sign） 1 0 表示正数，1 表示负数 阶码（exponent） 11 偏移量（bias）为 1023，表示数值的量级 尾数（fraction / mantissa） 52 有效数字，不包括隐藏位 浮点数的表示公式:\nPLAINTEXT Collapse Copy value = (-1)^sign x (1 + fraction) x 2^(exponent - bias) Click to expand and view more 正常数 Normalized numbers\n阶码 exponent: 不全为0, 也不全为1, [1, 2^11-2] 尾数 fraction: 隐含1, [0, 1 - 2^-52], (52位全1 位 1 - 2^-52) PLAINTEXT Collapse Copy value = (-1)^sign x (1 + fraction) x 2^(exponent - 1023) Click to expand and view more 其中, bias = 2^(exponent - 1) - 1, 这里为 1023\n最大正常数: 阶码最大为 1024*2-2 = 2046, 尾数全为1 1-2^-52, 即 ( 1 + (1 - 2^-52) ) x 2^(2026-1023) 最小正常数: 阶码最小位 1, 尾数全为0, 即 ( 1 + 0 ) x 2^(1-1023) 非正规数 Subnormal numbers / Denormalized numbers\n阶码 exponent: 全0 尾数 fraction: [0, 1-2^-52], 没有隐藏位1 PLAINTEXT Collapse Copy value = (-1)^sign x (fraction) x 2^(1 - bias) Click to expand and view more 非正规数指数紧接最小正常数, 使非正规数数值连续接近零\n注意: 非正规数的指数并不是阶码减 bias 的直接结果(0−1023 = −1023), 而是约定使用最小正常数指数 E_min = −1022. 这样可以让非正规数顺接正常数, 形成连续的可表示范围, 并支持渐进下溢.\n最大非正规数: 阶码为0, 尾数全为1, 即 ( 1 - 2^-52 ) x 2^(-1022) 最小非正规数: 阶码位0, 尾数最低位为1, 其他为0, 即 ( 2^-52 x 2^(-1022) ) 零 0\n符号 sign: 0/1 正负零 阶码 exponent: 0 尾数 fraction: 0 无穷 infinity\n符号sign: 0/1 正负无穷 阶码 exponent: 2047 (全1) 尾数 fraction: 0 非数值 NaN\n阶码 exponent: 2047 (全1) 尾数 fraction != 0 表示未定义或非法运算, 如 0/0\n类别 (categories) 符号位 (sign) 阶码 (exponent) 尾数 (fraction / mantissa) 描述 正常数 0 或 1 [1, 2046] 1.f 范围: [1.0, 2-ε) 阶码非全0且非全1, 尾数隐含最高位1 非正规数 0 或 1 全 0 0.f 范围: (0, 1.0-ε] 阶码全0, 尾数非全0, 无隐藏位1, 接近0 ±0 0 或 1 全 0 全 0 阶码全0, 尾数全0 ±∞ 0 或 1 全 1 [2047] 全 0 阶码全1, 尾数全0 NaN (qNaN / sNaN) 0 或 1 全 1 [2047] 非全 0 阶码全1, 尾数非全0, 表示无效或未定义运算 注意: 非正规数的阶码虽然为全0, 但是计算时约定为 1-bias = 1-1023 = -1022, 而不是像正规数那样 exponent - bias\n","title":"IEEE-754 Introduce"},{"link":"/posts/designing-and-building-rest-apis/","text":"这篇文章延续之前微服务的内容, 将介绍关于 REST API 的以下几个方面:\nREST API 的设计原则 Richardson maturity model (RMM) 如何帮助理解 REST 的优势和设计原则 REST API 中资源(resource)和端点(endpoints)设计的概念 表达性状态转移 representational state transfer (REST) 描述了一种通过网络进行通信的应用程序架构风格. 最初, REST 的概念包含了一组用于设计分布式、可扩展 Web 应用的约束条件. 随着时间推移, 出现了更为细致的协议和规范, 为 REST API 的设计提供了明确的指导方针. 如今, REST 已经成为构建 Web API 的最流行选择.\n下面将继续在 CoffeeMesh 项目上, 设计相关订单 API.\nWhat is REST? REST 由 Roy Fielding 在他的博士论文 \u0026ldquo;Architectural Styles and the Design of Network-based Software Atchitecture\u0026rdquo; (PhD diss. University of California,Irvine,2000,p. 109) 中创造.\n定义: REST 是一个松耦合和高伸缩的 API 架构风格. REST APIs 以资源为核心来组织, 这些资源是可以通过 API 操作的实体.\n资源 resource 是可以通过唯一的 URL 来标识的实体, 有两种类型: 集和 collections 和 单体 singletons. 单体标识一个单独的实体, 而集和标识一组实体.\n例如, 在 CoffeeMesh 的订单服务负责管理订单, 通过 /orders/{order_id} 访问特定订单, 是一个单体端点(singleton endpoint); 而所有订单通过 /orders 获取, 是一个集和端点 (collection endpoint).\n某些资源还可以嵌套进其他资源中, 例如一个订单的 payload 中, 可能包含一个嵌套数组列出该订单的多个商品 , 例如下面这样:\nJSON Collapse Copy { \u0026#34;id\u0026#34;: \u0026#34;924721eb-a1a1-4f13-b384-37e89c0e0875\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;progress\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2023-09-01\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;cappuccino\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;small\u0026#34;, \u0026#34;quantity\u0026#34;: 1 }, { \u0026#34;product\u0026#34;: \u0026#34;croissant\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ] } Click to expand and view more 可以创建一个嵌套端点来表示嵌套资源, 例如通过 GET /orders/{order_id}/status 端点查询订单的状态和细节信息. 当资源对应的负载 payload 较大时, 使用嵌套端点是一种常见的优化策略, 例如只想知道状态信息, 就不需要查询大量的详细数据了, status 端点返回信息如下:\nJSON Collapse Copy { \u0026#34;status\u0026#34;: \u0026#34;processing\u0026#34; } Click to expand and view more Architectural constraints of REST applications 这里解释 REST 应用的架构约束, 这些约束由 Fielding 列出, 用于规定服务器应如何处理并响应客户端请求. 下面是每个约束的简单描述:\nClient-server architecture 客户端-服务器架构: 用户界面必须与后端解耦 decoupled Statelessness 无状态性: 服务器不能在请求之间维护状态 Cacheability 可缓存性: 返回相同内容的请求, 应支持缓存 Layered system 分层系统: API 按层架构, 但要向用户隐藏复杂性 Code on demand 按需代码: 服务器可以按需将代码注入到用户界面 Uniform interferace 统一接口: API 必须提供一致的接口来访问和操作资源 Separation of concers: The client-server architecture principle 关注点分离: 客户端-服务器架构原则\nREST 依赖于关注点分离原则, 因此要求用户界面(UI)必须于数据存储和服务器逻辑解耦. 这样一来, 服务器组件就可以独立于 UI 元素进行开发. 一种常见的实现方法是: 将 UI 构建为一个独立应用, 例如单页应用(SPA)\nMake it scalable: The statelessness principle 可扩展性: 无状态原则\n在 REST 中, 每一次对服务器的请求都必须包含处理该请求的全部信息. 特别是, 服务器不能在请求之间保持状态. 将状态管理从服务器组件中移除, 可以更容易地对后端进行水平扩展, 这使得我们能够部署多个服务器示例, 并且由于这些实例都不管理 API 客户端的状态, 客户端就可以于任意一个实例进行通信.\nOptimize for performance: The cacheability principle 性能优化: 可缓存原则\n在适用的情况下, 服务器必须是可缓存的. 缓存提升 API 的性能, 这意味着不必一次又一次地执行生成响应所需要的计算. GET 请求适合缓存, 因为他们返回的是服务器中已保存的数据. 通过缓存 GET 请求, 可以避免在用户每次请求相同信息时都从数据源重新获取数据, 生成 GET 请求响应所需要的时间越长, 缓存所带来的收益就越大.\nMake it simple for the client: The layered system principle 让客户端更简单: 分层系统原则\n在 REST 架构中, 客户端必须通过一个唯一的入口访问 API, 而且不应该知道自己是直接连接到最终服务器, 还是连接到某个中间层(例如负载均衡器). 可以把服务端的应用的不同组件部署在不同的服务器上, 或者把相同的组件部署在多个服务器上, 以实现冗余和壳扩展性. 但这些复杂性必须对用户隐藏, 只暴露一个统一的入口来封装服务访问.\nExtendable interferaces: The code-on-demand principle 可扩展接口: 按需代码原则\n服务器可以通过直接从后端发送可执行代码, 来扩展客户端应用的功能. 这个约束是可选的, 只适用于后端提供客户端界面的应用.\nKeep it consistent: The uniform interface principle 保持统一性: 统一接口原则\nREST 应用必须向其使用者提供统一且一直的接口, 接口必须有文档说明, 服务器和客户端必须严格遵循 API 规范. 每个资源通过统一资源标识符(URI)来标识, 每个 URI 必须唯一, 并且始终返回相同的资源. 资源必须使用某种序列化方法表示, 并且这种方法在整个 API 中应保持一致. 如今, REST API 通常使用 JSON 作为序列化格式, 但也可以使用其他格式, 例如 XML.\nHypermedia as the engine of application state 超媒介作为应用状态引擎 (HATEOAS)\n在 2008 年发表的一篇题为REST APIs Must Be Hypertext-Driven的文章中, Fielding 提出:\nREST API 的响应必须包含相关链接, 以便客户端可以通过这些链接导航 API\nHATEOAS 是 REST API 设计中的一种范式(paradigm), 它强调可发现性. 每当客户端向服务器请求某个资源时, 响应必须包含指向该资源的相关链接列表. 例如, 客户端请求订单详情时, 响应必须包含取消订单和支付订单的相关链接.\n例如下面这样\nJSON Collapse Copy { \u0026#34;id\u0026#34;: 8, \u0026#34;status\u0026#34;: \u0026#34;progress\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2025-8-16\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;cappuccino\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;small\u0026#34;, \u0026#34;quantity\u0026#34;: 1 }, { \u0026#34;product\u0026#34;: \u0026#34;croissant\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ], \u0026#34;links\u0026#34;: [ { \u0026#34;href\u0026#34;: \u0026#34;/orders/8/cancel\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Cancels the order\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;POST\u0026#34; }, { \u0026#34;href\u0026#34;: \u0026#34;/orders/8/pay\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Pays for the order\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;POST\u0026#34; } ] } Click to expand and view more 提供关联链接可以使 API 具有可导航性, 更易于使用, 因为每个资源都会附带与之交互所需的所有 URL. 然而在实际中, 许多 API 并没有这样实现, 原因包括:\n超链接提供的信息在 API 文档中已经可用 实际上, OpenAPI 规范中包含的信息比单独为特定资源提供的相关链接列表要丰富和结构化得多 不总是清楚应该返回哪些链接 不同用户拥有不同的权限和角色, 可以执行不同操作和访问不同资源 例如，CoffeeMesh API 的外部用户可以使用 POST /orders 下单, 也可以使用 GET /orders/{order_id} 查询订单详情, 但不能使用 DELETE /orders/{order_id} 删除订单, 因为该接口仅限内部用户 如果 HATEOAS 的目标是让 API 可以从单一入口导航, 那么向外部用户返回他们无法使用的 DELETE 链接显然没有意义 因此, 需要根据用户权限返回不同的相关链接列表, 但这会增加 API 设计和实现的复杂性, 并将授权层与 API 层耦合 资源状态可能限制某些操作 例如, POST /orders/1234/cancel 只能在活跃订单上调用, 而无法对已取消订单调用 这种不确定性会增加遵循 HATEOAS 原则的接口设计和实现难度 响应负载可能过大 在一些 API 中, 相关链接列表可能非常庞大, 使响应体变大, 从而影响 API 性能, 以及对网络连接较差的小设备的可靠性 在设计自己的 API 时, 可以根据实际情况决定是否遵循 HATEOAS 原则, 在某些情况下是有用的, 例如:\n在 Wiki 应用中, 响应中的 \u0026ldquo;linked resources\u0026rdquo; 部分可以列出\n与某篇文章相关的内容 该文章的多语言版本链接 可以对文章执行的操作链接 总体来说, 需要在 API 文档已经清晰详细提供信息 与 通过响应辅助客户端交互 之间找到平衡\n面向公众的 API: 客户端会从关联链接中受益 小型内部 API: 通常不需要提供关联链接 Analyzing the matruity of an API with the Richardson maturity model 使用 Richardson 成熟度模型分析 API 的成熟度\n这是由 Leonard Richardson 提出的一种思维模型, 用于帮助评估一个 API 在多大程度上遵循了 REST 原则, Richardson 成熟度模型将 API 的\u0026quot;成熟度\u0026quot;划分为四个等级: 0. Level 0: RPC over HTTP\nLevel 1: Resources Level 2: HTTP methods and status codes Level 3: Hypermedia controls (HATEOAS) Glory of REST! Level 0: Web APIs à la RPC 类似 PRC 的 Web API\n在0级中, HTTP 本质上只作为一种传输系统, 用于承载与服务器的交互. 在这种情况下, API 的概念更接近 远程过程调用(remote procedure call, RPC). 所有服务器的请求都在同一个端点发起, 并使用相同的 HTTP 方法, 客户端请求的具体细节通过 HTTP 的 payload 传递.\n例如, 在 CoffeeMesh 网站下单时, 客户端可能会向通用 /api 端点发送如下 POST 请求:\nJSON Collapse Copy { \u0026#34;action\u0026#34;: \u0026#34;placeOrder\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;mocha\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ] } Click to expand and view more 服务器通常会返回200状态码, 并附带一个 payload, 告诉请求处理结果.\n类似地, 要获取某个订单的详情, 客户端也可能向通用 /api 端点发送如下 POST 请求:\nJSON Collapse Copy { \u0026#34;action\u0026#34;: \u0026#34;getOrder\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;id\u0026#34;: 8 } ] } Click to expand and view more Level 1: Intorducing the concept of resource 第1级引入了资源 URL 的概念, 服务器不再使用通用的 /api 端点, 而是暴露表示资源的 URL. 例如:\n/orders 表示订单集和 /order/{order_id} 表示单个订单 要下单时, 客户端向 /orders 端点发送 POST 请求, payload 与 0 级类似\nJSON Collapse Copy { \u0026#34;action\u0026#34;: \u0026#34;placeOrder\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;mocha\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ] } Click to expand and view more 在这一层, API 还没有使用不同的 HTTP 方法来区分不同操作\nLevel 2: Using HTTP methods and status codes 第2级引入了 HTTP 请求方法verbs 和 状态码status 的概念, 这一层, HTTP verbs 用于表示具体操作. 例如, 要下订单, 客户端向 /orders 端点发送一个 POST 请求, 内容如下:\nPYTHON Collapse Copy { \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;mocha\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ] } Click to expand and view more 在这个例子中, HTTP 方法 POST 表示要执行的操作, 而请求体仅包含想要下的订单的具体信息\n类似地, 如果要获取某个订单的详细信息, 我们会向该订单的 URI 发送 GET 请求: /orders/{order_id}. 这里使用 GET 告诉服务器, 希望获取 URI 指定资源的详细信息\n前几个级别的响应通常都使用相同的状态码(通常为 200), 而第二级引入了 HTTP 状态码的语义化使用, 用来报告客户端请求处理的结果. 例如:\n使用 POST 创建资源时, 服务器会返回 201 Created 状态码 请求不存在的资源时, 会返回 404 Not Found 状态码 Level 3: API discoverability 第3级引入了可发现性的概念, 通过 HATEOAS 原则, 并在响应中添加表示可对资源执行操作的链接来实现.\n例如, 对 /orders/{order_id} 端点发送 GET 请求, 会返回该订单的表示(representation), 并包含一系列相关链接\nPYTHON Collapse Copy { \u0026#34;id\u0026#34;: 8, \u0026#34;status\u0026#34;: \u0026#34;progress\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2023-09-01\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;cappuccino\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;small\u0026#34;, \u0026#34;quantity\u0026#34;: 1 }, { \u0026#34;product\u0026#34;: \u0026#34;croissant\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ], \u0026#34;links\u0026#34;: [ { \u0026#34;href\u0026#34;: \u0026#34;/orders/8/cancel\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Cancels the order\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;POST\u0026#34; }, { \u0026#34;href\u0026#34;: \u0026#34;/orders/8/pay\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Pays for the order\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;GET\u0026#34; } ] } Click to expand and view more 在 Richardson 成熟度模型中, 第三级代表了他所称的 \u0026ldquo;REST 的荣耀(Glory of REST)\u0026rdquo; 的最后一步\n该模型为我们提供了一个框架, 用来思考 API 设计在 REST 原则体系中的位置. 它的目的不是衡量 API 在多大程度上\u0026quot;符合\u0026quot;REST 原则, 也不是评估 API 设计的质量; 而是帮助我们思考如何充分利用 HTTP 协议, 创建表达力强、易理解、易使用的 API.\n","title":"Designing and Building REST APIs"},{"link":"/posts/intorduce-uuid/","text":"UUID(Universally Unique Identifier, 通用唯一标识符) 是一种标准化的128位标识符, 用于在分布式系统中生成几乎不会重复的唯一 ID. 最早于 IETF 制定为 RFC 4122 标准, 保证在不同机器、不同时间生成的 ID 也能保持全局唯一.\nUUID 通常以16进制表示, 采用5段结构, 用连字符 - 分隔, 例如:\nPLAINTEXT Collapse Copy 550e8400-e29b-41d4-a716-446655440000 Click to expand and view more 有如下特点:\n全局唯一 无中心依赖 不可预测 跨平台通用 UUID 有以下不同版本:\n版本 生成 特点 v1 基于时间戳 + MAC 地址 按时间排序，含生成设备信息 v3 基于命名空间的 MD5 哈希 输入相同则输出相同(MD5 已不再安全) v4 基于操作系统的随机数生成 完全随机, 最常用 v5 基于命名空间的 SHA-1 哈希 与 v3 类似, 但使用 SHA-1 v6~v8 现代版本(草案) 提高排序性能和隐私保护 其中, 对于需要时间有序的使用 v1, 大多数通用场景使用 v4\nUUID 的应用场景\n数据库主键(分布式环境避免冲突) 会话标识(Session ID、Token) 文件命名(防止重名) 分布式系统节点 ID 追踪请求链路(Trace ID) 示例代码\nPYTHON Collapse Copy import uuid # 生成 UUID v1 u1 = uuid.uuid1() print(\u0026#34;UUID v1:\u0026#34;, u1) # 生成 UUID v4（随机） u4 = uuid.uuid4() print(\u0026#34;UUID v4:\u0026#34;, u4) # 生成 UUID v3（命名空间 + MD5） u3 = uuid.uuid3(uuid.NAMESPACE_DNS, \u0026#34;example.com\u0026#34;) print(\u0026#34;UUID v3:\u0026#34;, u3) # 生成 UUID v5（命名空间 + SHA-1） u5 = uuid.uuid5(uuid.NAMESPACE_DNS, \u0026#34;example.com\u0026#34;) print(\u0026#34;UUID v5:\u0026#34;, u5) Click to expand and view more UUID v1: 9f7a1f7e-9e87-11ee-b15d-0242ac120002\nUUID v4: 5f9b44e4-62af-4d13-bd4c-52de5f028f33\nUUID v3: 9073926b-929f-31c2-abc9-fad77ae3e8eb\nUUID v5: 2ed6657d-e927-568b-95e1-2665a8aea6a2\n","title":"Intorduce UUID"},{"link":"/posts/microservice-with-fastapi/","text":"What are microservices ? 什么是微服务? 微服务可以有多种不同的定义方式, 具体取决于希望强调微服务架构的哪个方面, 不同作者会给出略有不同但相关的定义\nSam Newman, 微服务领域最有影响力的作者之一, 给出了一个极简的定义:\n“Microservices are small, autonomous services that work together.”\n这个定义强调了这样一个事实: 微服务是彼此独立运行的应用程序, 但它们可以协作完成任务. 该定义还强调微服务是 “small (小的)”, 这里的 small 并不是指微服务代码量的大小, 而是指微服务具有狭窄且定义清晰的职责范围, 符合单一职责原则(Single Responsibility Principle) —— 即“只做一件事，并把它做好”.\nJames Lewis 和 Martin Fowler 撰写的一篇开创性文章提供了一个更详细的定义, 他们将微服务定义为一种架构风格(architectural style)\n“an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API”\n这个定义强调了服务的自主性(autonomy), 指出它们运行在各自独立的进程中. Lewis 和 Fowler 同样强调了微服务职责的狭窄性(narrow scope of responsibilities), 称其为“small”, 并明确指出微服务之间通过轻量协议(如HTTP)进行通信\n定义\n微服务是一种架构风格，其中系统的各个组件被设计为可独立部署的服务(independently deployable services). 微服务围绕明确的业务子领域(business subdomains)进行设计，并通过如 HTTP 等轻量协议(lightweight protocols)相互通信 从以上定义中我们可以看到, 微服务可以被定义为一种架构风格, 其中服务作为组件执行一组小而明确的相关功能. 这意味着微服务是围绕特定的业务子领域来设计和构建的, 例如处理支付、发送邮件或处理客户订单等.\n微服务作为独立的进程进行部署, 通常运行在独立的环境中, 并通过定义清晰的接口暴露其能力\nA basic API implementation 这里通过一个 CoffeeMesh 项目的 orders service (订单服务) api 介绍微服务\n首先给出 OpenAPI 格式的 API 定义文档 oas.yaml, 可以通过 Swagger UI 来查看该文档内容 (OAS 代表 OpenAPI specification/规范, 是一种标准的 REST API 文档)\n具体 API 如下\n/orders: 检索订单(GET) 和 创建订单(POST) /orders/{order_id}: 检索某个订单的细节(GET), 更新订单(PUT) 和 删除订单(DELETE) /orders/{order_id}/cancel: 删除某个订单 /orders/{order_id}/pay: 支付订单 除了 API endpoints, 还有 data models (在 OpenAPI 中被称为 schemas). Schemas 告诉客户端需要什么样的数据载荷(payload)以及什么是类型.\n例如,OrderItemSchema 指定了 product 和 size 是必填的, 而 quantity 属性是可选的, 当这个属性消失的时候, 默认值为 1\nYAML Collapse Copy # file: oas.yaml OrderItemSchema: type: object required: - product - size properties: product: type: string size: type: string enum: - small - medium - big quantity: type: integer default: 1 minimum: 1 Click to expand and view more 请求处理流大概下面这样: HTTP request -\u0026gt; Uvicorn -\u0026gt; FastAPI(Starlette routing -\u0026gt; data -\u0026gt; api endpoints) -\u0026gt; Pydantic\n下面是一个 orders API 的最小实现\nPYTHON Collapse Copy from datetime import datetime from uuid import UUID from starlette.responses import Response from starlette import status from orders.app import app order = { \u0026#34;id\u0026#34;: \u0026#34;ff0f1355-e821-4178-9567-550dec27a373\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;delivered\u0026#34;, \u0026#34;created\u0026#34;: datetime.utcnow(), \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;cappuccino\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 1, } ] } @app.get(\u0026#34;/orders\u0026#34;) def get_orders(): return {\u0026#34;orders\u0026#34;: [orders]} @app.post(\u0026#34;/orders\u0026#34;, status_code=status.HTTP_201_CREATED) def create_order(): return order @app.get(\u0026#34;/orders/{order_id}\u0026#34;) def get_order(order_id: UUID): return order @app.get(\u0026#34;/orders/{order_id}\u0026#34;) def update_order(order_id: UUID): return order @app.delete(\u0026#34;/orders/{order_id}\u0026#34;, status_code=status.HTTP_204_NO_CONTENT) def delete_order(order: UUID): return Response(status_code=HTTPStatus.NO_CONTENT.value) @app.post(\u0026#34;/orders/{order_id}/cancel\u0026#34;) def cancel_order(order_id: UUID): return order @app.post(\u0026#34;/orders/{order_id}/pay\u0026#34;) def pay_order(order_id: UUID): return order Click to expand and view more 现在有了 API 的基本骨架, 后面将继续实现 incoming payload 和 outgoing response 的验证\nImplementing data validation models with pydantic 这里介绍 data validation 和 marshalling\n\u0026ldquo;Marshalling\u0026rdquo; 指的是将一个内存中的数据结构转换成一种适合存储或通过网络传输的格式. 在 Web API 的上下文中, Marshalling 特指将一个对象转换为一个数据结构(比如 JSON 或 XML). 以便将其序列化为所选的内容类型, 同时明确指定对象属性的映射关系\n点单系统包含了3个shcemas: CreateOrderSchema, GetOrderSchema 和 OrderItemSchema, 可以在oas.yaml查看\n下面使用 Pydantic 实现对应 schema, 可以在 schema.py找到\nPYTHON Collapse Copy from enum import Enum class Size(Enum): small = \u0026#34;small\u0026#34; medium = \u0026#34;medium\u0026#34; big = \u0026#34;big\u0026#34; class StatusEnum(Enum): created = \u0026#34;created\u0026#34; paid = \u0026#34;paid\u0026#34; progress = \u0026#34;progress\u0026#34; cancelled = \u0026#34;cancelled\u0026#34; dispatched = \u0026#34;dispatched\u0026#34; delivered = \u0026#34;delivered\u0026#34; Click to expand and view more 对于只能从特定值中选择的类型, 定义枚举类型 Size 和 StatusEnum\nPYTHON Collapse Copy class OrderItemSchema(BaseModel): product: str size: Size quantity: conint(ge=1, strict=True) | None = 1 Click to expand and view more 将 OrderItemSchema 的属性设置为 conint, 这将强制使用整数值, 并且规定数值要大于等于1, 以及默认值1\nPYTHON Collapse Copy class CreateOrderSchema(BaseModel): order: conlist(OrderItemSchema, min_items=1) class GetOrderSchema(CreateOrderSchema): id: UUID created: datetime status: StatusEnum class GetOrdersSchema(BaseModel): orders: List[GetOrderSchema] Click to expand and view more 使用 pydantic 的 conlist 类型定义了 CreateOrderSchema 的 order 属性, 要求列表至少有一个元素\nValidating request payloads with pydantic 上面实现了模型定义, 现在通过将其声明为视图函数的一个参数来拦截请求负载, 并通过将其类型设置为相关的 Pydantic 模型进行验证\n代码可以在api.py里找到\nPYTHON Collapse Copy from uuid import UUID from starlette.response import Response from starlette import status from orders.app import app from orders.api.schemas import CreateOrderSchema # 导入数据模型 @app.post(\u0026#34;/orders\u0026#34;, status_code=status.HTTP_201_CREATED) def create_order(order_details: CreateOrderSchema): return order @app.get(\u0026#34;/orders/{order_id}\u0026#34;) def get_order(order_id: UUID): return order @app.put(\u0026#34;/orders/{order_id}\u0026#34;) def update_order(order_id: UUID, order_details: CreateOrderSchema): return order Click to expand and view more 如果发送一个有问题的数据(例如移除 product 字段), FastAPI 将会生成一份错误消息.\nJSON Collapse Copy { \u0026#34;detail\u0026#34;: [ { \u0026#34;loc\u0026#34;: [ \u0026#34;body\u0026#34;, \u0026#34;order\u0026#34;, 0, \u0026#34;product\u0026#34; ], \u0026#34;msg\u0026#34;: \u0026#34;field required\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;value_error.missing\u0026#34; } ] } Click to expand and view more 该错误消息使用 JSON Pointer 来指示问题所在, JSON Pointer 是一种语法, 用来表示 JSON 文档中特定值的路径\n例如, loc: /body/order/0/product 大概等同于 Pytohn 中的以下表示法 loc['body']['order'][0]['product']\nbody 指的是请求的主体部分 order 指的是主体中的 order 键 0 指的是 order 列表中的第一个元素 product 指的是这个元素中的 product 键 有时候参数可能是可选的, 但是并不能为 null. 这里使用 Pydantic 的 validator() 装饰器来添加额外的规则\nPYTHON Collapse Copy from pydantic import BaseModel, conint, validator ... class OrderItemSchema(BaseModel): product: int size: Size quantity: conint(ge=1, strict=True) | None = 1 @validator(\u0026#39;quantity\u0026#39;) def quantity_non_nullable(): assert value is not None, \u0026#34;quantity may not be None\u0026#34; return value Click to expand and view more Marshalling and validating response payloads with pydantic 这里定义一下返回类型 api.py\nPYTHON Collapse Copy from starlette.responses import Response from starlette import status from orders.api.schemas import ( GetOrderSchema, CreateOrderSchema, GetOrdersSchema, ) @app.get(\u0026#34;/orders\u0026#34;, response_model=GetOrdersSchema) def get_orders(): return [ order ] @app.post( \u0026#34;/orders\u0026#34;, status_code=status.HTTP_201_CREATED, response_model=GetOrderSchema ) def create_order(order_details: CreateOrderSchema): return order Click to expand and view more 现在, 如果 response payload 中缺少了返回类型需要的属性, FastAPI 则会报错, 如果有多的属性, 则会被去除\nAdding an in-memory list of orders to the API 现在通过一个简单的内存列表来管理订单状态\nPYTHON Collapse Copy import time import uuid from datetime import datetime from uuid import UUID from fastapi import HTTPException from starlette.responses import Response from starlette import status from orders.app import app from orders.api.schemas import GetOrderSchema, CreateOrderSchema ORDERS = [] # in memory list # 获取订单列表 @app.get(\u0026#34;/orders\u0026#34;, respones_model=GetOrderSchema) def get_orders(): return ORDERS # return order list # 创建订单 @app.post( \u0026#34;/orders\u0026#34;, status_code=status.HTTP_201_CREATED, response_model=GetOrderSchema, ) def create_order(order_details: CreateOrderSchema): # convert Pydantic model -\u0026gt; dict: v1 use .dict(); v2 use .model_dump() order = order_details.model_dump() order[\u0026#34;id\u0026#34;] = uuid.uuid4() # 获取订单 @app.get(\u0026#34;/orders/{order_id}\u0026#34;, response_model=GetOrderSchema) def get_order(order_id: UUID): for order in ORDERS: if order[\u0026#34;id\u0026#34;] == order_id: return order raise HTTPException( status_code=404, detail=f\u0026#34;Order with ID {order_id} not found\u0026#34;, ) # 更新订单 @app.put(\u0026#34;/orders/{order_id}\u0026#34;, response_model=GetOrderSchema) def update_order(order_id: UUID, order_details: CreateOrderSchema): for order in ORDERS: if order[\u0026#34;id\u0026#34;] == order_id: order.update(order_details.model_dump()) return order raise HTTPException( status_code=404, detail=f\u0026#34;Order with ID {order_id} not found\u0026#34;, ) # 删除订单 @app.delete( \u0026#34;/orders/{order_id}\u0026#34;, status_code=status.HTTP_204_NO_CONTENT, response_class=Response ) def delete_order(order_id: UUID): for index, order in enumerate(ORDERS): if order[\u0026#34;id\u0026#34;] == order_id: ORDERS.pop(index) return Response(status_code=HTTPStatus.NO_CONTENT.value) raise HTTPException( status_code=404, detail=f\u0026#34;Order with ID {order_id} not found\u0026#34;, ) # 取消订单 @app.post(\u0026#34;/orders/{order_id}/cancel\u0026#34;, response_model=GetOrderSchema) def cancel_order(order_id: UUID): for order in ORDERS: if order[\u0026#34;id\u0026#34;] == order_id: order[\u0026#34;status\u0026#34;] = \u0026#34;cancelled\u0026#34; return order raise HTTPException( status_code=404, detail=f\u0026#34;Order with ID {order_id} not found\u0026#34;, ) # 支付订单 @app.get(\u0026#34;/orders/{order_id}/pay\u0026#34;, response_model=GetOrderSchema) def pay_order(order_id: UUID): for order in ORDERS: if order[\u0026#34;id\u0026#34;] == order_id: order[\u0026#34;status\u0026#34;] = \u0026#34;progress\u0026#34; return order raise HTTPException( status_code=404, detail=f\u0026#34;Order with ID {order_id} not found\u0026#34;\u0026lt;\u0026gt; ) Click to expand and view more Microservice Principles 微服务设计原则: 如何将系统拆分为微服务 service decomposition, 以及如何估计其质量 下面是三个设计原则:\nDatabase-per-service principle 服务独立数据库原则 Loose coupling principle 松耦合原则 Single Responsibility Principle (SRP) 单一职责原则 遵循这些原则将帮助你避免构建一个\u0026quot;分布式单体应用\u0026quot;(distributed monolith)的风险\nData-per-service principle 服务独立数据库原则是指, 每个微服务拥有一系列具体的数据, 并且其他微服务只能通过 API 访问.\n这并不意味着每个微服务都要连接到不同的数据库中, 可以是关系数据库中的不同 tables, 或者非关系数据库中的 collections, 关键是数据被某个服务拥有, 不能被其他服务直接访问.\n例如, 为了计算价格, orders service 从 Production database 中获取每个物品的价格, 它也需要知道用户是否有折扣优惠, 这个需要从 User database 获取. 然而, 不能直接诶访问这两个数据库, order service 需要从 products service 和 users service 获取数据.\nLoose coupling principle 松耦合原则要求在设计服务的时候, 必须清晰的关注分离点, 松耦合的服务不依赖另一个服务的实现细节, 这项原则有两个实际的应用:\n每个服务都可以独立于其他服务工作: 如果一个服务在不调用另一个服务的情况下无法完成一个简单的请求, 那么这两个服务之间没有清晰的关注点分离, 他们应被视为一个整体 每个服务都可以在不影响其他服务工作的情况下进行更新: 如果一个服务的更新需要其他服务, 那么这些服务之间存在紧密耦合, 需要重新设计 例如, 一个基于历史数据计算销售预测的服务(Sales Forecast Service), 以及一个拥有历史销售数据的服务(Historical Data Service), 为了计算预测, 销售服务会调用历史数据服务的API来获取历史数据. 在这种情况下, 销售预测服务在不调用历史数据服务的情况下无法响应任何请求, 因此两个服务之间存在紧密耦合.\n解决方案是重新设计这两个服务, 使它们不相互依赖, 或者将它们合并成一个单一的服务.\nSingle responsibility principle 单一职责原则(SRP)指出, 我们要设计职责少、理想情况下只有一个职责的组件. 当应用于微服务设计架构时, 这意味着我们应努力围绕单一的业务能力或子域来设计服务.\nDecomposing micorservices by business capabilities 下面将 CoffeeMesh 系统根据业务内容分成以下部分\n产品团队对应产品服务 原料团队对应原料服务 销售团队对应销售服务 金融团队对应金融服务 厨房团队对应厨房服务 配送团队对应配送服务 在上面的微服务架构中, 将不同的业务定义为一个微服务, 这样是为了方便, 但并不一定要这样实现\n如上的设计规则, 满足了 SRP 原则, 每个模块都处理自己的数据, 但是这种设计并不满足松耦合原则(loose couping principle), 产品服务需要确定每款产品的库存,由于库存数据在原料服务中, 这就需要依赖原料服务, 而为每个产品都设计一个面向原料服务的 API 显然不太合理.\n因此, 这两个服务应该耦合在一起, 最终的服务结构如下:\nProducts service: Products and Ingredients team Sales service: Sales team Kitchen service: Kitchen team Finance service: Finance team Delivery service: Delivery service Service decomposition by subdomains 通过子领域分解是一种从 领域驱动设计(domain-driven desgin, DDD) 中汲取灵感的方法. 领域驱动设计是一种软件开发方法, 它专注于使用业务用户相同的语言来对业务流程和流向进行建模, 当应用于微服务设计时, DDD 能够帮助定义每个服务的核心职责和边界\n对于 CoffeeMesh 项目, 我们希望根据下单的过程, 以及配送给客户的过程来建模, 将其分解为以下8步:\n当用户登陆网站后, 像用户展示产品列表. 每个产品都表示是否有库存. 用户可以根据是否有库存和价格来排序 用户选择产品后下单 用户为订单付费 一但用户付费, 就将订单细节传递给 kitchen 服务 kitchen 服务根据订单制作咖啡 用户可以查询订单进度 一但订单制作完成, 就安排配送 用户可以追踪无人机的配送进度, 直到配送到用户手中 根据上面步骤, 将模块划分为以下几个子领域 (subdomains)\nProduction Subdomain 产品子领域\n第一个服务用于 CoffeeMesh 产品目录的子域, 这个子域告诉用户哪些产品可用, 哪些不可用. 为此, 产品子域会追踪每种产品和原料的库存\nOrders Subdomain 订单子域\n第二步代表一个允许用户选择产品的子域, 这个子域用于管理订单的声明周期. 该子域拥有用户订单的数据, 并提供一个接口来管理订单和检查其状态. 订单领域还负责第四步的第二部分: 在成功处理付款后, 将订单传递给厨房. 同时也满足了第六步的要求: 允许用户检查其订单状态. 作为订单管理者, 订单子域还会与配送子域协作来安排配送.\nPayments Subdomain 支付子域\n第三步代表一个处理用户支付的子域. 该子域包括用户支付处理的专门逻辑, 包括银行卡验证, 与第三方支付提供商集成, 处理不同支付方式等. 支付子领域拥有与用户支付相关的数据.\nKitchen Subdomain 厨房子域\n第五步代表一个与厨房协作来管理客户订单生产的子域. 厨房的生产系统是全自动的, 厨房子域与厨房系统进行接口交互, 以安排客户订单的生产并追踪其进度.一旦订单生产完成, 厨房子域会通知订单子域, 后者随后安排配送. 厨房子域拥有与客户订单生产相关的数据, 并公开一个接口, 允许我们向厨房发送订单并跟踪其进度. 订单子域通过与厨房子域的接口交互, 来更新订单状态, 以满足第六步的需求.\nDelivery Subdomain 配送子域\n第七步代表一个与自动化配送系统进行接口交互的子域. 该子域包含专门的逻辑, 用于解析客户的地理位置并计算到达他们的最佳路线. 它管理着配送无人机机队并优化配送, 同时拥有与所有配送相关的数据. 订单子域通过与配送子域的接口交互, 来更新客户订单的行程, 以满足第八步的需求.\n通过以上分析, 将 CoffeeMesh 分解为5个子领域, 这些子领域可以被映射为微服务, 每个子领域都封装了定义明确, 职责清晰且拥有自己的逻辑区域. 领域驱动设计的微服务也满足了之前的微服务设计原则: 所有这些子域都可以在不依赖其他微服务的情况下执行其核心任务, 因此是松耦合的; 每个服务都拥有自己的数据, 因此符合服务独立数据库原则; 最后, 每个服务都在一个定义狭窄的子域内执行任务, 这符合单一职责原则.\nWrapping Up 上面介绍了微服务的概念, 并通过一个 CoffeeMesh 的项目解释了如何将其分解(decompose)为微服务架构, 分别通过业务分解和通过子领域分解, 以及设计微服务的3条原则:\nDatabase-per-service principle 数据库独享原则 Loose coupling principle 松耦合原则 Single responsibility principle 单一责任原则 ","title":"Microservice with FastAPI"},{"link":"/posts/python-generics/","text":"本篇文件介绍 Python 中的 泛型(Generics)\nIntro 在没有泛型的情况下, 会遇上以下几个问题:\n难以表达意图\n假设你编写了一个函数, 它接受一个列表, 并返回列表中的第一个元素. 在不使用类型提示的情况下, 这个函数可以处理任何类型的列表, 但我们无法在函数签名中表达\u0026quot;返回的元素的类型与列表中的元素类型相同\u0026quot;这个意图\nPYTHON Collapse Copy def get_first_element(items): return items[0] Click to expand and view more 丧失类型信息\n如果使用类型提示, 可能会像下面这样写, 但这样会丢失类型信息. list[Any] 表示可以接收任何类型的列表, 但 -\u0026gt; Any 意味着不知道返回的元素类型是什么, 这使得 mypy 等静态类型检测工具无法追踪类型, 降低了代码的可读性和安全性\nPYTHON Collapse Copy from typing import Any def get_first_element(items: list[Any]) -\u0026gt; Any: return items[0] # 调用时, 类型检查工具无法得知 first_str 的类型 first_str = get_first_element([\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]) Click to expand and view more 代码重复\n如果为每种可能的类型都编写一个单独的函数, 则会导致代码重复\nPYTHON Collapse Copy def get_first_int(items: list[int]) -\u0026gt; int: return items[0] def get_first_str(items: list[str]) -\u0026gt; str: return items[0] Click to expand and view more 通过引入 类型变量 (TypeVar) 来解决问题, 类型变量就像一个占位符, 代表在未来某时刻会被具体指定的类型\nPYTHON Collapse Copy from typing import TypeVar T = TypeVar(\u0026#34;T\u0026#34;) def get_first_element(items: list[T]) -\u0026gt; T: return items[0] # 现在, 类型检查工具可以正确推断出类型 first_str: str = get_first_element([\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]) first_int: int = get_first_element([1, 2, 3]) Click to expand and view more T = TypeVar('T') 定义了一个名为 T 的类型变量, 这里 T 只是一个约定俗成的名字, 也可以使用其他字母 items: list[T] 表示 items 是一个列表, 其内部元素类型是 T -\u0026gt; T: 返回类型也是 T 当使用 [\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;] 调用函数时, 静态类型检查器会推断出 T 是 str, 返回类型为 str 当使用 [1, 2, 3] 调用函数时, T 被推断为 int 注意: 这个函数假设列表非空, 如果传入空列表会抛出 IndexError\nGeneric Class 除了函数, 泛型也常用于定义泛型类\nPYTHON Collapse Copy from typing import TypeVar, Generic T = TypeVar(\u0026#34;T\u0026#34;) class Box(Generic[T]): def __init__(self, items: list[T]): self._items = items def get(self) -\u0026gt; T: return self._items[0] def add(self, item: T) -\u0026gt; None: self._items.append(item) # 创建一个存储字符串的 Box string_box = Box([\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;]) item_str = string_box.get() # str string_box.add(\u0026#34;cherry\u0026#34;) # 创建一个存储整数的 Box int_box = Box([10, 20]) item_int = int_box.get() # int int_box.add(30) Click to expand and view more TypeVar 定义类型变量: 相当于一个占位符, 将来由使用者指定具体类型 Generic 定义泛型类或泛型接口: 使这个类在类型检查器眼中变成一个模板 Advanced Usage 简单介绍一下泛型的一些进阶用法\n多类型参数\nPYTHON Collapse Copy from typing import TypeVar, Generic K = TypeVar(\u0026#34;K\u0026#34;) V = TypeVar(\u0026#34;V\u0026#34;) class Pair(Generic[K, V]): def __init__(self, key: K, value: V): self.key = key self.value = value def get_key(self) -\u0026gt; K: return self.key def get_value(self) -\u0026gt; V: return self.value # 使用示例 pair = Pair(\u0026#34;name\u0026#34;, 25) # Pair[str, int] Click to expand and view more 支持多个类型变量, 类似 dict[K, V] 的结构\n类型约束 (Constraints)\n有时候可能希望泛型只能是某些特定类型\nPYTHON Collapse Copy from typing import TypeVar Number = TypeVar(\u0026#39;Number\u0026#39;, int, float) def add(a: Number, b: Number) -\u0026gt; Number: return a + b # 正确使用 result1 = add(1, 2) # int result2 = add(1.5, 2.3) # float # 错误使用: mypy 会报错 # result3 = add(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;) # str 不被允许 Click to expand and view more Number 只能为 int 或 float, 传入其他类型, 类型检查工具会报错\n协变与逆变 (Covariance/Contravariance)\n在泛型类型中, 可以控制类型变量的变型关系\nPYTHON Collapse Copy from typing import Generic, TypeVar T_co = TypeVar(\u0026#34;T_co\u0026#34;, covariant=True) # 协变 T_contra = TypeVar(\u0026#34;T_contra\u0026#34;, contravariant=True) # 逆变 class Producer(Generic[T_co]): \u0026#34;\u0026#34;\u0026#34;只产出 T_co 类型的数据 (协变)\u0026#34;\u0026#34;\u0026#34; def __init__(self, value: T_co): self._value = value def get(self) -\u0026gt; T_co: return self._value class Consumer(Generic[T_contra]): \u0026#34;\u0026#34;\u0026#34;只消费 T_contra 类型的数据 (逆变)\u0026#34;\u0026#34;\u0026#34; def __init__(self): pass def consume(self, value: T_contra) -\u0026gt; None: print(f\u0026#34;Consuming: {value}\u0026#34;) Click to expand and view more 协变 (covariant): 如果 A 是 B 的子类型, 那么 Generic[A] 也是 Generic[B] 的子类型. 适用于只产出数据的场景 逆变 (contravariant): 如果 A 是 B 的子类型, 那么 Generic[B] 是 Generic[A] 的子类型. 适用于只消费数据的场景 这主要用于接口设计中的读/写分离 泛型与 Protocol\nProtocol 允许定义泛型接口 (duck typing)\nPYTHON Collapse Copy from typing import Protocol, TypeVar T = TypeVar(\u0026#39;T\u0026#39;) class SupportsLen(Protocol): def __len__(self) -\u0026gt; int: ... def total_length(items: list[SupportsLen]) -\u0026gt; int: return sum(len(x) for x in items) # 使用示例 result = total_length([\u0026#34;hello\u0026#34;, [1, 2, 3], {\u0026#34;a\u0026#34;: 1}]) # 可以接受任何有 __len__ 方法的对象 Click to expand and view more 任何实现了__len__方法的对象都能被接受, 比继承更加灵活\n泛型在标准库中的使用\n集合类: list[T], dict[K, V], set[T] 迭代器: Iterator[T], Iterable[T] 函数工具: Callable[[T1, T2], R] 上下文管理器: ContextManager[T] PYTHON Collapse Copy from typing import Callable def operate(a: int, b: int, func: Callable[[int, int], int]) -\u0026gt; int: return func(a, b) # 使用示例 def add(x: int, y: int) -\u0026gt; int: return x + y def multiply(x: int, y: int) -\u0026gt; int: return x * y result1 = operate(5, 3, add) # 8 result2 = operate(5, 3, multiply) # 15 Click to expand and view more Wrapping Up 泛型是 Python 类型提示系统中一个非常强大的工具, 它通过类型变量帮助我们编写更加灵活、安全且可维护的代码.\n它虽然不会影响程序的运行时行为 (类型信息在运行时会被擦除), 但它为静态类型分析提供了必要的信息, 使得代码意图更加清晰, 并且能在早期发现类型错误.\nPython 的泛型是类型提示系统的一部分, 和 C++/Java 的编译期泛型不同, 它的作用主要是:\n帮助 IDE 和类型检查工具发现类型错误 提升代码可读性和可维护性 提供更精确的 API 类型签名 支持更好的代码重用和抽象 ","title":"Python Generics"},{"link":"/posts/python-strings/","text":"这篇文章总结一下 Python 中字符串的类型\nUnicode String 字符串 u 在 Python3 中是多余的, 因为所有的普通字符串默认都是 Unicode, 但在 Python2 中, u 用来显示的表示 Unicode 字符串, 现在保留这个是为了向后兼容\nFromatted String 格式化字符串 f 前缀用于创建格式化字符串, 这是最常见的字符串格式方法, 运行在字符串中嵌入表达式, 在求值时转换为普通的 str\nPYTHON Collapse Copy name = \u0026#34;World\u0026#34; greeting = f\u0026#34;Hello, {name}!\u0026#34; # 结果: \u0026#34;Hello, World!\u0026#34; Click to expand and view more Raw String 原始字符串 r 前缀用于创建原始字符串, 会忽略反斜杠 \\ 的转义功能, 在编写文件路径或正则表达式的时候非常有用, 可以避免大量的反斜杠转义\nPYTHON Collapse Copy path = r\u0026#34;C:\\Users\\Documents\u0026#34; # 单个反斜杠 \u0026#39; regex = r\u0026#34;\\bword\\b\u0026#34; # \\b 不会被转义 Click to expand and view more Bytes String 字节串 b 前缀用于创建字节串字面量, 表示一个不可变的字节序列, 而不是 Unicode 文本, 字节串主要用于二进制数据, 例如图像文件、网络数据或压缩文件等\nPYTHON Collapse Copy binary_data = b\u0026#34;Hello\u0026#34; # 存储的是 ASCII 编码的字节 Click to expand and view more Template String 模板字符串 t 前缀用于创建模板字符串, 这是 Python 3.14 引入的新功能, 由 PEP 750 通过.\n不同于 f-string, t-string 不会立即求值为 str, 而是求值为一个 Template 对象, 这为开发者提供了将在将字符串和插值组合之前进行处理(和安全转义)的能力\nPYTHON Collapse Copy from string.templatelib import Template template = t\u0026#34;Hello, {name}\u0026#34; # template 是一个 Template 对象 Click to expand and view more 组合使用 前缀 含义 用途 f 格式化 嵌入变量和表达式 r 原始 忽略反斜杠转义 b 字节 处理二进制数据 t 模板 在组合前处理插值 u Unicode Python 3 中默认开启 fr / rf 格式化+原始 在正则表达式中嵌入变量 br / rb 字节+原始 忽略二进制数据中的转义 tr / rb 模板+原始 模板中处理原始文本 ","title":"Python Strings"},{"link":"/posts/fastapi-response-model/","text":"本篇文章介绍 FastAPI 的返回类型 response model\n可以在返回函数的类型注解中声明该接口的响应数据类型\n类型注解的用法和输入数据参数一样, 可以使用:\nPydantic 模型 list 列表 dict 字典 scalar 标量值 (int, bool \u0026hellip;) PYTHON Collapse Copy @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item) -\u0026gt; Item: ... @app.get(\u0026#34;/items/\u0026#34;) async def read_items() -\u0026gt; list[Item]: ... Click to expand and view more FastAPI 会使用返回类型完成一下事情:\n验证返回类型 如果返回的数据无效, 说明业务代码有问题, FastAPI 会返回服务器错误, 而不是把数据发给客户端\n在 OpenAPI 中为响应添加 JSON Schema 用于自动生成接口文档, 自动生成客户端代码\n最重要的是 它会限制并过滤出数据, 只保留返回类型中定义的字段\nresponse_model Parameter 有时候可能需要返回的数据和类型注解不完全一致, 例如:\n可能想返回字典或数据库对象, 但声明的响应类型为 Pydantic 模型 这样 Pydantic 会做数据文档、验证等工作, 即使返回的是字典或 ORM 对象 如果直接用返回类型注解, 编辑器会提示类型不匹配的错误\n这种情况下, 可以用路径装饰器的 response_model 参数来声明响应类型, 而不是用返回类型注解\nPYTHON Collapse Copy class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list[str] = [] @app.post(\u0026#34;/items/\u0026#34;, response_model=Item) async def create_item(item: Item) -\u0026gt; Any: return item @app.get(\u0026#34;/items/\u0026#34;, response_model=list[Item]) async def read_items() -\u0026gt; Any: return [ {\u0026#34;name\u0026#34;: \u0026#34;Portal Gun\u0026#34;, \u0026#34;price\u0026#34;: 42.0}, {\u0026#34;name\u0026#34;: \u0026#34;Plumbus\u0026#34;, \u0026#34;price\u0026#34;: 32.0}, ] Click to expand and view more 注意:\nresponse_model 是装饰器(get、post 等方法)的参数, 不是函数的参数 接收的类型和 Pydantic 字段定义一样, 可以是单个模型, 也可以是模型列表等 FastAPI 用其做数据库验证、文档生成、以及过滤输出数据 如果使用 mypy 之类做 static type check, 可以声明函数返回类型为 Any\nresponse_model 优先级 如果同时声明了 response_model 和返回类型, 则 response_model 会优先生效\n如果想要禁用响应模型, 可以设置 response_model=None (用于一些非 Pydantic 类型的返回值) Return the Same Input Data 返回相同数据数据 很多情况下, 希望模型返回与输入模型相同的数据\n这式, 可以在路径函数中直接声明 response_model=YourModel, FastAPI 会自动处理\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserIn(BaseModel): username: str password: str email: EmailStr full_name: str | None = None # Don\u0026#39;t do this in production! @app.post(\u0026#34;/user/\u0026#34;) async def create_user(user: UserIn) -\u0026gt; UserIn: return user Click to expand and view more 不要在生产环境中以明文形式存储用户密码, 也不要像这样直接返回密码\nAdd an Output Model 添加输出模型 我们可以改成: 输入模型包含明文密码, 输出模型不含\nPYTHON Collapse Copy from typing import Any from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() # Input model class UserIn(BaseModel): username: str password: str email: EmailStr full_name: str | None = None # Output model class UserOut(BaseModel): username: str email: EmailStr full_name: str | None = None @app.post(\u0026#34;/user/\u0026#34;, response_model=UserOut) # output async def create_user(user: UserIn) -\u0026gt; Any: return user # like input Click to expand and view more 这样, 即使路径操作函数返回的对象中包含该字段, FastAPI 也会按照 response_model=UserOut 来过滤密码\nReturn Type and Data Filtering 返回类型与数据过滤 延续上面的例子, 希望函数的类型注解和实际返回值不同:\n函数返回的对象可能包含更多数据, 但响应中只保留输出模型声明的字段\n之前由于类不同, 只能用 response_model, 这样就失去了编辑器和类型检查对返回值的检查\n大多数情况下, 我们只是想去掉或过滤掉部分数据, 这时可以用 类继承(classes and inheritance) 来兼顾类型注解和数据过滤\nPYTHON Collapse Copy class BaseUser(BaseModel): username: str email: EmailStr full_name: str | None = None class UserIn(BaseUser): password: str @app.post(\u0026#34;/user/\u0026#34;) async def create_user(user: UserIn) -\u0026gt; BaseUser: return user Click to expand and view more 通过这种方式:\nType Annotations and Testing 编辑器和类型检查工具支持: UserIn 是 BaseUser 的子类, 返回 UserIn 实例完全符合 BaseUser 类型要求 FastAPI Data Filtering 数据过滤: 响应中会自动去掉 password 字段, 只保留 BaseUser 中声明的字段 Other Return Type Annotations 其他类型注解 有些时候, 返回的内容不是有效的 Pydantic 字段, 但在函数中添加了注解, 为了获取工具支持\nReturn a response directly 直接返回响应 最常见的就是直接返回一个 Resposne\nPYTHON Collapse Copy from fastapi import FastAPI, Response from fastapi.resposnes import JSONResponse, RedirectResponse app = FastAPI() @app.get(\u0026#34;/portal\u0026#34;) async def get_protal(teleport: bool = False) -\u0026gt; Response: if teleport: return RedirectResponse(url=\u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34;) return JSONResponse(content={\u0026#34;message\u0026#34;: \u0026#34;Here\u0026#39;s your interdimensional portal.\u0026#34;}) Click to expand and view more 这种简单情况由 FastAPI 自动处理, 因为返回类型注解是 Response 类\n开发工具也能正常工作, 因为 RedirectResponse 和 JSONResponse 都是 Response 的子类, 所以类型注解是正确的\nInvalid return type annotations 无效的类型注解 但是, 当返回一些其他任意对象(不是有效的 Pydantic 类型, 例如数据库对象)并在函数中这样注解时, FastAPI 会尝试从该类型注解创建一个 Pydantic 响应模型, 然后会失败\n如果使用了联合模型, 其中有一个或多个不是有效的 Pydantic 类型, 同样会失败\nPYTHON Collapse Copy from fastapi import FastAPI, Response from fastapi.responses import RedirectResponse app = FastAPI() @app.get(\u0026#34;/portal\u0026#34;) async def get_portal(teleport: bool = False) -\u0026gt; Response | dict: if teleport: return RedirectResponse(url=\u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34;) return {\u0026#34;message\u0026#34;: \u0026#34;Here\u0026#39;s your interdimensional portal.\u0026#34;} Click to expand and view more 这会失败是因为类型注解不是单一的 Pydantic 类型, 也不是单一的 Response 类或子类, 而是 Response 和 dict 之间的联合类型\nDisable response Model 禁用响应类型 如果不希望 FastAPI 执行默认的数据验证、文档生成、过滤等操作, 但是又想在函数中保留返回类型注解, 以获得编辑器和类型检查工具的支持, 这种情况下设置 response_model=None 来禁用响应生成\nPYTHON Collapse Copy from fastapi import FastAPI, Response from fastapi.response import RedirectResponse app = FastAPI() @app.get(\u0026#34;/portal\u0026#34;, response_model=None) async def get_protal(teleport: bool = False) -\u0026gt; Response | dict: if teleport: return RedirectResponse(url=\u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34;) return JSONResponse(content={\u0026#34;message\u0026#34;: \u0026#34;Here\u0026#39;s your interdimensional portal.\u0026#34;}) Click to expand and view more Response Model Encoding Parameters 响应模型编码参数 响应模型可能有默认值\nPYTHON Collapse Copy class Item(BaseModel): name: str description: str | None = None price: float tax: float = 10.5 tags: list[str] = [] Click to expand and view more 例如, 在 NoSQL 数据库中哟许多可选属性的模型, 但不想发送默认值的很长的 JSON 响应\n可以使用 path operation operator 的 response_model_exclude_mode 参数来去除默认值\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;, response_model=Item, response_model_exclude_unset=True) async def read_item(item_id: str): return items[item_id] Click to expand and view more description: str | None = None 默认值为 None tax: float = 10.5 的默认值为 10.5 tags: List[str] = [] 的默认值是空列表 [] 此时, 如果向该路径发送 ID 为 foo 的项目请求\nYAML Collapse Copy \u0026#34;foo\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;price\u0026#34;: 50.2} Click to expand and view more 响应将是\nYAML Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;price\u0026#34;: 50.2, } Click to expand and view more response_model_include 和 response_model_exclude 也可以使用 path operation parameter 中的 response_model_include 和 response_model_exclude, 他们接受一个包含属性名称字符串的 set, 用于包含(省略其余部分)或排除(包含其余部分)\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float = 10.5 items = { \u0026#34;foo\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;price\u0026#34;: 50.2}, \u0026#34;bar\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Bar\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The Bar fighters\u0026#34;, \u0026#34;price\u0026#34;: 62, \u0026#34;tax\u0026#34;: 20.2}, \u0026#34;baz\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Baz\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;There goes my baz\u0026#34;, \u0026#34;price\u0026#34;: 50.2, \u0026#34;tax\u0026#34;: 10.5, }, } @app.get( \u0026#34;/items/{item_id}/name\u0026#34;, response_model=Item, response_model_include={\u0026#34;name\u0026#34;, \u0026#34;description\u0026#34;}, # 包含 ) async def read_item_name(item_id: str): return items[item_id] @app.get( \u0026#34;/items/{item_id}/public\u0026#34;, response_model=Item, response_model_exclude={\u0026#34;tax\u0026#34;}, # 排除 ) async def read_item_public_data(item_id: str): return items[item_id] Click to expand and view more 虽然可以通过上述方法自定义返回参数包含哪些, 但还是建议使用多个类来实现该功能, 而不这些参数\n这是因为, 即使使用 response_model_include 或 response_model_exclude 来省略某些属性, 在应用程序的 OpenAPI 中生成的 JSON Schema 仍将是完整模型的 Schema\n这对于 response_model_by_alias 也是一样的\nUsing list instead of sets 如果忘记使用集和而使用元组或列表, FastAPI 仍会将其转换为集和, 确保正常工作\nPYTHON Collapse Copy @app.get( \u0026#34;/items/{item_id}/name\u0026#34;, response_model=Item, response_model_include=[\u0026#34;name\u0026#34;, \u0026#34;description\u0026#34;], # 使用列表 ) async def read_item_name(item_id: str): return items[item_id] @app.get( \u0026#34;/items/{item_id}/public\u0026#34;, response_model=Item, response_model_exclude=[\u0026#34;tax\u0026#34;], # 使用列表 ) async def read_item_public_data(item_id: str): return items[item_id] Click to expand and view more Response Status Code 响应状态码 就像可以指定响应模型一样, 也可以在任何路径操作中使用 status_code 参数声明用于响应:\n@app.get() @app.post() @app.put() @app.delete() PYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.post(\u0026#34;/items/\u0026#34;, status_code=201) async def create_item(name: str): return {\u0026#34;name\u0026#34;: name} Click to expand and view more status_code 是\u0026quot;装饰器\u0026quot;方法的一个参数, 而不是你的路径操作函数 path operation function 的参数\nstatus_code 参数接收一个表示 HTTP 状态码的数字, 也可以接收一个 IntEnum, 比如 Python 中的 http.HTTPStatus\n将在响应中返回该状态码 并在 OpenAPI 模式中也如此记录 About HTTP status codes 在 HTTP 协议中, 会在响应中发送一个3位数的数字状态码\n这些状态码又一个相关联的名称便于识别, 但重要的是数字本身\n100~199: 用于\u0026quot;信息\u0026quot;, 很少会直接使用它们, 这些状态码的响应不能有响应体 200~299: 用于\u0026quot;成功\u0026quot;的响应, 这些是最常用的 200 的默认的\u0026quot;成功\u0026quot;响应, 表示一切 OK 201 表示已创建, 通常在数据库中创建新记录后使用 204 表示无内容, 当没有内容返回给客户端时使用此响应, 因此不能有响应体 300~399: 用于\u0026quot;重定向\u0026quot;, 这些状态码的响应可能有也可能没有响应体. 但 304 (未修改) 除外, 它必须没有响应体 400~499: 用于\u0026quot;客户端错误\u0026quot;响应, 404 用于\u0026quot;未找到\u0026quot;的响应 400 客户端通用错误 500~599: 用于服务器错误, 几乎从不直接使用它们. 当的应用代码或服务器的某个部分出错时, 它会自动返回这些状态码之一 要了解更多关于每个状态码的信息以及哪个代码用于什么目的，请查阅 MDN 关于 HTTP 状态码的文档\nShortcut to remember the names 除了直接使用数字外, 还可以使用 fastapi.status 中的便捷变量\nPYTHON Collapse Copy from fastapi import FastAPI, status app = FastAPI() @app.post(\u0026#34;/items/\u0026#34;, status_code=status.HTTP_201_CREATED) async def create_item(name: str): return {\u0026#34;name\u0026#34;: name} Click to expand and view more 这只是一直便利, 都是一样的树枝, 但这样可以使用编辑器的自动补全功能\n也可以使用 from starlette import status\n","title":"FastAPI Response Model"},{"link":"/posts/fastapi-cookie-and-header-parameters/","text":"这篇文章介绍 Fastapi 的 Cookie 和 Header 参数\nCookie Parameters 通过定义 Query 和 Path 参数一样定义 Cookie 参数\nPYTHON Collapse Copy from typing Annotated from fastapi import Cookie, FastAPI app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(ads_id: Annotated[str | None, Cookie()] = None): return {\u0026#34;ads_id\u0026#34;: ads_id} Click to expand and view more Cookie Parameters Models 如果有一组相关的 cookies, 可以使用 Pydantic model 来声明.\n这样可以在多个部分复用这个模型, 同时还能一次性为所有参数声明验证规则和元数据.\n下面使用 Pydantic 模型定义 Cookies, 然后将参数声明为 Cookie\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Cookie from pydantic import BaseModel app = FastAPI() class Cookie(BaseModel): session_id: str fatebook_tracker: str | None = None googall_tracker: str | None = None @app.get(\u0026#34;/items/\u0026#34;) async def read_items(cookies: Annotated[Cookies, Cookie()]): return cookies Click to expand and view more Forbid Extra Cookies 禁止额外的Cookie 在某些场景下(虽然并不常见), 可能希望限制 API 只能接收特定的 Cookie. 这样, API 就可以\u0026quot;自己\u0026quot;管理 Cookie 同意策略了.\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Cookie from pydantic import BaseModel app = FastAPI() class Cookies(BaseModel): model_config = {\u0026#34;extra\u0026#34;: \u0026#34;forbid\u0026#34;} # forbid extra cookies session_id: str fatebook_tracker: str | None = None googall_tracker: str | None = None @app.get(\u0026#34;/items/\u0026#34;) async def read_items(cookies: Annotated[Cookies, Cookie()]): return cookies Click to expand and view more 这样, 如果客户端发送额外的 cookies, 则会收到一个错误响应. 例如, 客户端发送了 santa_tracker 这个额外 Cookie\nPYTHON Collapse Copy santa_tracker = good-list-please Click to expand and view more 将会收到如下错误响应\nJSON Collapse Copy { \u0026#34;detail\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;extra_forbidden\u0026#34;, \u0026#34;loc\u0026#34;: [\u0026#34;cookie\u0026#34;, \u0026#34;santa_tracker\u0026#34;], \u0026#34;msg\u0026#34;: \u0026#34;Extra inputs are not permitted\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;good-list-please\u0026#34;, } ] } Click to expand and view more Header Parameters 同样的, 通过定义 Query 和 Path 参数一样定义 Header 参数\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Header app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(user_agent: Annotated[str | None, Header()] = None): return {\u0026#34;User-Agent\u0026#34;: user_agent} Click to expand and view more Automatic conversoin 自动转换 Header 拥有一些在 Path, Query 和 Cookie 上的额外功能\n大多数标准的 header 都通过一个连字符(hyphen character), 也称为减号(minus symbol)分开, 但是变量 user-agent 这样在 Python 中是不合法的. 所以, 默认情况下 Header 会将参数名中的 hypen(-) 使用下划线 undersocre(_) 替换.\n同样的, HTTP headers 是不区分大小写的, 所以可以使用标准的 Python 风格 (snake_case). 因此可以使用 user_agent 在 Python 代码中, 而不需要首字母大写成 User_Agent.\n如果想要禁止这种自动转换, 需要将 Header 的参数 convert_undersocres 设置为 False\nPYTHON Collapse Copy from typing import Typing from fastapi import FastAPI, Header app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items( strange_header: Annotated[str | None, Header(convert_undersocres=False)] = None ): return {\u0026#34;strange_header\u0026#34;: strange_header} Click to expand and view more Duplicate headers 重复请求头 一个请求中可能会收到重复的 headers, 也就是同一个 header 有多个值.\n可以在类型声明中使用 list 来处理这种情况, 这样会得到一个 Python 列表.\n例如要声明一个可能多次出现的 X-Token 头部, 可以这样写:\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Header app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(x_token: Annotated[list[str] | None, Header()] = None): return {\u0026#34;X-Token values\u0026#34;: x_token} Click to expand and view more 如果向该接口发送两个这样的 HTTP headers\nPLAINTEXT Collapse Copy X-Token: foo X-Token: bar Click to expand and view more 返回类似这样\nJSON Collapse Copy { \u0026#34;X-Token values\u0026#34;: [ \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34; ] } Click to expand and view more Header parameters models 请求头参数模型 同样可以使用 Pydantic model 定义 Header Parameters, 这样可以在多个地方复用模型, 还能一次性为所有参数声明规则和元数据\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Header from pydantic import BaseModel app = FastAPI() class CommonHeaders(BaseModel): host: str save_data: str if_modified_since: str | None = None traceparent: str | None = None x_tag: list[str] = [] @app.get(\u0026#34;/items\u0026#34;) async def read_items(headers: Annotated[CommonHeaders, Header()]): return headers Click to expand and view more Forbid extra headers 禁止额外请求头 同样也可以禁止额外的 headers\nPYTHON Collapse Copy class CommonHeaders(BaseModel): model_config = {\u0026#34;extra\u0026#34;: \u0026#34;forbid\u0026#34;} # 禁止额外字段 ... Click to expand and view more 如果客户端尝试发送额外的 Header，将会收到错误响应. 例如, 客户端发送了 tool 这个额外 Header\nPLAINTEXT Collapse Copy tool: plumbus Click to expand and view more 将会收到如下错误响应\nJSON Collapse Copy { \u0026#34;detail\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;extra_forbidden\u0026#34;, \u0026#34;loc\u0026#34;: [\u0026#34;header\u0026#34;, \u0026#34;tool\u0026#34;], \u0026#34;msg\u0026#34;: \u0026#34;Extra inputs are not permitted\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;plumbus\u0026#34; } ] } Click to expand and view more Disable convert undersocres 禁止转换下划线 同样可以禁用自动下换线转换\n与普通的 Header 参数一样, 如果参数名中包含下划线 undersocre (_), FastAPI 会自动将其转换为连字符 hypens (-)\nPYTHON Collapse Copy async def read_items( headers: Annotated[CommonHeaders, Header(convert_underscores=False)], ): ... Click to expand and view more 在将 convert_underscores 设置为 False 前, 注意有些 HTTP 代理和服务器不允许带下划线的头部字段\n","title":"Fastapi Cookie and Header Parameters"},{"link":"/posts/python-function-parameters/","text":"今天是周日, 简单写点吧, 简单总结一下 Python 中函数参数\nPython Function Parameters Python 函数参数机制非常灵活丰富, 理解各种参数类型及其用法对于写出优雅、易维护的代码非常重要. 本文将介绍 Python 中函数参数的种类与用法, 并详细讲解 Python 3.8 引入的参数分隔符 / 和 *, 帮助你更好地设计函数接口.\n1. Postional Arguments 位置参数 函数定义中最常见的参数, 调用时按顺序传入值\nPYTHON Collapse Copy def greet(name, age): print(f\u0026#34;Hello, {name}. You are {age} years old.\u0026#34;) greet(\u0026#34;Alice\u0026#34;, 30) # Hello, Alice. You are 30 years old. Click to expand and view more 2. Keyword Arguments 关键字参数 调用时以 key=value 形式传入, 顺序可变\nPYTHON Collapse Copy greet(age=30, name=\u0026#34;Alice\u0026#34;) Click to expand and view more 3. Default Arguments 默认参数 定义函数时给参数赋默认值, 调用时可省略\nPYTHON Collapse Copy def greet(name, age=20): print(f\u0026#34;Hello, {name}. You are {age} years old.\u0026#34;) greet(\u0026#34;Bob\u0026#34;) # 使用默认年龄20 greet(\u0026#34;Bob\u0026#34;, 25) # 指定年龄 Click to expand and view more 注意: 使用默认参数尽量不要使用可变类型(mutable), 例如列表, 因为默认参数是存储在函数中的, 而非函数实例中, 多次调用会改变默认值的内容. PYTHON Collapse Copy def greet(names: list[str] = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;]): ... Click to expand and view more 若希望使用默认值, 建议使用下面这种方法\nPYTHON Collapse Copy def greet(names: list[str] | None = None): if not names: names = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;] ... Click to expand and view more 同样的, 默认值参数如果为一个表达式, 则是在定义时求值, 而非运行改函数时才求值\n4. *args 可变位置参数 用于接收任意数量的位置参数, 形成元组\nPYTHON Collapse Copy def sum_all(*args): return sum(args) sum_all(1, 2, 3) # 6 sum_all() # 0 Click to expand and view more 5. **kwargs 可变关键字参数 用于接收任意数量的关键字参数, 形成字典\nPYTHON Collapse Copy def print_info(**kwargs): for k, v in kwargs.items(): print(f\u0026#34;{k} = {v}\u0026#34;) print_info(name=\u0026#34;Alice\u0026#34;, age=30) Click to expand and view more / 和 * 的用法 Python 3.8 引入了两种新的函数参数分隔符: 斜杠 /(forward slash) 和 星号 *(asterisk) 符号, 用于更精细地控制参数的调用方式\nPostional-only parameters (/) 斜杠前的参数必须通过位置传递, 不能用关键字传递\nPYTHON Collapse Copy def func(a, b, /, c, d): print(a, b, c, d) Click to expand and view more 调用时\nPYTHON Collapse Copy func(1, 2, c=3, d=4) # 正确 func(1, 2, 3, 4) # 也正确 func(a=1, b=2, c=3, d=4) # 错误，a 和 b 不能用关键字传递 Click to expand and view more 用途:\n保护函数接口的参数顺序, 避免调用者用关键字修改参数值 兼容一些C语言扩展模块的调用约定 明确哪些参数是\u0026quot;位置专用\u0026quot;的 Keyword-only parameters (*) 星号后的参数必须用关键字传递, 不能用位置传递\nPYTHON Collapse Copy def func(a, b, *, c, d): print(a, b, c, d) Click to expand and view more 调用时\nPYTHON Collapse Copy func(1, 2, c=3, d=4) # 正确 func(1, 2, 3, 4) # 错误，c 和 d 只能用关键字传递 Click to expand and view more 用途:\n强制调用者明确指定关键字参数, 提高代码可读性 避免参数顺序引起的混淆 Use both / and * / 和 * 也可以同时使用\nPYTHON Collapse Copy def func(a, b, /, c, d, *, e, f): print(a, b, c, d, e, f) Click to expand and view more 调用时\na 和 b 只能用位置参数传递 c 和 d 都可以 e 和 f 只能用关键字参数传递 ","title":"Python Function Parameters"},{"link":"/posts/fastapi-body-advanced-uses/","text":"本篇文章介绍 FastAPI Request Body 的进阶用法\nBody - Multiple Parameters 首先, 可以将Path, Query 和 request body 参数声明自由的写在一起\n对于 request body 参数可以是可选的, 并且可设置为默认的 None\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Path from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item( item_id: Annotated[int, Path(title=\u0026#34;The ID of the item to get\u0026#34;, ge=0, le=1000)], # Path q: str | None = None, # Query item: Item | None = None, # body ): results = {\u0026#34;item_id\u0026#34;: item_id} if q: results.update({\u0026#34;q\u0026#34;: q}) if item: results.update({\u0026#34;item\u0026#34;: item}) return results Click to expand and view more Multiple body parameters 多参数请求体 在上面例子中, FastAPI 期望一个包含 Item 属性的 JSON body, 例如\nJSON Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 } Click to expand and view more 但也可以声明多个body parameters, 例如 item 和 user\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None class User(BaseModel): username: str full_name: str | None = None @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item(item_id: int, item: Item, user: User): results = {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;item\u0026#34;: item, \u0026#34;user\u0026#34;: user} return results Click to expand and view more 在这种情况下, FastAPI 会检测到函数有一个 body parameter, 这时会使用中的参数名作为请求体的 key(field names), 并期望如下结构:\nJSON Collapse Copy { \u0026#34;item\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 }, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;dave\u0026#34;, \u0026#34;full_name\u0026#34;: \u0026#34;Dave Grohl\u0026#34; } } Click to expand and view more FastAPI 会自动进行请求解析、类型转换、验证, 并在 OpenAPI 文档中反映出这种结构\nSingular values in body 请求体中的单个参数 和 Query 、Path 可以添加额外信息一样, FastAPI 也提供了 Body 来对请求参数添加额外信息\n例如, 除了 item 和 user 外, 还想在请求体中添加一个 importance 字段, 如果直接写 importance: int 则会被当作查询参数\n可以通过 Body() 明确告诉 FastAPI 把它当作一个 body parameter\nPYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item( item_id: int, item: Item, user: User, importance: Annotated[int, Body()] ): ... Click to expand and view more 这种情况下, FastAPI 会期待如下的请求体:\nJSON Collapse Copy { \u0026#34;item\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 }, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;dave\u0026#34;, \u0026#34;full_name\u0026#34;: \u0026#34;Dave Grohl\u0026#34; }, \u0026#34;importance\u0026#34;: 5 } Click to expand and view more 它同样会自动转换数据类型、校验并生成文档\nMultiple body params and query 多个请求体参数和查询参数 也可以在多请求体参数的基础上, 添加查询参数\nPYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item( *, # 强制 key=value item_id: int, item: Item, user: User, importance: Annotated[int, Body(gt=0)], q: str | None = None, # 查询参数 ): ... Click to expand and view more Embed a single body parameter 嵌入单个请求体参数 假设只有一个请求体参数 item: Item, 默认情况下 FastAPI 期望请求体就是一个 Item 对应的结构\nJSON Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 } Click to expand and view more 但若希望如下带有 itemkey 的结构\nJSON Collapse Copy { \u0026#34;item\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 } } Click to expand and view more 那么可以使用 Body(embed=True)\nPYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item( item_id: int, item: Annotated[ Item, Body(embed=True), # embed a single param ] ): ... Click to expand and view more 这将使 FastAPI 将请求体视为嵌套结构, key 为 item\nBody - Fields 除了可以在 path operation (路径操作)函数参数中使用 Query、Path和Body来声明额外的验证和数据, 还可以在 Pydantic 模型内部的 Field 的字段验证规则和元数据\nDeclare model attributes 声明模型字段属性 首先要导入 Filed\nPYTHON Collapse Copy from pydantic import BaseModel, Field # import Filed Click to expand and view more 可以在模型字段上使用 Filed 来添加验证规则和信息\nPYTHON Collapse Copy class Item(BaseModel): name: str description: str | None = Field( default=None, title=\u0026#34;项目的描述\u0026#34;, max_length=300 ) price: float = Field(gt=0, description=\u0026#34;价格必须大于 0\u0026#34;) tax: float | None = None Click to expand and view more 实际上, Query、Path 和其他类, 都继承自一个公共的 Param 类, 而 Param 是 Pydantic 的 FieldInfo 类的子类, pydantic.Field() 返回的就是一个 FieldInfo 实例\nBody - Nested Models 在 FastAPI 中, 可以定义、校验、文档化并使用任意深度嵌套的模型\nList fields 列表字段 可以将字段定义为某种子类型, 例如 Python 的 list\nPYTHON Collapse Copy class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list = [] # list Click to expand and view more List fields with type parameter 带类型参数的列表字段 Python 提供一种\u0026quot;类型参数\u0026quot;的方法, 来指定列表类型\nPYTHON Collapse Copy # Python 3.10+ tags: list[str] = [] Click to expand and view more 对于py3.10之前的版本, 需要使用 typing 模块\nPYTHON Collapse Copy tags: List[str] = [] Click to expand and view more Set types 集和类型 如果不希望 tages 重复, 则使用 set 更加合适\nPYTHON Collapse Copy class Item(BaseModel): ... tags: set[str] = set() Click to expand and view more 这样即使客户端传来重复元素, FastAPI 也会自动去重并返回一个唯一元素集合\nNested Models 嵌套模型 Pydantic 的每个字段都可以是另一模型, 从而形成嵌套结构\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Image(BaseModel): url: str name: str class Item(BaseModel): ... image: Image | None = None @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item(item_id: int, item: Item): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;item\u0026#34;: item} Click to expand and view more 此时的 FastAPI 会期望请求体为如下结构:\nJSON Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2, \u0026#34;tags\u0026#34;: [\u0026#34;rock\u0026#34;, \u0026#34;metal\u0026#34;, \u0026#34;bar\u0026#34;], \u0026#34;image\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://example.com/baz.jpg\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;The Foo live\u0026#34; } } Click to expand and view more 这样使用 FastAPI 会获得:\n编辑器自动补全 类型转换 数据校验 自动生成文档 Special types and validation 特殊类型与验证 除了像 str, int, float 这类 singular types, 还可以使用更加负责的继承于 str 的 singular types, 全部类型可以在 Pydantic\u0026rsquo;s Type Overview 查看\n下面是 HttpUrl 的例子\nPYTHON Collapse Copy from pydantic import HttpUrl class Image(BaseModel): url: HttpUrl name: str Click to expand and view more 这样会检查 JSON schema 中的 url 是否合法, 并在 OpenAPI 文档中显示\nAttributes with lists of submodels 带有子模型属性的列表 PYTHON Collapse Copy class Image(BaseModel): url: HttpUrl name: str class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() images: list[Image] | None = None # lists of submodels Click to expand and view more 此时 FastAPI 会期望请求体有一个 images 字段, 为 Image 对象的列表\nJSON Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2, \u0026#34;tags\u0026#34;: [ \u0026#34;rock\u0026#34;, \u0026#34;metal\u0026#34;, \u0026#34;bar\u0026#34; ], \u0026#34;images\u0026#34;: [ { \u0026#34;url\u0026#34;: \u0026#34;http://example.com/baz.jpg\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;The Foo live\u0026#34; }, { \u0026#34;url\u0026#34;: \u0026#34;http://example.com/dave.jpg\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;The Baz\u0026#34; } ] } Click to expand and view more Deeply nested models 深度嵌套模型 可以定义任意深度的嵌套模型\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Image(BaseModel): url: HttpUrl name: str class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() images: list[Image] | None = None class Offer(BaseModel): name: str description: str | None = None price: float items: list[Item] @app.post(\u0026#34;/offers/\u0026#34;) async def create_offer(offer: Offer): return offer Click to expand and view more Bodies of pure lists 纯列表请求体 如果请求体的顶层是一个数组(例如上传多个图片), 可以直接将参数类型声明为列表:\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Image(BaseModel): url: HttpUrl name: str @app.post(\u0026#34;/images/multiple/\u0026#34;) async def create_multiple_images(images: list[Image]): return images Click to expand and view more Bodies of arbitrary dictS 任意字典作为请求体 可以声明请求体为一个字典 (键和值都可指定类型)\nPYTHON Collapse Copy @app.post(\u0026#34;/index-weights/\u0026#34;) async def create_index_weights(weights: dict[int, float]): return weights Click to expand and view more 虽然 JSON 标准只支持字符串作为 key, 但 Pydantic 会自动将字符串形式的数字转换为 int 因此, 如果客户端发送 { \u0026quot;1\u0026quot;: 0.1, \u0026quot;2\u0026quot;: 0.2 }, 接收到的将是 {1: 0.1, 2: 0.2} ","title":"FastAPI Body Advanced Uses"},{"link":"/posts/git-whitelist/","text":"有时你开启了一个新的项目, 运行了 cargo init、uv init 和 go mod init\n这些命令创建了工作所需要的必要文件, 同时也在 .gitignore 文件中添加了以下内容\nPLAINTEXT Collapse Copy target __pycache__ bin Click to expand and view more 一切都很顺利, 你继续开发新功能, 等到时机成熟时就将项目发布到了 Git 托管平台上\n人们开始对你的项目感兴趣, 甚至有人决定为你实现一个新功能, 这简直是免费劳动力!\n当你查看代码, 发现了一个格格不入的文件 .DS_Store, 你问那个人这是什么, 他说他根本不知道\n然后你只是将该文件从分支里面删除, 并把文件名加入了仓库的 .gitignore\nPLAINTEXT Collapse Copy target __pycache__ bin .DS_Store Click to expand and view more 现在代码合并到了 main, 仓库里只包含有用的内容\n接着, 另一人使用基于 Web 技术的 IDE 提交了另一个合并请求, 一看发现有一个完全无关的目录也被提交了, 于是 .gitignore 里又增加了一条内容\nPLAINTEXT Collapse Copy target __pycache__ bin .DS_Store .vscode Click to expand and view more 接下来, 有人使用 IntelliJ IDEA 提交了五百个 XML 文件和 .idea 目录, 这时又不得不将其加入 .gitignore\nPLAINTEXT Collapse Copy target __pycache__ bin .DS_Store .vscode .idea Click to expand and view more 多年后, .gitignore 已经有了上百行, 但是仍然时不时有各种奇怪的文件, 例如 testscripts、foo、a、qux、data.tar.gz、start.sh、cat \u0026hellip;\u0026hellip;\n你就像西西弗斯一样, 因欺骗死亡和冥界而受到永无止境的惩罚\n西西弗斯推着一块写着 .DS_Store 的巨石艰难上山\n如何改变偷偷溜进来的文件循环呢? 去教育每一个提交合并请求的人肯定不行, 得通过自动化工具解决, 而不是主观沟通\n幸运的是, 可以将这个黑名单变成白名单, 可以通过默认忽略所有文件, 然后只手动“取消忽略”明确允许的文件\nPLAINTEXT Collapse Copy * !.gitignore # 白名单：任意位置下的 src 目录及其子文件夹 !src/ !src/**/ !src/**/*.rs !Cargo.{toml,lock} # 白名单：项目根目录下的 pysrc 目录 !/pysrc/ !/pysrc/*.py !pyproject.toml !uv.lock !/cmd/ !/cmd/*.go !main.go !go.{mod,sum} !/docs/ !/docs/*.md Click to expand and view more 现在, 没人再能不小心提交不该提交的文件了. Git 会自动忽略所有文件, 只允许那些明确列入白名单的文件.\n这种做法也具备一定的“面向未来”的能力——当然, 前提是以后不会有某个 IDE 把 src/ide.rs 当成保存项目配置的理想文件路径, 但愿那一天永远不会到来\u0026hellip;\n","title":"Git Whitelist"},{"link":"/posts/fastapi-parameters-and-validations/","text":"这篇文章介绍 FastAPI 中的参数验证功能\nQuery Parameters and String Validations FastAPI 允许为参数声明额外的信息和验证规则\nPYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(q: str | None = None): results = {\u0026#34;items\u0026#34;: [{\u0026#34;item_id\u0026#34;: \u0026#34;Foo\u0026#34;}, {\u0026#34;item_id\u0026#34;: \u0026#34;Bar\u0026#34;}]} if q: results.update({\u0026#34;q\u0026#34;: q}) return results Click to expand and view more q 是类型为 str | None 的查询参数, 这意味着它可以是字符串, 也可以是 None. 其默认值是 None, 因此 FastAPI 会识别它为“可选参数”\nFastAPI 通过 = None 的默认值知道该参数是非必填的\n使用 str | None 还能帮助编辑器提供更好的类型提示和错误检测\nAdditional validation 额外验证 即使 q 是可选的, 但仍然可以设置条件: 如果提供了 q, 则长度不能超过50个字符\n使用 Query 和 Annotated 来实现\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(q: Annotated[str | None, Query(max_length=50)] = None): results = {\u0026#34;items\u0026#34;: [{\u0026#34;item_id\u0026#34;: \u0026#34;Foo\u0026#34;}, {\u0026#34;item_id\u0026#34;: \u0026#34;Bar\u0026#34;}]} if q: results.update({\u0026#34;q\u0026#34;: q}) return results Click to expand and view more 使用 Annotated 包装后, 就可以传递额外的元数据(Query(max_length=5)), 用于校验或者文档\n注意: 使用 Annotated 的时候，不能在 Query() 中再次使用 default\n❌ 错误写法 PYTHON Collapse Copy q: Annotated[str, Query(default=\u0026#34;rick\u0026#34;)] = \u0026#34;morty\u0026#34; Click to expand and view more ✅ 正确写法 PYTHON Collapse Copy q: Annotated[str, Query()] = \u0026#34;rick\u0026#34; Click to expand and view more 使用 Annotated 有以下优点\n默认值直接写在函数参数上，更符合 Python 风格 该函数在非 FastAPI 环境中调用时也能正常工作 类型检查器能更准确提示 可复用于如 Typer 等其它框架 Annotated 可附加多个元数据 More Validations 更多验证 也可以添加参数 min_length\nPYTHON Collapse Copy @app.get(\u0026#34;/items/\u0026#34;) async def read_items( q: Annotated[str | None, Query(min_length=3, max_length=50)] = None, ): ... Click to expand and view more regular expressions 正则表达式\nPYTHON Collapse Copy @app.get(\u0026#34;/items/\u0026#34;) async def read_items( q: Annotated[ str | None, Query(min_length=3, max_length=50, pattern=\u0026#34;^fixedquery$\u0026#34;) ] = None, ): ... Click to expand and view more ^: 以后面字符串开始, 之前没有其他字符串\nfixedquery: 完全匹配的单词\n$: 在此结束, 之后没有更多字符\ndefault values 默认值\n除了 None, 也可以设置其他默认值\nPYTHON Collapse Copy q: Annotated[str, Query(min_length=3)] = \u0026#34;fixedquery\u0026#34; Click to expand and view more reuqired parameters 必填参数\n如果想让参数 q 是必填的, 不设置默认值即可\nPYTHON Collapse Copy q: Annotated[str, Query(min_length=3)] Click to expand and view more 即使参数可以为 None, 但仍强制要求传值\nPYTHON Collapse Copy q: Annotated[str | None, Query(min_length=3)] Click to expand and view more query parameter list / multiple values 参数列表/多个值\n可以接收多个值的查询参数\nPYTHON Collapse Copy @app.get(\u0026#34;/items/\u0026#34;) async def read_items(q: Annotated[list[str] | None, Query()] = None): query_items = {\u0026#34;q\u0026#34;: q} return query_items Click to expand and view more 访问如下 URL\nPLAINTEXT Collapse Copy http://localhost:8000/items/?q=foo\u0026amp;q=bar Click to expand and view more 将得到多个 q 查询参数值, URL response 将如下\nJSON Collapse Copy { \u0026#34;q\u0026#34;: [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;] } Click to expand and view more 若不使用 Query(), FastAPI 会把 list[str] 当成 request body (请求体)\nDeclare more metadata 添加更多元信息 这些信息会出现在 OpenAPI 文档中\nPYTHON Collapse Copy q: Annotated[str | None, Query( title=\u0026#34;查询字符串\u0026#34;, description=\u0026#34;用于数据库中模糊搜索匹配的查询字符串\u0026#34;, min_length=3 )] = None Click to expand and view more Alias parameters 参数别名 有时想使用一个在 Python 中非法的别名, 例如 item-query\nPLAINTEXT Collapse Copy http://127.0.0.1:8000/items/?item-query=foobaritems Click to expand and view more 最接近的变量名为 item_query, 但是 item-query 不能为变量名\n此时, 可以使用别名 alias\nPYTHON Collapse Copy q: Annotated[str | None, Query(alias=\u0026#34;item-query\u0026#34;)] = None Click to expand and view more Deprecating parameters 弃用参数 想标记某个参数已被弃用, 可以加上\nPYTHON Collapse Copy Query(..., deprecated=True) Click to expand and view more Exclude parameters from OpenAPI 从OpenAPI中隐藏参数 可以设置参数不出现在自动生成的文章中\nPYTHON Collapse Copy hidden_query: Annotated[str | None, Query(include_in_schema=False)] = None Click to expand and view more Custom validation 自定义校验 若内建参数不够用, 可以使用 Pydantic v2 的 AfterValidator\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import AfterValidator from typing import Annotated def check_valid_id(id: str): if not id.startswith((\u0026#34;isbn-\u0026#34;, \u0026#34;imdb-\u0026#34;)): raise ValueError(\u0026#34;Invalid ID format, 必须以 \u0026#39;isbn-\u0026#39; 或 \u0026#39;imdb-\u0026#39; 开头\u0026#34;) return id @app.get(\u0026#34;/items/\u0026#34;) async def read_items( id: Annotated[str | None, AfterValidator(check_valid_id)] = None, ): if id: team = data.get(id) else: id, item = random.choice(list(data.items())) return {\u0026#34;id\u0026#34;: id, \u0026#34;name\u0026#34;: item} Click to expand and view more value.startswith((\u0026quot;isbn-\u0026quot;, \u0026quot;imdb-\u0026quot;)) 可以一次检查多个前缀 random.choice(list(data.items())) 取出随机的键值对 Path Parameters and Numberic Validations 和使用 Query 查询参数声明更多验证规则和元数据一样, 也可以使用 Path 为路径参数声明相同类型的规则验证和元数据\nImport Path 导入路径 首先, 从 fastapi 中导入 Path, 并导入 Annotated\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Path, Query app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( item_id: Annotated[int, Path(title=\u0026#34;要获取的物品 ID\u0026#34;)], q: Annotated[str | None, Query(alias=\u0026#34;item-query\u0026#34;)] = None, ): results = {\u0026#34;item_id\u0026#34;: item_id} if q: results.update({\u0026#34;q\u0026#34;: q}) return results Click to expand and view more Declare metadata 声明元数据 可以像在 Query 中一样声明所有的参数\nPYTHON Collapse Copy item_id: Annotated[int, Path(title=\u0026#34;要获取的物品 ID\u0026#34;)] Click to expand and view more ⚠️ 路径参数总是必填的, 它必须作为路径的一部分存在. 即使将它设为 None 或指定默认值, 也不会生效, 它仍然是必须的\nOrder the parameters 自由排序参数 如果希望 query parameter 声明为必填的 str, 并且不需要声明任何其他事情, 那么不需要用 Query() 包裹\n但是对于 path parameter item_id 仍然需要使用 Path, 并且出于一些原因并不像使用 Annotated\n如果将有 defalult 默认值的参数, 放到没有默认值参数前面, 那么 Python 会报错, 所以要这样声明函数\nPYTHON Collapse Copy from fastapi import FastAPI, Path app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items(q: str, item_id: int = Path(title=\u0026#34;要获取的物品 ID\u0026#34;)): results = {\u0026#34;item_id\u0026#34;: item_id} if q: results.update({\u0026#34;q\u0026#34;: q}) return results Click to expand and view more 但是, 如果使用 Annotated 就不会有这个顺序的问题, 因为默认值并不写在函数参数中\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( q: str, item_id: Annotated[int, Path(title=\u0026#34;要获取的物品 ID\u0026#34;)] ): ... Click to expand and view more Order the parameters tricks 参数顺序技巧 如果不想使用 Annotated, 但是又想:\n为查询参数 q 不使用 Query, 也不设置默认值 为路径参数 item_id 使用 Path 两个参数顺序任意 不想用 Annotated 那可以使用一个小技巧: 在函数参数前面加一个星号 *\n作用是: 告诉 Python, 后面所有参数必须作为关键字参数传入 (即使用key=value的方法, 不能省略参数名)\nPYTHON Collapse Copy async def read_items(*, item_id: int = Path(title=\u0026#34;The ID of the item to get\u0026#34;), q: str): ... Click to expand and view more Better with Annotated 推荐使用Annotated 如果使用 Annotated, 由于不是用参数默认值来传递 Path()、Query(), 就不需要使用*这种语法\nPYTHON Collapse Copy # Python 3.9+ async def read_items( item_id: Annotated[int, Path(title=\u0026#34;The ID of the item to get\u0026#34;)], q: str ): ... Click to expand and view more Number Validations 数字验证 在 FastAPI 中, 可以通过 Path()、Query() (以及其他参数类) 为数值类型参数添加约数条件, 有以下四种:\ngt: greater than (大于) ge: greater than or equal (大于等于) lt: less than (小于) le: less than or equal (小于等于) 这些验证适用于路径参数(path parameter)和查询参数(query parameter), 并且支持 int 和 float 类型\n整数验证示例 (Path 参数)\n使用 ge=1 表示 item_id 必须是一个大于等于1的整数\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Path app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( item_id: Annotated[int, Path(title=\u0026#34;要获取的项目 ID\u0026#34;, ge=1)], q: str ): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q} Click to expand and view more 也可以通过 ge 和 le 同时限制一个整数的区间范围\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( item_id: Annotated[int, Path(title=\u0026#34;要获取的项目 ID\u0026#34;, gt=0, le=1000)], q: str ): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q} Click to expand and view more 浮点数验证示例 (Query 参数)\n浮点类型的校验同样适用. 例如, 使用 gt 可以确保值 严格大于 0\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( *, item_id: Annotated[int, Path(title=\u0026#34;项目 ID\u0026#34;, ge=0, le=1000)], q: str, size: Annotated[float, Query(gt=0, lt=10.5)], ): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q, \u0026#34;size\u0026#34;: size} Click to expand and view more item_id 必须在 [0, 1000] 区间内 size 必须在 (0, 10.5) 区间内 ","title":"FastAPI Parameters and Validations"},{"link":"/posts/fastapi-parameters/","text":"FastAPI 是一个现代、快速（高性能）的 Python Web 框架, 它自动处理参数的解析、验证和文档生成\n本文将介绍 FastAPI 中三类最常用的参数: 路径参数 (Path Parameters)、查询参数 (Query Parameters) 和 请求体(Request Body) 的用法与原理\n1. Path Parameters 路径参数 路径参数是 URL 路径中的动态部分, 使用 {} 包裹表示\nPYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str): return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more 访问 /items/foo 返回:\nPYTHON Collapse Copy {\u0026#34;item_id\u0026#34;: \u0026#34;foo\u0026#34;} Click to expand and view more Data conversion \u0026amp; validation 类型声明与自动转换 可以为路径参数声明类型, FastAPI 会自动解析并验证:\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: int): return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more 访问 /items/3, item_id 会被转换为 int 类型\nRouting orders 路由匹配顺序 路径匹配按声明顺序执行, 例如\nPYTHON Collapse Copy @app.get(\u0026#34;/users/me\u0026#34;) async def read_user_me(): return {\u0026#34;user_id\u0026#34;: \u0026#34;current_user\u0026#34;} @app.get(\u0026#34;/users/{user_id}\u0026#34;) async def read_user(user_id: str): return {\u0026#34;user_id\u0026#34;: user_id} Click to expand and view more 必须先声明 /users/me, 否则会被 /users/{user_id} 捕获\nPredefined enum values 预定义枚举值 使用 Python 的 Enum 定义一组可选的路径参数值\nPYTHON Collapse Copy from enum import Enum class ModelName(str, Enum): alexnet = \u0026#34;alexnet\u0026#34; resnet = \u0026#34;resnet\u0026#34; lenet = \u0026#34;lenet\u0026#34; @app.get(\u0026#34;/models/{model_name}\u0026#34;) async def get_model(model_name: ModelName): return {\u0026#34;model_name\u0026#34;: model_name} Click to expand and view more Swagger 文档会自动显示可选值\nPath parameters containing paths 路径型参数 默认路径参数不能包含斜杠 /, 但可以用 :path 声明允许匹配完整路径\nPYTHON Collapse Copy @app.get(\u0026#34;/files/{file_path:path}\u0026#34;) async def read_file(file_path: str): return {\u0026#34;file_path\u0026#34;: file_path} Click to expand and view more 访问 /files/home/user/file.txt, file_path 会是 \u0026quot;home/user/file.txt\u0026quot;\n2. Query Parameters 查询参数 查询参数是 URL ? 后的键值对, 不属于路径部分\nPYTHON Collapse Copy fake_items_db = [{\u0026#34;item_name\u0026#34;: \u0026#34;Foo\u0026#34;}, {\u0026#34;item_name\u0026#34;: \u0026#34;Bar\u0026#34;}] @app.get(\u0026#34;/items/\u0026#34;) async def read_items(skip: int = 0, limit: int = 10): return fake_items_db[skip : skip + limit] Click to expand and view more 访问 /items/?skip=0\u0026amp;limit=10 时, 会自动把查询参数 skip 和 limit 转成 int\nOptional parameters 可选参数默认值 给查询参数赋默认值即为可选\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str, q: str | None = None): if q: return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q} return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more q 是可选查询参数, 默认为 None\nQuery parameter type conversion 查询参数类型转换 PYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str, q: str | None = None, short: bool = False): ... Click to expand and view more 支持自动把字符串转换成布尔值, 以下都会被识别为 True\nPLAINTEXT Collapse Copy http://127.0.0.1:8000/items/foo?short=1 Click to expand and view more 或者\n?short=true ?short=on ?short=yes Multiple path and query parameters 多路径查询参数组合 路径参数和查询参数可混合使用, 无需声明顺\nPYTHON Collapse Copy @app.get(\u0026#34;/users/{user_id}/items/{item_id}\u0026#34;) async def read_user_item(user_id: int, item_id: str, q: str | None = None, short: bool = False): ... Click to expand and view more Required query parameters 必填查询参数 未设置默认值的查询参数为必填参数\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str, needy: str): ... Click to expand and view more 上面的 needy 就是一个必填的 str 类型\n当然也可以定义一些必填参数, 以及有默认值的可选参数\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_user_item( item_id: str, needy: str, skip: int = 0, limit: int | None = None ): ... Click to expand and view more needy \u0026amp; item_id, 必填 str 类型 skip, 默认值为 0 的类型 limit, 一个可选的类型 [注]\n路径参数永远是必填的, 因为它们来自 URL 本身 PYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) def read(item_id: str = \u0026#34;123\u0026#34;): # 这里写默认值是无效的 ... Click to expand and view more 类型为 Optional[...] 或 type | None 不等于可选参数, 仍然要配合默认值 = None 才是可选 PYTHON Collapse Copy def func(x: int | None): # 必填 def func(x: int | None = None): # 可选 Click to expand and view more 3. Request Body 当通过 API 传送数据的时候, 通常通过 request body 发送\nrequest body 是 client 客户端发送给 API 的数据, 而 response body 是 API 发送给 client 的数据\nPydantic\u0026rsquo;s BaseModel 使用 Pydantic 定义数据模型\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None app = FastAPI() @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item): return item Click to expand and view more Declare it as a parameter 在路由中声明请求体\nPYTHON Collapse Copy @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item): return item Click to expand and view more FastAPI 会:\n读取 request body, 并转换为 JSON 校验字段和类型 返回类型错误时给出详细反馈, 包括数据那里以及导致了什么错误 提供编辑器类型提示 生成模型的 JSON Schema 定义, 也可以在项目中任何位置使用 根据 schema 自动生成文档 Request body + path + query parameters 路径参数、查询参数与请求体同时使用 PYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item(item_id: int, item: Item, q: str | None = None): result = {\u0026#34;item_id\u0026#34;: item_id, **item.dict()} if q: result.update({\u0026#34;q\u0026#34;: q}) return result Click to expand and view more 这个函数参数会被以下方式识别:\n如果参数同时在 path 中声明, 被当成 path parameter 如果参数为单一类型, 如 int, float, str 或 bool 等, 将会被解释为 query parameter 如果参数声明为一个 Pydantic Model, 将被解释为 request body ","title":"FastAPI Parameters"},{"link":"/posts/python-tricks/","text":"1. The Self-Replicating Trick 将一个含有空列表的列表乘5, 得到有5个空列表的列表\nPYTHON Collapse Copy x = [[]] * 5 x Click to expand and view more [[], [], [], [], []]\n当使用.append(\u0026quot;x\u0026quot;)方法时, 所有列表都被修改\nPYTHON Collapse Copy x[0].append(\u0026#34;x\u0026#34;) x Click to expand and view more [[\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;]]\n打印其 id 可以看到, id 都相同\nPYTHON Collapse Copy for item in x: print(id(item)) Click to expand and view more 4417579584\n4417579584\n4417579584\n4417579584\n4417579584\n或者使用set()发现 id 唯一\nPYTHON Collapse Copy set(id(item) for item in x) Click to expand and view more {4417579584}\n也就是说, 当使用乘法的时候, 创建了5个内部列表的引用副本\n使用反汇编发现, 只创建了两个列表, 并执行乘5\nPYTHON Collapse Copy dis.dis(\u0026#34;[[]] * 5\u0026#34;) 0 0 RESUME 0 # 用于支持解释器恢复 (py3.11) 1 2 BUILD_LIST 0 # 构造一个空列表[], 压栈 4 BUILD_LIST 1 # 从栈顶取一个对象, 构造列表[[]] 6 LOAD_CONST 0 (5) # 加载常量 5 8 BINARY_OP 5 (*) # 对栈顶两个元素执行乘法 12 RETURN_VALUE # 返回栈顶结果 Click to expand and view more The alternative 如果要构造独立列表, 应改用列表推导式\nPYTHON Collapse Copy x = [[] for _ in range(5)] x Click to expand and view more [[], [], [], [], []]\nPYTHON Collapse Copy for item in x: print(id(item)) Click to expand and view more 4587832384\n4587818752\n4587831168\n4587839168\n4587809152\nPYTHON Collapse Copy set(id(item) for item in x) Click to expand and view more {4587809152, 4587818752, 4587831168, 4587832384, 4587839168}\n2. The Teleportation Trick PYTHON Collapse Copy def add_to_shopping_list(item, shopping_list=[]): shopping_list.append(item) return shopping_list Click to expand and view more 上面函数为一个空列表中添加一个 item, 期望每次创建一个新的空列表, 并添加一个item\nPYTHON Collapse Copy groceries = add_to_shopping_list(\u0026#34;Bread\u0026#34;) groceries Click to expand and view more [\u0026lsquo;Bread\u0026rsquo;]\nPYTHON Collapse Copy books = add_to_shopping_list(\u0026#34;A Brief History of Time\u0026#34;) books Click to expand and view more [\u0026lsquo;Bread\u0026rsquo;, \u0026lsquo;A Brief History of Time\u0026rsquo;]\n然而, \u0026lsquo;Bread\u0026rsquo; 被传送到 books 里面去了\n下面不使用默认参数, 测试一下函数\nPYTHON Collapse Copy cakes = [] cakes = add_to_shopping_list(\u0026#34;Chorolate Cake\u0026#34;, cakes) cakes Click to expand and view more [\u0026lsquo;Chorolate Cake\u0026rsquo;]\nPYTHON Collapse Copy tools = [] tools = add_to_shopping_list(\u0026#34;Snapper\u0026#34;, tools) tools Click to expand and view more [\u0026lsquo;Snapper\u0026rsquo;]\n当传入一个存在的列表时, 没有发生传送行为\n回到函数定义: 默认参数的列表, 在函数定义的时候已经被创建了, 因此每次使用该函数而不传入列表参数的时候, 默认列表shopping_list就会被使用, 且 list 是一个可变类型, 因此每次会修改这个列表\n使用下面方法, 每次打印出使用列表的 id, 会发现不传入列表参数时的 id 都相同\nPYTHON Collapse Copy def add_to_shopping_list(item, shopping_list=[]): print(id(shopping_list)) shopping_list.append(item) return shopping_list Click to expand and view more The alternative 这个 bug 在使用可变类型(mutable)作为默认参数的时候都会发生, 应该避免可变数据类型作为默认参数\n如果想要默认值参数, 可以考虑使用 None 作为参数默认值\nPYTHON Collapse Copy def add_to_shopping_list(item, shopping_list=None): if shopping_list is None: shopping_list = [] shopping_list.append(item) return shopping_list Click to expand and view more The Vanishing Trick 下面是最后一个 trick\nPYTHON Collapse Copy doubles = (number * 2 for number in range(10)) 4 in doubles # True 4 in doubles # False Click to expand and view more 上面结果看起来很矛盾, 4 怎么一会儿在 doubles 中, 一会儿又不再 doubles 中?\n再来看一个例子\nPYTHON Collapse Copy another_doubles = [number * 2 for number in range(10)] 4 in another_doubles # True 4 in another_doubles # True Click to expand and view more 上面这个例子中, 就都是 True\n问题出在, 当使用括号()创建 doubles 的时候, 并不是创建了元组 tuple, 而是一个生成器 generator\nPYTHON Collapse Copy doubles = (number ** 2 for number in range(10)) doubles Click to expand and view more \u0026lt;generator object at 0x111718e10\u0026gt;\n生成器并不会包含所有的值, 而是在使用的时候生成每个值\n例如, 调用 next() 会返回下一个值\nPYTHON Collapse Copy next(doubles) # 0 next(doubles) # 1 next(doubles) # 2 next(doubles) # 4 ... next(doubles) # 18 next(doubles) Click to expand and view more StopIteration Traceback (most recent call last)\n生成器是一次型的数据结构, 当生成下一个数据的时候, 之前的数据不会被保存, 也就是只能遍历数据一次\n一但遍历完成, 就会报StopIteration的错误, 所以当运行4 in doubles的时候, 先得到0, 为 False, 生成器会继续遍历下一个, 直到得到4, 当再次调用的时候, 下一个返回6, 直到遍历结束也无法得到到4\n同样的行为在迭代器 iterator 上也一样\nPYTHON Collapse Copy numbers = [2, 4, 6, 8] numbers_rev = reversed(numbers) numbers_rev # \u0026lt;list_reverseiterator object at 0x......\u0026gt; 4 in numbers_rev # True 4 in numbers_rev # False Click to expand and view more The alternative 如果使用生成器, 要知道只能遍历每个元素一次, 如果要获得一个有所有元素的数据结构, 应该使用元素 tuple 或列表 list\nPYTHON Collapse Copy doubles = (number * 2 for number in range(10)) # generator more_doubles = tuple(number * 2 for number in range(10)) # tuple 4 in more_doubles # True 4 in more_doubles # True Click to expand and view more ","title":"Python Tricks"},{"link":"/posts/executing-arbitrary-python-code-from-a-comment/","text":"通过注释执行任意Python代码\n问题描述 Q: 只能控制一行的.py代码中注释的内容(\\n\\r均会被替换为空字符), 如何执行任意代码?\nA: 在注释#中, 构造一个.zip 文件, python 会将该内容当成一个zip包执行, 触发任意代码执行\n解决方案 从 Python 3.5 起, 可以直接执行一个 .zip 文件\nPYTHON3 Collapse Copy python myapp.zip Click to expand and view more 前提是ZIP 包中包含一个顶层的__main__.py文件, Python 会把它当作 zipapp, 自动解压并运行__main__.py\nPython 会从末尾找到 ZIP 的目录结构, 而不是依赖文件头, 所以前面的“垃圾”字节会被忽略\nPython 源码中的任何行, 只要以 # 开头, 解释器都会忽略后面内容, 因此可以:\n把 ZIP 文件的数据藏在 Python 源码中的注释中（开头加 #） 把 ZIP 数据直接拼接在 Python 文件的后面, 只保证文件头部分是合法 Python ZIP 不关心前缀, Python 只要最前面是有效源码, 也不会管后面 难点 ZIP 文件头包含二进制字段，比如\n偏移量（文件数据相对于 ZIP 开头的位置） 长度（文件名长度、注释长度等） 这些值写死在 header 里, 是十六进制整数 如果这些字节中出现了像 \\x00、\\xFF 等非 ASCII 内容, Python 就不能把它当注释 解决方法: 暴力穷举合法组合\n想办法 调整偏移值和结构位置，使得最终写出来的 ZIP 文件\n所有的字段值都转化为 可打印字符（ASCII 范围内） 所有 binary 字段看起来都像合法的注释字符串 于是用 itertools.product(range(256), repeat=2) 暴力尝试偏移组合，只要碰巧生成的 ZIP 包所有关键字节都在可打印范围内（ASCII 32~126），就认为成功。 下面是generate_polygloy_zip.py代码, 会生成一个符合要求的polygloy.py代码, 最后运行该代码, 可以执行Body里面的内容BODY = b\u0026quot;print('FROM MAIN.py FILE!!!')#\u0026quot;\nPYTHON3 Collapse Copy # struct: 按字节结构打包数据，方便构造 ZIP 文件二进制头 # itertools: 用来暴力枚举 CRC 校验和后缀（确保安全ASCII） # zlib: 计算 CRC32 校验和 import struct, itertools, zlib # 文件开头代码 # encode(): Unicode 字符串 -\u0026gt; bytes 字节串 JUNK_HEAD = \u0026#34;\u0026#34;\u0026#34;print(\u0026#34;Hello World!\u0026#34;) # This is a comment. Here\u0026#39;s another: # \u0026#34;\u0026#34;\u0026#34;.encode() # 文件结尾代码 JUNK_TAIL = \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Thanks for playing!\u0026#34;)\u0026#34;\u0026#34;\u0026#34; # zip 文件核心代码 # b: 字节串 FILENAME = b\u0026#34;__main__.py\u0026#34; BODY = b\u0026#34;print(\u0026#39;FROM MAIN.py FILE!!!\u0026#39;)#\u0026#34; # 校验 CRC 是否为 ASCII-safe def ascii_safe(x: int) -\u0026gt; bool: return all(((x \u0026gt;\u0026gt; (8*i)) \u0026amp; 0x80) == 0 for i in range(4)) # 检查 32 位整数的四个字节，每个字节最高位（0x80）是否为 0，即是否为 ASCII 范围内的字节 def find_suffix(core: bytes, length: int = 4) -\u0026gt; tuple[bytes, int]: \u0026#34;\u0026#34;\u0026#34; - ZIP 文件 CRC32 计算结果必须 ASCII-safe（低于 0x80） - 这里用暴力方法，给 payload 后面加4字节后缀，找到合适的后缀让 CRC32 满足 ASCII-safe 条件 \u0026#34;\u0026#34;\u0026#34; printable = range(0x20, 0x7f) for tail in itertools.product(printable, repeat=length): payload = core + bytes(tail) crc = zlib.crc32(payload) \u0026amp; 0xFFFFFFFF if ascii_safe(crc): return bytes(tail), crc raise RuntimeError(\u0026#34;No ASCII-safe CRC found.\u0026#34;) # 计算最终 payload SUFFIX, CRC = find_suffix(BODY) PAYLOAD = BODY + SUFFIX SIZE = len(PAYLOAD) def le32(x): return struct.pack(\u0026#34;\u0026lt;I\u0026#34;, x) # 4字节小端无符号整数 def le16(x): return struct.pack(\u0026#34;\u0026lt;H\u0026#34;, x) # 2字节小端无符号整数 # ZIP 结构中各签名常量 SIG_LFH = 0x04034B50 # 本地文件头 Local File Header SIG_CDH = 0x02014B50 # 中央目录头 Central Directory Header SIG_EOCD = 0x06054B50 # 结束目录头 End of Central Directory # zip 文件偏移量设置 delta = len(JUNK_HEAD) # 构建 Local File Header \u0026#34;\u0026#34;\u0026#34; Local File Header 是 ZIP 格式中的一部分，告诉解压程序该文件的元信息 - version needed to extract，flags，compression method 等字段置 0 表示无压缩，简单存储 - CRC32、压缩大小、解压大小都是我们计算的 - 文件名长度和文件名 \u0026#34;\u0026#34;\u0026#34; lfh = ( le32(SIG_LFH) + le16(0) + le16(0) + le16(0) + le16(0) + le16(0) + le32(CRC) + le32(SIZE) + le32(SIZE) + le16(len(FILENAME)) + le16(0) + FILENAME ) # 构建 Central Directory Header \u0026#34;\u0026#34;\u0026#34; - Central Directory 是 ZIP 文件目录结构，记录每个文件信息和偏移， - 其中重要的是 relative offset of LFH，也就是 Local File Header 在整个 ZIP 文件里的偏移，必须加上 delta \u0026#34;\u0026#34;\u0026#34; cdh = ( le32(SIG_CDH) + le16(0) + le16(0) + le16(0) + le16(0) + le16(0) + le16(0) + le32(CRC) + le32(SIZE) + le32(SIZE) + le16(len(FILENAME)) + le16(0) + le16(0) + le16(0) + le16(0) + le32(0) + le32(delta) + FILENAME ) # 确保偏移量 ASCII-safe \u0026#34;\u0026#34;\u0026#34; - ZIP 目录偏移需要是 ASCII 字节，否则写入 .py 文件时会出错 - 这里通过填充若干 \\x00 字节，保证偏移合法 \u0026#34;\u0026#34;\u0026#34; cd_offset = delta + len(lfh) + len(PAYLOAD) pad = 0 while not ascii_safe(cd_offset + pad): pad += 1 padding = b\u0026#39;\\x00\u0026#39; * pad cd_offset += pad # 构建 End of Central Directory Header \u0026#34;\u0026#34;\u0026#34; EOCD 记录 ZIP 中央目录大小、偏移及注释长度等信息 \u0026#34;\u0026#34;\u0026#34; eocd = ( le32(SIG_EOCD) + le16(0) + le16(0) + le16(1) + le16(1) + le32(len(cdh)) + le32(cd_offset) + le16(len(JUNK_TAIL)) ) # 拼接完整 ZIP 内容 zip_bytes = lfh + PAYLOAD + padding + cdh + eocd zip_bytes = bytearray(zip_bytes) assert all(b \u0026lt; 0x80 for b in zip_bytes), \u0026#34;非 ASCII 字节存在\u0026#34; # 写入 polyglot.py 文件 with open(\u0026#34;polyglot.py\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(JUNK_HEAD + zip_bytes + JUNK_TAIL.encode()) # 运行提示 print(\u0026#34;✅ polyglot.py 生成完毕。运行它即可执行嵌入的 __main__.py 内容：\u0026#34;) print(\u0026#34; $ python3 polyglot.py\u0026#34;) Click to expand and view more ","title":"Executing arbitrary Python code from a comment"},{"link":"/posts/how-fastapi-works/","text":"FastAPI 的工作原理: 从 routing 到 lifecycle 以及在现实中的使用\nFastAPI FastAPI 是一个现代的 Python Web 框架, 注重高性能和开发效率. 旨在帮助开发者编写结构清晰、可靠的API, 同时尽量减少样板代码 (boilerplate)\n其由以下两个库驱动:\nStarlette: 负责 Web 服务器逻辑、路由、中间件和异步能力 Pydantic: 基于 Python 类型提示, 处理数据验证、解析和序列化 此外, Fastapi 还有输入验证、基于 Swagger UI 的自动文档生成和代码清晰化的基础\nAPI 请求周期 Fastapi 的请求生命周期如下\nPLAINTEXT Collapse Copy 客户端请求 (Client Request) ↓ FastAPI App ↓ 中间件（Middleware） ↓ 路由匹配 (Route Matching) ↓ 依赖注入（Dependency Injection） ↓ 输入验证 (Input Validation) ↓ 端点函数 (Endpoint) ↓ 响应序列化 (Response Serialization) ↓ 客户端响应 (Client Response) Click to expand and view more 请求首先进入 FastAPI 应用 (本质就是一个 Starlette 应用) 所有中间件优先执行 (如: 日志、错误处理、CORS等) 路由器检查路径和方法, 找到对应的处理函数 FastAPI 使用Depends解析依赖 使用 Pydantic 自动解析并验证输入数据 执行端点函数, 参数验证完毕 返回结果被序列化为合适的响应格式 (JSON) 响应返回给客户端 路由 Router 在应用对象上定义\n适合小项目或原型验证 PYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) def read_item(): return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more 使用 APIRouter 模块化\n适合大项目 PYTHON Collapse Copy from fastapi import FastAPI router = APIRouter(prefix=\u0026#34;/users\u0026#34;, tags=[\u0026#34;users\u0026#34;]) @router.get(\u0026#34;/{user_id}\u0026#34;) def get_user(user_id: int): return {\u0026#34;user_id\u0026#34;: user_id} Click to expand and view more 使用APIRouter可以将相关的端点分组, 添加前缀和标签, 保持代码结构清晰模块化 当某个请求与端点匹配时, FastAPI 内部执行一下步骤:\nStarlette 找到对应路由, 并创建一个APIRouter实例 FastAPI 使用get_router_header()包装端点函数并解析依赖 使用 Pydantic 或基本类型对请求数据解析与验证 装饰函数被调用, 传入验证后的参数 返回值被序列化为响应对象 依赖注入: 干净、可复用的逻辑 FastAPI 有一个轻量且强大的依赖注入系统, 可以进行数据库链接、身份验证信息或配置信息等\nPYTHON Collapse Copy from fastapi import Depends def get_db(): db = create_db_session() try: yield db finally: db.close() @app.get(\u0026#34;/items/\u0026#34;) def read_items(db=Depends(get_db)): return db.query(item).all() Click to expand and view more 使用Depends, FastAPI 会负责调用get_db, 处理生成器生命周期, 并将结果注入到函数中\n原生支持异步 (Async) 不同于一些后加入 async 的框架, FastAPI 一开始就设计为支持 async/await\nPYTHON Collapse Copy from fastapi import FastAPI import asyncio app = FastAPI() @app.get(\u0026#34;/hi\u0026#34;) async def greet(): await asyncio.sleep(1) return \u0026#34;Hello? World?\u0026#34; Click to expand and view more 当 fastapi 收到 /hi 这个 URL 的 GET 请求时，会自动调用 async greet(), 无需在任何地方添加 await\n但是, 对于其他的 async def 函数, 调用的时候必须在前面加上 await\nFastAPI 会运行一个异步事件循环，用于执行异步路径函数(async path functions)，同时也会使用一个线程池来处理同步函数(synchronous path functions), 这样就不需要手动调用 asyncio.gather() 和 asyncio.run() 之类的方法\n示例: CURD API PYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str = None price: float tax: float = None @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item): total = item.price + (item.tax or 0) return {\u0026#34;name\u0026#34;: item.name, \u0026#34;total_price\u0026#34;: total} @app.get(\u0026#34;/\u0026#34;) def read_root(): return {\u0026#34;message\u0026#34;: \u0026#34;FastAPI is working!\u0026#34;} Click to expand and view more 运行\nPLAINTEXT Collapse Copy uvicorn main:app --reload Click to expand and view more 还可以使用 Gunicorn 部署4个 Uvicorn 异步服务 PLAINTEXT Collapse Copy gunicorn main:app --workers 4 --worker-class \\ uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000 Click to expand and view more 实际上也可以直接诶使用 uvicorn 运行多个进程, 但是这样无法进行进程管理，因此使用 gunicorn 的方法一般更多被使用 性能提升 如果 API 返回大量数据, 使用 ORJSON 加快序列化速度\nPYTHON Collapse Copy from fastapi import FastAPI from fastapi.responses import ORJSONResponse app = FastAPI(default_response_class=ORJSONResponse) Click to expand and view more ","title":"How FastAPI Works"},{"link":"/posts/chaos-enginnering-in-partice/","text":"记录一个小故事 hhh\n“混沌工程”实践 项目延期，开发说时间不够干不完 老板：“不够就招人”\n今天偶然听到旁边同事给新来的员工做code review：\nQ：你这个代码不要这样写，因为\u0026hellip;\u0026hellip; A：哦，懂了 Q：唉？你这个 .idea/ 文件是什么？ A：啊？我也不知道 我：不是???(一脸震惊) 理想：Plan Do Check Act\n现实：Plan Delay Cancel Apologize\nWhy wouldn\u0026rsquo;t programmers like nature? It has too many bugs\u0026hellip;\n","title":"\"Chaos Enginnering\" In Partice"},{"link":"/posts/blaugust/","text":"🎈 Oh hello, August! It\u0026rsquo;s time for Blaugust.\nBlaugust Begins: Writing as a Develpoer Habit This year, I\u0026rsquo;m joining Blaugust - a month-long blogging challenge that encourage consistent writing throught August. For develpoers, blogging isn\u0026rsquo;t just sharing, it\u0026rsquo;s about orgainzing thoughts, documenting ideas, and creating term references.\nWhat I Plan to Write Here is what I aim to cover this month:\nDaily dev partices: tools, logging, project structure patterns Python ecosystem: FastAPI, Pydantic, Langchain, Pytest and more AI project logs: buliding AI agents and orchestration workflows Architecture notes: async patterns, micorservice, data flow Learning notes \u0026amp; translation of blogs: deep dive into code and quality tech atricles I\u0026rsquo;m not necessarily writing one post per day - some days I might write multiple posts in advance - but the goal is to publish daily with a focus on consistency, reusability, and value.\nWriting Platform and Setup This blog is build with Hugo + Github Pages, using the narrow theme. Markdown keeps things simple, and version control is headled vai Git.\nRSS feed is available (blogroll exchange is welcome!)\nIf you\u0026rsquo;re blogging too or joining Blaugust, feel free to connect 👋 ","title":"Blaugust"},{"link":"/posts/dive-into-deeplearning-02-preliminaries/","text":" Course Note: d2l-video-05 - 线性代数 Jupyter Notebook: chapter_preliminaries/linear-algebra.ipynb 预备知识中 Liner Algebra 的部分\n线性代数 Scalars 标量: 指只有一个元素的张量 tensors\nPYTHON Collapse Copy import torch x = torch.tensor(3.0) # scalar y = torch.tensor(2.0) Click to expand and view more Vectors 向量: 可以视作标量构成的列表\nPYTHON Collapse Copy x = torch.arange(4) x[3] # 通过张量索引访问任一元素 len(x) # 访问张量长度 x.shape # torch.Size([4]) 只有一个轴的张量, 形状只有一个元素 Click to expand and view more Matrices 矩阵: 类似向量的推广, 可以构建更多轴的数据结构\nPYTHON Collapse Copy # 构建矩阵 A = torch.arange(20).reshape(5, 4) A.T # 转置 # 对称矩阵 B = torch.tensor([[1, 2, 3], [2, 0, 4], [3, 4, 5]]) B = B.T Click to expand and view more 形状相同张量的计算\nPYTHON Collapse Copy A = torch.arange(20, dtype=torch.float32).reshape(5, 4) B = A.clone() A, A + B A * B # 对应元素相乘: Hadamard 积 Click to expand and view more 计算元素的和\nPYTHON Collapse Copy x = torch.arange(4, detype=torch.float64) x.sum() # 任意形状张量的和 Click to expand and view more 计算平均值\nPYTHON Collapse Copy A.mean() # 均值 A.sum() / A.numel() # 另一种计算均值的方法: 和 / 数量 Click to expand and view more 点乘是相同位置元素乘积的和\nPYTHON Collapse Copy x = torch.tensor([0., 1., 2., 3.]]) y = torch.tensor([1., 1., 1., 1.]]) torch.dot(x, y) # torch(6.) # 或者通过元素乘法, 求和表示点积 torch.sum(x * y) # torch(6.) Click to expand and view more 降维: axis 指定沿着哪一个轴来降低纬度\n假如现在有个张量A如下\nPLAINTEXT Collapse Copy tensor([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.], [16., 17., 18., 19.]]) Click to expand and view more 现在沿着第0轴, 通过求和降低纬度\nPYTHON Collapse Copy A_sum_axis0 = A.sum(axis=0) A_sum_axis0, A_sum_axis0.shape Click to expand and view more 输出如下\n上面降维的原理就是, 由于axis=0, 就将最外层的纬度去掉, 原来 A.shape=torch.Size([5, 4]), 现在变成了A_sum_axis0=torch.Size([4])\nPLAINTEXT Collapse Copy (tensor([40., 45., 50., 55.]), torch.Size([4])) Click to expand and view more 类似的, 还可以降低多个纬度\nPYTHON Collapse Copy A.sum(axis=[0, 1]) Click to expand and view more 由于A就两个轴, 两个轴都被降低就成了标量\nPLAINTEXT Collapse Copy tensor(190.) Click to expand and view more 此外, 还可以保持纬度不变, 将要降的纬度变成1\nPYTHON Collapse Copy sum_A = A.sum(axis=1, keepdims=True) # keepdims=True 不丢掉原来的纬度 Click to expand and view more 输出如下:\n原来 A.shape=torch.Size([5, 4]) 现在变成了sum_A.shape=torch.Size([5,1])\nPLAINTEXT Collapse Copy tensor([[ 6.], [22.], [38.], [54.], [70.]]) Click to expand and view more 这种机制常用于广播, 广播要求纬度相同, 例如 A / sum_A 的计算结果如下\nPLAINTEXT Collapse Copy tensor([[0.0000, 0.1667, 0.3333, 0.5000], [0.1818, 0.2273, 0.2727, 0.3182], [0.2105, 0.2368, 0.2632, 0.2895], [0.2222, 0.2407, 0.2593, 0.2778], [0.2286, 0.2429, 0.2571, 0.2714]]) Click to expand and view more 还可以通过某个轴计算A元素的累积总和 A.cumsum(axis=0)\nPLAINTEXT Collapse Copy tensor([[ 0., 1., 2., 3.], [ 4., 6., 8., 10.], [12., 15., 18., 21.], [24., 28., 32., 36.], [40., 45., 50., 55.]]) Click to expand and view more Norms 范数\n范数可以理解为\u0026quot;向量的长度/大小\u0026quot;的一种度量方式,\n向量范数 L1范数, 它表示为向量元素的绝对值之和 (曼哈顿距离)\nPYTHON Collapse Copy torch.abs(u).sum() Click to expand and view more L2范数是向量元素平方和的平方根 (欧几里德距离)\nPYTHON Collapse Copy u = torch.tensor([3.0, -4.0]) torch.norm(u) Click to expand and view more 矩阵范数: 最小的满足下面公式的值 $$ c = A \\cdot b \\quad \\text{hence} \\quad |c| \\leq |A| \\cdot |b| $$\n矩阵的Frobenius范数(Frobenius norm)是矩阵元素平方和的平方根\n$$ |A|_{Frob} = \\left(\\sum_{i,j} A_{ij}^2 \\right)^{\\frac{1}{2}} $$\nPYTHON Collapse Copy torch.norm(torch.ones((4, 9))) Click to expand and view more ","title":"Dive into DeepLearning - 02 - Preliminaries"},{"link":"/posts/dive-into-deeplearning-01-preliminaries/","text":" Course Note: d2l-video-04 - 数据操作+数据预处理 Jupyter Notebook: chapter_preliminaries/pandas.ipynb 预备知识中 Data Manipulation 和 Data Preprocessing 的部分\n介绍 N 纬数组介绍\n0-d (标量)\nPLAINTEXT Collapse Copy 1.0 Click to expand and view more 一个类别\n1-d (向量)\nPLAINTEXT Collapse Copy [1.0, 2.7, 3.4] Click to expand and view more 一个特征向量\n2-d (矩阵)\nPLAINTEXT Collapse Copy [[1.0, 2.7, 3.4], [1.0, 2.7, 3.4], [1.0, 2.7, 3.4]] Click to expand and view more 一个样本 - 特征矩阵\n3-d RGB 图片(宽 x 高 x 通道)\nPLAINTEXT Collapse Copy [[[1.0, 2.7, 3.4], [1.0, 2.7, 3.4], [1.0, 2.7, 3.4]], [[1.0, 2.7, 3.4], [1.0, 2.7, 3.4], [1.0, 2.7, 3.4]]] Click to expand and view more 4-d 一个 RGB 图片批量 (批量大小 x 宽 x 高 x 通道)\nPLAINTEXT Collapse Copy [[[[... ... ...]]]] Click to expand and view more 5-d 一个视屏批量 (批量大小 x 时间 x 宽 x 高 x 通道)\nData Manipulation 数据操作 张量(tensor)表示一个数值表示的数组, 这个数组可能有多个纬度, 下面介绍一下 pytorch 里面基础的张量运算\n创建张量\nPYTHON Collapse Copy import torch x = torch.arange(12) shape = x.shape # 元素形状 num = x.numel() # 元素总数 X = x.reshape(3, 4) # 改变张量形状 Click to expand and view more 生成张量\nPYTHON Collapse Copy torch.zeros((2, 3, 4)) # 形状为 2x3x4 的全0张量 torch.ones((2, 3, 4)) # 形状为 2x3x4 的全1张量 torch.randn(3, 4) # 形状为 3 x 4 的随机张量 torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]) # 通过py数组生成张量 Click to expand and view more 张量运算\nPYTHON Collapse Copy x = torch.tensor([1.0, 2, 4, 8]) # .0 表示为浮点数, 会转换为浮点数张量, 而不是整数 y = torch.tensor([2, 2, 2, 2]) x + y, x - y, x * y, x / y, x ** y # 对应位置的元素进行标准运算 Click to expand and view more 按照行 或 列 连结(concatenate) 在一起\nPYTHON Collapse Copy X = torch.arange(12, dtype=torch.float32).reshape((3,4)) # shape: 3x4 Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]) # shape: 3x4 torch.cat((X, Y), dim=0) # 第0纬(外层)连结: 变成6x8 torch.cat((X, Y), dim=1) # 第1纬(内存)连结: 变成3x8 Click to expand and view more 通过逻辑运算符构建二元张量\nPYTHON Collapse Copy X == Y Click to expand and view more 张量所有元素求和\nPYTHON Collapse Copy X.sum() Click to expand and view more 即使形状不同, 仍然可以通过调用 广播机制(broadcasting mechanism) 来执行按元素操作\nPYTHON Collapse Copy # 使用 广播机制(broadcasting mechanism) 将形状不同的元素相加 a = torch.arange(3).reshape((3, 1)) b = torch.arange(2).reshape((1, 2)) # 将 a 3x2 复制为 3x2 的矩阵 # 将 b 1x2 复制为 3x2 的矩阵 a + b Click to expand and view more 选择元素\nPYTHON Collapse Copy X[-1], X[1:3] # 使用下标, 切片获取元素 X[1, 2] = 9 # 使用指定索引修改元素 X[0:2, :] = 12 # 为多个元素复制 (第一纬度中的 0,1 全部赋值为12) Click to expand and view more 内存相关\n内存重新分配\nPYTHON Collapse Copy before = id(Y) Y = Y + X # 这里加法导致Y内存重新分配 id(Y) == before # False Click to expand and view more 执行原地操作\nPYTHON Collapse Copy Z = torch.zeros_like(Y) print(\u0026#39;id(Z):\u0026#39;, id(Z)) # 使用X[:] = X + Y或X += Y来减少操作的内存开销 Z[:] = X + Y print(\u0026#39;id(Z):\u0026#39;, id(Z)) # 与上 print 输出相同 before = id(X) X += Y id(X) == before # True Click to expand and view more 类型转换\n转换为NumPy张量 (ndarray)\nPYTHON Collapse Copy A = X.numpy() B = torch.tensor(A) type(A), type(B) #\u0026gt; (numpy.ndarray, torch.Tensor) Click to expand and view more 将大小为1的张量转换为Python标量\nPYTHON Collapse Copy a = torch.tensor([3.5]) a, a.item(), float(a), int(a) #\u0026gt; (tensor([3.5000]), 3.5, 3.5, 3) Click to expand and view more Data Preprocessing 数据预处理 csv 全称 Comma-Seperated Values 即逗号分开的值, 是一种文本文件格式, 用来存储表格数据, 数据项之间通常用逗号分隔, 行与行之间用换行符分隔. 实际上, 可以使用其他符号, 例如;来做分隔符\n下面通过一个读取csv文件的例子, 说明如何将csv中的数据读入 pytorch\n首先构造一个csv文件\nPYTHON Collapse Copy import os os.makedirs(os.path.join(\u0026#39;..\u0026#39;, \u0026#39;data\u0026#39;), exist_ok=True) data_file = os.path.join(\u0026#39;..\u0026#39;, \u0026#39;data\u0026#39;, \u0026#39;house_tiny.csv\u0026#39;) with open(data_file, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;NumRooms,Alley,Price\\n\u0026#39;) f.write(\u0026#39;NA,Pave,127500\\n\u0026#39;) f.write(\u0026#39;2,NA,106000\\n\u0026#39;) f.write(\u0026#39;4,NA,178100\\n\u0026#39;) f.write(\u0026#39;NA,NA,140000\\n\u0026#39;) Click to expand and view more 从创建的文件中加载原始数据集\nPYTHON Collapse Copy import pandas as pd data = pd.read_csv(data_file) print(data) Click to expand and view more 会得到如下表格(第一列索引不是表格内容)\nNumRooms Alley Price 0 NaN Pave 127500 1 2.0 NaN 106000 2 4.0 NaN 178100 3 NaN NaN 140000 为了处理缺失的数据, 常使用插值和删除的方法, 这里使用插值\nPYTHON Collapse Copy # inputs: 所有行, 前两列数据, 房间数量和小巷 # outputs: 所有行, 最后一列数据, 价格 inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2] # 使用 pd.get_dummies() 将 Alley 分成两类, dummy_na 表示是否为缺失值(NaN)创建一个新的独热编码列 # 当 dummy_na=True 时, 如果原始数据中有缺失值(NaN), 函数会创建一个新的列, 列名为原列名_nan, 并用True来标记所有原始值为NaN的行 inputs = pd.get_dummies(inputs, dummy_na=True) print(inputs) Click to expand and view more NumRooms Alley_Pave Alley_nan 0 NaN True False 1 2.0 False True 2 4.0 False True 3 NaN False True PYTHON Collapse Copy # 使用平均值填充 inputs = inputs.fillna(inputs.mean()) print(inputs) Click to expand and view more NumRooms Alley_Pave Alley_nan 0 3.0 1 0 1 2.0 0 1 2 4.0 0 1 3 3.0 0 1 最后转换为 torch 张量\nPYTHON Collapse Copy import torch X = torch.tensor(inputs.to_numpy(dtype=float)) y = torch.tensor(outputs.to_numpy(dtype=float)) X, y Click to expand and view more 输出\nPLAINTEXT Collapse Copy (tensor([[3., 1., 0.], [2., 0., 1.], [4., 0., 1.], [3., 0., 1.]], dtype=torch.float64), tensor([127500., 106000., 178100., 140000.], dtype=torch.float64)) Click to expand and view more 深度学习更多使用 float32 类型运算, 64位太慢了\n","title":"Dive into DeepLearning - 01 - Preliminaries"}],"tags":[{"link":"/tags/c/","name":"C","slug":"C"},{"link":"/tags/database/","name":"Database","slug":"Database"},{"link":"/tags/deeplearning/","name":"DeepLearning","slug":"DeepLearning"},{"link":"/tags/essay/","name":"Essay","slug":"Essay"},{"link":"/tags/fastapi/","name":"FastAPI","slug":"FastAPI"},{"link":"/tags/git/","name":"Git","slug":"Git"},{"link":"/tags/hack/","name":"Hack","slug":"Hack"},{"link":"/tags/http/","name":"HTTP","slug":"HTTP"},{"link":"/tags/microservice/","name":"Microservice","slug":"Microservice"},{"link":"/tags/openapi/","name":"OpenAPI","slug":"OpenAPI"},{"link":"/tags/python/","name":"Python","slug":"Python"},{"link":"/tags/redis/","name":"Redis","slug":"Redis"},{"link":"/tags/rest/","name":"REST","slug":"REST"},{"link":"/tags/rust/","name":"Rust","slug":"Rust"},{"link":"/tags/story/","name":"Story","slug":"Story"},{"link":"/tags/tools/","name":"Tools","slug":"Tools"}]}