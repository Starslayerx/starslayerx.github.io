{"categories":[],"pages":[],"posts":[{"link":"/posts/fastapi-parameters/","text":"FastAPI 是一个现代、快速（高性能）的 Python Web 框架, 它自动处理参数的解析、验证和文档生成\n本文将介绍 FastAPI 中三类最常用的参数: 路径参数 (Path Parameters)、查询参数 (Query Parameters) 和 请求体(Request Body) 的用法与原理\n1. Path Parameters 路径参数 路径参数是 URL 路径中的动态部分, 使用 {} 包裹表示\nPYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str): return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more 访问 /items/foo 返回:\nPYTHON Collapse Copy {\u0026#34;item_id\u0026#34;: \u0026#34;foo\u0026#34;} Click to expand and view more Data conversion \u0026amp; validation 类型声明与自动转换 可以为路径参数声明类型, FastAPI 会自动解析并验证:\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: int): return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more 访问 /items/3, item_id 会被转换为 int 类型\nRouting orders 路由匹配顺序 路径匹配按声明顺序执行, 例如\nPYTHON Collapse Copy @app.get(\u0026#34;/users/me\u0026#34;) async def read_user_me(): return {\u0026#34;user_id\u0026#34;: \u0026#34;current_user\u0026#34;} @app.get(\u0026#34;/users/{user_id}\u0026#34;) async def read_user(user_id: str): return {\u0026#34;user_id\u0026#34;: user_id} Click to expand and view more 必须先声明 /users/me, 否则会被 /users/{user_id} 捕获\nPredefined enum values 预定义枚举值 使用 Python 的 Enum 定义一组可选的路径参数值\nPYTHON Collapse Copy from enum import Enum class ModelName(str, Enum): alexnet = \u0026#34;alexnet\u0026#34; resnet = \u0026#34;resnet\u0026#34; lenet = \u0026#34;lenet\u0026#34; @app.get(\u0026#34;/models/{model_name}\u0026#34;) async def get_model(model_name: ModelName): return {\u0026#34;model_name\u0026#34;: model_name} Click to expand and view more Swagger 文档会自动显示可选值\nPath parameters containing paths 路径型参数 默认路径参数不能包含斜杠 /, 但可以用 :path 声明允许匹配完整路径\nPYTHON Collapse Copy @app.get(\u0026#34;/files/{file_path:path}\u0026#34;) async def read_file(file_path: str): return {\u0026#34;file_path\u0026#34;: file_path} Click to expand and view more 访问 /files/home/user/file.txt, file_path 会是 \u0026quot;home/user/file.txt\u0026quot;\n2. Query Parameters 查询参数 查询参数是 URL ? 后的键值对, 不属于路径部分\nPYTHON Collapse Copy fake_items_db = [{\u0026#34;item_name\u0026#34;: \u0026#34;Foo\u0026#34;}, {\u0026#34;item_name\u0026#34;: \u0026#34;Bar\u0026#34;}] @app.get(\u0026#34;/items/\u0026#34;) async def read_items(skip: int = 0, limit: int = 10): return fake_items_db[skip : skip + limit] Click to expand and view more 访问 /items/?skip=0\u0026amp;limit=10 时, 会自动把查询参数 skip 和 limit 转成 int\nOptional parameters 可选参数默认值 给查询参数赋默认值即为可选\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str, q: str | None = None): if q: return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q} return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more q 是可选查询参数, 默认为 None\nQuery parameter type conversion 查询参数类型转换 PYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str, q: str | None = None, short: bool = False): ... Click to expand and view more 支持自动把字符串转换成布尔值, 以下都会被识别为 True\nPLAINTEXT Collapse Copy http://127.0.0.1:8000/items/foo?short=1 Click to expand and view more 或者\n?short=true ?short=on ?short=yes Multiple path and query parameters 多路径查询参数组合 路径参数和查询参数可混合使用, 无需声明顺\nPYTHON Collapse Copy @app.get(\u0026#34;/users/{user_id}/items/{item_id}\u0026#34;) async def read_user_item(user_id: int, item_id: str, q: str | None = None, short: bool = False): ... Click to expand and view more Required query parameters 必填查询参数 未设置默认值的查询参数为必填参数\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str, needy: str): ... Click to expand and view more 上面的 needy 就是一个必填的 str 类型\n当然也可以定义一些必填参数, 以及有默认值的可选参数\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_user_item( item_id: str, needy: str, skip: int = 0, limit: int | None = None ): ... Click to expand and view more needy \u0026amp; item_id, 必填 str 类型 skip, 默认值为 0 的类型 limit, 一个可选的类型 [注]\n路径参数永远是必填的, 因为它们来自 URL 本身 PYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) def read(item_id: str = \u0026#34;123\u0026#34;): # 这里写默认值是无效的 ... Click to expand and view more 类型为 Optional[...] 或 type | None 不等于可选参数, 仍然要配合默认值 = None 才是可选 PYTHON Collapse Copy def func(x: int | None): # 必填 def func(x: int | None = None): # 可选 Click to expand and view more 3. Request Body 当通过 API 传送数据的时候, 通常通过 request body 发送\nrequest body 是 client 客户端发送给 API 的数据, 而 response body 是 API 发送给 client 的数据\nPydantic\u0026rsquo;s BaseModel 使用 Pydantic 定义数据模型\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None app = FastAPI() @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item): return item Click to expand and view more Declare it as a parameter 在路由中声明请求体\nPYTHON Collapse Copy @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item): return item Click to expand and view more FastAPI 会:\n读取 request body, 并转换为 JSON 校验字段和类型 返回类型错误时给出详细反馈, 包括数据那里以及导致了什么错误 提供编辑器类型提示 生成模型的 JSON Schema 定义, 也可以在项目中任何位置使用 根据 schema 自动生成文档 Request body + path + query parameters 路径参数、查询参数与请求体同时使用 PYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item(item_id: int, item: Item, q: str | None = None): result = {\u0026#34;item_id\u0026#34;: item_id, **item.dict()} if q: result.update({\u0026#34;q\u0026#34;: q}) return result Click to expand and view more 这个函数参数会被以下方式识别:\n如果参数同时在 path 中声明, 被当成 path parameter 如果参数为单一类型, 如 int, float, str 或 bool 等, 将会被解释为 query parameter 如果参数声明为一个 Pydantic Model, 将被解释为 request body ","title":"FastAPI Parameters"},{"link":"/posts/python-tricks/","text":"1. The Self-Replicating Trick 将一个含有空列表的列表乘5, 得到有5个空列表的列表\nPYTHON Collapse Copy x = [[]] * 5 x Click to expand and view more [[], [], [], [], []]\n当使用.append(\u0026quot;x\u0026quot;)方法时, 所有列表都被修改\nPYTHON Collapse Copy x[0].append(\u0026#34;x\u0026#34;) x Click to expand and view more [[\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;]]\n打印其 id 可以看到, id 都相同\nPYTHON Collapse Copy for item in x: print(id(item)) Click to expand and view more 4417579584\n4417579584\n4417579584\n4417579584\n4417579584\n或者使用set()发现 id 唯一\nPYTHON Collapse Copy set(id(item) for item in x) Click to expand and view more {4417579584}\n也就是说, 当使用乘法的时候, 创建了5个内部列表的引用副本\n使用反汇编发现, 只创建了两个列表, 并执行乘5\nPYTHON Collapse Copy dis.dis(\u0026#34;[[]] * 5\u0026#34;) 0 0 RESUME 0 # 用于支持解释器恢复 (py3.11) 1 2 BUILD_LIST 0 # 构造一个空列表[], 压栈 4 BUILD_LIST 1 # 从栈顶取一个对象, 构造列表[[]] 6 LOAD_CONST 0 (5) # 加载常量 5 8 BINARY_OP 5 (*) # 对栈顶两个元素执行乘法 12 RETURN_VALUE # 返回栈顶结果 Click to expand and view more The alternative 如果要构造独立列表, 应改用列表推导式\nPYTHON Collapse Copy x = [[] for _ in range(5)] x Click to expand and view more [[], [], [], [], []]\nPYTHON Collapse Copy for item in x: print(id(item)) Click to expand and view more 4587832384\n4587818752\n4587831168\n4587839168\n4587809152\nPYTHON Collapse Copy set(id(item) for item in x) Click to expand and view more {4587809152, 4587818752, 4587831168, 4587832384, 4587839168}\n2. The Teleportation Trick PYTHON Collapse Copy def add_to_shopping_list(item, shopping_list=[]): shopping_list.append(item) return shopping_list Click to expand and view more 上面函数为一个空列表中添加一个 item, 期望每次创建一个新的空列表, 并添加一个item\nPYTHON Collapse Copy groceries = add_to_shopping_list(\u0026#34;Bread\u0026#34;) groceries Click to expand and view more [\u0026lsquo;Bread\u0026rsquo;]\nPYTHON Collapse Copy books = add_to_shopping_list(\u0026#34;A Brief History of Time\u0026#34;) books Click to expand and view more [\u0026lsquo;Bread\u0026rsquo;, \u0026lsquo;A Brief History of Time\u0026rsquo;]\n然而, \u0026lsquo;Bread\u0026rsquo; 被传送到 books 里面去了\n下面不使用默认参数, 测试一下函数\nPYTHON Collapse Copy cakes = [] cakes = add_to_shopping_list(\u0026#34;Chorolate Cake\u0026#34;, cakes) cakes Click to expand and view more [\u0026lsquo;Chorolate Cake\u0026rsquo;]\nPYTHON Collapse Copy tools = [] tools = add_to_shopping_list(\u0026#34;Snapper\u0026#34;, tools) tools Click to expand and view more [\u0026lsquo;Snapper\u0026rsquo;]\n当传入一个存在的列表时, 没有发生传送行为\n回到函数定义: 默认参数的列表, 在函数定义的时候已经被创建了, 因此每次使用该函数而不传入列表参数的时候, 默认列表shopping_list就会被使用, 且 list 是一个可变类型, 因此每次会修改这个列表\n使用下面方法, 每次打印出使用列表的 id, 会发现不传入列表参数时的 id 都相同\nPYTHON Collapse Copy def add_to_shopping_list(item, shopping_list=[]): print(id(shopping_list)) shopping_list.append(item) return shopping_list Click to expand and view more The alternative 这个 bug 在使用可变类型(mutable)作为默认参数的时候都会发生, 应该避免可变数据类型作为默认参数\n如果想要默认值参数, 可以考虑使用 None 作为参数默认值\nPYTHON Collapse Copy def add_to_shopping_list(item, shopping_list=None): if shopping_list is None: shopping_list = [] shopping_list.append(item) return shopping_list Click to expand and view more The Vanishing Trick 下面是最后一个 trick\nPYTHON Collapse Copy doubles = (number * 2 for number in range(10)) 4 in doubles # True 4 in doubles # False Click to expand and view more 上面结果看起来很矛盾, 4 怎么一会儿在 doubles 中, 一会儿又不再 doubles 中?\n再来看一个例子\nPYTHON Collapse Copy another_doubles = [number * 2 for number in range(10)] 4 in another_doubles # True 4 in another_doubles # True Click to expand and view more 上面这个例子中, 就都是 True\n问题出在, 当使用括号()创建 doubles 的时候, 并不是创建了元组 tuple, 而是一个生成器 generator\nPYTHON Collapse Copy doubles = (number ** 2 for number in range(10)) doubles Click to expand and view more \u0026lt;generator object at 0x111718e10\u0026gt;\n生成器并不会包含所有的值, 而是在使用的时候生成每个值\n例如, 调用 next() 会返回下一个值\nPYTHON Collapse Copy next(doubles) # 0 next(doubles) # 1 next(doubles) # 2 next(doubles) # 4 ... next(doubles) # 18 next(doubles) Click to expand and view more StopIteration Traceback (most recent call last)\n生成器是一次型的数据结构, 当生成下一个数据的时候, 之前的数据不会被保存, 也就是只能遍历数据一次\n一但遍历完成, 就会报StopIteration的错误, 所以当运行4 in doubles的时候, 先得到0, 为 False, 生成器会继续遍历下一个, 直到得到4, 当再次调用的时候, 下一个返回6, 直到遍历结束也无法得到到4\n同样的行为在迭代器 iterator 上也一样\nPYTHON Collapse Copy numbers = [2, 4, 6, 8] numbers_rev = reversed(numbers) numbers_rev # \u0026lt;list_reverseiterator object at 0x......\u0026gt; 4 in numbers_rev # True 4 in numbers_rev # False Click to expand and view more The alternative 如果使用生成器, 要知道只能遍历每个元素一次, 如果要获得一个有所有元素的数据结构, 应该使用元素 tuple 或列表 list\nPYTHON Collapse Copy doubles = (number * 2 for number in range(10)) # generator more_doubles = tuple(number * 2 for number in range(10)) # tuple 4 in more_doubles # True 4 in more_doubles # True Click to expand and view more ","title":"Python Tricks"},{"link":"/posts/executing-arbitrary-python-code-from-a-comment/","text":"通过注释执行任意Python代码\n问题描述 Q: 只能控制一行的.py代码中注释的内容(\\n\\r均会被替换为空字符), 如何执行任意代码?\nA: 在注释#中, 构造一个.zip 文件, python 会将该内容当成一个zip包执行, 触发任意代码执行\n解决方案 从 Python 3.5 起, 可以直接执行一个 .zip 文件\nPYTHON3 Collapse Copy python myapp.zip Click to expand and view more 前提是ZIP 包中包含一个顶层的__main__.py文件, Python 会把它当作 zipapp, 自动解压并运行__main__.py\nPython 会从末尾找到 ZIP 的目录结构, 而不是依赖文件头, 所以前面的“垃圾”字节会被忽略\nPython 源码中的任何行, 只要以 # 开头, 解释器都会忽略后面内容, 因此可以:\n把 ZIP 文件的数据藏在 Python 源码中的注释中（开头加 #） 把 ZIP 数据直接拼接在 Python 文件的后面, 只保证文件头部分是合法 Python ZIP 不关心前缀, Python 只要最前面是有效源码, 也不会管后面 难点 ZIP 文件头包含二进制字段，比如\n偏移量（文件数据相对于 ZIP 开头的位置） 长度（文件名长度、注释长度等） 这些值写死在 header 里, 是十六进制整数 如果这些字节中出现了像 \\x00、\\xFF 等非 ASCII 内容, Python 就不能把它当注释 解决方法: 暴力穷举合法组合\n想办法 调整偏移值和结构位置，使得最终写出来的 ZIP 文件\n所有的字段值都转化为 可打印字符（ASCII 范围内） 所有 binary 字段看起来都像合法的注释字符串 于是用 itertools.product(range(256), repeat=2) 暴力尝试偏移组合，只要碰巧生成的 ZIP 包所有关键字节都在可打印范围内（ASCII 32~126），就认为成功。 下面是generate_polygloy_zip.py代码, 会生成一个符合要求的polygloy.py代码, 最后运行该代码, 可以执行Body里面的内容BODY = b\u0026quot;print('FROM MAIN.py FILE!!!')#\u0026quot;\nPYTHON3 Collapse Copy # struct: 按字节结构打包数据，方便构造 ZIP 文件二进制头 # itertools: 用来暴力枚举 CRC 校验和后缀（确保安全ASCII） # zlib: 计算 CRC32 校验和 import struct, itertools, zlib # 文件开头代码 # encode(): Unicode 字符串 -\u0026gt; bytes 字节串 JUNK_HEAD = \u0026#34;\u0026#34;\u0026#34;print(\u0026#34;Hello World!\u0026#34;) # This is a comment. Here\u0026#39;s another: # \u0026#34;\u0026#34;\u0026#34;.encode() # 文件结尾代码 JUNK_TAIL = \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Thanks for playing!\u0026#34;)\u0026#34;\u0026#34;\u0026#34; # zip 文件核心代码 # b: 字节串 FILENAME = b\u0026#34;__main__.py\u0026#34; BODY = b\u0026#34;print(\u0026#39;FROM MAIN.py FILE!!!\u0026#39;)#\u0026#34; # 校验 CRC 是否为 ASCII-safe def ascii_safe(x: int) -\u0026gt; bool: return all(((x \u0026gt;\u0026gt; (8*i)) \u0026amp; 0x80) == 0 for i in range(4)) # 检查 32 位整数的四个字节，每个字节最高位（0x80）是否为 0，即是否为 ASCII 范围内的字节 def find_suffix(core: bytes, length: int = 4) -\u0026gt; tuple[bytes, int]: \u0026#34;\u0026#34;\u0026#34; - ZIP 文件 CRC32 计算结果必须 ASCII-safe（低于 0x80） - 这里用暴力方法，给 payload 后面加4字节后缀，找到合适的后缀让 CRC32 满足 ASCII-safe 条件 \u0026#34;\u0026#34;\u0026#34; printable = range(0x20, 0x7f) for tail in itertools.product(printable, repeat=length): payload = core + bytes(tail) crc = zlib.crc32(payload) \u0026amp; 0xFFFFFFFF if ascii_safe(crc): return bytes(tail), crc raise RuntimeError(\u0026#34;No ASCII-safe CRC found.\u0026#34;) # 计算最终 payload SUFFIX, CRC = find_suffix(BODY) PAYLOAD = BODY + SUFFIX SIZE = len(PAYLOAD) def le32(x): return struct.pack(\u0026#34;\u0026lt;I\u0026#34;, x) # 4字节小端无符号整数 def le16(x): return struct.pack(\u0026#34;\u0026lt;H\u0026#34;, x) # 2字节小端无符号整数 # ZIP 结构中各签名常量 SIG_LFH = 0x04034B50 # 本地文件头 Local File Header SIG_CDH = 0x02014B50 # 中央目录头 Central Directory Header SIG_EOCD = 0x06054B50 # 结束目录头 End of Central Directory # zip 文件偏移量设置 delta = len(JUNK_HEAD) # 构建 Local File Header \u0026#34;\u0026#34;\u0026#34; Local File Header 是 ZIP 格式中的一部分，告诉解压程序该文件的元信息 - version needed to extract，flags，compression method 等字段置 0 表示无压缩，简单存储 - CRC32、压缩大小、解压大小都是我们计算的 - 文件名长度和文件名 \u0026#34;\u0026#34;\u0026#34; lfh = ( le32(SIG_LFH) + le16(0) + le16(0) + le16(0) + le16(0) + le16(0) + le32(CRC) + le32(SIZE) + le32(SIZE) + le16(len(FILENAME)) + le16(0) + FILENAME ) # 构建 Central Directory Header \u0026#34;\u0026#34;\u0026#34; - Central Directory 是 ZIP 文件目录结构，记录每个文件信息和偏移， - 其中重要的是 relative offset of LFH，也就是 Local File Header 在整个 ZIP 文件里的偏移，必须加上 delta \u0026#34;\u0026#34;\u0026#34; cdh = ( le32(SIG_CDH) + le16(0) + le16(0) + le16(0) + le16(0) + le16(0) + le16(0) + le32(CRC) + le32(SIZE) + le32(SIZE) + le16(len(FILENAME)) + le16(0) + le16(0) + le16(0) + le16(0) + le32(0) + le32(delta) + FILENAME ) # 确保偏移量 ASCII-safe \u0026#34;\u0026#34;\u0026#34; - ZIP 目录偏移需要是 ASCII 字节，否则写入 .py 文件时会出错 - 这里通过填充若干 \\x00 字节，保证偏移合法 \u0026#34;\u0026#34;\u0026#34; cd_offset = delta + len(lfh) + len(PAYLOAD) pad = 0 while not ascii_safe(cd_offset + pad): pad += 1 padding = b\u0026#39;\\x00\u0026#39; * pad cd_offset += pad # 构建 End of Central Directory Header \u0026#34;\u0026#34;\u0026#34; EOCD 记录 ZIP 中央目录大小、偏移及注释长度等信息 \u0026#34;\u0026#34;\u0026#34; eocd = ( le32(SIG_EOCD) + le16(0) + le16(0) + le16(1) + le16(1) + le32(len(cdh)) + le32(cd_offset) + le16(len(JUNK_TAIL)) ) # 拼接完整 ZIP 内容 zip_bytes = lfh + PAYLOAD + padding + cdh + eocd zip_bytes = bytearray(zip_bytes) assert all(b \u0026lt; 0x80 for b in zip_bytes), \u0026#34;非 ASCII 字节存在\u0026#34; # 写入 polyglot.py 文件 with open(\u0026#34;polyglot.py\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(JUNK_HEAD + zip_bytes + JUNK_TAIL.encode()) # 运行提示 print(\u0026#34;✅ polyglot.py 生成完毕。运行它即可执行嵌入的 __main__.py 内容：\u0026#34;) print(\u0026#34; $ python3 polyglot.py\u0026#34;) Click to expand and view more ","title":"Executing arbitrary Python code from a comment"},{"link":"/posts/how-fastapi-works/","text":"FastAPI 的工作原理: 从 routing 到 lifecycle 以及在现实中的使用\nFastAPI FastAPI 是一个现代的 Python Web 框架, 注重高性能和开发效率. 旨在帮助开发者编写结构清晰、可靠的API, 同时尽量减少样板代码 (boilerplate)\n其由以下两个库驱动:\nStarlette: 负责 Web 服务器逻辑、路由、中间件和异步能力 Pydantic: 基于 Python 类型提示, 处理数据验证、解析和序列化 此外, Fastapi 还有输入验证、基于 Swagger UI 的自动文档生成和代码清晰化的基础\nAPI 请求周期 Fastapi 的请求生命周期如下\nPLAINTEXT Collapse Copy 客户端请求 (Client Request) ↓ FastAPI App ↓ 中间件（Middleware） ↓ 路由匹配 (Route Matching) ↓ 依赖注入（Dependency Injection） ↓ 输入验证 (Input Validation) ↓ 端点函数 (Endpoint) ↓ 响应序列化 (Response Serialization) ↓ 客户端响应 (Client Response) Click to expand and view more 请求首先进入 FastAPI 应用 (本质就是一个 Starlette 应用) 所有中间件优先执行 (如: 日志、错误处理、CORS等) 路由器检查路径和方法, 找到对应的处理函数 FastAPI 使用Depends解析依赖 使用 Pydantic 自动解析并验证输入数据 执行端点函数, 参数验证完毕 返回结果被序列化为合适的响应格式 (JSON) 响应返回给客户端 路由 Router 在应用对象上定义\n适合小项目或原型验证 PYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) def read_item(): return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more 使用 APIRouter 模块化\n适合大项目 PYTHON Collapse Copy from fastapi import FastAPI router = APIRouter(prefix=\u0026#34;/users\u0026#34;, tags=[\u0026#34;users\u0026#34;]) @router.get(\u0026#34;/{user_id}\u0026#34;) def get_user(user_id: int): return {\u0026#34;user_id\u0026#34;: user_id} Click to expand and view more 使用APIRouter可以将相关的端点分组, 添加前缀和标签, 保持代码结构清晰模块化 当某个请求与端点匹配时, FastAPI 内部执行一下步骤:\nStarlette 找到对应路由, 并创建一个APIRouter实例 FastAPI 使用get_router_header()包装端点函数并解析依赖 使用 Pydantic 或基本类型对请求数据解析与验证 装饰函数被调用, 传入验证后的参数 返回值被序列化为响应对象 依赖注入: 干净、可复用的逻辑 FastAPI 有一个轻量且强大的依赖注入系统, 可以进行数据库链接、身份验证信息或配置信息等\nPYTHON Collapse Copy from fastapi import Depends def get_db(): db = create_db_session() try: yield db finally: db.close() @app.get(\u0026#34;/items/\u0026#34;) def read_items(db=Depends(get_db)): return db.query(item).all() Click to expand and view more 使用Depends, FastAPI 会负责调用get_db, 处理生成器生命周期, 并将结果注入到函数中\n原生支持异步 (Async) 不同于一些后加入 async 的框架, FastAPI 一开始就设计为支持 async/await\nPYTHON Collapse Copy from fastapi import FastAPI import asyncio app = FastAPI() @app.get(\u0026#34;/hi\u0026#34;) async def greet(): await asyncio.sleep(1) return \u0026#34;Hello? World?\u0026#34; Click to expand and view more 当 fastapi 收到 /hi 这个 URL 的 GET 请求时，会自动调用 async greet(), 无需在任何地方添加 await\n但是, 对于其他的 async def 函数, 调用的时候必须在前面加上 await\nFastAPI 会运行一个异步事件循环，用于执行异步路径函数(async path functions)，同时也会使用一个线程池来处理同步函数(synchronous path functions), 这样就不需要手动调用 asyncio.gather() 和 asyncio.run() 之类的方法\n示例: CURD API PYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str = None price: float tax: float = None @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item): total = item.price + (item.tax or 0) return {\u0026#34;name\u0026#34;: item.name, \u0026#34;total_price\u0026#34;: total} @app.get(\u0026#34;/\u0026#34;) def read_root(): return {\u0026#34;message\u0026#34;: \u0026#34;FastAPI is working!\u0026#34;} Click to expand and view more 运行\nPLAINTEXT Collapse Copy uvicorn main:app --reload Click to expand and view more 还可以使用 Gunicorn 部署4个 Uvicorn 异步服务 PLAINTEXT Collapse Copy gunicorn main:app --workers 4 --worker-class \\ uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000 Click to expand and view more 实际上也可以直接诶使用 uvicorn 运行多个进程, 但是这样无法进行进程管理，因此使用 gunicorn 的方法一般更多被使用 性能提升 如果 API 返回大量数据, 使用 ORJSON 加快序列化速度\nPYTHON Collapse Copy from fastapi import FastAPI from fastapi.responses import ORJSONResponse app = FastAPI(default_response_class=ORJSONResponse) Click to expand and view more ","title":"How FastAPI Works"},{"link":"/posts/blaugust/","text":"🎈 Oh hello, August! It\u0026rsquo;s time for Blaugust.\nBlaugust Begins: Writing as a Develpoer Habit This year, I\u0026rsquo;m joining Blaugust - a month-long blogging challenge that encourage consistent writing throught August. For develpoers, blogging isn\u0026rsquo;t just sharing, it\u0026rsquo;s about orgainzing thoughts, documenting ideas, and creating term references.\nWhat I Plan to Write Here is what I aim to cover this month:\nDaily dev partices: tools, logging, project structure patterns Python ecosystem: FastAPI, Pydantic, Langchain, Pytest and more AI project logs: buliding AI agents and orchestration workflows Architecture notes: async patterns, micorservice, data flow Learning notes \u0026amp; translation of blogs: deep dive into code and quality tech atricles I\u0026rsquo;m not necessarily writing one post per day - some days I might write multiple posts in advance - but the goal is to publish daily with a focus on consistency, reusability, and value.\nWriting Platform and Setup This blog is build with Hugo + Github Pages, using the narrow theme. Markdown keeps things simple, and version control is headled vai Git.\nRSS feed is available (blogroll exchange is welcome!)\nIf you\u0026rsquo;re blogging too or joining Blaugust, feel free to connect 👋 ","title":"Blaugust"}],"tags":[]}