{"categories":[],"pages":[],"posts":[{"link":"/posts/http-methods-status-codes-and-payloads/","text":"本篇文章基于 REST api 介绍HTTP请求方法、HTTP响应码和API数据载荷, 是之前介绍 REST 那篇文章的延伸\nHTTP Methods HTTP Status Codes ","title":"HTTP Methods, Status Codes and Payloads"},{"link":"/posts/redis-string/","text":"介绍Redis中的字符串键\n字符串 字符串建是 Redis 最基本的键值对类型, 这种类型的键值对会在数据库中把单独的一个值关联起来, 被关联的键和值可以为文本, 也可以是图片, 视屏, 音频等二进制数据.\nSET: 为字符串键设置值 O(1) SET key value\n```Redis SET number \u0026quot;10086\u0026quot; \u0026gt; OK SET book \u0026quot;Redis in action\u0026quot; \u0026gt; OK ``` 对于已经存在的 key, 再次赋值会覆盖原值, 若不想覆盖后面添加参数 NX, 相反, 默认 XX 允许覆盖 ```Redis SET key \u0026quot;10086\u0026quot; NX \u0026gt; (nil) SET key \u0026quot;10086\u0026quot; XX \u0026gt; OK ``` GET: 获取字符串键的值 O(1) GET key\n```Redis GET number \u0026gt; \u0026quot;10086\u0026quot; ``` 对于不存在的值, 返回空 ```Redis GET key_new \u0026gt; (nil) ``` GETSET: 获取旧值并更新值 O(1) GETSET key new_value\n```Redis GETSET key \u0026quot;123456\u0026quot; \u0026gt; \u0026quot;10086\u0026quot; ``` 示例: 缓存 对数据进行缓存是Redis最常见的用法之一, 将数据存储在内存比存储在硬盘要快得多 首先定义缓存\nPYTHON Collapse Copy class Cache: def __init__(self, client): self.client = client def set(self, key, value): self.client.set(key, value) def get(self, key): return self.client.get(key) def update(self, new_value, key): return self.client.getset(key, new_value) # 设置新值, 返回旧值 Click to expand and view more 然后缓存文本数据\nPYTHON Collapse Copy client = Redis(decode_responses=True) # 使用文本编码方式打开客户端 cache = Cache(client) cache.set(\u0026#34;web_page\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;\u0026lt;p\u0026gt;hello world\u0026lt;/p\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;) print(cache.get(\u0026#34;web_page\u0026#34;)) print(cache.update(\u0026#34;web_page\u0026#34;, \u0026#34;\u0026lt;html\u0026gt;\u0026lt;p\u0026gt;update\u0026lt;p\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;)) print(cache.get(\u0026#34;web_page\u0026#34;)) Click to expand and view more 下面是存储一个二进制图片的缓存示例\nPYTHON Collapse Copy client = Redis() # 二进制编码打开客户端 cache = Cache(client) image = open(\u0026#34;DailyBing.jpg\u0026#34;, \u0026#34;rb\u0026#34;) # 二进制只读方式打开图片 data = image.read() # 读取文件内容 image.close() # 关闭文件 cache.set(\u0026#34;daily_bing.jpg\u0026#34;, data) # 将二进制图片缓存到键 daily_bing.jpg 中 print(cache.get(\u0026#34;daily_bing.jpg\u0026#34;)[:20]) # 读取二进制数据的前20字节 Click to expand and view more b\u0026rsquo;\\xff\\xd8\\xff\\xe0\\x00\\x10JFIF\\x00\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00'\n示例: 锁 锁是一种同步机制, 用于保证一种资源任何时候只能被一个进程使用. 一个锁的实现通常有获取 (acquire) 和释放 (relase) 这两种操作.\n获取操作用于获取资源的独占使用权, 任何时候只能有一个进程取得锁, 此时, 取得锁的进程称为锁的持有者. 释放操作用于放弃资源的独占使用权, 一般由持有者调用. PYTHON Collapse Copy from redis import Redis VALUE_OF_LOCK = \u0026#34;locking\u0026#34; class Lock: def __init__(self, client, key): self.client = client self.key = key def acquire(self): result = self.client.set(self.key, VALUE_OF_LOCK, nx=True) return result is True def relase(self): return self.client.delete(self.key) == 1 client = Redis(decode_responses=True) lock = Lock(client, \u0026#39;test-lock\u0026#39;) print(\u0026#34;第一次获取锁:\u0026#34;, lock.acquire()) print(\u0026#34;第二次获得锁:\u0026#34;, lock.acquire()) print(\u0026#34;取消锁:\u0026#34;, lock.relase()) print(\u0026#34;第三次获得锁:\u0026#34;, lock.acquire()) Click to expand and view more 第一次获取锁: True 第二次获得锁: False 取消锁: True 第三次获得锁: True\n若要设置锁的时间 SET key value NX EX time 这样是原子性语法, 删除操作对应命令是 DEL key, 返回0表示 key 不存在, 返回1~N表示删除key的数量.\nNX 确保锁只有在没有值时加锁成功, 若有值则返回 None, 通过检查 result 是否为 True 来判断是否获得了锁.\nMSET: 一次为多个字符串键设置值 O(N) MSET key value [key value \u0026hellip;]\n同 SET 命令, MSET 执行成功后返回 OK, 并且会用新值覆盖旧值. 由于执行多条 SET 命令要客户端和服务端之间多次进行网络通讯, 因此 MSET 能减少程序执行操作的时间\nMGET: 一次获取多个字符串键的值 O(N) MGET key [key \u0026hellip;]\nMSETNX: 只在键不存在的情况下, 一次为多个键设置值 MSETNX key value [key value \u0026hellip;]\n若有任意一次键存在值, 则会取消所有操作, 并返回0. 只有所有键都没有值的时候, 执行才成功, 返回1.\n示例: 存储文章信息 在构建应用程序的时候, 经常会需要批量设计和获取多项信息, 以博客为例:\n当用户注册博客时, 程序将用户名字、帐号、密码、注册时间等存储起来, 并在登陆时查取这些信息. 当编写一篇博客文章时, 就要将博客标题、内容、作者、发表时间存储起来, 并在用户阅读的时候取出这些信息. 通过 MSET、MSETNX、MGET 命令, 可以实现上面提到的这些批量设置和批量获取操作\nPYTHON Collapse Copy from redis import Redis from datetime import datetime class Article: def __init__(self, client, article_id): \u0026#34;\u0026#34;\u0026#34;根据id创建文章id\u0026#34;\u0026#34;\u0026#34; self.client = client self.id = str(article_id) self.title_key = \u0026#34;article::\u0026#34; + self.id + \u0026#34;::title\u0026#34; self.content_key = \u0026#34;article::\u0026#34; + self.id + \u0026#34;::content\u0026#34; self.author_key = \u0026#34;article::\u0026#34; + self.id + \u0026#34;author\u0026#34; self.create_at_key = \u0026#34;article::\u0026#34; + self.id + datetime.now() def create(self, title, content, author): \u0026#34;\u0026#34;\u0026#34;创建文章\u0026#34;\u0026#34;\u0026#34; article_data = { self.title_key: title, self.content_key: content, self.author_key: author, self.create_at_key: datetime.now(), } return self.client.msetnx(article_data) def get(self): \u0026#34;\u0026#34;\u0026#34;获取文章信息\u0026#34;\u0026#34;\u0026#34; result = self.client.mget( self.title_key, self.content_key, self.author_key, self.create_at_key, ) return { \u0026#34;id\u0026#34;: self.id, \u0026#34;title\u0026#34;: result[0], \u0026#34;content\u0026#34;: result[1], \u0026#34;author\u0026#34;: result[2], \u0026#34;create_at_key\u0026#34;: result[3], } def update(self, title=None, content=None, author=None): \u0026#34;\u0026#34;\u0026#34;更新文章\u0026#34;\u0026#34;\u0026#34; article_data = {} if title is not None: article_data[self.title_key] = title if content is not None: article_data[self.content_key] = content if author is not None: article_data[self.author_key] = author return self.client.mset(article_data) client = Redis(decode_responses=True) article = Article(client, 10086) # 创建文章 print(article.create(\u0026#34;message\u0026#34;, \u0026#34;hello world\u0026#34;, \u0026#34;sx\u0026#34;)) # 获取文章信息 print(article.get()) # 更新文章作者 print(article.update(author=\u0026#34;join\u0026#34;)) Click to expand and view more 上面程序使用了多个字符串键存储文章信息: article::\u0026lt;id\u0026gt;::\u0026lt;attribute\u0026gt;\nSTRLEN: 获取字符串的字节长度 O(1) STRLEN key\n对于存在的键, 返回字节长度信息. 对于不存在的键, 返回0\nGETRANGE: 获取字符串值指定索引范围上的内容 O(N) GETRANGE key start end\nREDIS Collapse Copy SET message \u0026#34;hello world\u0026#34; GETRANG message 0 4 \u0026gt; hello GETRANGE message -5 -1 \u0026gt; world Click to expand and view more SETRANGE: 修改字符串索引范围的值 O(N) SETRANGE key index subsitute\nREDIS Collapse Copy set message \u0026#34;hello world\u0026#34; SETRANGE message 6 Redis \u0026gt; (integer) 11 GET message \u0026gt; hello Redis Click to expand and view more 当用户给定的新内容比被替换内容长的时候, SETRANGE 会自动扩展被修改的字符串值\nREDIS Collapse Copy SETRANGE message 5 \u0026#34;, this is a message\u0026#34; \u0026gt; (integer) 24 GET message \u0026gt; \u0026#34;hello, this is a message\u0026#34; Click to expand and view more 当用户给出的索引长度超出被替换字符长度时, 字符串末尾到 index-1 之间部分将使用空字符串填充为0\nREDIS Collapse Copy SET greeting \u0026#34;hello\u0026#34; SETRANGE greeting 10 \u0026#34;hello\u0026#34; \u0026gt; (integer) 15 GET greeting \u0026gt; \u0026#34;hello\\x00\\x00\\x00\\x00\\x00world\u0026#34; Click to expand and view more 示例: 给文章存储程序加上文章长度计数功能和文章御览功能给 文章长度计数功能: 显示文章长度, 用于估计阅读时长 文章预览功能: 显示文章开头一部分内容, 帮助读者快速了解文章 PYTHON Collapse Copy class Article: ... def get_content_len(self): return self.client.strlen(self.content_key) def get_content_perview(self, preview_len): start_index = 0 end_index = preview_len - 1 return self.client.getrange(self.content, start_index, end_index) Click to expand and view more APPEND: 追加新内容到值的末尾 APPEND key suffix\n若用户给定的 key 不存在, 则相当于 SET key suffix\n示例: 存储日志 很多程序运行的时候会产生日志, 日志记录了程序的运行状态以及执行过的重要操作. 若每条日志存储一个键值对, 则会消耗很多资源, 且分散在数据库中, 需要额外的时间查找日志, 这里将不同日志拼接在同一个值里面.\nPYTHON Collapse Copy from redis import Redis LOG_SEPERATOR = \u0026#34;\\n\u0026#34; class Log: def __init__(self, client, key): self.client = client self.key = key def add(self, new_log): new_log += LOG_SEPERATOR self.client.append(self.key, new_log) def get_all(self): all_logs = self.client.get(self.key) if all_logs is not None: log_list = all_logs.split(LOG_SEPERATOR) log_list.remove(\u0026#34;\u0026#34;) # 删除默认多余的空字符串 return log_list else: return [] Click to expand and view more 数字值 下面介绍使用字符串键存储数字值:\n每当存储一个值到字符串键里面的时候, 有下面两种情况\nC 语言 long long int 类型的整数, 取值范围为 -2^63 ~ 2^63-1 (超出范围会被当成字符串) C 语言 long double 类型的浮点数 为了方便地处理字符串键的值, Redis 提供了一系列加法和减法操作命令, 下面介绍这些命令\nINCRBY, DECRBY: 对整数执行加法和减法操作 O(1) INCRBY key increment DECRBY key increment\n如果类型为浮点数, 使用上面方法会报错 (key的值 和 increment 都必须为整数) 当该命令遇到**不存在的键**时, 会将键的值初始化为0, 然后再执行操作 INCR, DECR: 对整数执行加1和减1操作 O(1) INCR key DECR key\nINCRBYFLOAT: 对数字值执行浮点数加减法操作 INCRBYFLOAT key increment\nINCRBYFLOAT 命令即执行加法操作, 也可以执行加法操作, 并且操作对象和 increment 都既可以为整数也可以为浮点数 虽然 Redis 没有限制字符串键存储浮点数的小数位数, 但是 INCRBYFLOAT 最多只会保留小数点后的17位数字, 超出部分将被截断 示例: ID 生成器 identifier 标识符, 经常在程序中使用, 通常以数字形式出现, 并通过递增的方法创建新的ID.\nPYTHON Collapse Copy from redis import Redis class IdGenerator: def __init__(self, client, key): self.client = client self.key = key def produce(self): \u0026#34;\u0026#34;\u0026#34;生成下一个id\u0026#34;\u0026#34;\u0026#34; return self.client.incr(self.key) def reserve(self, n): \u0026#34;\u0026#34;\u0026#34;初始化\u0026#34;\u0026#34;\u0026#34; result = self.client.set(self.key, n, nx=1) # key 不存在才行 return result is True client = Redis(decode_responses=True) id_generator = IdGenerator(client, \u0026#34;user::id\u0026#34;) print(id_generator.reserve(1000000)) # 保留100万个ID -\u0026gt; True print(id_generator.produce()) # 生成ID, 均大于100万 print(id_generator.reserve(1000)) # 已存在 -\u0026gt; False Click to expand and view more 示例: 计数器 除了ID生成器, 计数器也是常用的组件之一, 例如点赞回复数量, 播放量等.\nPYTHON Collapse Copy from redis import Redis class Counter: def __init__(self, client, key): self.client = client self.key = key def increase(self, n=1): return self.client.incr(self.key, n) def decrease(self, n=1): return self.client.decr(self.key, n) def get(self): value = self.client.get(self.key) if value in None: return 0 else: return int(value) def reset(self): old_value = self.client.getset(self.key) if old_value is None: return 0 else: return(old_value) client = Redis(decode_responses=True) counter = Counter(client, \u0026#34;counter::page_viewed\u0026#34;) print(counter.increase()) # +1 print(counter.increase()) print(counter.increase(10)) # +10 print(counter.decrease()) # -1 print(counter.decrease(5)) # -5 print(counter.reset()) # 重置计数器 print(counter.get()) # 返回计数器当前值 Click to expand and view more 注: 在 redis-py 中 INCR 和 INCRBY 都使用 .incr() 方法\n示例: 限速器 为了保障系统的安全性和性能, 并保证重要资源不被滥用, 应用程序需要对用户的行为进行限制\n防止网络爬虫: 限制每个IP地址在固定时间段内访问的页面数量 防止爆力破解: 当用户多次输入错误的密码, 会帐号进行冻结 上面机制的实现可以使用限速器, 下面是一个限速器示例代码, 该程序将操作最大可执行次数存储在一个字符串里面, 每次用户进行该操作后就将其减1\nPYTHON Collapse Copy from redis import Redis class Limter: def __init__(self, client, key): self.client = client self.key = key def set_max_execute_times(self, max_execut_time): self.client.set(self.key, max_execut_time) def still_valid_to_execute(self): num = self.client.decr(self.key) return (num \u0026gt;= 0) def remaining_execute_times(self): num = int(self.client.get(self.key)) if num \u0026lt; 0: return 0 else: return num client = Redis(decode_responses=True) limter = Limter(client, \u0026#34;wrong_password_limter\u0026#34;) print(limter.set_max_execute_times(5)) # 最多5次输入错误密码 print(limter.still_valid_to_execute()) # 前5次 True, 之后 False Click to expand and view more ","title":"Redis String"},{"link":"/posts/ieee-754-introduce/","text":"IEEE 754 标准数值类型及分类\n整数 Integer 整数是没有小数部分的值, 在计算机内通常有两种表示方式:\n有符号整数: 可以表示正数和负数, 最常用的是二补码表示. 例如 8 位二进制的范围为[-2^7, 2^7-1] 无符号整数: 仅表示非负数, 8 位二进制的范围为 [0, 2^8-1] 其中补码(Two\u0026rsquo;s Complement)用于表示负数\n正数补码与原码相同 负数的补码 = 该数绝对值的二进制取反 + 1 通过补码, 可以使得加减运算统一, 溢出检测更加简单\n浮点数 Floating-point 浮点数用于表示带小数的实数, 尤其适合科学计算和近似表示很大或很小的数值. IEEE 754 定义了浮点数的标准格式, 类似科学计数法:\nPLAINTEXT Collapse Copy value = (-1)^(sign) x mantissa x 2^(exponent) Click to expand and view more 浮点数由三部分组成:\n符号位 sign: 0/1代表正负 阶码 exponent: 通常使用偏移表示法 尾数 fraction/mantissa: 小数部分 常见浮点数类型:\n单精度 float32: 1 位符号 + 8 位阶码 + 23 位尾数 双精度 float64: 1 位符号 + 11 位阶码 + 52 位尾数 浮点数的分类 Categories 以 64 精度为例\n部分 位数 描述 符号位（sign） 1 0 表示正数，1 表示负数 阶码（exponent） 11 偏移量（bias）为 1023，表示数值的量级 尾数（fraction / mantissa） 52 有效数字，不包括隐藏位 浮点数的表示公式:\nPLAINTEXT Collapse Copy value = (-1)^sign x (1 + fraction) x 2^(exponent - bias) Click to expand and view more 正常数 Normalized numbers\n阶码 exponent: 不全为0, 也不全为1, [1, 2^11-2] 尾数 fraction: 隐含1, [0, 1 - 2^-52], (52位全1 位 1 - 2^-52) PLAINTEXT Collapse Copy value = (-1)^sign x (1 + fraction) x 2^(exponent - 1023) Click to expand and view more 其中, bias = 2^(exponent - 1) - 1, 这里为 1023\n最大正常数: 阶码最大为 1024*2-2 = 2046, 尾数全为1 1-2^-52, 即 ( 1 + (1 - 2^-52) ) x 2^(2026-1023) 最小正常数: 阶码最小位 1, 尾数全为0, 即 ( 1 + 0 ) x 2^(1-1023) 非正规数 Subnormal numbers / Denormalized numbers\n阶码 exponent: 全0 尾数 fraction: [0, 1-2^-52], 没有隐藏位1 PLAINTEXT Collapse Copy value = (-1)^sign x (fraction) x 2^(1 - bias) Click to expand and view more 非正规数指数紧接最小正常数, 使非正规数数值连续接近零\n注意: 非正规数的指数并不是阶码减 bias 的直接结果(0−1023 = −1023), 而是约定使用最小正常数指数 E_min = −1022. 这样可以让非正规数顺接正常数, 形成连续的可表示范围, 并支持渐进下溢.\n最大非正规数: 阶码为0, 尾数全为1, 即 ( 1 - 2^-52 ) x 2^(-1022) 最小非正规数: 阶码位0, 尾数最低位为1, 其他为0, 即 ( 2^-52 x 2^(-1022) ) 零 0\n符号 sign: 0/1 正负零 阶码 exponent: 0 尾数 fraction: 0 无穷 infinity\n符号sign: 0/1 正负无穷 阶码 exponent: 2047 (全1) 尾数 fraction: 0 非数值 NaN\n阶码 exponent: 2047 (全1) 尾数 fraction != 0 表示未定义或非法运算, 如 0/0\n类别 (categories) 符号位 (sign) 阶码 (exponent) 尾数 (fraction / mantissa) 描述 正常数 0 或 1 [1, 2046] 1.f 范围: [1.0, 2-ε) 阶码非全0且非全1, 尾数隐含最高位1 非正规数 0 或 1 全 0 0.f 范围: (0, 1.0-ε] 阶码全0, 尾数非全0, 无隐藏位1, 接近0 ±0 0 或 1 全 0 全 0 阶码全0, 尾数全0 ±∞ 0 或 1 全 1 [2047] 全 0 阶码全1, 尾数全0 NaN (qNaN / sNaN) 0 或 1 全 1 [2047] 非全 0 阶码全1, 尾数非全0, 表示无效或未定义运算 注意: 非正规数的阶码虽然为全0, 但是计算时约定为 1-bias = 1-1023 = -1022, 而不是像正规数那样 exponent - bias\n","title":"IEEE-754 Introduce"},{"link":"/posts/designing-and-building-rest-apis/","text":"这篇文章延续之前微服务的内容, 将介绍关于 REST API 的以下几个方面:\nREST API 的设计原则 Richardson maturity model (RMM) 如何帮助理解 REST 的优势和设计原则 REST API 中资源(resource)和端点(endpoints)设计的概念 表达性状态转移 representational state transfer (REST) 描述了一种通过网络进行通信的应用程序架构风格. 最初, REST 的概念包含了一组用于设计分布式、可扩展 Web 应用的约束条件. 随着时间推移, 出现了更为细致的协议和规范, 为 REST API 的设计提供了明确的指导方针. 如今, REST 已经成为构建 Web API 的最流行选择.\n下面将继续在 CoffeeMesh 项目上, 设计相关订单 API.\nWhat is REST? REST 由 Roy Fielding 在他的博士论文 \u0026ldquo;Architectural Styles and the Design of Network-based Software Atchitecture\u0026rdquo; (PhD diss. University of California,Irvine,2000,p. 109) 中创造.\n定义: REST 是一个松耦合和高伸缩的 API 架构风格. REST APIs 以资源为核心来组织, 这些资源是可以通过 API 操作的实体.\n资源 resource 是可以通过唯一的 URL 来标识的实体, 有两种类型: 集和 collections 和 单体 singletons. 单体标识一个单独的实体, 而集和标识一组实体.\n例如, 在 CoffeeMesh 的订单服务负责管理订单, 通过 /orders/{order_id} 访问特定订单, 是一个单体端点(singleton endpoint); 而所有订单通过 /orders 获取, 是一个集和端点 (collection endpoint).\n某些资源还可以嵌套进其他资源中, 例如一个订单的 payload 中, 可能包含一个嵌套数组列出该订单的多个商品 , 例如下面这样:\nJSON Collapse Copy { \u0026#34;id\u0026#34;: \u0026#34;924721eb-a1a1-4f13-b384-37e89c0e0875\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;progress\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2023-09-01\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;cappuccino\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;small\u0026#34;, \u0026#34;quantity\u0026#34;: 1 }, { \u0026#34;product\u0026#34;: \u0026#34;croissant\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ] } Click to expand and view more 可以创建一个嵌套端点来表示嵌套资源, 例如通过 GET /orders/{order_id}/status 端点查询订单的状态和细节信息. 当资源对应的负载 payload 较大时, 使用嵌套端点是一种常见的优化策略, 例如只想知道状态信息, 就不需要查询大量的详细数据了, status 端点返回信息如下:\nJSON Collapse Copy { \u0026#34;status\u0026#34;: \u0026#34;processing\u0026#34; } Click to expand and view more Architectural constraints of REST applications 这里解释 REST 应用的架构约束, 这些约束由 Fielding 列出, 用于规定服务器应如何处理并响应客户端请求. 下面是每个约束的简单描述:\nClient-server architecture 客户端-服务器架构: 用户界面必须与后端解耦 decoupled Statelessness 无状态性: 服务器不能在请求之间维护状态 Cacheability 可缓存性: 返回相同内容的请求, 应支持缓存 Layered system 分层系统: API 按层架构, 但要向用户隐藏复杂性 Code on demand 按需代码: 服务器可以按需将代码注入到用户界面 Uniform interferace 统一接口: API 必须提供一致的接口来访问和操作资源 Separation of concers: The client-server architecture principle 关注点分离: 客户端-服务器架构原则\nREST 依赖于关注点分离原则, 因此要求用户界面(UI)必须于数据存储和服务器逻辑解耦. 这样一来, 服务器组件就可以独立于 UI 元素进行开发. 一种常见的实现方法是: 将 UI 构建为一个独立应用, 例如单页应用(SPA)\nMake it scalable: The statelessness principle 可扩展性: 无状态原则\n在 REST 中, 每一次对服务器的请求都必须包含处理该请求的全部信息. 特别是, 服务器不能在请求之间保持状态. 将状态管理从服务器组件中移除, 可以更容易地对后端进行水平扩展, 这使得我们能够部署多个服务器示例, 并且由于这些实例都不管理 API 客户端的状态, 客户端就可以于任意一个实例进行通信.\nOptimize for performance: The cacheability principle 性能优化: 可缓存原则\n在适用的情况下, 服务器必须是可缓存的. 缓存提升 API 的性能, 这意味着不必一次又一次地执行生成响应所需要的计算. GET 请求适合缓存, 因为他们返回的是服务器中已保存的数据. 通过缓存 GET 请求, 可以避免在用户每次请求相同信息时都从数据源重新获取数据, 生成 GET 请求响应所需要的时间越长, 缓存所带来的收益就越大.\nMake it simple for the client: The layered system principle 让客户端更简单: 分层系统原则\n在 REST 架构中, 客户端必须通过一个唯一的入口访问 API, 而且不应该知道自己是直接连接到最终服务器, 还是连接到某个中间层(例如负载均衡器). 可以把服务端的应用的不同组件部署在不同的服务器上, 或者把相同的组件部署在多个服务器上, 以实现冗余和壳扩展性. 但这些复杂性必须对用户隐藏, 只暴露一个统一的入口来封装服务访问.\nExtendable interferaces: The code-on-demand principle 可扩展接口: 按需代码原则\n服务器可以通过直接从后端发送可执行代码, 来扩展客户端应用的功能. 这个约束是可选的, 只适用于后端提供客户端界面的应用.\nKeep it consistent: The uniform interface principle 保持统一性: 统一接口原则\nREST 应用必须向其使用者提供统一且一直的接口, 接口必须有文档说明, 服务器和客户端必须严格遵循 API 规范. 每个资源通过统一资源标识符(URI)来标识, 每个 URI 必须唯一, 并且始终返回相同的资源. 资源必须使用某种序列化方法表示, 并且这种方法在整个 API 中应保持一致. 如今, REST API 通常使用 JSON 作为序列化格式, 但也可以使用其他格式, 例如 XML.\nHypermedia as the engine of application state 超媒介作为应用状态引擎 (HATEOAS)\n在 2008 年发表的一篇题为REST APIs Must Be Hypertext-Driven的文章中, Fielding 提出:\nREST API 的响应必须包含相关链接, 以便客户端可以通过这些链接导航 API\nHATEOAS 是 REST API 设计中的一种范式(paradigm), 它强调可发现性. 每当客户端向服务器请求某个资源时, 响应必须包含指向该资源的相关链接列表. 例如, 客户端请求订单详情时, 响应必须包含取消订单和支付订单的相关链接.\n例如下面这样\nJSON Collapse Copy { \u0026#34;id\u0026#34;: 8, \u0026#34;status\u0026#34;: \u0026#34;progress\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2025-8-16\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;cappuccino\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;small\u0026#34;, \u0026#34;quantity\u0026#34;: 1 }, { \u0026#34;product\u0026#34;: \u0026#34;croissant\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ], \u0026#34;links\u0026#34;: [ { \u0026#34;href\u0026#34;: \u0026#34;/orders/8/cancel\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Cancels the order\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;POST\u0026#34; }, { \u0026#34;href\u0026#34;: \u0026#34;/orders/8/pay\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Pays for the order\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;POST\u0026#34; } ] } Click to expand and view more 提供关联链接可以使 API 具有可导航性, 更易于使用, 因为每个资源都会附带与之交互所需的所有 URL. 然而在实际中, 许多 API 并没有这样实现, 原因包括:\n超链接提供的信息在 API 文档中已经可用 实际上, OpenAPI 规范中包含的信息比单独为特定资源提供的相关链接列表要丰富和结构化得多 不总是清楚应该返回哪些链接 不同用户拥有不同的权限和角色, 可以执行不同操作和访问不同资源 例如，CoffeeMesh API 的外部用户可以使用 POST /orders 下单, 也可以使用 GET /orders/{order_id} 查询订单详情, 但不能使用 DELETE /orders/{order_id} 删除订单, 因为该接口仅限内部用户 如果 HATEOAS 的目标是让 API 可以从单一入口导航, 那么向外部用户返回他们无法使用的 DELETE 链接显然没有意义 因此, 需要根据用户权限返回不同的相关链接列表, 但这会增加 API 设计和实现的复杂性, 并将授权层与 API 层耦合 资源状态可能限制某些操作 例如, POST /orders/1234/cancel 只能在活跃订单上调用, 而无法对已取消订单调用 这种不确定性会增加遵循 HATEOAS 原则的接口设计和实现难度 响应负载可能过大 在一些 API 中, 相关链接列表可能非常庞大, 使响应体变大, 从而影响 API 性能, 以及对网络连接较差的小设备的可靠性 在设计自己的 API 时, 可以根据实际情况决定是否遵循 HATEOAS 原则, 在某些情况下是有用的, 例如:\n在 Wiki 应用中, 响应中的 \u0026ldquo;linked resources\u0026rdquo; 部分可以列出\n与某篇文章相关的内容 该文章的多语言版本链接 可以对文章执行的操作链接 总体来说, 需要在 API 文档已经清晰详细提供信息 与 通过响应辅助客户端交互 之间找到平衡\n面向公众的 API: 客户端会从关联链接中受益 小型内部 API: 通常不需要提供关联链接 Analyzing the matruity of an API with the Richardson maturity model 使用 Richardson 成熟度模型分析 API 的成熟度\n这是由 Leonard Richardson 提出的一种思维模型, 用于帮助评估一个 API 在多大程度上遵循了 REST 原则, Richardson 成熟度模型将 API 的\u0026quot;成熟度\u0026quot;划分为四个等级: 0. Level 0: RPC over HTTP\nLevel 1: Resources Level 2: HTTP methods and status codes Level 3: Hypermedia controls (HATEOAS) Glory of REST! Level 0: Web APIs à la RPC 类似 PRC 的 Web API\n在0级中, HTTP 本质上只作为一种传输系统, 用于承载与服务器的交互. 在这种情况下, API 的概念更接近 远程过程调用(remote procedure call, RPC). 所有服务器的请求都在同一个端点发起, 并使用相同的 HTTP 方法, 客户端请求的具体细节通过 HTTP 的 payload 传递.\n例如, 在 CoffeeMesh 网站下单时, 客户端可能会向通用 /api 端点发送如下 POST 请求:\nJSON Collapse Copy { \u0026#34;action\u0026#34;: \u0026#34;placeOrder\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;mocha\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ] } Click to expand and view more 服务器通常会返回200状态码, 并附带一个 payload, 告诉请求处理结果.\n类似地, 要获取某个订单的详情, 客户端也可能向通用 /api 端点发送如下 POST 请求:\nJSON Collapse Copy { \u0026#34;action\u0026#34;: \u0026#34;getOrder\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;id\u0026#34;: 8 } ] } Click to expand and view more Level 1: Intorducing the concept of resource 第1级引入了资源 URL 的概念, 服务器不再使用通用的 /api 端点, 而是暴露表示资源的 URL. 例如:\n/orders 表示订单集和 /order/{order_id} 表示单个订单 要下单时, 客户端向 /orders 端点发送 POST 请求, payload 与 0 级类似\nJSON Collapse Copy { \u0026#34;action\u0026#34;: \u0026#34;placeOrder\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;mocha\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ] } Click to expand and view more 在这一层, API 还没有使用不同的 HTTP 方法来区分不同操作\nLevel 2: Using HTTP methods and status codes 第2级引入了 HTTP 请求方法verbs 和 状态码status 的概念, 这一层, HTTP verbs 用于表示具体操作. 例如, 要下订单, 客户端向 /orders 端点发送一个 POST 请求, 内容如下:\nPYTHON Collapse Copy { \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;mocha\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ] } Click to expand and view more 在这个例子中, HTTP 方法 POST 表示要执行的操作, 而请求体仅包含想要下的订单的具体信息\n类似地, 如果要获取某个订单的详细信息, 我们会向该订单的 URI 发送 GET 请求: /orders/{order_id}. 这里使用 GET 告诉服务器, 希望获取 URI 指定资源的详细信息\n前几个级别的响应通常都使用相同的状态码(通常为 200), 而第二级引入了 HTTP 状态码的语义化使用, 用来报告客户端请求处理的结果. 例如:\n使用 POST 创建资源时, 服务器会返回 201 Created 状态码 请求不存在的资源时, 会返回 404 Not Found 状态码 Level 3: API discoverability 第3级引入了可发现性的概念, 通过 HATEOAS 原则, 并在响应中添加表示可对资源执行操作的链接来实现.\n例如, 对 /orders/{order_id} 端点发送 GET 请求, 会返回该订单的表示(representation), 并包含一系列相关链接\nPYTHON Collapse Copy { \u0026#34;id\u0026#34;: 8, \u0026#34;status\u0026#34;: \u0026#34;progress\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2023-09-01\u0026#34;, \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;cappuccino\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;small\u0026#34;, \u0026#34;quantity\u0026#34;: 1 }, { \u0026#34;product\u0026#34;: \u0026#34;croissant\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 2 } ], \u0026#34;links\u0026#34;: [ { \u0026#34;href\u0026#34;: \u0026#34;/orders/8/cancel\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Cancels the order\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;POST\u0026#34; }, { \u0026#34;href\u0026#34;: \u0026#34;/orders/8/pay\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Pays for the order\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;GET\u0026#34; } ] } Click to expand and view more 在 Richardson 成熟度模型中, 第三级代表了他所称的 \u0026ldquo;REST 的荣耀(Glory of REST)\u0026rdquo; 的最后一步\n该模型为我们提供了一个框架, 用来思考 API 设计在 REST 原则体系中的位置. 它的目的不是衡量 API 在多大程度上\u0026quot;符合\u0026quot;REST 原则, 也不是评估 API 设计的质量; 而是帮助我们思考如何充分利用 HTTP 协议, 创建表达力强、易理解、易使用的 API.\n","title":"Designing and Building REST APIs"},{"link":"/posts/intorduce-uuid/","text":"UUID(Universally Unique Identifier, 通用唯一标识符) 是一种标准化的128位标识符, 用于在分布式系统中生成几乎不会重复的唯一 ID. 最早于 IETF 制定为 RFC 4122 标准, 保证在不同机器、不同时间生成的 ID 也能保持全局唯一.\nUUID 通常以16进制表示, 采用5段结构, 用连字符 - 分隔, 例如:\nPLAINTEXT Collapse Copy 550e8400-e29b-41d4-a716-446655440000 Click to expand and view more 有如下特点:\n全局唯一 无中心依赖 不可预测 跨平台通用 UUID 有以下不同版本:\n版本 生成 特点 v1 基于时间戳 + MAC 地址 按时间排序，含生成设备信息 v3 基于命名空间的 MD5 哈希 输入相同则输出相同(MD5 已不再安全) v4 基于操作系统的随机数生成 完全随机, 最常用 v5 基于命名空间的 SHA-1 哈希 与 v3 类似, 但使用 SHA-1 v6~v8 现代版本(草案) 提高排序性能和隐私保护 其中, 对于需要时间有序的使用 v1, 大多数通用场景使用 v4\nUUID 的应用场景\n数据库主键(分布式环境避免冲突) 会话标识(Session ID、Token) 文件命名(防止重名) 分布式系统节点 ID 追踪请求链路(Trace ID) 示例代码\nPYTHON Collapse Copy import uuid # 生成 UUID v1 u1 = uuid.uuid1() print(\u0026#34;UUID v1:\u0026#34;, u1) # 生成 UUID v4（随机） u4 = uuid.uuid4() print(\u0026#34;UUID v4:\u0026#34;, u4) # 生成 UUID v3（命名空间 + MD5） u3 = uuid.uuid3(uuid.NAMESPACE_DNS, \u0026#34;example.com\u0026#34;) print(\u0026#34;UUID v3:\u0026#34;, u3) # 生成 UUID v5（命名空间 + SHA-1） u5 = uuid.uuid5(uuid.NAMESPACE_DNS, \u0026#34;example.com\u0026#34;) print(\u0026#34;UUID v5:\u0026#34;, u5) Click to expand and view more UUID v1: 9f7a1f7e-9e87-11ee-b15d-0242ac120002\nUUID v4: 5f9b44e4-62af-4d13-bd4c-52de5f028f33\nUUID v3: 9073926b-929f-31c2-abc9-fad77ae3e8eb\nUUID v5: 2ed6657d-e927-568b-95e1-2665a8aea6a2\n","title":"Intorduce UUID"},{"link":"/posts/microservice-with-fastapi/","text":"What are microservices ? 什么是微服务? 微服务可以有多种不同的定义方式, 具体取决于希望强调微服务架构的哪个方面, 不同作者会给出略有不同但相关的定义\nSam Newman, 微服务领域最有影响力的作者之一, 给出了一个极简的定义:\n“Microservices are small, autonomous services that work together.”\n这个定义强调了这样一个事实: 微服务是彼此独立运行的应用程序, 但它们可以协作完成任务. 该定义还强调微服务是 “small (小的)”, 这里的 small 并不是指微服务代码量的大小, 而是指微服务具有狭窄且定义清晰的职责范围, 符合单一职责原则(Single Responsibility Principle) —— 即“只做一件事，并把它做好”.\nJames Lewis 和 Martin Fowler 撰写的一篇开创性文章提供了一个更详细的定义, 他们将微服务定义为一种架构风格(architectural style)\n“an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API”\n这个定义强调了服务的自主性(autonomy), 指出它们运行在各自独立的进程中. Lewis 和 Fowler 同样强调了微服务职责的狭窄性(narrow scope of responsibilities), 称其为“small”, 并明确指出微服务之间通过轻量协议(如HTTP)进行通信\n定义\n微服务是一种架构风格，其中系统的各个组件被设计为可独立部署的服务(independently deployable services). 微服务围绕明确的业务子领域(business subdomains)进行设计，并通过如 HTTP 等轻量协议(lightweight protocols)相互通信 从以上定义中我们可以看到, 微服务可以被定义为一种架构风格, 其中服务作为组件执行一组小而明确的相关功能. 这意味着微服务是围绕特定的业务子领域来设计和构建的, 例如处理支付、发送邮件或处理客户订单等.\n微服务作为独立的进程进行部署, 通常运行在独立的环境中, 并通过定义清晰的接口暴露其能力\nA basic API implementation 这里通过一个 CoffeeMesh 项目的 orders service (订单服务) api 介绍微服务\n首先给出 OpenAPI 格式的 API 定义文档 oas.yaml, 可以通过 Swagger UI 来查看该文档内容 (OAS 代表 OpenAPI specification/规范, 是一种标准的 REST API 文档)\n具体 API 如下\n/orders: 检索订单(GET) 和 创建订单(POST) /orders/{order_id}: 检索某个订单的细节(GET), 更新订单(PUT) 和 删除订单(DELETE) /orders/{order_id}/cancel: 删除某个订单 /orders/{order_id}/pay: 支付订单 除了 API endpoints, 还有 data models (在 OpenAPI 中被称为 schemas). Schemas 告诉客户端需要什么样的数据载荷(payload)以及什么是类型.\n例如,OrderItemSchema 指定了 product 和 size 是必填的, 而 quantity 属性是可选的, 当这个属性消失的时候, 默认值为 1\nYAML Collapse Copy # file: oas.yaml OrderItemSchema: type: object required: - product - size properties: product: type: string size: type: string enum: - small - medium - big quantity: type: integer default: 1 minimum: 1 Click to expand and view more 请求处理流大概下面这样: HTTP request -\u0026gt; Uvicorn -\u0026gt; FastAPI(Starlette routing -\u0026gt; data -\u0026gt; api endpoints) -\u0026gt; Pydantic\n下面是一个 orders API 的最小实现\nPYTHON Collapse Copy from datetime import datetime from uuid import UUID from starlette.responses import Response from starlette import status from orders.app import app order = { \u0026#34;id\u0026#34;: \u0026#34;ff0f1355-e821-4178-9567-550dec27a373\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;delivered\u0026#34;, \u0026#34;created\u0026#34;: datetime.utcnow(), \u0026#34;order\u0026#34;: [ { \u0026#34;product\u0026#34;: \u0026#34;cappuccino\u0026#34;, \u0026#34;size\u0026#34;: \u0026#34;medium\u0026#34;, \u0026#34;quantity\u0026#34;: 1, } ] } @app.get(\u0026#34;/orders\u0026#34;) def get_orders(): return {\u0026#34;orders\u0026#34;: [orders]} @app.post(\u0026#34;/orders\u0026#34;, status_code=status.HTTP_201_CREATED) def create_order(): return order @app.get(\u0026#34;/orders/{order_id}\u0026#34;) def get_order(order_id: UUID): return order @app.get(\u0026#34;/orders/{order_id}\u0026#34;) def update_order(order_id: UUID): return order @app.delete(\u0026#34;/orders/{order_id}\u0026#34;, status_code=status.HTTP_204_NO_CONTENT) def delete_order(order: UUID): return Response(status_code=HTTPStatus.NO_CONTENT.value) @app.post(\u0026#34;/orders/{order_id}/cancel\u0026#34;) def cancel_order(order_id: UUID): return order @app.post(\u0026#34;/orders/{order_id}/pay\u0026#34;) def pay_order(order_id: UUID): return order Click to expand and view more 现在有了 API 的基本骨架, 后面将继续实现 incoming payload 和 outgoing response 的验证\nImplementing data validation models with pydantic 这里介绍 data validation 和 marshalling\n\u0026ldquo;Marshalling\u0026rdquo; 指的是将一个内存中的数据结构转换成一种适合存储或通过网络传输的格式. 在 Web API 的上下文中, Marshalling 特指将一个对象转换为一个数据结构(比如 JSON 或 XML). 以便将其序列化为所选的内容类型, 同时明确指定对象属性的映射关系\n点单系统包含了3个shcemas: CreateOrderSchema, GetOrderSchema 和 OrderItemSchema, 可以在oas.yaml查看\n下面使用 Pydantic 实现对应 schema, 可以在 schema.py找到\nPYTHON Collapse Copy from enum import Enum class Size(Enum): small = \u0026#34;small\u0026#34; medium = \u0026#34;medium\u0026#34; big = \u0026#34;big\u0026#34; class StatusEnum(Enum): created = \u0026#34;created\u0026#34; paid = \u0026#34;paid\u0026#34; progress = \u0026#34;progress\u0026#34; cancelled = \u0026#34;cancelled\u0026#34; dispatched = \u0026#34;dispatched\u0026#34; delivered = \u0026#34;delivered\u0026#34; Click to expand and view more 对于只能从特定值中选择的类型, 定义枚举类型 Size 和 StatusEnum\nPYTHON Collapse Copy class OrderItemSchema(BaseModel): product: str size: Size quantity: conint(ge=1, strict=True) | None = 1 Click to expand and view more 将 OrderItemSchema 的属性设置为 conint, 这将强制使用整数值, 并且规定数值要大于等于1, 以及默认值1\nPYTHON Collapse Copy class CreateOrderSchema(BaseModel): order: conlist(OrderItemSchema, min_items=1) class GetOrderSchema(CreateOrderSchema): id: UUID created: datetime status: StatusEnum class GetOrdersSchema(BaseModel): orders: List[GetOrderSchema] Click to expand and view more 使用 pydantic 的 conlist 类型定义了 CreateOrderSchema 的 order 属性, 要求列表至少有一个元素\nValidating request payloads with pydantic 上面实现了模型定义, 现在通过将其声明为视图函数的一个参数来拦截请求负载, 并通过将其类型设置为相关的 Pydantic 模型进行验证\n代码可以在api.py里找到\nPYTHON Collapse Copy from uuid import UUID from starlette.response import Response from starlette import status from orders.app import app from orders.api.schemas import CreateOrderSchema # 导入数据模型 @app.post(\u0026#34;/orders\u0026#34;, status_code=status.HTTP_201_CREATED) def create_order(order_details: CreateOrderSchema): return order @app.get(\u0026#34;/orders/{order_id}\u0026#34;) def get_order(order_id: UUID): return order @app.put(\u0026#34;/orders/{order_id}\u0026#34;) def update_order(order_id: UUID, order_details: CreateOrderSchema): return order Click to expand and view more 如果发送一个有问题的数据(例如移除 product 字段), FastAPI 将会生成一份错误消息.\nJSON Collapse Copy { \u0026#34;detail\u0026#34;: [ { \u0026#34;loc\u0026#34;: [ \u0026#34;body\u0026#34;, \u0026#34;order\u0026#34;, 0, \u0026#34;product\u0026#34; ], \u0026#34;msg\u0026#34;: \u0026#34;field required\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;value_error.missing\u0026#34; } ] } Click to expand and view more 该错误消息使用 JSON Pointer 来指示问题所在, JSON Pointer 是一种语法, 用来表示 JSON 文档中特定值的路径\n例如, loc: /body/order/0/product 大概等同于 Pytohn 中的以下表示法 loc['body']['order'][0]['product']\nbody 指的是请求的主体部分 order 指的是主体中的 order 键 0 指的是 order 列表中的第一个元素 product 指的是这个元素中的 product 键 有时候参数可能是可选的, 但是并不能为 null. 这里使用 Pydantic 的 validator() 装饰器来添加额外的规则\nPYTHON Collapse Copy from pydantic import BaseModel, conint, validator ... class OrderItemSchema(BaseModel): product: int size: Size quantity: conint(ge=1, strict=True) | None = 1 @validator(\u0026#39;quantity\u0026#39;) def quantity_non_nullable(): assert value is not None, \u0026#34;quantity may not be None\u0026#34; return value Click to expand and view more Marshalling and validating response payloads with pydantic 这里定义一下返回类型 api.py\nPYTHON Collapse Copy from starlette.responses import Response from starlette import status from orders.api.schemas import ( GetOrderSchema, CreateOrderSchema, GetOrdersSchema, ) @app.get(\u0026#34;/orders\u0026#34;, response_model=GetOrdersSchema) def get_orders(): return [ order ] @app.post( \u0026#34;/orders\u0026#34;, status_code=status.HTTP_201_CREATED, response_model=GetOrderSchema ) def create_order(order_details: CreateOrderSchema): return order Click to expand and view more 现在, 如果 response payload 中缺少了返回类型需要的属性, FastAPI 则会报错, 如果有多的属性, 则会被去除\nAdding an in-memory list of orders to the API 现在通过一个简单的内存列表来管理订单状态\nPYTHON Collapse Copy import time import uuid from datetime import datetime from uuid import UUID from fastapi import HTTPException from starlette.responses import Response from starlette import status from orders.app import app from orders.api.schemas import GetOrderSchema, CreateOrderSchema ORDERS = [] # in memory list # 获取订单列表 @app.get(\u0026#34;/orders\u0026#34;, respones_model=GetOrderSchema) def get_orders(): return ORDERS # return order list # 创建订单 @app.post( \u0026#34;/orders\u0026#34;, status_code=status.HTTP_201_CREATED, response_model=GetOrderSchema, ) def create_order(order_details: CreateOrderSchema): # convert Pydantic model -\u0026gt; dict: v1 use .dict(); v2 use .model_dump() order = order_details.model_dump() order[\u0026#34;id\u0026#34;] = uuid.uuid4() # 获取订单 @app.get(\u0026#34;/orders/{order_id}\u0026#34;, response_model=GetOrderSchema) def get_order(order_id: UUID): for order in ORDERS: if order[\u0026#34;id\u0026#34;] == order_id: return order raise HTTPException( status_code=404, detail=f\u0026#34;Order with ID {order_id} not found\u0026#34;, ) # 更新订单 @app.put(\u0026#34;/orders/{order_id}\u0026#34;, response_model=GetOrderSchema) def update_order(order_id: UUID, order_details: CreateOrderSchema): for order in ORDERS: if order[\u0026#34;id\u0026#34;] == order_id: order.update(order_details.model_dump()) return order raise HTTPException( status_code=404, detail=f\u0026#34;Order with ID {order_id} not found\u0026#34;, ) # 删除订单 @app.delete( \u0026#34;/orders/{order_id}\u0026#34;, status_code=status.HTTP_204_NO_CONTENT, response_class=Response ) def delete_order(order_id: UUID): for index, order in enumerate(ORDERS): if order[\u0026#34;id\u0026#34;] == order_id: ORDERS.pop(index) return Response(status_code=HTTPStatus.NO_CONTENT.value) raise HTTPException( status_code=404, detail=f\u0026#34;Order with ID {order_id} not found\u0026#34;, ) # 取消订单 @app.post(\u0026#34;/orders/{order_id}/cancel\u0026#34;, response_model=GetOrderSchema) def cancel_order(order_id: UUID): for order in ORDERS: if order[\u0026#34;id\u0026#34;] == order_id: order[\u0026#34;status\u0026#34;] = \u0026#34;cancelled\u0026#34; return order raise HTTPException( status_code=404, detail=f\u0026#34;Order with ID {order_id} not found\u0026#34;, ) # 支付订单 @app.get(\u0026#34;/orders/{order_id}/pay\u0026#34;, response_model=GetOrderSchema) def pay_order(order_id: UUID): for order in ORDERS: if order[\u0026#34;id\u0026#34;] == order_id: order[\u0026#34;status\u0026#34;] = \u0026#34;progress\u0026#34; return order raise HTTPException( status_code=404, detail=f\u0026#34;Order with ID {order_id} not found\u0026#34;\u0026lt;\u0026gt; ) Click to expand and view more Microservice Principles 微服务设计原则: 如何将系统拆分为微服务 service decomposition, 以及如何估计其质量 下面是三个设计原则:\nDatabase-per-service principle 服务独立数据库原则 Loose coupling principle 松耦合原则 Single Responsibility Principle (SRP) 单一职责原则 遵循这些原则将帮助你避免构建一个\u0026quot;分布式单体应用\u0026quot;(distributed monolith)的风险\nData-per-service principle 服务独立数据库原则是指, 每个微服务拥有一系列具体的数据, 并且其他微服务只能通过 API 访问.\n这并不意味着每个微服务都要连接到不同的数据库中, 可以是关系数据库中的不同 tables, 或者非关系数据库中的 collections, 关键是数据被某个服务拥有, 不能被其他服务直接访问.\n例如, 为了计算价格, orders service 从 Production database 中获取每个物品的价格, 它也需要知道用户是否有折扣优惠, 这个需要从 User database 获取. 然而, 不能直接诶访问这两个数据库, order service 需要从 products service 和 users service 获取数据.\nLoose coupling principle 松耦合原则要求在设计服务的时候, 必须清晰的关注分离点, 松耦合的服务不依赖另一个服务的实现细节, 这项原则有两个实际的应用:\n每个服务都可以独立于其他服务工作: 如果一个服务在不调用另一个服务的情况下无法完成一个简单的请求, 那么这两个服务之间没有清晰的关注点分离, 他们应被视为一个整体 每个服务都可以在不影响其他服务工作的情况下进行更新: 如果一个服务的更新需要其他服务, 那么这些服务之间存在紧密耦合, 需要重新设计 例如, 一个基于历史数据计算销售预测的服务(Sales Forecast Service), 以及一个拥有历史销售数据的服务(Historical Data Service), 为了计算预测, 销售服务会调用历史数据服务的API来获取历史数据. 在这种情况下, 销售预测服务在不调用历史数据服务的情况下无法响应任何请求, 因此两个服务之间存在紧密耦合.\n解决方案是重新设计这两个服务, 使它们不相互依赖, 或者将它们合并成一个单一的服务.\nSingle responsibility principle 单一职责原则(SRP)指出, 我们要设计职责少、理想情况下只有一个职责的组件. 当应用于微服务设计架构时, 这意味着我们应努力围绕单一的业务能力或子域来设计服务.\nDecomposing micorservices by business capabilities 下面将 CoffeeMesh 系统根据业务内容分成以下部分\n产品团队对应产品服务 原料团队对应原料服务 销售团队对应销售服务 金融团队对应金融服务 厨房团队对应厨房服务 配送团队对应配送服务 在上面的微服务架构中, 将不同的业务定义为一个微服务, 这样是为了方便, 但并不一定要这样实现\n如上的设计规则, 满足了 SRP 原则, 每个模块都处理自己的数据, 但是这种设计并不满足松耦合原则(loose couping principle), 产品服务需要确定每款产品的库存,由于库存数据在原料服务中, 这就需要依赖原料服务, 而为每个产品都设计一个面向原料服务的 API 显然不太合理.\n因此, 这两个服务应该耦合在一起, 最终的服务结构如下:\nProducts service: Products and Ingredients team Sales service: Sales team Kitchen service: Kitchen team Finance service: Finance team Delivery service: Delivery service Service decomposition by subdomains 通过子领域分解是一种从 领域驱动设计(domain-driven desgin, DDD) 中汲取灵感的方法. 领域驱动设计是一种软件开发方法, 它专注于使用业务用户相同的语言来对业务流程和流向进行建模, 当应用于微服务设计时, DDD 能够帮助定义每个服务的核心职责和边界\n对于 CoffeeMesh 项目, 我们希望根据下单的过程, 以及配送给客户的过程来建模, 将其分解为以下8步:\n当用户登陆网站后, 像用户展示产品列表. 每个产品都表示是否有库存. 用户可以根据是否有库存和价格来排序 用户选择产品后下单 用户为订单付费 一但用户付费, 就将订单细节传递给 kitchen 服务 kitchen 服务根据订单制作咖啡 用户可以查询订单进度 一但订单制作完成, 就安排配送 用户可以追踪无人机的配送进度, 直到配送到用户手中 根据上面步骤, 将模块划分为以下几个子领域 (subdomains)\nProduction Subdomain 产品子领域\n第一个服务用于 CoffeeMesh 产品目录的子域, 这个子域告诉用户哪些产品可用, 哪些不可用. 为此, 产品子域会追踪每种产品和原料的库存\nOrders Subdomain 订单子域\n第二步代表一个允许用户选择产品的子域, 这个子域用于管理订单的声明周期. 该子域拥有用户订单的数据, 并提供一个接口来管理订单和检查其状态. 订单领域还负责第四步的第二部分: 在成功处理付款后, 将订单传递给厨房. 同时也满足了第六步的要求: 允许用户检查其订单状态. 作为订单管理者, 订单子域还会与配送子域协作来安排配送.\nPayments Subdomain 支付子域\n第三步代表一个处理用户支付的子域. 该子域包括用户支付处理的专门逻辑, 包括银行卡验证, 与第三方支付提供商集成, 处理不同支付方式等. 支付子领域拥有与用户支付相关的数据.\nKitchen Subdomain 厨房子域\n第五步代表一个与厨房协作来管理客户订单生产的子域. 厨房的生产系统是全自动的, 厨房子域与厨房系统进行接口交互, 以安排客户订单的生产并追踪其进度.一旦订单生产完成, 厨房子域会通知订单子域, 后者随后安排配送. 厨房子域拥有与客户订单生产相关的数据, 并公开一个接口, 允许我们向厨房发送订单并跟踪其进度. 订单子域通过与厨房子域的接口交互, 来更新订单状态, 以满足第六步的需求.\nDelivery Subdomain 配送子域\n第七步代表一个与自动化配送系统进行接口交互的子域. 该子域包含专门的逻辑, 用于解析客户的地理位置并计算到达他们的最佳路线. 它管理着配送无人机机队并优化配送, 同时拥有与所有配送相关的数据. 订单子域通过与配送子域的接口交互, 来更新客户订单的行程, 以满足第八步的需求.\n通过以上分析, 将 CoffeeMesh 分解为5个子领域, 这些子领域可以被映射为微服务, 每个子领域都封装了定义明确, 职责清晰且拥有自己的逻辑区域. 领域驱动设计的微服务也满足了之前的微服务设计原则: 所有这些子域都可以在不依赖其他微服务的情况下执行其核心任务, 因此是松耦合的; 每个服务都拥有自己的数据, 因此符合服务独立数据库原则; 最后, 每个服务都在一个定义狭窄的子域内执行任务, 这符合单一职责原则.\nWrapping Up 上面介绍了微服务的概念, 并通过一个 CoffeeMesh 的项目解释了如何将其分解(decompose)为微服务架构, 分别通过业务分解和通过子领域分解, 以及设计微服务的3条原则:\nDatabase-per-service principle 数据库独享原则 Loose coupling principle 松耦合原则 Single responsibility principle 单一责任原则 ","title":"Microservice with FastAPI"},{"link":"/posts/python-generics/","text":"本篇文件介绍 Python 中的 泛型(Generics)\nIntro 在没有泛型的情况下, 会遇上以下几个问题:\n难以表达意图\n假设你编写了一个函数, 它接受一个列表, 并返回列表中的第一个元素. 在不使用类型提示的情况下, 这个函数可以处理任何类型的列表, 但我们无法在函数签名中表达\u0026quot;返回的元素的类型与列表中的元素类型相同\u0026quot;这个意图\nPYTHON Collapse Copy def get_first_element(items): return items[0] Click to expand and view more 丧失类型信息\n如果使用类型提示, 可能会像下面这样写, 但这样会丢失类型信息. list[Any] 表示可以接收任何类型的列表, 但 -\u0026gt; Any 意味着不知道返回的元素类型是什么, 这使得 mypy 等静态类型检测工具无法追踪类型, 降低了代码的可读性和安全性\nPYTHON Collapse Copy from typing import Any def get_first_element(items: list[Any]) -\u0026gt; Any: return items[0] # 调用时, 类型检查工具无法得知 first_str 的类型 first_str = get_first_element([\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]) Click to expand and view more 代码重复\n如果为每种可能的类型都编写一个单独的函数, 则会导致代码重复\nPYTHON Collapse Copy def get_first_int(items: list[int]) -\u0026gt; int: return items[0] def get_first_str(items: list[str]) -\u0026gt; str: return items[0] Click to expand and view more 通过引入 类型变量 (TypeVar) 来解决问题, 类型变量就像一个占位符, 代表在未来某时刻会被具体指定的类型\nPYTHON Collapse Copy from typing import TypeVar T = TypeVar(\u0026#34;T\u0026#34;) def get_first_element(items: list[T]) -\u0026gt; T: return items[0] # 现在, 类型检查工具可以正确推断出类型 first_str: str = get_first_element([\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]) first_int: int = get_first_element([1, 2, 3]) Click to expand and view more T = TypeVar('T') 定义了一个名为 T 的类型变量, 这里 T 只是一个约定俗成的名字, 也可以使用其他字母 items: list[T] 表示 items 是一个列表, 其内部元素类型是 T -\u0026gt; T: 返回类型也是 T 当使用 [\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;] 调用函数时, 静态类型检查器会推断出 T 是 str, 返回类型为 str 当使用 [1, 2, 3] 调用函数时, T 被推断为 int 注意: 这个函数假设列表非空, 如果传入空列表会抛出 IndexError\nGeneric Class 除了函数, 泛型也常用于定义泛型类\nPYTHON Collapse Copy from typing import TypeVar, Generic T = TypeVar(\u0026#34;T\u0026#34;) class Box(Generic[T]): def __init__(self, items: list[T]): self._items = items def get(self) -\u0026gt; T: return self._items[0] def add(self, item: T) -\u0026gt; None: self._items.append(item) # 创建一个存储字符串的 Box string_box = Box([\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;]) item_str = string_box.get() # str string_box.add(\u0026#34;cherry\u0026#34;) # 创建一个存储整数的 Box int_box = Box([10, 20]) item_int = int_box.get() # int int_box.add(30) Click to expand and view more TypeVar 定义类型变量: 相当于一个占位符, 将来由使用者指定具体类型 Generic 定义泛型类或泛型接口: 使这个类在类型检查器眼中变成一个模板 Advanced Usage 简单介绍一下泛型的一些进阶用法\n多类型参数\nPYTHON Collapse Copy from typing import TypeVar, Generic K = TypeVar(\u0026#34;K\u0026#34;) V = TypeVar(\u0026#34;V\u0026#34;) class Pair(Generic[K, V]): def __init__(self, key: K, value: V): self.key = key self.value = value def get_key(self) -\u0026gt; K: return self.key def get_value(self) -\u0026gt; V: return self.value # 使用示例 pair = Pair(\u0026#34;name\u0026#34;, 25) # Pair[str, int] Click to expand and view more 支持多个类型变量, 类似 dict[K, V] 的结构\n类型约束 (Constraints)\n有时候可能希望泛型只能是某些特定类型\nPYTHON Collapse Copy from typing import TypeVar Number = TypeVar(\u0026#39;Number\u0026#39;, int, float) def add(a: Number, b: Number) -\u0026gt; Number: return a + b # 正确使用 result1 = add(1, 2) # int result2 = add(1.5, 2.3) # float # 错误使用: mypy 会报错 # result3 = add(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;) # str 不被允许 Click to expand and view more Number 只能为 int 或 float, 传入其他类型, 类型检查工具会报错\n协变与逆变 (Covariance/Contravariance)\n在泛型类型中, 可以控制类型变量的变型关系\nPYTHON Collapse Copy from typing import Generic, TypeVar T_co = TypeVar(\u0026#34;T_co\u0026#34;, covariant=True) # 协变 T_contra = TypeVar(\u0026#34;T_contra\u0026#34;, contravariant=True) # 逆变 class Producer(Generic[T_co]): \u0026#34;\u0026#34;\u0026#34;只产出 T_co 类型的数据 (协变)\u0026#34;\u0026#34;\u0026#34; def __init__(self, value: T_co): self._value = value def get(self) -\u0026gt; T_co: return self._value class Consumer(Generic[T_contra]): \u0026#34;\u0026#34;\u0026#34;只消费 T_contra 类型的数据 (逆变)\u0026#34;\u0026#34;\u0026#34; def __init__(self): pass def consume(self, value: T_contra) -\u0026gt; None: print(f\u0026#34;Consuming: {value}\u0026#34;) Click to expand and view more 协变 (covariant): 如果 A 是 B 的子类型, 那么 Generic[A] 也是 Generic[B] 的子类型. 适用于只产出数据的场景 逆变 (contravariant): 如果 A 是 B 的子类型, 那么 Generic[B] 是 Generic[A] 的子类型. 适用于只消费数据的场景 这主要用于接口设计中的读/写分离 泛型与 Protocol\nProtocol 允许定义泛型接口 (duck typing)\nPYTHON Collapse Copy from typing import Protocol, TypeVar T = TypeVar(\u0026#39;T\u0026#39;) class SupportsLen(Protocol): def __len__(self) -\u0026gt; int: ... def total_length(items: list[SupportsLen]) -\u0026gt; int: return sum(len(x) for x in items) # 使用示例 result = total_length([\u0026#34;hello\u0026#34;, [1, 2, 3], {\u0026#34;a\u0026#34;: 1}]) # 可以接受任何有 __len__ 方法的对象 Click to expand and view more 任何实现了__len__方法的对象都能被接受, 比继承更加灵活\n泛型在标准库中的使用\n集合类: list[T], dict[K, V], set[T] 迭代器: Iterator[T], Iterable[T] 函数工具: Callable[[T1, T2], R] 上下文管理器: ContextManager[T] PYTHON Collapse Copy from typing import Callable def operate(a: int, b: int, func: Callable[[int, int], int]) -\u0026gt; int: return func(a, b) # 使用示例 def add(x: int, y: int) -\u0026gt; int: return x + y def multiply(x: int, y: int) -\u0026gt; int: return x * y result1 = operate(5, 3, add) # 8 result2 = operate(5, 3, multiply) # 15 Click to expand and view more Wrapping Up 泛型是 Python 类型提示系统中一个非常强大的工具, 它通过类型变量帮助我们编写更加灵活、安全且可维护的代码.\n它虽然不会影响程序的运行时行为 (类型信息在运行时会被擦除), 但它为静态类型分析提供了必要的信息, 使得代码意图更加清晰, 并且能在早期发现类型错误.\nPython 的泛型是类型提示系统的一部分, 和 C++/Java 的编译期泛型不同, 它的作用主要是:\n帮助 IDE 和类型检查工具发现类型错误 提升代码可读性和可维护性 提供更精确的 API 类型签名 支持更好的代码重用和抽象 ","title":"Python Generics"},{"link":"/posts/python-strings/","text":"这篇文章总结一下 Python 中字符串的类型\nUnicode String 字符串 u 在 Python3 中是多余的, 因为所有的普通字符串默认都是 Unicode, 但在 Python2 中, u 用来显示的表示 Unicode 字符串, 现在保留这个是为了向后兼容\nFromatted String 格式化字符串 f 前缀用于创建格式化字符串, 这是最常见的字符串格式方法, 运行在字符串中嵌入表达式, 在求值时转换为普通的 str\nPYTHON Collapse Copy name = \u0026#34;World\u0026#34; greeting = f\u0026#34;Hello, {name}!\u0026#34; # 结果: \u0026#34;Hello, World!\u0026#34; Click to expand and view more Raw String 原始字符串 r 前缀用于创建原始字符串, 会忽略反斜杠 \\ 的转义功能, 在编写文件路径或正则表达式的时候非常有用, 可以避免大量的反斜杠转义\nPYTHON Collapse Copy path = r\u0026#34;C:\\Users\\Documents\u0026#34; # 单个反斜杠 \u0026#39; regex = r\u0026#34;\\bword\\b\u0026#34; # \\b 不会被转义 Click to expand and view more Bytes String 字节串 b 前缀用于创建字节串字面量, 表示一个不可变的字节序列, 而不是 Unicode 文本, 字节串主要用于二进制数据, 例如图像文件、网络数据或压缩文件等\nPYTHON Collapse Copy binary_data = b\u0026#34;Hello\u0026#34; # 存储的是 ASCII 编码的字节 Click to expand and view more Template String 模板字符串 t 前缀用于创建模板字符串, 这是 Python 3.14 引入的新功能, 由 PEP 750 通过.\n不同于 f-string, t-string 不会立即求值为 str, 而是求值为一个 Template 对象, 这为开发者提供了将在将字符串和插值组合之前进行处理(和安全转义)的能力\nPYTHON Collapse Copy from string.templatelib import Template template = t\u0026#34;Hello, {name}\u0026#34; # template 是一个 Template 对象 Click to expand and view more 组合使用 前缀 含义 用途 f 格式化 嵌入变量和表达式 r 原始 忽略反斜杠转义 b 字节 处理二进制数据 t 模板 在组合前处理插值 u Unicode Python 3 中默认开启 fr / rf 格式化+原始 在正则表达式中嵌入变量 br / rb 字节+原始 忽略二进制数据中的转义 tr / rb 模板+原始 模板中处理原始文本 ","title":"Python Strings"},{"link":"/posts/fastapi-response-model/","text":"本篇文章介绍 FastAPI 的返回类型 response model\n可以在返回函数的类型注解中声明该接口的响应数据类型\n类型注解的用法和输入数据参数一样, 可以使用:\nPydantic 模型 list 列表 dict 字典 scalar 标量值 (int, bool \u0026hellip;) PYTHON Collapse Copy @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item) -\u0026gt; Item: ... @app.get(\u0026#34;/items/\u0026#34;) async def read_items() -\u0026gt; list[Item]: ... Click to expand and view more FastAPI 会使用返回类型完成一下事情:\n验证返回类型 如果返回的数据无效, 说明业务代码有问题, FastAPI 会返回服务器错误, 而不是把数据发给客户端\n在 OpenAPI 中为响应添加 JSON Schema 用于自动生成接口文档, 自动生成客户端代码\n最重要的是 它会限制并过滤出数据, 只保留返回类型中定义的字段\nresponse_model Parameter 有时候可能需要返回的数据和类型注解不完全一致, 例如:\n可能想返回字典或数据库对象, 但声明的响应类型为 Pydantic 模型 这样 Pydantic 会做数据文档、验证等工作, 即使返回的是字典或 ORM 对象 如果直接用返回类型注解, 编辑器会提示类型不匹配的错误\n这种情况下, 可以用路径装饰器的 response_model 参数来声明响应类型, 而不是用返回类型注解\nPYTHON Collapse Copy class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list[str] = [] @app.post(\u0026#34;/items/\u0026#34;, response_model=Item) async def create_item(item: Item) -\u0026gt; Any: return item @app.get(\u0026#34;/items/\u0026#34;, response_model=list[Item]) async def read_items() -\u0026gt; Any: return [ {\u0026#34;name\u0026#34;: \u0026#34;Portal Gun\u0026#34;, \u0026#34;price\u0026#34;: 42.0}, {\u0026#34;name\u0026#34;: \u0026#34;Plumbus\u0026#34;, \u0026#34;price\u0026#34;: 32.0}, ] Click to expand and view more 注意:\nresponse_model 是装饰器(get、post 等方法)的参数, 不是函数的参数 接收的类型和 Pydantic 字段定义一样, 可以是单个模型, 也可以是模型列表等 FastAPI 用其做数据库验证、文档生成、以及过滤输出数据 如果使用 mypy 之类做 static type check, 可以声明函数返回类型为 Any\nresponse_model 优先级 如果同时声明了 response_model 和返回类型, 则 response_model 会优先生效\n如果想要禁用响应模型, 可以设置 response_model=None (用于一些非 Pydantic 类型的返回值) Return the Same Input Data 返回相同数据数据 很多情况下, 希望模型返回与输入模型相同的数据\n这式, 可以在路径函数中直接声明 response_model=YourModel, FastAPI 会自动处理\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserIn(BaseModel): username: str password: str email: EmailStr full_name: str | None = None # Don\u0026#39;t do this in production! @app.post(\u0026#34;/user/\u0026#34;) async def create_user(user: UserIn) -\u0026gt; UserIn: return user Click to expand and view more 不要在生产环境中以明文形式存储用户密码, 也不要像这样直接返回密码\nAdd an Output Model 添加输出模型 我们可以改成: 输入模型包含明文密码, 输出模型不含\nPYTHON Collapse Copy from typing import Any from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() # Input model class UserIn(BaseModel): username: str password: str email: EmailStr full_name: str | None = None # Output model class UserOut(BaseModel): username: str email: EmailStr full_name: str | None = None @app.post(\u0026#34;/user/\u0026#34;, response_model=UserOut) # output async def create_user(user: UserIn) -\u0026gt; Any: return user # like input Click to expand and view more 这样, 即使路径操作函数返回的对象中包含该字段, FastAPI 也会按照 response_model=UserOut 来过滤密码\nReturn Type and Data Filtering 返回类型与数据过滤 延续上面的例子, 希望函数的类型注解和实际返回值不同:\n函数返回的对象可能包含更多数据, 但响应中只保留输出模型声明的字段\n之前由于类不同, 只能用 response_model, 这样就失去了编辑器和类型检查对返回值的检查\n大多数情况下, 我们只是想去掉或过滤掉部分数据, 这时可以用 类继承(classes and inheritance) 来兼顾类型注解和数据过滤\nPYTHON Collapse Copy class BaseUser(BaseModel): username: str email: EmailStr full_name: str | None = None class UserIn(BaseUser): password: str @app.post(\u0026#34;/user/\u0026#34;) async def create_user(user: UserIn) -\u0026gt; BaseUser: return user Click to expand and view more 通过这种方式:\nType Annotations and Testing 编辑器和类型检查工具支持: UserIn 是 BaseUser 的子类, 返回 UserIn 实例完全符合 BaseUser 类型要求 FastAPI Data Filtering 数据过滤: 响应中会自动去掉 password 字段, 只保留 BaseUser 中声明的字段 Other Return Type Annotations 其他类型注解 有些时候, 返回的内容不是有效的 Pydantic 字段, 但在函数中添加了注解, 为了获取工具支持\nReturn a response directly 直接返回响应 最常见的就是直接返回一个 Resposne\nPYTHON Collapse Copy from fastapi import FastAPI, Response from fastapi.resposnes import JSONResponse, RedirectResponse app = FastAPI() @app.get(\u0026#34;/portal\u0026#34;) async def get_protal(teleport: bool = False) -\u0026gt; Response: if teleport: return RedirectResponse(url=\u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34;) return JSONResponse(content={\u0026#34;message\u0026#34;: \u0026#34;Here\u0026#39;s your interdimensional portal.\u0026#34;}) Click to expand and view more 这种简单情况由 FastAPI 自动处理, 因为返回类型注解是 Response 类\n开发工具也能正常工作, 因为 RedirectResponse 和 JSONResponse 都是 Response 的子类, 所以类型注解是正确的\nInvalid return type annotations 无效的类型注解 但是, 当返回一些其他任意对象(不是有效的 Pydantic 类型, 例如数据库对象)并在函数中这样注解时, FastAPI 会尝试从该类型注解创建一个 Pydantic 响应模型, 然后会失败\n如果使用了联合模型, 其中有一个或多个不是有效的 Pydantic 类型, 同样会失败\nPYTHON Collapse Copy from fastapi import FastAPI, Response from fastapi.responses import RedirectResponse app = FastAPI() @app.get(\u0026#34;/portal\u0026#34;) async def get_portal(teleport: bool = False) -\u0026gt; Response | dict: if teleport: return RedirectResponse(url=\u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34;) return {\u0026#34;message\u0026#34;: \u0026#34;Here\u0026#39;s your interdimensional portal.\u0026#34;} Click to expand and view more 这会失败是因为类型注解不是单一的 Pydantic 类型, 也不是单一的 Response 类或子类, 而是 Response 和 dict 之间的联合类型\nDisable response Model 禁用响应类型 如果不希望 FastAPI 执行默认的数据验证、文档生成、过滤等操作, 但是又想在函数中保留返回类型注解, 以获得编辑器和类型检查工具的支持, 这种情况下设置 response_model=None 来禁用响应生成\nPYTHON Collapse Copy from fastapi import FastAPI, Response from fastapi.response import RedirectResponse app = FastAPI() @app.get(\u0026#34;/portal\u0026#34;, response_model=None) async def get_protal(teleport: bool = False) -\u0026gt; Response | dict: if teleport: return RedirectResponse(url=\u0026#34;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#34;) return JSONResponse(content={\u0026#34;message\u0026#34;: \u0026#34;Here\u0026#39;s your interdimensional portal.\u0026#34;}) Click to expand and view more Response Model Encoding Parameters 响应模型编码参数 响应模型可能有默认值\nPYTHON Collapse Copy class Item(BaseModel): name: str description: str | None = None price: float tax: float = 10.5 tags: list[str] = [] Click to expand and view more 例如, 在 NoSQL 数据库中哟许多可选属性的模型, 但不想发送默认值的很长的 JSON 响应\n可以使用 path operation operator 的 response_model_exclude_mode 参数来去除默认值\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;, response_model=Item, response_model_exclude_unset=True) async def read_item(item_id: str): return items[item_id] Click to expand and view more description: str | None = None 默认值为 None tax: float = 10.5 的默认值为 10.5 tags: List[str] = [] 的默认值是空列表 [] 此时, 如果向该路径发送 ID 为 foo 的项目请求\nYAML Collapse Copy \u0026#34;foo\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;price\u0026#34;: 50.2} Click to expand and view more 响应将是\nYAML Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;price\u0026#34;: 50.2, } Click to expand and view more response_model_include 和 response_model_exclude 也可以使用 path operation parameter 中的 response_model_include 和 response_model_exclude, 他们接受一个包含属性名称字符串的 set, 用于包含(省略其余部分)或排除(包含其余部分)\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float = 10.5 items = { \u0026#34;foo\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;price\u0026#34;: 50.2}, \u0026#34;bar\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;Bar\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The Bar fighters\u0026#34;, \u0026#34;price\u0026#34;: 62, \u0026#34;tax\u0026#34;: 20.2}, \u0026#34;baz\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Baz\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;There goes my baz\u0026#34;, \u0026#34;price\u0026#34;: 50.2, \u0026#34;tax\u0026#34;: 10.5, }, } @app.get( \u0026#34;/items/{item_id}/name\u0026#34;, response_model=Item, response_model_include={\u0026#34;name\u0026#34;, \u0026#34;description\u0026#34;}, # 包含 ) async def read_item_name(item_id: str): return items[item_id] @app.get( \u0026#34;/items/{item_id}/public\u0026#34;, response_model=Item, response_model_exclude={\u0026#34;tax\u0026#34;}, # 排除 ) async def read_item_public_data(item_id: str): return items[item_id] Click to expand and view more 虽然可以通过上述方法自定义返回参数包含哪些, 但还是建议使用多个类来实现该功能, 而不这些参数\n这是因为, 即使使用 response_model_include 或 response_model_exclude 来省略某些属性, 在应用程序的 OpenAPI 中生成的 JSON Schema 仍将是完整模型的 Schema\n这对于 response_model_by_alias 也是一样的\nUsing list instead of sets 如果忘记使用集和而使用元组或列表, FastAPI 仍会将其转换为集和, 确保正常工作\nPYTHON Collapse Copy @app.get( \u0026#34;/items/{item_id}/name\u0026#34;, response_model=Item, response_model_include=[\u0026#34;name\u0026#34;, \u0026#34;description\u0026#34;], # 使用列表 ) async def read_item_name(item_id: str): return items[item_id] @app.get( \u0026#34;/items/{item_id}/public\u0026#34;, response_model=Item, response_model_exclude=[\u0026#34;tax\u0026#34;], # 使用列表 ) async def read_item_public_data(item_id: str): return items[item_id] Click to expand and view more Response Status Code 响应状态码 就像可以指定响应模型一样, 也可以在任何路径操作中使用 status_code 参数声明用于响应:\n@app.get() @app.post() @app.put() @app.delete() PYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.post(\u0026#34;/items/\u0026#34;, status_code=201) async def create_item(name: str): return {\u0026#34;name\u0026#34;: name} Click to expand and view more status_code 是\u0026quot;装饰器\u0026quot;方法的一个参数, 而不是你的路径操作函数 path operation function 的参数\nstatus_code 参数接收一个表示 HTTP 状态码的数字, 也可以接收一个 IntEnum, 比如 Python 中的 http.HTTPStatus\n将在响应中返回该状态码 并在 OpenAPI 模式中也如此记录 About HTTP status codes 在 HTTP 协议中, 会在响应中发送一个3位数的数字状态码\n这些状态码又一个相关联的名称便于识别, 但重要的是数字本身\n100~199: 用于\u0026quot;信息\u0026quot;, 很少会直接使用它们, 这些状态码的响应不能有响应体 200~299: 用于\u0026quot;成功\u0026quot;的响应, 这些是最常用的 200 的默认的\u0026quot;成功\u0026quot;响应, 表示一切 OK 201 表示已创建, 通常在数据库中创建新记录后使用 204 表示无内容, 当没有内容返回给客户端时使用此响应, 因此不能有响应体 300~399: 用于\u0026quot;重定向\u0026quot;, 这些状态码的响应可能有也可能没有响应体. 但 304 (未修改) 除外, 它必须没有响应体 400~499: 用于\u0026quot;客户端错误\u0026quot;响应, 404 用于\u0026quot;未找到\u0026quot;的响应 400 客户端通用错误 500~599: 用于服务器错误, 几乎从不直接使用它们. 当的应用代码或服务器的某个部分出错时, 它会自动返回这些状态码之一 要了解更多关于每个状态码的信息以及哪个代码用于什么目的，请查阅 MDN 关于 HTTP 状态码的文档\nShortcut to remember the names 除了直接使用数字外, 还可以使用 fastapi.status 中的便捷变量\nPYTHON Collapse Copy from fastapi import FastAPI, status app = FastAPI() @app.post(\u0026#34;/items/\u0026#34;, status_code=status.HTTP_201_CREATED) async def create_item(name: str): return {\u0026#34;name\u0026#34;: name} Click to expand and view more 这只是一直便利, 都是一样的树枝, 但这样可以使用编辑器的自动补全功能\n也可以使用 from starlette import status\n","title":"FastAPI Response Model"},{"link":"/posts/fastapi-cookie-and-header-parameters/","text":"这篇文章介绍 Fastapi 的 Cookie 和 Header 参数\nCookie Parameters 通过定义 Query 和 Path 参数一样定义 Cookie 参数\nPYTHON Collapse Copy from typing Annotated from fastapi import Cookie, FastAPI app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(ads_id: Annotated[str | None, Cookie()] = None): return {\u0026#34;ads_id\u0026#34;: ads_id} Click to expand and view more Cookie Parameters Models 如果有一组相关的 cookies, 可以使用 Pydantic model 来声明.\n这样可以在多个部分复用这个模型, 同时还能一次性为所有参数声明验证规则和元数据.\n下面使用 Pydantic 模型定义 Cookies, 然后将参数声明为 Cookie\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Cookie from pydantic import BaseModel app = FastAPI() class Cookie(BaseModel): session_id: str fatebook_tracker: str | None = None googall_tracker: str | None = None @app.get(\u0026#34;/items/\u0026#34;) async def read_items(cookies: Annotated[Cookies, Cookie()]): return cookies Click to expand and view more Forbid Extra Cookies 禁止额外的Cookie 在某些场景下(虽然并不常见), 可能希望限制 API 只能接收特定的 Cookie. 这样, API 就可以\u0026quot;自己\u0026quot;管理 Cookie 同意策略了.\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Cookie from pydantic import BaseModel app = FastAPI() class Cookies(BaseModel): model_config = {\u0026#34;extra\u0026#34;: \u0026#34;forbid\u0026#34;} # forbid extra cookies session_id: str fatebook_tracker: str | None = None googall_tracker: str | None = None @app.get(\u0026#34;/items/\u0026#34;) async def read_items(cookies: Annotated[Cookies, Cookie()]): return cookies Click to expand and view more 这样, 如果客户端发送额外的 cookies, 则会收到一个错误响应. 例如, 客户端发送了 santa_tracker 这个额外 Cookie\nPYTHON Collapse Copy santa_tracker = good-list-please Click to expand and view more 将会收到如下错误响应\nJSON Collapse Copy { \u0026#34;detail\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;extra_forbidden\u0026#34;, \u0026#34;loc\u0026#34;: [\u0026#34;cookie\u0026#34;, \u0026#34;santa_tracker\u0026#34;], \u0026#34;msg\u0026#34;: \u0026#34;Extra inputs are not permitted\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;good-list-please\u0026#34;, } ] } Click to expand and view more Header Parameters 同样的, 通过定义 Query 和 Path 参数一样定义 Header 参数\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Header app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(user_agent: Annotated[str | None, Header()] = None): return {\u0026#34;User-Agent\u0026#34;: user_agent} Click to expand and view more Automatic conversoin 自动转换 Header 拥有一些在 Path, Query 和 Cookie 上的额外功能\n大多数标准的 header 都通过一个连字符(hyphen character), 也称为减号(minus symbol)分开, 但是变量 user-agent 这样在 Python 中是不合法的. 所以, 默认情况下 Header 会将参数名中的 hypen(-) 使用下划线 undersocre(_) 替换.\n同样的, HTTP headers 是不区分大小写的, 所以可以使用标准的 Python 风格 (snake_case). 因此可以使用 user_agent 在 Python 代码中, 而不需要首字母大写成 User_Agent.\n如果想要禁止这种自动转换, 需要将 Header 的参数 convert_undersocres 设置为 False\nPYTHON Collapse Copy from typing import Typing from fastapi import FastAPI, Header app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items( strange_header: Annotated[str | None, Header(convert_undersocres=False)] = None ): return {\u0026#34;strange_header\u0026#34;: strange_header} Click to expand and view more Duplicate headers 重复请求头 一个请求中可能会收到重复的 headers, 也就是同一个 header 有多个值.\n可以在类型声明中使用 list 来处理这种情况, 这样会得到一个 Python 列表.\n例如要声明一个可能多次出现的 X-Token 头部, 可以这样写:\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Header app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(x_token: Annotated[list[str] | None, Header()] = None): return {\u0026#34;X-Token values\u0026#34;: x_token} Click to expand and view more 如果向该接口发送两个这样的 HTTP headers\nPLAINTEXT Collapse Copy X-Token: foo X-Token: bar Click to expand and view more 返回类似这样\nJSON Collapse Copy { \u0026#34;X-Token values\u0026#34;: [ \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34; ] } Click to expand and view more Header parameters models 请求头参数模型 同样可以使用 Pydantic model 定义 Header Parameters, 这样可以在多个地方复用模型, 还能一次性为所有参数声明规则和元数据\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Header from pydantic import BaseModel app = FastAPI() class CommonHeaders(BaseModel): host: str save_data: str if_modified_since: str | None = None traceparent: str | None = None x_tag: list[str] = [] @app.get(\u0026#34;/items\u0026#34;) async def read_items(headers: Annotated[CommonHeaders, Header()]): return headers Click to expand and view more Forbid extra headers 禁止额外请求头 同样也可以禁止额外的 headers\nPYTHON Collapse Copy class CommonHeaders(BaseModel): model_config = {\u0026#34;extra\u0026#34;: \u0026#34;forbid\u0026#34;} # 禁止额外字段 ... Click to expand and view more 如果客户端尝试发送额外的 Header，将会收到错误响应. 例如, 客户端发送了 tool 这个额外 Header\nPLAINTEXT Collapse Copy tool: plumbus Click to expand and view more 将会收到如下错误响应\nJSON Collapse Copy { \u0026#34;detail\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;extra_forbidden\u0026#34;, \u0026#34;loc\u0026#34;: [\u0026#34;header\u0026#34;, \u0026#34;tool\u0026#34;], \u0026#34;msg\u0026#34;: \u0026#34;Extra inputs are not permitted\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;plumbus\u0026#34; } ] } Click to expand and view more Disable convert undersocres 禁止转换下划线 同样可以禁用自动下换线转换\n与普通的 Header 参数一样, 如果参数名中包含下划线 undersocre (_), FastAPI 会自动将其转换为连字符 hypens (-)\nPYTHON Collapse Copy async def read_items( headers: Annotated[CommonHeaders, Header(convert_underscores=False)], ): ... Click to expand and view more 在将 convert_underscores 设置为 False 前, 注意有些 HTTP 代理和服务器不允许带下划线的头部字段\n","title":"Fastapi Cookie and Header Parameters"},{"link":"/posts/python-function-parameters/","text":"今天是周日, 简单写点吧, 简单总结一下 Python 中函数参数\nPython Function Parameters Python 函数参数机制非常灵活丰富, 理解各种参数类型及其用法对于写出优雅、易维护的代码非常重要. 本文将介绍 Python 中函数参数的种类与用法, 并详细讲解 Python 3.8 引入的参数分隔符 / 和 *, 帮助你更好地设计函数接口.\n1. Postional Arguments 位置参数 函数定义中最常见的参数, 调用时按顺序传入值\nPYTHON Collapse Copy def greet(name, age): print(f\u0026#34;Hello, {name}. You are {age} years old.\u0026#34;) greet(\u0026#34;Alice\u0026#34;, 30) # Hello, Alice. You are 30 years old. Click to expand and view more 2. Keyword Arguments 关键字参数 调用时以 key=value 形式传入, 顺序可变\nPYTHON Collapse Copy greet(age=30, name=\u0026#34;Alice\u0026#34;) Click to expand and view more 3. Default Arguments 默认参数 定义函数时给参数赋默认值, 调用时可省略\nPYTHON Collapse Copy def greet(name, age=20): print(f\u0026#34;Hello, {name}. You are {age} years old.\u0026#34;) greet(\u0026#34;Bob\u0026#34;) # 使用默认年龄20 greet(\u0026#34;Bob\u0026#34;, 25) # 指定年龄 Click to expand and view more 注意: 使用默认参数尽量不要使用可变类型(mutable), 例如列表, 因为默认参数是存储在函数中的, 而非函数实例中, 多次调用会改变默认值的内容. PYTHON Collapse Copy def greet(names: list[str] = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;]): ... Click to expand and view more 若希望使用默认值, 建议使用下面这种方法\nPYTHON Collapse Copy def greet(names: list[str] | None = None): if not names: names = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;] ... Click to expand and view more 同样的, 默认值参数如果为一个表达式, 则是在定义时求值, 而非运行改函数时才求值\n4. *args 可变位置参数 用于接收任意数量的位置参数, 形成元组\nPYTHON Collapse Copy def sum_all(*args): return sum(args) sum_all(1, 2, 3) # 6 sum_all() # 0 Click to expand and view more 5. **kwargs 可变关键字参数 用于接收任意数量的关键字参数, 形成字典\nPYTHON Collapse Copy def print_info(**kwargs): for k, v in kwargs.items(): print(f\u0026#34;{k} = {v}\u0026#34;) print_info(name=\u0026#34;Alice\u0026#34;, age=30) Click to expand and view more / 和 * 的用法 Python 3.8 引入了两种新的函数参数分隔符: 斜杠 /(forward slash) 和 星号 *(asterisk) 符号, 用于更精细地控制参数的调用方式\nPostional-only parameters (/) 斜杠前的参数必须通过位置传递, 不能用关键字传递\nPYTHON Collapse Copy def func(a, b, /, c, d): print(a, b, c, d) Click to expand and view more 调用时\nPYTHON Collapse Copy func(1, 2, c=3, d=4) # 正确 func(1, 2, 3, 4) # 也正确 func(a=1, b=2, c=3, d=4) # 错误，a 和 b 不能用关键字传递 Click to expand and view more 用途:\n保护函数接口的参数顺序, 避免调用者用关键字修改参数值 兼容一些C语言扩展模块的调用约定 明确哪些参数是\u0026quot;位置专用\u0026quot;的 Keyword-only parameters (*) 星号后的参数必须用关键字传递, 不能用位置传递\nPYTHON Collapse Copy def func(a, b, *, c, d): print(a, b, c, d) Click to expand and view more 调用时\nPYTHON Collapse Copy func(1, 2, c=3, d=4) # 正确 func(1, 2, 3, 4) # 错误，c 和 d 只能用关键字传递 Click to expand and view more 用途:\n强制调用者明确指定关键字参数, 提高代码可读性 避免参数顺序引起的混淆 Use both / and * / 和 * 也可以同时使用\nPYTHON Collapse Copy def func(a, b, /, c, d, *, e, f): print(a, b, c, d, e, f) Click to expand and view more 调用时\na 和 b 只能用位置参数传递 c 和 d 都可以 e 和 f 只能用关键字参数传递 ","title":"Python Function Parameters"},{"link":"/posts/fastapi-body-advanced-uses/","text":"本篇文章介绍 FastAPI Request Body 的进阶用法\nBody - Multiple Parameters 首先, 可以将Path, Query 和 request body 参数声明自由的写在一起\n对于 request body 参数可以是可选的, 并且可设置为默认的 None\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Path from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item( item_id: Annotated[int, Path(title=\u0026#34;The ID of the item to get\u0026#34;, ge=0, le=1000)], # Path q: str | None = None, # Query item: Item | None = None, # body ): results = {\u0026#34;item_id\u0026#34;: item_id} if q: results.update({\u0026#34;q\u0026#34;: q}) if item: results.update({\u0026#34;item\u0026#34;: item}) return results Click to expand and view more Multiple body parameters 多参数请求体 在上面例子中, FastAPI 期望一个包含 Item 属性的 JSON body, 例如\nJSON Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 } Click to expand and view more 但也可以声明多个body parameters, 例如 item 和 user\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None class User(BaseModel): username: str full_name: str | None = None @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item(item_id: int, item: Item, user: User): results = {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;item\u0026#34;: item, \u0026#34;user\u0026#34;: user} return results Click to expand and view more 在这种情况下, FastAPI 会检测到函数有一个 body parameter, 这时会使用中的参数名作为请求体的 key(field names), 并期望如下结构:\nJSON Collapse Copy { \u0026#34;item\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 }, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;dave\u0026#34;, \u0026#34;full_name\u0026#34;: \u0026#34;Dave Grohl\u0026#34; } } Click to expand and view more FastAPI 会自动进行请求解析、类型转换、验证, 并在 OpenAPI 文档中反映出这种结构\nSingular values in body 请求体中的单个参数 和 Query 、Path 可以添加额外信息一样, FastAPI 也提供了 Body 来对请求参数添加额外信息\n例如, 除了 item 和 user 外, 还想在请求体中添加一个 importance 字段, 如果直接写 importance: int 则会被当作查询参数\n可以通过 Body() 明确告诉 FastAPI 把它当作一个 body parameter\nPYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item( item_id: int, item: Item, user: User, importance: Annotated[int, Body()] ): ... Click to expand and view more 这种情况下, FastAPI 会期待如下的请求体:\nJSON Collapse Copy { \u0026#34;item\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 }, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;dave\u0026#34;, \u0026#34;full_name\u0026#34;: \u0026#34;Dave Grohl\u0026#34; }, \u0026#34;importance\u0026#34;: 5 } Click to expand and view more 它同样会自动转换数据类型、校验并生成文档\nMultiple body params and query 多个请求体参数和查询参数 也可以在多请求体参数的基础上, 添加查询参数\nPYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item( *, # 强制 key=value item_id: int, item: Item, user: User, importance: Annotated[int, Body(gt=0)], q: str | None = None, # 查询参数 ): ... Click to expand and view more Embed a single body parameter 嵌入单个请求体参数 假设只有一个请求体参数 item: Item, 默认情况下 FastAPI 期望请求体就是一个 Item 对应的结构\nJSON Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 } Click to expand and view more 但若希望如下带有 itemkey 的结构\nJSON Collapse Copy { \u0026#34;item\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 } } Click to expand and view more 那么可以使用 Body(embed=True)\nPYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item( item_id: int, item: Annotated[ Item, Body(embed=True), # embed a single param ] ): ... Click to expand and view more 这将使 FastAPI 将请求体视为嵌套结构, key 为 item\nBody - Fields 除了可以在 path operation (路径操作)函数参数中使用 Query、Path和Body来声明额外的验证和数据, 还可以在 Pydantic 模型内部的 Field 的字段验证规则和元数据\nDeclare model attributes 声明模型字段属性 首先要导入 Filed\nPYTHON Collapse Copy from pydantic import BaseModel, Field # import Filed Click to expand and view more 可以在模型字段上使用 Filed 来添加验证规则和信息\nPYTHON Collapse Copy class Item(BaseModel): name: str description: str | None = Field( default=None, title=\u0026#34;项目的描述\u0026#34;, max_length=300 ) price: float = Field(gt=0, description=\u0026#34;价格必须大于 0\u0026#34;) tax: float | None = None Click to expand and view more 实际上, Query、Path 和其他类, 都继承自一个公共的 Param 类, 而 Param 是 Pydantic 的 FieldInfo 类的子类, pydantic.Field() 返回的就是一个 FieldInfo 实例\nBody - Nested Models 在 FastAPI 中, 可以定义、校验、文档化并使用任意深度嵌套的模型\nList fields 列表字段 可以将字段定义为某种子类型, 例如 Python 的 list\nPYTHON Collapse Copy class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list = [] # list Click to expand and view more List fields with type parameter 带类型参数的列表字段 Python 提供一种\u0026quot;类型参数\u0026quot;的方法, 来指定列表类型\nPYTHON Collapse Copy # Python 3.10+ tags: list[str] = [] Click to expand and view more 对于py3.10之前的版本, 需要使用 typing 模块\nPYTHON Collapse Copy tags: List[str] = [] Click to expand and view more Set types 集和类型 如果不希望 tages 重复, 则使用 set 更加合适\nPYTHON Collapse Copy class Item(BaseModel): ... tags: set[str] = set() Click to expand and view more 这样即使客户端传来重复元素, FastAPI 也会自动去重并返回一个唯一元素集合\nNested Models 嵌套模型 Pydantic 的每个字段都可以是另一模型, 从而形成嵌套结构\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Image(BaseModel): url: str name: str class Item(BaseModel): ... image: Image | None = None @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item(item_id: int, item: Item): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;item\u0026#34;: item} Click to expand and view more 此时的 FastAPI 会期望请求体为如下结构:\nJSON Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2, \u0026#34;tags\u0026#34;: [\u0026#34;rock\u0026#34;, \u0026#34;metal\u0026#34;, \u0026#34;bar\u0026#34;], \u0026#34;image\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://example.com/baz.jpg\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;The Foo live\u0026#34; } } Click to expand and view more 这样使用 FastAPI 会获得:\n编辑器自动补全 类型转换 数据校验 自动生成文档 Special types and validation 特殊类型与验证 除了像 str, int, float 这类 singular types, 还可以使用更加负责的继承于 str 的 singular types, 全部类型可以在 Pydantic\u0026rsquo;s Type Overview 查看\n下面是 HttpUrl 的例子\nPYTHON Collapse Copy from pydantic import HttpUrl class Image(BaseModel): url: HttpUrl name: str Click to expand and view more 这样会检查 JSON schema 中的 url 是否合法, 并在 OpenAPI 文档中显示\nAttributes with lists of submodels 带有子模型属性的列表 PYTHON Collapse Copy class Image(BaseModel): url: HttpUrl name: str class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() images: list[Image] | None = None # lists of submodels Click to expand and view more 此时 FastAPI 会期望请求体有一个 images 字段, 为 Image 对象的列表\nJSON Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2, \u0026#34;tags\u0026#34;: [ \u0026#34;rock\u0026#34;, \u0026#34;metal\u0026#34;, \u0026#34;bar\u0026#34; ], \u0026#34;images\u0026#34;: [ { \u0026#34;url\u0026#34;: \u0026#34;http://example.com/baz.jpg\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;The Foo live\u0026#34; }, { \u0026#34;url\u0026#34;: \u0026#34;http://example.com/dave.jpg\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;The Baz\u0026#34; } ] } Click to expand and view more Deeply nested models 深度嵌套模型 可以定义任意深度的嵌套模型\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Image(BaseModel): url: HttpUrl name: str class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() images: list[Image] | None = None class Offer(BaseModel): name: str description: str | None = None price: float items: list[Item] @app.post(\u0026#34;/offers/\u0026#34;) async def create_offer(offer: Offer): return offer Click to expand and view more Bodies of pure lists 纯列表请求体 如果请求体的顶层是一个数组(例如上传多个图片), 可以直接将参数类型声明为列表:\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Image(BaseModel): url: HttpUrl name: str @app.post(\u0026#34;/images/multiple/\u0026#34;) async def create_multiple_images(images: list[Image]): return images Click to expand and view more Bodies of arbitrary dictS 任意字典作为请求体 可以声明请求体为一个字典 (键和值都可指定类型)\nPYTHON Collapse Copy @app.post(\u0026#34;/index-weights/\u0026#34;) async def create_index_weights(weights: dict[int, float]): return weights Click to expand and view more 虽然 JSON 标准只支持字符串作为 key, 但 Pydantic 会自动将字符串形式的数字转换为 int 因此, 如果客户端发送 { \u0026quot;1\u0026quot;: 0.1, \u0026quot;2\u0026quot;: 0.2 }, 接收到的将是 {1: 0.1, 2: 0.2} ","title":"FastAPI Body Advanced Uses"},{"link":"/posts/git-whitelist/","text":"有时你开启了一个新的项目, 运行了 cargo init、uv init 和 go mod init\n这些命令创建了工作所需要的必要文件, 同时也在 .gitignore 文件中添加了以下内容\nPLAINTEXT Collapse Copy target __pycache__ bin Click to expand and view more 一切都很顺利, 你继续开发新功能, 等到时机成熟时就将项目发布到了 Git 托管平台上\n人们开始对你的项目感兴趣, 甚至有人决定为你实现一个新功能, 这简直是免费劳动力!\n当你查看代码, 发现了一个格格不入的文件 .DS_Store, 你问那个人这是什么, 他说他根本不知道\n然后你只是将该文件从分支里面删除, 并把文件名加入了仓库的 .gitignore\nPLAINTEXT Collapse Copy target __pycache__ bin .DS_Store Click to expand and view more 现在代码合并到了 main, 仓库里只包含有用的内容\n接着, 另一人使用基于 Web 技术的 IDE 提交了另一个合并请求, 一看发现有一个完全无关的目录也被提交了, 于是 .gitignore 里又增加了一条内容\nPLAINTEXT Collapse Copy target __pycache__ bin .DS_Store .vscode Click to expand and view more 接下来, 有人使用 IntelliJ IDEA 提交了五百个 XML 文件和 .idea 目录, 这时又不得不将其加入 .gitignore\nPLAINTEXT Collapse Copy target __pycache__ bin .DS_Store .vscode .idea Click to expand and view more 多年后, .gitignore 已经有了上百行, 但是仍然时不时有各种奇怪的文件, 例如 testscripts、foo、a、qux、data.tar.gz、start.sh、cat \u0026hellip;\u0026hellip;\n你就像西西弗斯一样, 因欺骗死亡和冥界而受到永无止境的惩罚\n西西弗斯推着一块写着 .DS_Store 的巨石艰难上山\n如何改变偷偷溜进来的文件循环呢? 去教育每一个提交合并请求的人肯定不行, 得通过自动化工具解决, 而不是主观沟通\n幸运的是, 可以将这个黑名单变成白名单, 可以通过默认忽略所有文件, 然后只手动“取消忽略”明确允许的文件\nPLAINTEXT Collapse Copy * !.gitignore # 白名单：任意位置下的 src 目录及其子文件夹 !src/ !src/**/ !src/**/*.rs !Cargo.{toml,lock} # 白名单：项目根目录下的 pysrc 目录 !/pysrc/ !/pysrc/*.py !pyproject.toml !uv.lock !/cmd/ !/cmd/*.go !main.go !go.{mod,sum} !/docs/ !/docs/*.md Click to expand and view more 现在, 没人再能不小心提交不该提交的文件了. Git 会自动忽略所有文件, 只允许那些明确列入白名单的文件.\n这种做法也具备一定的“面向未来”的能力——当然, 前提是以后不会有某个 IDE 把 src/ide.rs 当成保存项目配置的理想文件路径, 但愿那一天永远不会到来\u0026hellip;\n","title":"Git Whitelist"},{"link":"/posts/fastapi-parameters-and-validations/","text":"这篇文章介绍 FastAPI 中的参数验证功能\nQuery Parameters and String Validations FastAPI 允许为参数声明额外的信息和验证规则\nPYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(q: str | None = None): results = {\u0026#34;items\u0026#34;: [{\u0026#34;item_id\u0026#34;: \u0026#34;Foo\u0026#34;}, {\u0026#34;item_id\u0026#34;: \u0026#34;Bar\u0026#34;}]} if q: results.update({\u0026#34;q\u0026#34;: q}) return results Click to expand and view more q 是类型为 str | None 的查询参数, 这意味着它可以是字符串, 也可以是 None. 其默认值是 None, 因此 FastAPI 会识别它为“可选参数”\nFastAPI 通过 = None 的默认值知道该参数是非必填的\n使用 str | None 还能帮助编辑器提供更好的类型提示和错误检测\nAdditional validation 额外验证 即使 q 是可选的, 但仍然可以设置条件: 如果提供了 q, 则长度不能超过50个字符\n使用 Query 和 Annotated 来实现\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(q: Annotated[str | None, Query(max_length=50)] = None): results = {\u0026#34;items\u0026#34;: [{\u0026#34;item_id\u0026#34;: \u0026#34;Foo\u0026#34;}, {\u0026#34;item_id\u0026#34;: \u0026#34;Bar\u0026#34;}]} if q: results.update({\u0026#34;q\u0026#34;: q}) return results Click to expand and view more 使用 Annotated 包装后, 就可以传递额外的元数据(Query(max_length=5)), 用于校验或者文档\n注意: 使用 Annotated 的时候，不能在 Query() 中再次使用 default\n❌ 错误写法 PYTHON Collapse Copy q: Annotated[str, Query(default=\u0026#34;rick\u0026#34;)] = \u0026#34;morty\u0026#34; Click to expand and view more ✅ 正确写法 PYTHON Collapse Copy q: Annotated[str, Query()] = \u0026#34;rick\u0026#34; Click to expand and view more 使用 Annotated 有以下优点\n默认值直接写在函数参数上，更符合 Python 风格 该函数在非 FastAPI 环境中调用时也能正常工作 类型检查器能更准确提示 可复用于如 Typer 等其它框架 Annotated 可附加多个元数据 More Validations 更多验证 也可以添加参数 min_length\nPYTHON Collapse Copy @app.get(\u0026#34;/items/\u0026#34;) async def read_items( q: Annotated[str | None, Query(min_length=3, max_length=50)] = None, ): ... Click to expand and view more regular expressions 正则表达式\nPYTHON Collapse Copy @app.get(\u0026#34;/items/\u0026#34;) async def read_items( q: Annotated[ str | None, Query(min_length=3, max_length=50, pattern=\u0026#34;^fixedquery$\u0026#34;) ] = None, ): ... Click to expand and view more ^: 以后面字符串开始, 之前没有其他字符串\nfixedquery: 完全匹配的单词\n$: 在此结束, 之后没有更多字符\ndefault values 默认值\n除了 None, 也可以设置其他默认值\nPYTHON Collapse Copy q: Annotated[str, Query(min_length=3)] = \u0026#34;fixedquery\u0026#34; Click to expand and view more reuqired parameters 必填参数\n如果想让参数 q 是必填的, 不设置默认值即可\nPYTHON Collapse Copy q: Annotated[str, Query(min_length=3)] Click to expand and view more 即使参数可以为 None, 但仍强制要求传值\nPYTHON Collapse Copy q: Annotated[str | None, Query(min_length=3)] Click to expand and view more query parameter list / multiple values 参数列表/多个值\n可以接收多个值的查询参数\nPYTHON Collapse Copy @app.get(\u0026#34;/items/\u0026#34;) async def read_items(q: Annotated[list[str] | None, Query()] = None): query_items = {\u0026#34;q\u0026#34;: q} return query_items Click to expand and view more 访问如下 URL\nPLAINTEXT Collapse Copy http://localhost:8000/items/?q=foo\u0026amp;q=bar Click to expand and view more 将得到多个 q 查询参数值, URL response 将如下\nJSON Collapse Copy { \u0026#34;q\u0026#34;: [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;] } Click to expand and view more 若不使用 Query(), FastAPI 会把 list[str] 当成 request body (请求体)\nDeclare more metadata 添加更多元信息 这些信息会出现在 OpenAPI 文档中\nPYTHON Collapse Copy q: Annotated[str | None, Query( title=\u0026#34;查询字符串\u0026#34;, description=\u0026#34;用于数据库中模糊搜索匹配的查询字符串\u0026#34;, min_length=3 )] = None Click to expand and view more Alias parameters 参数别名 有时想使用一个在 Python 中非法的别名, 例如 item-query\nPLAINTEXT Collapse Copy http://127.0.0.1:8000/items/?item-query=foobaritems Click to expand and view more 最接近的变量名为 item_query, 但是 item-query 不能为变量名\n此时, 可以使用别名 alias\nPYTHON Collapse Copy q: Annotated[str | None, Query(alias=\u0026#34;item-query\u0026#34;)] = None Click to expand and view more Deprecating parameters 弃用参数 想标记某个参数已被弃用, 可以加上\nPYTHON Collapse Copy Query(..., deprecated=True) Click to expand and view more Exclude parameters from OpenAPI 从OpenAPI中隐藏参数 可以设置参数不出现在自动生成的文章中\nPYTHON Collapse Copy hidden_query: Annotated[str | None, Query(include_in_schema=False)] = None Click to expand and view more Custom validation 自定义校验 若内建参数不够用, 可以使用 Pydantic v2 的 AfterValidator\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import AfterValidator from typing import Annotated def check_valid_id(id: str): if not id.startswith((\u0026#34;isbn-\u0026#34;, \u0026#34;imdb-\u0026#34;)): raise ValueError(\u0026#34;Invalid ID format, 必须以 \u0026#39;isbn-\u0026#39; 或 \u0026#39;imdb-\u0026#39; 开头\u0026#34;) return id @app.get(\u0026#34;/items/\u0026#34;) async def read_items( id: Annotated[str | None, AfterValidator(check_valid_id)] = None, ): if id: team = data.get(id) else: id, item = random.choice(list(data.items())) return {\u0026#34;id\u0026#34;: id, \u0026#34;name\u0026#34;: item} Click to expand and view more value.startswith((\u0026quot;isbn-\u0026quot;, \u0026quot;imdb-\u0026quot;)) 可以一次检查多个前缀 random.choice(list(data.items())) 取出随机的键值对 Path Parameters and Numberic Validations 和使用 Query 查询参数声明更多验证规则和元数据一样, 也可以使用 Path 为路径参数声明相同类型的规则验证和元数据\nImport Path 导入路径 首先, 从 fastapi 中导入 Path, 并导入 Annotated\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Path, Query app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( item_id: Annotated[int, Path(title=\u0026#34;要获取的物品 ID\u0026#34;)], q: Annotated[str | None, Query(alias=\u0026#34;item-query\u0026#34;)] = None, ): results = {\u0026#34;item_id\u0026#34;: item_id} if q: results.update({\u0026#34;q\u0026#34;: q}) return results Click to expand and view more Declare metadata 声明元数据 可以像在 Query 中一样声明所有的参数\nPYTHON Collapse Copy item_id: Annotated[int, Path(title=\u0026#34;要获取的物品 ID\u0026#34;)] Click to expand and view more ⚠️ 路径参数总是必填的, 它必须作为路径的一部分存在. 即使将它设为 None 或指定默认值, 也不会生效, 它仍然是必须的\nOrder the parameters 自由排序参数 如果希望 query parameter 声明为必填的 str, 并且不需要声明任何其他事情, 那么不需要用 Query() 包裹\n但是对于 path parameter item_id 仍然需要使用 Path, 并且出于一些原因并不像使用 Annotated\n如果将有 defalult 默认值的参数, 放到没有默认值参数前面, 那么 Python 会报错, 所以要这样声明函数\nPYTHON Collapse Copy from fastapi import FastAPI, Path app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items(q: str, item_id: int = Path(title=\u0026#34;要获取的物品 ID\u0026#34;)): results = {\u0026#34;item_id\u0026#34;: item_id} if q: results.update({\u0026#34;q\u0026#34;: q}) return results Click to expand and view more 但是, 如果使用 Annotated 就不会有这个顺序的问题, 因为默认值并不写在函数参数中\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( q: str, item_id: Annotated[int, Path(title=\u0026#34;要获取的物品 ID\u0026#34;)] ): ... Click to expand and view more Order the parameters tricks 参数顺序技巧 如果不想使用 Annotated, 但是又想:\n为查询参数 q 不使用 Query, 也不设置默认值 为路径参数 item_id 使用 Path 两个参数顺序任意 不想用 Annotated 那可以使用一个小技巧: 在函数参数前面加一个星号 *\n作用是: 告诉 Python, 后面所有参数必须作为关键字参数传入 (即使用key=value的方法, 不能省略参数名)\nPYTHON Collapse Copy async def read_items(*, item_id: int = Path(title=\u0026#34;The ID of the item to get\u0026#34;), q: str): ... Click to expand and view more Better with Annotated 推荐使用Annotated 如果使用 Annotated, 由于不是用参数默认值来传递 Path()、Query(), 就不需要使用*这种语法\nPYTHON Collapse Copy # Python 3.9+ async def read_items( item_id: Annotated[int, Path(title=\u0026#34;The ID of the item to get\u0026#34;)], q: str ): ... Click to expand and view more Number Validations 数字验证 在 FastAPI 中, 可以通过 Path()、Query() (以及其他参数类) 为数值类型参数添加约数条件, 有以下四种:\ngt: greater than (大于) ge: greater than or equal (大于等于) lt: less than (小于) le: less than or equal (小于等于) 这些验证适用于路径参数(path parameter)和查询参数(query parameter), 并且支持 int 和 float 类型\n整数验证示例 (Path 参数)\n使用 ge=1 表示 item_id 必须是一个大于等于1的整数\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Path app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( item_id: Annotated[int, Path(title=\u0026#34;要获取的项目 ID\u0026#34;, ge=1)], q: str ): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q} Click to expand and view more 也可以通过 ge 和 le 同时限制一个整数的区间范围\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( item_id: Annotated[int, Path(title=\u0026#34;要获取的项目 ID\u0026#34;, gt=0, le=1000)], q: str ): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q} Click to expand and view more 浮点数验证示例 (Query 参数)\n浮点类型的校验同样适用. 例如, 使用 gt 可以确保值 严格大于 0\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( *, item_id: Annotated[int, Path(title=\u0026#34;项目 ID\u0026#34;, ge=0, le=1000)], q: str, size: Annotated[float, Query(gt=0, lt=10.5)], ): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q, \u0026#34;size\u0026#34;: size} Click to expand and view more item_id 必须在 [0, 1000] 区间内 size 必须在 (0, 10.5) 区间内 ","title":"FastAPI Parameters and Validations"},{"link":"/posts/fastapi-parameters/","text":"FastAPI 是一个现代、快速（高性能）的 Python Web 框架, 它自动处理参数的解析、验证和文档生成\n本文将介绍 FastAPI 中三类最常用的参数: 路径参数 (Path Parameters)、查询参数 (Query Parameters) 和 请求体(Request Body) 的用法与原理\n1. Path Parameters 路径参数 路径参数是 URL 路径中的动态部分, 使用 {} 包裹表示\nPYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str): return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more 访问 /items/foo 返回:\nPYTHON Collapse Copy {\u0026#34;item_id\u0026#34;: \u0026#34;foo\u0026#34;} Click to expand and view more Data conversion \u0026amp; validation 类型声明与自动转换 可以为路径参数声明类型, FastAPI 会自动解析并验证:\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: int): return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more 访问 /items/3, item_id 会被转换为 int 类型\nRouting orders 路由匹配顺序 路径匹配按声明顺序执行, 例如\nPYTHON Collapse Copy @app.get(\u0026#34;/users/me\u0026#34;) async def read_user_me(): return {\u0026#34;user_id\u0026#34;: \u0026#34;current_user\u0026#34;} @app.get(\u0026#34;/users/{user_id}\u0026#34;) async def read_user(user_id: str): return {\u0026#34;user_id\u0026#34;: user_id} Click to expand and view more 必须先声明 /users/me, 否则会被 /users/{user_id} 捕获\nPredefined enum values 预定义枚举值 使用 Python 的 Enum 定义一组可选的路径参数值\nPYTHON Collapse Copy from enum import Enum class ModelName(str, Enum): alexnet = \u0026#34;alexnet\u0026#34; resnet = \u0026#34;resnet\u0026#34; lenet = \u0026#34;lenet\u0026#34; @app.get(\u0026#34;/models/{model_name}\u0026#34;) async def get_model(model_name: ModelName): return {\u0026#34;model_name\u0026#34;: model_name} Click to expand and view more Swagger 文档会自动显示可选值\nPath parameters containing paths 路径型参数 默认路径参数不能包含斜杠 /, 但可以用 :path 声明允许匹配完整路径\nPYTHON Collapse Copy @app.get(\u0026#34;/files/{file_path:path}\u0026#34;) async def read_file(file_path: str): return {\u0026#34;file_path\u0026#34;: file_path} Click to expand and view more 访问 /files/home/user/file.txt, file_path 会是 \u0026quot;home/user/file.txt\u0026quot;\n2. Query Parameters 查询参数 查询参数是 URL ? 后的键值对, 不属于路径部分\nPYTHON Collapse Copy fake_items_db = [{\u0026#34;item_name\u0026#34;: \u0026#34;Foo\u0026#34;}, {\u0026#34;item_name\u0026#34;: \u0026#34;Bar\u0026#34;}] @app.get(\u0026#34;/items/\u0026#34;) async def read_items(skip: int = 0, limit: int = 10): return fake_items_db[skip : skip + limit] Click to expand and view more 访问 /items/?skip=0\u0026amp;limit=10 时, 会自动把查询参数 skip 和 limit 转成 int\nOptional parameters 可选参数默认值 给查询参数赋默认值即为可选\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str, q: str | None = None): if q: return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q} return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more q 是可选查询参数, 默认为 None\nQuery parameter type conversion 查询参数类型转换 PYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str, q: str | None = None, short: bool = False): ... Click to expand and view more 支持自动把字符串转换成布尔值, 以下都会被识别为 True\nPLAINTEXT Collapse Copy http://127.0.0.1:8000/items/foo?short=1 Click to expand and view more 或者\n?short=true ?short=on ?short=yes Multiple path and query parameters 多路径查询参数组合 路径参数和查询参数可混合使用, 无需声明顺\nPYTHON Collapse Copy @app.get(\u0026#34;/users/{user_id}/items/{item_id}\u0026#34;) async def read_user_item(user_id: int, item_id: str, q: str | None = None, short: bool = False): ... Click to expand and view more Required query parameters 必填查询参数 未设置默认值的查询参数为必填参数\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str, needy: str): ... Click to expand and view more 上面的 needy 就是一个必填的 str 类型\n当然也可以定义一些必填参数, 以及有默认值的可选参数\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_user_item( item_id: str, needy: str, skip: int = 0, limit: int | None = None ): ... Click to expand and view more needy \u0026amp; item_id, 必填 str 类型 skip, 默认值为 0 的类型 limit, 一个可选的类型 [注]\n路径参数永远是必填的, 因为它们来自 URL 本身 PYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) def read(item_id: str = \u0026#34;123\u0026#34;): # 这里写默认值是无效的 ... Click to expand and view more 类型为 Optional[...] 或 type | None 不等于可选参数, 仍然要配合默认值 = None 才是可选 PYTHON Collapse Copy def func(x: int | None): # 必填 def func(x: int | None = None): # 可选 Click to expand and view more 3. Request Body 当通过 API 传送数据的时候, 通常通过 request body 发送\nrequest body 是 client 客户端发送给 API 的数据, 而 response body 是 API 发送给 client 的数据\nPydantic\u0026rsquo;s BaseModel 使用 Pydantic 定义数据模型\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None app = FastAPI() @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item): return item Click to expand and view more Declare it as a parameter 在路由中声明请求体\nPYTHON Collapse Copy @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item): return item Click to expand and view more FastAPI 会:\n读取 request body, 并转换为 JSON 校验字段和类型 返回类型错误时给出详细反馈, 包括数据那里以及导致了什么错误 提供编辑器类型提示 生成模型的 JSON Schema 定义, 也可以在项目中任何位置使用 根据 schema 自动生成文档 Request body + path + query parameters 路径参数、查询参数与请求体同时使用 PYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item(item_id: int, item: Item, q: str | None = None): result = {\u0026#34;item_id\u0026#34;: item_id, **item.dict()} if q: result.update({\u0026#34;q\u0026#34;: q}) return result Click to expand and view more 这个函数参数会被以下方式识别:\n如果参数同时在 path 中声明, 被当成 path parameter 如果参数为单一类型, 如 int, float, str 或 bool 等, 将会被解释为 query parameter 如果参数声明为一个 Pydantic Model, 将被解释为 request body ","title":"FastAPI Parameters"},{"link":"/posts/python-tricks/","text":"1. The Self-Replicating Trick 将一个含有空列表的列表乘5, 得到有5个空列表的列表\nPYTHON Collapse Copy x = [[]] * 5 x Click to expand and view more [[], [], [], [], []]\n当使用.append(\u0026quot;x\u0026quot;)方法时, 所有列表都被修改\nPYTHON Collapse Copy x[0].append(\u0026#34;x\u0026#34;) x Click to expand and view more [[\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;]]\n打印其 id 可以看到, id 都相同\nPYTHON Collapse Copy for item in x: print(id(item)) Click to expand and view more 4417579584\n4417579584\n4417579584\n4417579584\n4417579584\n或者使用set()发现 id 唯一\nPYTHON Collapse Copy set(id(item) for item in x) Click to expand and view more {4417579584}\n也就是说, 当使用乘法的时候, 创建了5个内部列表的引用副本\n使用反汇编发现, 只创建了两个列表, 并执行乘5\nPYTHON Collapse Copy dis.dis(\u0026#34;[[]] * 5\u0026#34;) 0 0 RESUME 0 # 用于支持解释器恢复 (py3.11) 1 2 BUILD_LIST 0 # 构造一个空列表[], 压栈 4 BUILD_LIST 1 # 从栈顶取一个对象, 构造列表[[]] 6 LOAD_CONST 0 (5) # 加载常量 5 8 BINARY_OP 5 (*) # 对栈顶两个元素执行乘法 12 RETURN_VALUE # 返回栈顶结果 Click to expand and view more The alternative 如果要构造独立列表, 应改用列表推导式\nPYTHON Collapse Copy x = [[] for _ in range(5)] x Click to expand and view more [[], [], [], [], []]\nPYTHON Collapse Copy for item in x: print(id(item)) Click to expand and view more 4587832384\n4587818752\n4587831168\n4587839168\n4587809152\nPYTHON Collapse Copy set(id(item) for item in x) Click to expand and view more {4587809152, 4587818752, 4587831168, 4587832384, 4587839168}\n2. The Teleportation Trick PYTHON Collapse Copy def add_to_shopping_list(item, shopping_list=[]): shopping_list.append(item) return shopping_list Click to expand and view more 上面函数为一个空列表中添加一个 item, 期望每次创建一个新的空列表, 并添加一个item\nPYTHON Collapse Copy groceries = add_to_shopping_list(\u0026#34;Bread\u0026#34;) groceries Click to expand and view more [\u0026lsquo;Bread\u0026rsquo;]\nPYTHON Collapse Copy books = add_to_shopping_list(\u0026#34;A Brief History of Time\u0026#34;) books Click to expand and view more [\u0026lsquo;Bread\u0026rsquo;, \u0026lsquo;A Brief History of Time\u0026rsquo;]\n然而, \u0026lsquo;Bread\u0026rsquo; 被传送到 books 里面去了\n下面不使用默认参数, 测试一下函数\nPYTHON Collapse Copy cakes = [] cakes = add_to_shopping_list(\u0026#34;Chorolate Cake\u0026#34;, cakes) cakes Click to expand and view more [\u0026lsquo;Chorolate Cake\u0026rsquo;]\nPYTHON Collapse Copy tools = [] tools = add_to_shopping_list(\u0026#34;Snapper\u0026#34;, tools) tools Click to expand and view more [\u0026lsquo;Snapper\u0026rsquo;]\n当传入一个存在的列表时, 没有发生传送行为\n回到函数定义: 默认参数的列表, 在函数定义的时候已经被创建了, 因此每次使用该函数而不传入列表参数的时候, 默认列表shopping_list就会被使用, 且 list 是一个可变类型, 因此每次会修改这个列表\n使用下面方法, 每次打印出使用列表的 id, 会发现不传入列表参数时的 id 都相同\nPYTHON Collapse Copy def add_to_shopping_list(item, shopping_list=[]): print(id(shopping_list)) shopping_list.append(item) return shopping_list Click to expand and view more The alternative 这个 bug 在使用可变类型(mutable)作为默认参数的时候都会发生, 应该避免可变数据类型作为默认参数\n如果想要默认值参数, 可以考虑使用 None 作为参数默认值\nPYTHON Collapse Copy def add_to_shopping_list(item, shopping_list=None): if shopping_list is None: shopping_list = [] shopping_list.append(item) return shopping_list Click to expand and view more The Vanishing Trick 下面是最后一个 trick\nPYTHON Collapse Copy doubles = (number * 2 for number in range(10)) 4 in doubles # True 4 in doubles # False Click to expand and view more 上面结果看起来很矛盾, 4 怎么一会儿在 doubles 中, 一会儿又不再 doubles 中?\n再来看一个例子\nPYTHON Collapse Copy another_doubles = [number * 2 for number in range(10)] 4 in another_doubles # True 4 in another_doubles # True Click to expand and view more 上面这个例子中, 就都是 True\n问题出在, 当使用括号()创建 doubles 的时候, 并不是创建了元组 tuple, 而是一个生成器 generator\nPYTHON Collapse Copy doubles = (number ** 2 for number in range(10)) doubles Click to expand and view more \u0026lt;generator object at 0x111718e10\u0026gt;\n生成器并不会包含所有的值, 而是在使用的时候生成每个值\n例如, 调用 next() 会返回下一个值\nPYTHON Collapse Copy next(doubles) # 0 next(doubles) # 1 next(doubles) # 2 next(doubles) # 4 ... next(doubles) # 18 next(doubles) Click to expand and view more StopIteration Traceback (most recent call last)\n生成器是一次型的数据结构, 当生成下一个数据的时候, 之前的数据不会被保存, 也就是只能遍历数据一次\n一但遍历完成, 就会报StopIteration的错误, 所以当运行4 in doubles的时候, 先得到0, 为 False, 生成器会继续遍历下一个, 直到得到4, 当再次调用的时候, 下一个返回6, 直到遍历结束也无法得到到4\n同样的行为在迭代器 iterator 上也一样\nPYTHON Collapse Copy numbers = [2, 4, 6, 8] numbers_rev = reversed(numbers) numbers_rev # \u0026lt;list_reverseiterator object at 0x......\u0026gt; 4 in numbers_rev # True 4 in numbers_rev # False Click to expand and view more The alternative 如果使用生成器, 要知道只能遍历每个元素一次, 如果要获得一个有所有元素的数据结构, 应该使用元素 tuple 或列表 list\nPYTHON Collapse Copy doubles = (number * 2 for number in range(10)) # generator more_doubles = tuple(number * 2 for number in range(10)) # tuple 4 in more_doubles # True 4 in more_doubles # True Click to expand and view more ","title":"Python Tricks"},{"link":"/posts/executing-arbitrary-python-code-from-a-comment/","text":"通过注释执行任意Python代码\n问题描述 Q: 只能控制一行的.py代码中注释的内容(\\n\\r均会被替换为空字符), 如何执行任意代码?\nA: 在注释#中, 构造一个.zip 文件, python 会将该内容当成一个zip包执行, 触发任意代码执行\n解决方案 从 Python 3.5 起, 可以直接执行一个 .zip 文件\nPYTHON3 Collapse Copy python myapp.zip Click to expand and view more 前提是ZIP 包中包含一个顶层的__main__.py文件, Python 会把它当作 zipapp, 自动解压并运行__main__.py\nPython 会从末尾找到 ZIP 的目录结构, 而不是依赖文件头, 所以前面的“垃圾”字节会被忽略\nPython 源码中的任何行, 只要以 # 开头, 解释器都会忽略后面内容, 因此可以:\n把 ZIP 文件的数据藏在 Python 源码中的注释中（开头加 #） 把 ZIP 数据直接拼接在 Python 文件的后面, 只保证文件头部分是合法 Python ZIP 不关心前缀, Python 只要最前面是有效源码, 也不会管后面 难点 ZIP 文件头包含二进制字段，比如\n偏移量（文件数据相对于 ZIP 开头的位置） 长度（文件名长度、注释长度等） 这些值写死在 header 里, 是十六进制整数 如果这些字节中出现了像 \\x00、\\xFF 等非 ASCII 内容, Python 就不能把它当注释 解决方法: 暴力穷举合法组合\n想办法 调整偏移值和结构位置，使得最终写出来的 ZIP 文件\n所有的字段值都转化为 可打印字符（ASCII 范围内） 所有 binary 字段看起来都像合法的注释字符串 于是用 itertools.product(range(256), repeat=2) 暴力尝试偏移组合，只要碰巧生成的 ZIP 包所有关键字节都在可打印范围内（ASCII 32~126），就认为成功。 下面是generate_polygloy_zip.py代码, 会生成一个符合要求的polygloy.py代码, 最后运行该代码, 可以执行Body里面的内容BODY = b\u0026quot;print('FROM MAIN.py FILE!!!')#\u0026quot;\nPYTHON3 Collapse Copy # struct: 按字节结构打包数据，方便构造 ZIP 文件二进制头 # itertools: 用来暴力枚举 CRC 校验和后缀（确保安全ASCII） # zlib: 计算 CRC32 校验和 import struct, itertools, zlib # 文件开头代码 # encode(): Unicode 字符串 -\u0026gt; bytes 字节串 JUNK_HEAD = \u0026#34;\u0026#34;\u0026#34;print(\u0026#34;Hello World!\u0026#34;) # This is a comment. Here\u0026#39;s another: # \u0026#34;\u0026#34;\u0026#34;.encode() # 文件结尾代码 JUNK_TAIL = \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Thanks for playing!\u0026#34;)\u0026#34;\u0026#34;\u0026#34; # zip 文件核心代码 # b: 字节串 FILENAME = b\u0026#34;__main__.py\u0026#34; BODY = b\u0026#34;print(\u0026#39;FROM MAIN.py FILE!!!\u0026#39;)#\u0026#34; # 校验 CRC 是否为 ASCII-safe def ascii_safe(x: int) -\u0026gt; bool: return all(((x \u0026gt;\u0026gt; (8*i)) \u0026amp; 0x80) == 0 for i in range(4)) # 检查 32 位整数的四个字节，每个字节最高位（0x80）是否为 0，即是否为 ASCII 范围内的字节 def find_suffix(core: bytes, length: int = 4) -\u0026gt; tuple[bytes, int]: \u0026#34;\u0026#34;\u0026#34; - ZIP 文件 CRC32 计算结果必须 ASCII-safe（低于 0x80） - 这里用暴力方法，给 payload 后面加4字节后缀，找到合适的后缀让 CRC32 满足 ASCII-safe 条件 \u0026#34;\u0026#34;\u0026#34; printable = range(0x20, 0x7f) for tail in itertools.product(printable, repeat=length): payload = core + bytes(tail) crc = zlib.crc32(payload) \u0026amp; 0xFFFFFFFF if ascii_safe(crc): return bytes(tail), crc raise RuntimeError(\u0026#34;No ASCII-safe CRC found.\u0026#34;) # 计算最终 payload SUFFIX, CRC = find_suffix(BODY) PAYLOAD = BODY + SUFFIX SIZE = len(PAYLOAD) def le32(x): return struct.pack(\u0026#34;\u0026lt;I\u0026#34;, x) # 4字节小端无符号整数 def le16(x): return struct.pack(\u0026#34;\u0026lt;H\u0026#34;, x) # 2字节小端无符号整数 # ZIP 结构中各签名常量 SIG_LFH = 0x04034B50 # 本地文件头 Local File Header SIG_CDH = 0x02014B50 # 中央目录头 Central Directory Header SIG_EOCD = 0x06054B50 # 结束目录头 End of Central Directory # zip 文件偏移量设置 delta = len(JUNK_HEAD) # 构建 Local File Header \u0026#34;\u0026#34;\u0026#34; Local File Header 是 ZIP 格式中的一部分，告诉解压程序该文件的元信息 - version needed to extract，flags，compression method 等字段置 0 表示无压缩，简单存储 - CRC32、压缩大小、解压大小都是我们计算的 - 文件名长度和文件名 \u0026#34;\u0026#34;\u0026#34; lfh = ( le32(SIG_LFH) + le16(0) + le16(0) + le16(0) + le16(0) + le16(0) + le32(CRC) + le32(SIZE) + le32(SIZE) + le16(len(FILENAME)) + le16(0) + FILENAME ) # 构建 Central Directory Header \u0026#34;\u0026#34;\u0026#34; - Central Directory 是 ZIP 文件目录结构，记录每个文件信息和偏移， - 其中重要的是 relative offset of LFH，也就是 Local File Header 在整个 ZIP 文件里的偏移，必须加上 delta \u0026#34;\u0026#34;\u0026#34; cdh = ( le32(SIG_CDH) + le16(0) + le16(0) + le16(0) + le16(0) + le16(0) + le16(0) + le32(CRC) + le32(SIZE) + le32(SIZE) + le16(len(FILENAME)) + le16(0) + le16(0) + le16(0) + le16(0) + le32(0) + le32(delta) + FILENAME ) # 确保偏移量 ASCII-safe \u0026#34;\u0026#34;\u0026#34; - ZIP 目录偏移需要是 ASCII 字节，否则写入 .py 文件时会出错 - 这里通过填充若干 \\x00 字节，保证偏移合法 \u0026#34;\u0026#34;\u0026#34; cd_offset = delta + len(lfh) + len(PAYLOAD) pad = 0 while not ascii_safe(cd_offset + pad): pad += 1 padding = b\u0026#39;\\x00\u0026#39; * pad cd_offset += pad # 构建 End of Central Directory Header \u0026#34;\u0026#34;\u0026#34; EOCD 记录 ZIP 中央目录大小、偏移及注释长度等信息 \u0026#34;\u0026#34;\u0026#34; eocd = ( le32(SIG_EOCD) + le16(0) + le16(0) + le16(1) + le16(1) + le32(len(cdh)) + le32(cd_offset) + le16(len(JUNK_TAIL)) ) # 拼接完整 ZIP 内容 zip_bytes = lfh + PAYLOAD + padding + cdh + eocd zip_bytes = bytearray(zip_bytes) assert all(b \u0026lt; 0x80 for b in zip_bytes), \u0026#34;非 ASCII 字节存在\u0026#34; # 写入 polyglot.py 文件 with open(\u0026#34;polyglot.py\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(JUNK_HEAD + zip_bytes + JUNK_TAIL.encode()) # 运行提示 print(\u0026#34;✅ polyglot.py 生成完毕。运行它即可执行嵌入的 __main__.py 内容：\u0026#34;) print(\u0026#34; $ python3 polyglot.py\u0026#34;) Click to expand and view more ","title":"Executing arbitrary Python code from a comment"},{"link":"/posts/how-fastapi-works/","text":"FastAPI 的工作原理: 从 routing 到 lifecycle 以及在现实中的使用\nFastAPI FastAPI 是一个现代的 Python Web 框架, 注重高性能和开发效率. 旨在帮助开发者编写结构清晰、可靠的API, 同时尽量减少样板代码 (boilerplate)\n其由以下两个库驱动:\nStarlette: 负责 Web 服务器逻辑、路由、中间件和异步能力 Pydantic: 基于 Python 类型提示, 处理数据验证、解析和序列化 此外, Fastapi 还有输入验证、基于 Swagger UI 的自动文档生成和代码清晰化的基础\nAPI 请求周期 Fastapi 的请求生命周期如下\nPLAINTEXT Collapse Copy 客户端请求 (Client Request) ↓ FastAPI App ↓ 中间件（Middleware） ↓ 路由匹配 (Route Matching) ↓ 依赖注入（Dependency Injection） ↓ 输入验证 (Input Validation) ↓ 端点函数 (Endpoint) ↓ 响应序列化 (Response Serialization) ↓ 客户端响应 (Client Response) Click to expand and view more 请求首先进入 FastAPI 应用 (本质就是一个 Starlette 应用) 所有中间件优先执行 (如: 日志、错误处理、CORS等) 路由器检查路径和方法, 找到对应的处理函数 FastAPI 使用Depends解析依赖 使用 Pydantic 自动解析并验证输入数据 执行端点函数, 参数验证完毕 返回结果被序列化为合适的响应格式 (JSON) 响应返回给客户端 路由 Router 在应用对象上定义\n适合小项目或原型验证 PYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) def read_item(): return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more 使用 APIRouter 模块化\n适合大项目 PYTHON Collapse Copy from fastapi import FastAPI router = APIRouter(prefix=\u0026#34;/users\u0026#34;, tags=[\u0026#34;users\u0026#34;]) @router.get(\u0026#34;/{user_id}\u0026#34;) def get_user(user_id: int): return {\u0026#34;user_id\u0026#34;: user_id} Click to expand and view more 使用APIRouter可以将相关的端点分组, 添加前缀和标签, 保持代码结构清晰模块化 当某个请求与端点匹配时, FastAPI 内部执行一下步骤:\nStarlette 找到对应路由, 并创建一个APIRouter实例 FastAPI 使用get_router_header()包装端点函数并解析依赖 使用 Pydantic 或基本类型对请求数据解析与验证 装饰函数被调用, 传入验证后的参数 返回值被序列化为响应对象 依赖注入: 干净、可复用的逻辑 FastAPI 有一个轻量且强大的依赖注入系统, 可以进行数据库链接、身份验证信息或配置信息等\nPYTHON Collapse Copy from fastapi import Depends def get_db(): db = create_db_session() try: yield db finally: db.close() @app.get(\u0026#34;/items/\u0026#34;) def read_items(db=Depends(get_db)): return db.query(item).all() Click to expand and view more 使用Depends, FastAPI 会负责调用get_db, 处理生成器生命周期, 并将结果注入到函数中\n原生支持异步 (Async) 不同于一些后加入 async 的框架, FastAPI 一开始就设计为支持 async/await\nPYTHON Collapse Copy from fastapi import FastAPI import asyncio app = FastAPI() @app.get(\u0026#34;/hi\u0026#34;) async def greet(): await asyncio.sleep(1) return \u0026#34;Hello? World?\u0026#34; Click to expand and view more 当 fastapi 收到 /hi 这个 URL 的 GET 请求时，会自动调用 async greet(), 无需在任何地方添加 await\n但是, 对于其他的 async def 函数, 调用的时候必须在前面加上 await\nFastAPI 会运行一个异步事件循环，用于执行异步路径函数(async path functions)，同时也会使用一个线程池来处理同步函数(synchronous path functions), 这样就不需要手动调用 asyncio.gather() 和 asyncio.run() 之类的方法\n示例: CURD API PYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str = None price: float tax: float = None @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item): total = item.price + (item.tax or 0) return {\u0026#34;name\u0026#34;: item.name, \u0026#34;total_price\u0026#34;: total} @app.get(\u0026#34;/\u0026#34;) def read_root(): return {\u0026#34;message\u0026#34;: \u0026#34;FastAPI is working!\u0026#34;} Click to expand and view more 运行\nPLAINTEXT Collapse Copy uvicorn main:app --reload Click to expand and view more 还可以使用 Gunicorn 部署4个 Uvicorn 异步服务 PLAINTEXT Collapse Copy gunicorn main:app --workers 4 --worker-class \\ uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000 Click to expand and view more 实际上也可以直接诶使用 uvicorn 运行多个进程, 但是这样无法进行进程管理，因此使用 gunicorn 的方法一般更多被使用 性能提升 如果 API 返回大量数据, 使用 ORJSON 加快序列化速度\nPYTHON Collapse Copy from fastapi import FastAPI from fastapi.responses import ORJSONResponse app = FastAPI(default_response_class=ORJSONResponse) Click to expand and view more ","title":"How FastAPI Works"},{"link":"/posts/chaos-enginnering-in-partice/","text":"记录一个小故事 hhh\n“混沌工程”实践 项目延期，开发说时间不够干不完 老板：“不够就招人”\n今天偶然听到旁边同事给新来的员工做code review：\nQ：你这个代码不要这样写，因为\u0026hellip;\u0026hellip; A：哦，懂了 Q：唉？你这个 .idea/ 文件是什么？ A：啊？我也不知道 我：不是???(一脸震惊) 理想：Plan Do Check Act\n现实：Plan Delay Cancel Apologize\n","title":"\"Chaos Enginnering\" In Partice"},{"link":"/posts/blaugust/","text":"🎈 Oh hello, August! It\u0026rsquo;s time for Blaugust.\nBlaugust Begins: Writing as a Develpoer Habit This year, I\u0026rsquo;m joining Blaugust - a month-long blogging challenge that encourage consistent writing throught August. For develpoers, blogging isn\u0026rsquo;t just sharing, it\u0026rsquo;s about orgainzing thoughts, documenting ideas, and creating term references.\nWhat I Plan to Write Here is what I aim to cover this month:\nDaily dev partices: tools, logging, project structure patterns Python ecosystem: FastAPI, Pydantic, Langchain, Pytest and more AI project logs: buliding AI agents and orchestration workflows Architecture notes: async patterns, micorservice, data flow Learning notes \u0026amp; translation of blogs: deep dive into code and quality tech atricles I\u0026rsquo;m not necessarily writing one post per day - some days I might write multiple posts in advance - but the goal is to publish daily with a focus on consistency, reusability, and value.\nWriting Platform and Setup This blog is build with Hugo + Github Pages, using the narrow theme. Markdown keeps things simple, and version control is headled vai Git.\nRSS feed is available (blogroll exchange is welcome!)\nIf you\u0026rsquo;re blogging too or joining Blaugust, feel free to connect 👋 ","title":"Blaugust"},{"link":"/posts/dive-into-deeplearning-preliminaries/","text":" Course Note: d2l-video-04 - 数据操作+数据预处理 Jupyter Notebook: chapter_preliminaries/ 介绍 N 纬数组介绍\n0-d (标量)\nPLAINTEXT Collapse Copy 1.0 Click to expand and view more 一个类别\n1-d (向量)\nPLAINTEXT Collapse Copy [1.0, 2.7, 3.4] Click to expand and view more 一个特征向量\n2-d (矩阵)\nPLAINTEXT Collapse Copy [[1.0, 2.7, 3.4], [1.0, 2.7, 3.4], [1.0, 2.7, 3.4]] Click to expand and view more 一个样本 - 特征矩阵\n3-d RGB 图片(宽 x 高 x 通道)\nPLAINTEXT Collapse Copy [[[1.0, 2.7, 3.4], [1.0, 2.7, 3.4], [1.0, 2.7, 3.4]], [[1.0, 2.7, 3.4], [1.0, 2.7, 3.4], [1.0, 2.7, 3.4]]] Click to expand and view more 4-d 一个 RGB 图片批量 (批量大小 x 宽 x 高 x 通道)\nPLAINTEXT Collapse Copy [[[[... ... ...]]]] Click to expand and view more 5-d 一个视屏批量 (批量大小 x 时间 x 宽 x 高 x 通道)\nData Manipulation 数据操作 张量(tensor)表示一个数值表示的数组, 这个数组可能有多个纬度, 下面介绍一下 pytorch 里面基础的张量运算\n创建张量\nPYTHON Collapse Copy import torch x = torch.arange(12) shape = x.shape # 元素形状 num = x.numel() # 元素总数 X = x.reshape(3, 4) # 改变张量形状 Click to expand and view more 生成张量\nPYTHON Collapse Copy torch.zeros((2, 3, 4)) # 形状为 2x3x4 的全0张量 torch.ones((2, 3, 4)) # 形状为 2x3x4 的全1张量 torch.randn(3, 4) # 形状为 3 x 4 的随机张量 torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]) # 通过py数组生成张量 Click to expand and view more 张量运算\nPYTHON Collapse Copy x = torch.tensor([1.0, 2, 4, 8]) # .0 表示为浮点数, 会转换为浮点数张量, 而不是整数 y = torch.tensor([2, 2, 2, 2]) x + y, x - y, x * y, x / y, x ** y # 对应位置的元素进行标准运算 Click to expand and view more 按照行 或 列 连结(concatenate) 在一起\nPYTHON Collapse Copy X = torch.arange(12, dtype=torch.float32).reshape((3,4)) # shape: 3x4 Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]) # shape: 3x4 torch.cat((X, Y), dim=0) # 第0纬(外层)连结: 变成6x8 torch.cat((X, Y), dim=1) # 第1纬(内存)连结: 变成3x8 Click to expand and view more 通过逻辑运算符构建二元张量\nPYTHON Collapse Copy X == Y Click to expand and view more 张量所有元素求和\nPYTHON Collapse Copy X.sum() Click to expand and view more 即使形状不同, 仍然可以通过调用 广播机制(broadcasting mechanism) 来执行按元素操作\nPYTHON Collapse Copy # 使用 广播机制(broadcasting mechanism) 将形状不同的元素相加 a = torch.arange(3).reshape((3, 1)) b = torch.arange(2).reshape((1, 2)) # 将 a 3x2 复制为 3x2 的矩阵 # 将 b 1x2 复制为 3x2 的矩阵 a + b Click to expand and view more 选择元素\nPYTHON Collapse Copy X[-1], X[1:3] # 使用下标, 切片获取元素 X[1, 2] = 9 # 使用指定索引修改元素 X[0:2, :] = 12 # 为多个元素复制 (第一纬度中的 0,1 全部赋值为12) Click to expand and view more 内存相关\n内存重新分配\nPYTHON Collapse Copy before = id(Y) Y = Y + X # 这里加法导致Y内存重新分配 id(Y) == before # False Click to expand and view more 执行原地操作\nPYTHON Collapse Copy Z = torch.zeros_like(Y) print(\u0026#39;id(Z):\u0026#39;, id(Z)) # 使用X[:] = X + Y或X += Y来减少操作的内存开销 Z[:] = X + Y print(\u0026#39;id(Z):\u0026#39;, id(Z)) # 与上 print 输出相同 before = id(X) X += Y id(X) == before # True Click to expand and view more 类型转换\n转换为NumPy张量 (ndarray)\nPYTHON Collapse Copy A = X.numpy() B = torch.tensor(A) type(A), type(B) #\u0026gt; (numpy.ndarray, torch.Tensor) Click to expand and view more 将大小为1的张量转换为Python标量\nPYTHON Collapse Copy a = torch.tensor([3.5]) a, a.item(), float(a), int(a) #\u0026gt; (tensor([3.5000]), 3.5, 3.5, 3) Click to expand and view more Data Preprocessing 数据预处理 csv 全称 Comma-Seperated Values 即逗号分开的值, 是一种文本文件格式, 用来存储表格数据, 数据项之间通常用逗号分隔, 行与行之间用换行符分隔. 实际上, 可以使用其他符号, 例如;来做分隔符\n下面通过一个读取csv文件的例子, 说明如何将csv中的数据读入 pytorch\n首先构造一个csv文件\nPYTHON Collapse Copy import os os.makedirs(os.path.join(\u0026#39;..\u0026#39;, \u0026#39;data\u0026#39;), exist_ok=True) data_file = os.path.join(\u0026#39;..\u0026#39;, \u0026#39;data\u0026#39;, \u0026#39;house_tiny.csv\u0026#39;) with open(data_file, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;NumRooms,Alley,Price\\n\u0026#39;) f.write(\u0026#39;NA,Pave,127500\\n\u0026#39;) f.write(\u0026#39;2,NA,106000\\n\u0026#39;) f.write(\u0026#39;4,NA,178100\\n\u0026#39;) f.write(\u0026#39;NA,NA,140000\\n\u0026#39;) Click to expand and view more 从创建的文件中加载原始数据集\nPYTHON Collapse Copy import pandas as pd data = pd.read_csv(data_file) print(data) Click to expand and view more 会得到如下表格(第一列索引不是表格内容)\nNumRooms Alley Price 0 NaN Pave 127500 1 2.0 NaN 106000 2 4.0 NaN 178100 3 NaN NaN 140000 为了处理缺失的数据, 常使用插值和删除的方法, 这里使用插值\nPYTHON Collapse Copy # inputs: 所有行, 前两列数据, 房间数量和小巷 # outputs: 所有行, 最后一列数据, 价格 inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2] # 使用 pd.get_dummies() 将 Alley 分成两类, dummy_na 表示是否为缺失值(NaN)创建一个新的独热编码列 # 当 dummy_na=True 时, 如果原始数据中有缺失值(NaN), 函数会创建一个新的列, 列名为原列名_nan, 并用True来标记所有原始值为NaN的行 inputs = pd.get_dummies(inputs, dummy_na=True) print(inputs) Click to expand and view more NumRooms Alley_Pave Alley_nan 0 NaN True False 1 2.0 False True 2 4.0 False True 3 NaN False True PYTHON Collapse Copy # 使用平均值填充 inputs = inputs.fillna(inputs.mean()) print(inputs) Click to expand and view more NumRooms Alley_Pave Alley_nan 0 3.0 1 0 1 2.0 0 1 2 4.0 0 1 3 3.0 0 1 最后转换为 torch 张量\nPYTHON Collapse Copy import torch X = torch.tensor(inputs.to_numpy(dtype=float)) y = torch.tensor(outputs.to_numpy(dtype=float)) X, y Click to expand and view more 输出\nPLAINTEXT Collapse Copy (tensor([[3., 1., 0.], [2., 0., 1.], [4., 0., 1.], [3., 0., 1.]], dtype=torch.float64), tensor([127500., 106000., 178100., 140000.], dtype=torch.float64)) Click to expand and view more 深度学习更多使用 float32 类型运算, 64位太慢了\n","title":"Dive into DeepLearning - Preliminaries"}],"tags":[{"link":"/tags/c/","name":"C","slug":"C"},{"link":"/tags/database/","name":"Database","slug":"Database"},{"link":"/tags/deeplearning/","name":"DeepLearning","slug":"DeepLearning"},{"link":"/tags/essay/","name":"Essay","slug":"Essay"},{"link":"/tags/fastapi/","name":"FastAPI","slug":"FastAPI"},{"link":"/tags/git/","name":"Git","slug":"Git"},{"link":"/tags/hack/","name":"Hack","slug":"Hack"},{"link":"/tags/http/","name":"HTTP","slug":"HTTP"},{"link":"/tags/microservice/","name":"Microservice","slug":"Microservice"},{"link":"/tags/python/","name":"Python","slug":"Python"},{"link":"/tags/redis/","name":"Redis","slug":"Redis"},{"link":"/tags/rest/","name":"REST","slug":"REST"},{"link":"/tags/story/","name":"Story","slug":"Story"}]}