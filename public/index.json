{"categories":[],"pages":[],"posts":[{"link":"/posts/fastapi-cookie-and-header-parameters/","text":"这篇文章介绍 Fastapi 的 Cookie 和 Header 参数\nCookie Parameters 通过定义 Query 和 Path 参数一样定义 Cookie 参数\nPYTHON Collapse Copy from typing Annotated from fastapi import Cookie, FastAPI app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(ads_id: Annotated[str | None, Cookie()] = None): return {\u0026#34;ads_id\u0026#34;: ads_id} Click to expand and view more Cookie Parameters Models 如果有一组相关的 cookies, 可以使用 Pydantic model 来声明.\n这样可以在多个部分复用这个模型, 同时还能一次性为所有参数声明验证规则和元数据.\n下面使用 Pydantic 模型定义 Cookies, 然后将参数声明为 Cookie\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Cookie from pydantic import BaseModel app = FastAPI() class Cookie(BaseModel): session_id: str fatebook_tracker: str | None = None googall_tracker: str | None = None @app.get(\u0026#34;/items/\u0026#34;) async def read_items(cookies: Annotated[Cookies, Cookie()]): return cookies Click to expand and view more Forbid Extra Cookies 禁止额外的Cookie 在某些场景下(虽然并不常见), 可能希望限制 API 只能接收特定的 Cookie. 这样, API 就可以\u0026quot;自己\u0026quot;管理 Cookie 同意策略了.\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Cookie from pydantic import BaseModel app = FastAPI() class Cookies(BaseModel): model_config = {\u0026#34;extra\u0026#34;: \u0026#34;forbid\u0026#34;} # forbid extra cookies session_id: str fatebook_tracker: str | None = None googall_tracker: str | None = None @app.get(\u0026#34;/items/\u0026#34;) async def read_items(cookies: Annotated[Cookies, Cookie()]): return cookies Click to expand and view more 这样, 如果客户端发送额外的 cookies, 则会收到一个错误响应. 例如, 客户端发送了 santa_tracker 这个额外 Cookie\nPYTHON Collapse Copy santa_tracker = good-list-please Click to expand and view more 将会收到如下错误响应\nJSON Collapse Copy { \u0026#34;detail\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;extra_forbidden\u0026#34;, \u0026#34;loc\u0026#34;: [\u0026#34;cookie\u0026#34;, \u0026#34;santa_tracker\u0026#34;], \u0026#34;msg\u0026#34;: \u0026#34;Extra inputs are not permitted\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;good-list-please\u0026#34;, } ] } Click to expand and view more Header Parameters 同样的, 通过定义 Query 和 Path 参数一样定义 Header 参数\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Header app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(user_agent: Annotated[str | None, Header()] = None): return {\u0026#34;User-Agent\u0026#34;: user_agent} Click to expand and view more Automatic conversoin 自动转换 Header 拥有一些在 Path, Query 和 Cookie 上的额外功能\n大多数标准的 header 都通过一个连字符(hyphen character), 也称为减号(minus symbol)分开, 但是变量 user-agent 这样在 Python 中是不合法的. 所以, 默认情况下 Header 会将参数名中的 hypen(-) 使用下划线 undersocre(_) 替换.\n同样的, HTTP headers 是不区分大小写的, 所以可以使用标准的 Python 风格 (snake_case). 因此可以使用 user_agent 在 Python 代码中, 而不需要首字母大写成 User_Agent.\n如果想要禁止这种自动转换, 需要将 Header 的参数 convert_undersocres 设置为 False\nPYTHON Collapse Copy from typing import Typing from fastapi import FastAPI, Header app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items( strange_header: Annotated[str | None, Header(convert_undersocres=False)] = None ): return {\u0026#34;strange_header\u0026#34;: strange_header} Click to expand and view more Duplicate headers 重复请求头 一个请求中可能会收到重复的 headers, 也就是同一个 header 有多个值.\n可以在类型声明中使用 list 来处理这种情况, 这样会得到一个 Python 列表.\n例如要声明一个可能多次出现的 X-Token 头部, 可以这样写:\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Header app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(x_token: Annotated[list[str] | None, Header()] = None): return {\u0026#34;X-Token values\u0026#34;: x_token} Click to expand and view more 如果向该接口发送两个这样的 HTTP headers\nPLAINTEXT Collapse Copy X-Token: foo X-Token: bar Click to expand and view more 返回类似这样\nJSON Collapse Copy { \u0026#34;X-Token values\u0026#34;: [ \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34; ] } Click to expand and view more Header parameters models 请求头参数模型 同样可以使用 Pydantic model 定义 Header Parameters, 这样可以在多个地方复用模型, 还能一次性为所有参数声明规则和元数据\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Header from pydantic import BaseModel app = FastAPI() class CommonHeaders(BaseModel): host: str save_data: str if_modified_since: str | None = None traceparent: str | None = None x_tag: list[str] = [] @app.get(\u0026#34;/items\u0026#34;) async def read_items(headers: Annotated[CommonHeaders, Header()]): return headers Click to expand and view more Forbid extra headers 禁止额外请求头 同样也可以禁止额外的 headers\nPYTHON Collapse Copy class CommonHeaders(BaseModel): model_config = {\u0026#34;extra\u0026#34;: \u0026#34;forbid\u0026#34;} # 禁止额外字段 ... Click to expand and view more 如果客户端尝试发送额外的 Header，将会收到错误响应. 例如, 客户端发送了 tool 这个额外 Header\nPLAINTEXT Collapse Copy tool: plumbus Click to expand and view more 将会收到如下错误响应\nJSON Collapse Copy { \u0026#34;detail\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;extra_forbidden\u0026#34;, \u0026#34;loc\u0026#34;: [\u0026#34;header\u0026#34;, \u0026#34;tool\u0026#34;], \u0026#34;msg\u0026#34;: \u0026#34;Extra inputs are not permitted\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;plumbus\u0026#34; } ] } Click to expand and view more Disable convert undersocres 禁止转换下划线 同样可以禁用自动下换线转换\n与普通的 Header 参数一样, 如果参数名中包含下划线 undersocre (_), FastAPI 会自动将其转换为连字符 hypens (-)\nPYTHON Collapse Copy async def read_items( headers: Annotated[CommonHeaders, Header(convert_underscores=False)], ): ... Click to expand and view more 在将 convert_underscores 设置为 False 前, 注意有些 HTTP 代理和服务器不允许带下划线的头部字段\n","title":"Fastapi Cookie and Header Parameters"},{"link":"/posts/python-function-parameters/","text":"今天是周日, 简单写点吧, 简单总结一下 Python 中函数参数\nPython Function Parameters Python 函数参数机制非常灵活丰富, 理解各种参数类型及其用法对于写出优雅、易维护的代码非常重要. 本文将介绍 Python 中函数参数的种类与用法, 并详细讲解 Python 3.8 引入的参数分隔符 / 和 *, 帮助你更好地设计函数接口.\n1. Postional Arguments 位置参数 函数定义中最常见的参数, 调用时按顺序传入值\nPYTHON Collapse Copy def greet(name, age): print(f\u0026#34;Hello, {name}. You are {age} years old.\u0026#34;) greet(\u0026#34;Alice\u0026#34;, 30) # Hello, Alice. You are 30 years old. Click to expand and view more 2. Keyword Arguments 关键字参数 调用时以 key=value 形式传入, 顺序可变\nPYTHON Collapse Copy greet(age=30, name=\u0026#34;Alice\u0026#34;) Click to expand and view more 3. Default Arguments 默认参数 定义函数时给参数赋默认值, 调用时可省略\nPYTHON Collapse Copy def greet(name, age=20): print(f\u0026#34;Hello, {name}. You are {age} years old.\u0026#34;) greet(\u0026#34;Bob\u0026#34;) # 使用默认年龄20 greet(\u0026#34;Bob\u0026#34;, 25) # 指定年龄 Click to expand and view more 注意: 使用默认参数尽量不要使用可变类型(mutable), 例如列表, 因为默认参数是存储在函数中的, 而非函数实例中, 多次调用会改变默认值的内容. PYTHON Collapse Copy def greet(names: list[str] = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;]): ... Click to expand and view more 若希望使用默认值, 建议使用下面这种方法\nPYTHON Collapse Copy def greet(names: list[str] | None = None): if not names: names = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;] ... Click to expand and view more 同样的, 默认值参数如果为一个表达式, 则是在定义时求值, 而非运行改函数时才求值\n4. *args 可变位置参数 用于接收任意数量的位置参数, 形成元组\nPYTHON Collapse Copy def sum_all(*args): return sum(args) sum_all(1, 2, 3) # 6 sum_all() # 0 Click to expand and view more 5. **kwargs 可变关键字参数 用于接收任意数量的关键字参数, 形成字典\nPYTHON Collapse Copy def print_info(**kwargs): for k, v in kwargs.items(): print(f\u0026#34;{k} = {v}\u0026#34;) print_info(name=\u0026#34;Alice\u0026#34;, age=30) Click to expand and view more / 和 * 的用法 Python 3.8 引入了两种新的函数参数分隔符: 斜杠 /(forward slash) 和 星号 *(asterisk) 符号, 用于更精细地控制参数的调用方式\nPostional-only parameters (/) 斜杠前的参数必须通过位置传递, 不能用关键字传递\nPYTHON Collapse Copy def func(a, b, /, c, d): print(a, b, c, d) Click to expand and view more 调用时\nPYTHON Collapse Copy func(1, 2, c=3, d=4) # 正确 func(1, 2, 3, 4) # 也正确 func(a=1, b=2, c=3, d=4) # 错误，a 和 b 不能用关键字传递 Click to expand and view more 用途:\n保护函数接口的参数顺序, 避免调用者用关键字修改参数值 兼容一些C语言扩展模块的调用约定 明确哪些参数是\u0026quot;位置专用\u0026quot;的 Keyword-only parameters (*) 星号后的参数必须用关键字传递, 不能用位置传递\nPYTHON Collapse Copy def func(a, b, *, c, d): print(a, b, c, d) Click to expand and view more 调用时\nPYTHON Collapse Copy func(1, 2, c=3, d=4) # 正确 func(1, 2, 3, 4) # 错误，c 和 d 只能用关键字传递 Click to expand and view more 用途:\n强制调用者明确指定关键字参数, 提高代码可读性 避免参数顺序引起的混淆 Use both / and * / 和 * 也可以同时使用\nPYTHON Collapse Copy def func(a, b, /, c, d, *, e, f): print(a, b, c, d, e, f) Click to expand and view more 调用时\na 和 b 只能用位置参数传递 c 和 d 都可以 e 和 f 只能用关键字参数传递 ","title":"Python Function Parameters"},{"link":"/posts/fastapi-body-advanced-uses/","text":"本篇文章介绍 FastAPI Request Body 的进阶用法\nBody - Multiple Parameters 首先, 可以将Path, Query 和 request body 参数声明自由的写在一起\n对于 request body 参数可以是可选的, 并且可设置为默认的 None\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Path from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item( item_id: Annotated[int, Path(title=\u0026#34;The ID of the item to get\u0026#34;, ge=0, le=1000)], # Path q: str | None = None, # Query item: Item | None = None, # body ): results = {\u0026#34;item_id\u0026#34;: item_id} if q: results.update({\u0026#34;q\u0026#34;: q}) if item: results.update({\u0026#34;item\u0026#34;: item}) return results Click to expand and view more Multiple body parameters 多参数请求体 在上面例子中, FastAPI 期望一个包含 Item 属性的 JSON body, 例如\nJSON Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 } Click to expand and view more 但也可以声明多个body parameters, 例如 item 和 user\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None class User(BaseModel): username: str full_name: str | None = None @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item(item_id: int, item: Item, user: User): results = {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;item\u0026#34;: item, \u0026#34;user\u0026#34;: user} return results Click to expand and view more 在这种情况下, FastAPI 会检测到函数有一个 body parameter, 这时会使用中的参数名作为请求体的 key(field names), 并期望如下结构:\nJSON Collapse Copy { \u0026#34;item\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 }, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;dave\u0026#34;, \u0026#34;full_name\u0026#34;: \u0026#34;Dave Grohl\u0026#34; } } Click to expand and view more FastAPI 会自动进行请求解析、类型转换、验证, 并在 OpenAPI 文档中反映出这种结构\nSingular values in body 请求体中的单个参数 和 Query 、Path 可以添加额外信息一样, FastAPI 也提供了 Body 来对请求参数添加额外信息\n例如, 除了 item 和 user 外, 还想在请求体中添加一个 importance 字段, 如果直接写 importance: int 则会被当作查询参数\n可以通过 Body() 明确告诉 FastAPI 把它当作一个 body parameter\nPYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item( item_id: int, item: Item, user: User, importance: Annotated[int, Body()] ): ... Click to expand and view more 这种情况下, FastAPI 会期待如下的请求体:\nJSON Collapse Copy { \u0026#34;item\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 }, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;dave\u0026#34;, \u0026#34;full_name\u0026#34;: \u0026#34;Dave Grohl\u0026#34; }, \u0026#34;importance\u0026#34;: 5 } Click to expand and view more 它同样会自动转换数据类型、校验并生成文档\nMultiple body params and query 多个请求体参数和查询参数 也可以在多请求体参数的基础上, 添加查询参数\nPYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item( *, # 强制 key=value item_id: int, item: Item, user: User, importance: Annotated[int, Body(gt=0)], q: str | None = None, # 查询参数 ): ... Click to expand and view more Embed a single body parameter 嵌入单个请求体参数 假设只有一个请求体参数 item: Item, 默认情况下 FastAPI 期望请求体就是一个 Item 对应的结构\nJSON Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 } Click to expand and view more 但若希望如下带有 itemkey 的结构\nJSON Collapse Copy { \u0026#34;item\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2 } } Click to expand and view more 那么可以使用 Body(embed=True)\nPYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item( item_id: int, item: Annotated[ Item, Body(embed=True), # embed a single param ] ): ... Click to expand and view more 这将使 FastAPI 将请求体视为嵌套结构, key 为 item\nBody - Fields 除了可以在 path operation (路径操作)函数参数中使用 Query、Path和Body来声明额外的验证和数据, 还可以在 Pydantic 模型内部的 Field 的字段验证规则和元数据\nDeclare model attributes 声明模型字段属性 首先要导入 Filed\nPYTHON Collapse Copy from pydantic import BaseModel, Field # import Filed Click to expand and view more 可以在模型字段上使用 Filed 来添加验证规则和信息\nPYTHON Collapse Copy class Item(BaseModel): name: str description: str | None = Field( default=None, title=\u0026#34;项目的描述\u0026#34;, max_length=300 ) price: float = Field(gt=0, description=\u0026#34;价格必须大于 0\u0026#34;) tax: float | None = None Click to expand and view more 实际上, Query、Path 和其他类, 都继承自一个公共的 Param 类, 而 Param 是 Pydantic 的 FieldInfo 类的子类, pydantic.Field() 返回的就是一个 FieldInfo 实例\nBody - Nested Models 在 FastAPI 中, 可以定义、校验、文档化并使用任意深度嵌套的模型\nList fields 列表字段 可以将字段定义为某种子类型, 例如 Python 的 list\nPYTHON Collapse Copy class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list = [] # list Click to expand and view more List fields with type parameter 带类型参数的列表字段 Python 提供一种\u0026quot;类型参数\u0026quot;的方法, 来指定列表类型\nPYTHON Collapse Copy # Python 3.10+ tags: list[str] = [] Click to expand and view more 对于py3.10之前的版本, 需要使用 typing 模块\nPYTHON Collapse Copy tags: List[str] = [] Click to expand and view more Set types 集和类型 如果不希望 tages 重复, 则使用 set 更加合适\nPYTHON Collapse Copy class Item(BaseModel): ... tags: set[str] = set() Click to expand and view more 这样即使客户端传来重复元素, FastAPI 也会自动去重并返回一个唯一元素集合\nNested Models 嵌套模型 Pydantic 的每个字段都可以是另一模型, 从而形成嵌套结构\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Image(BaseModel): url: str name: str class Item(BaseModel): ... image: Image | None = None @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item(item_id: int, item: Item): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;item\u0026#34;: item} Click to expand and view more 此时的 FastAPI 会期望请求体为如下结构:\nJSON Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2, \u0026#34;tags\u0026#34;: [\u0026#34;rock\u0026#34;, \u0026#34;metal\u0026#34;, \u0026#34;bar\u0026#34;], \u0026#34;image\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://example.com/baz.jpg\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;The Foo live\u0026#34; } } Click to expand and view more 这样使用 FastAPI 会获得:\n编辑器自动补全 类型转换 数据校验 自动生成文档 Special types and validation 特殊类型与验证 除了像 str, int, float 这类 singular types, 还可以使用更加负责的继承于 str 的 singular types, 全部类型可以在 Pydantic\u0026rsquo;s Type Overview 查看\n下面是 HttpUrl 的例子\nPYTHON Collapse Copy from pydantic import HttpUrl class Image(BaseModel): url: HttpUrl name: str Click to expand and view more 这样会检查 JSON schema 中的 url 是否合法, 并在 OpenAPI 文档中显示\nAttributes with lists of submodels 带有子模型属性的列表 PYTHON Collapse Copy class Image(BaseModel): url: HttpUrl name: str class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() images: list[Image] | None = None # lists of submodels Click to expand and view more 此时 FastAPI 会期望请求体有一个 images 字段, 为 Image 对象的列表\nJSON Collapse Copy { \u0026#34;name\u0026#34;: \u0026#34;Foo\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The pretender\u0026#34;, \u0026#34;price\u0026#34;: 42.0, \u0026#34;tax\u0026#34;: 3.2, \u0026#34;tags\u0026#34;: [ \u0026#34;rock\u0026#34;, \u0026#34;metal\u0026#34;, \u0026#34;bar\u0026#34; ], \u0026#34;images\u0026#34;: [ { \u0026#34;url\u0026#34;: \u0026#34;http://example.com/baz.jpg\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;The Foo live\u0026#34; }, { \u0026#34;url\u0026#34;: \u0026#34;http://example.com/dave.jpg\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;The Baz\u0026#34; } ] } Click to expand and view more Deeply nested models 深度嵌套模型 可以定义任意深度的嵌套模型\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Image(BaseModel): url: HttpUrl name: str class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() images: list[Image] | None = None class Offer(BaseModel): name: str description: str | None = None price: float items: list[Item] @app.post(\u0026#34;/offers/\u0026#34;) async def create_offer(offer: Offer): return offer Click to expand and view more Bodies of pure lists 纯列表请求体 如果请求体的顶层是一个数组(例如上传多个图片), 可以直接将参数类型声明为列表:\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Image(BaseModel): url: HttpUrl name: str @app.post(\u0026#34;/images/multiple/\u0026#34;) async def create_multiple_images(images: list[Image]): return images Click to expand and view more Bodies of arbitrary dictS 任意字典作为请求体 可以声明请求体为一个字典 (键和值都可指定类型)\nPYTHON Collapse Copy @app.post(\u0026#34;/index-weights/\u0026#34;) async def create_index_weights(weights: dict[int, float]): return weights Click to expand and view more 虽然 JSON 标准只支持字符串作为 key, 但 Pydantic 会自动将字符串形式的数字转换为 int 因此, 如果客户端发送 { \u0026quot;1\u0026quot;: 0.1, \u0026quot;2\u0026quot;: 0.2 }, 接收到的将是 {1: 0.1, 2: 0.2} ","title":"FastAPI Body Advanced Uses"},{"link":"/posts/git-whitelist/","text":"有时你开启了一个新的项目, 运行了 cargo init、uv init 和 go mod init\n这些命令创建了工作所需要的必要文件, 同时也在 .gitignore 文件中添加了以下内容\nPLAINTEXT Collapse Copy target __pycache__ bin Click to expand and view more 一切都很顺利, 你继续开发新功能, 等到时机成熟时就将项目发布到了 Git 托管平台上\n人们开始对你的项目感兴趣, 甚至有人决定为你实现一个新功能, 这简直是免费劳动力!\n当你查看代码, 发现了一个格格不入的文件 .DS_Store, 你问那个人这是什么, 他说他根本不知道\n然后你只是将该文件从分支里面删除, 并把文件名加入了仓库的 .gitignore\nPLAINTEXT Collapse Copy target __pycache__ bin .DS_Store Click to expand and view more 现在代码合并到了 main, 仓库里只包含有用的内容\n接着, 另一人使用基于 Web 技术的 IDE 提交了另一个合并请求, 一看发现有一个完全无关的目录也被提交了, 于是 .gitignore 里又增加了一条内容\nPLAINTEXT Collapse Copy target __pycache__ bin .DS_Store .vscode Click to expand and view more 接下来, 有人使用 IntelliJ IDEA 提交了五百个 XML 文件和 .idea 目录, 这时又不得不将其加入 .gitignore\nPLAINTEXT Collapse Copy target __pycache__ bin .DS_Store .vscode .idea Click to expand and view more 多年后, .gitignore 已经有了上百行, 但是仍然时不时有各种奇怪的文件, 例如 testscripts、foo、a、qux、data.tar.gz、start.sh、cat \u0026hellip;\u0026hellip;\n你就像西西弗斯一样, 因欺骗死亡和冥界而受到永无止境的惩罚\n西西弗斯推着一块写着 .DS_Store 的巨石艰难上山\n如何改变偷偷溜进来的文件循环呢? 去教育每一个提交合并请求的人肯定不行, 得通过自动化工具解决, 而不是主观沟通\n幸运的是, 可以将这个黑名单变成白名单, 可以通过默认忽略所有文件, 然后只手动“取消忽略”明确允许的文件\nPLAINTEXT Collapse Copy * !.gitignore # 白名单：任意位置下的 src 目录及其子文件夹 !src/ !src/**/ !src/**/*.rs !Cargo.{toml,lock} # 白名单：项目根目录下的 pysrc 目录 !/pysrc/ !/pysrc/*.py !pyproject.toml !uv.lock !/cmd/ !/cmd/*.go !main.go !go.{mod,sum} !/docs/ !/docs/*.md Click to expand and view more 现在, 没人再能不小心提交不该提交的文件了. Git 会自动忽略所有文件, 只允许那些明确列入白名单的文件.\n这种做法也具备一定的“面向未来”的能力——当然, 前提是以后不会有某个 IDE 把 src/ide.rs 当成保存项目配置的理想文件路径, 但愿那一天永远不会到来\u0026hellip;\n","title":"Git Whitelist"},{"link":"/posts/fastapi-parameters-and-validations/","text":"这篇文章介绍 FastAPI 中的参数验证功能\nQuery Parameters and String Validations FastAPI 允许为参数声明额外的信息和验证规则\nPYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(q: str | None = None): results = {\u0026#34;items\u0026#34;: [{\u0026#34;item_id\u0026#34;: \u0026#34;Foo\u0026#34;}, {\u0026#34;item_id\u0026#34;: \u0026#34;Bar\u0026#34;}]} if q: results.update({\u0026#34;q\u0026#34;: q}) return results Click to expand and view more q 是类型为 str | None 的查询参数, 这意味着它可以是字符串, 也可以是 None. 其默认值是 None, 因此 FastAPI 会识别它为“可选参数”\nFastAPI 通过 = None 的默认值知道该参数是非必填的\n使用 str | None 还能帮助编辑器提供更好的类型提示和错误检测\nAdditional validation 额外验证 即使 q 是可选的, 但仍然可以设置条件: 如果提供了 q, 则长度不能超过50个字符\n使用 Query 和 Annotated 来实现\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\u0026#34;/items/\u0026#34;) async def read_items(q: Annotated[str | None, Query(max_length=50)] = None): results = {\u0026#34;items\u0026#34;: [{\u0026#34;item_id\u0026#34;: \u0026#34;Foo\u0026#34;}, {\u0026#34;item_id\u0026#34;: \u0026#34;Bar\u0026#34;}]} if q: results.update({\u0026#34;q\u0026#34;: q}) return results Click to expand and view more 使用 Annotated 包装后, 就可以传递额外的元数据(Query(max_length=5)), 用于校验或者文档\n注意: 使用 Annotated 的时候，不能在 Query() 中再次使用 default\n❌ 错误写法 PYTHON Collapse Copy q: Annotated[str, Query(default=\u0026#34;rick\u0026#34;)] = \u0026#34;morty\u0026#34; Click to expand and view more ✅ 正确写法 PYTHON Collapse Copy q: Annotated[str, Query()] = \u0026#34;rick\u0026#34; Click to expand and view more 使用 Annotated 有以下优点\n默认值直接写在函数参数上，更符合 Python 风格 该函数在非 FastAPI 环境中调用时也能正常工作 类型检查器能更准确提示 可复用于如 Typer 等其它框架 Annotated 可附加多个元数据 More Validations 更多验证 也可以添加参数 min_length\nPYTHON Collapse Copy @app.get(\u0026#34;/items/\u0026#34;) async def read_items( q: Annotated[str | None, Query(min_length=3, max_length=50)] = None, ): ... Click to expand and view more regular expressions 正则表达式\nPYTHON Collapse Copy @app.get(\u0026#34;/items/\u0026#34;) async def read_items( q: Annotated[ str | None, Query(min_length=3, max_length=50, pattern=\u0026#34;^fixedquery$\u0026#34;) ] = None, ): ... Click to expand and view more ^: 以后面字符串开始, 之前没有其他字符串\nfixedquery: 完全匹配的单词\n$: 在此结束, 之后没有更多字符\ndefault values 默认值\n除了 None, 也可以设置其他默认值\nPYTHON Collapse Copy q: Annotated[str, Query(min_length=3)] = \u0026#34;fixedquery\u0026#34; Click to expand and view more reuqired parameters 必填参数\n如果想让参数 q 是必填的, 不设置默认值即可\nPYTHON Collapse Copy q: Annotated[str, Query(min_length=3)] Click to expand and view more 即使参数可以为 None, 但仍强制要求传值\nPYTHON Collapse Copy q: Annotated[str | None, Query(min_length=3)] Click to expand and view more query parameter list / multiple values 参数列表/多个值\n可以接收多个值的查询参数\nPYTHON Collapse Copy @app.get(\u0026#34;/items/\u0026#34;) async def read_items(q: Annotated[list[str] | None, Query()] = None): query_items = {\u0026#34;q\u0026#34;: q} return query_items Click to expand and view more 访问如下 URL\nPLAINTEXT Collapse Copy http://localhost:8000/items/?q=foo\u0026amp;q=bar Click to expand and view more 将得到多个 q 查询参数值, URL response 将如下\nJSON Collapse Copy { \u0026#34;q\u0026#34;: [\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;] } Click to expand and view more 若不使用 Query(), FastAPI 会把 list[str] 当成 request body (请求体)\nDeclare more metadata 添加更多元信息 这些信息会出现在 OpenAPI 文档中\nPYTHON Collapse Copy q: Annotated[str | None, Query( title=\u0026#34;查询字符串\u0026#34;, description=\u0026#34;用于数据库中模糊搜索匹配的查询字符串\u0026#34;, min_length=3 )] = None Click to expand and view more Alias parameters 参数别名 有时想使用一个在 Python 中非法的别名, 例如 item-query\nPLAINTEXT Collapse Copy http://127.0.0.1:8000/items/?item-query=foobaritems Click to expand and view more 最接近的变量名为 item_query, 但是 item-query 不能为变量名\n此时, 可以使用别名 alias\nPYTHON Collapse Copy q: Annotated[str | None, Query(alias=\u0026#34;item-query\u0026#34;)] = None Click to expand and view more Deprecating parameters 弃用参数 想标记某个参数已被弃用, 可以加上\nPYTHON Collapse Copy Query(..., deprecated=True) Click to expand and view more Exclude parameters from OpenAPI 从OpenAPI中隐藏参数 可以设置参数不出现在自动生成的文章中\nPYTHON Collapse Copy hidden_query: Annotated[str | None, Query(include_in_schema=False)] = None Click to expand and view more Custom validation 自定义校验 若内建参数不够用, 可以使用 Pydantic v2 的 AfterValidator\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import AfterValidator from typing import Annotated def check_valid_id(id: str): if not id.startswith((\u0026#34;isbn-\u0026#34;, \u0026#34;imdb-\u0026#34;)): raise ValueError(\u0026#34;Invalid ID format, 必须以 \u0026#39;isbn-\u0026#39; 或 \u0026#39;imdb-\u0026#39; 开头\u0026#34;) return id @app.get(\u0026#34;/items/\u0026#34;) async def read_items( id: Annotated[str | None, AfterValidator(check_valid_id)] = None, ): if id: team = data.get(id) else: id, item = random.choice(list(data.items())) return {\u0026#34;id\u0026#34;: id, \u0026#34;name\u0026#34;: item} Click to expand and view more value.startswith((\u0026quot;isbn-\u0026quot;, \u0026quot;imdb-\u0026quot;)) 可以一次检查多个前缀 random.choice(list(data.items())) 取出随机的键值对 Path Parameters and Numberic Validations 和使用 Query 查询参数声明更多验证规则和元数据一样, 也可以使用 Path 为路径参数声明相同类型的规则验证和元数据\nImport Path 导入路径 首先, 从 fastapi 中导入 Path, 并导入 Annotated\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Path, Query app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( item_id: Annotated[int, Path(title=\u0026#34;要获取的物品 ID\u0026#34;)], q: Annotated[str | None, Query(alias=\u0026#34;item-query\u0026#34;)] = None, ): results = {\u0026#34;item_id\u0026#34;: item_id} if q: results.update({\u0026#34;q\u0026#34;: q}) return results Click to expand and view more Declare metadata 声明元数据 可以像在 Query 中一样声明所有的参数\nPYTHON Collapse Copy item_id: Annotated[int, Path(title=\u0026#34;要获取的物品 ID\u0026#34;)] Click to expand and view more ⚠️ 路径参数总是必填的, 它必须作为路径的一部分存在. 即使将它设为 None 或指定默认值, 也不会生效, 它仍然是必须的\nOrder the parameters 自由排序参数 如果希望 query parameter 声明为必填的 str, 并且不需要声明任何其他事情, 那么不需要用 Query() 包裹\n但是对于 path parameter item_id 仍然需要使用 Path, 并且出于一些原因并不像使用 Annotated\n如果将有 defalult 默认值的参数, 放到没有默认值参数前面, 那么 Python 会报错, 所以要这样声明函数\nPYTHON Collapse Copy from fastapi import FastAPI, Path app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items(q: str, item_id: int = Path(title=\u0026#34;要获取的物品 ID\u0026#34;)): results = {\u0026#34;item_id\u0026#34;: item_id} if q: results.update({\u0026#34;q\u0026#34;: q}) return results Click to expand and view more 但是, 如果使用 Annotated 就不会有这个顺序的问题, 因为默认值并不写在函数参数中\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( q: str, item_id: Annotated[int, Path(title=\u0026#34;要获取的物品 ID\u0026#34;)] ): ... Click to expand and view more Order the parameters tricks 参数顺序技巧 如果不想使用 Annotated, 但是又想:\n为查询参数 q 不使用 Query, 也不设置默认值 为路径参数 item_id 使用 Path 两个参数顺序任意 不想用 Annotated 那可以使用一个小技巧: 在函数参数前面加一个星号 *\n作用是: 告诉 Python, 后面所有参数必须作为关键字参数传入 (即使用key=value的方法, 不能省略参数名)\nPYTHON Collapse Copy async def read_items(*, item_id: int = Path(title=\u0026#34;The ID of the item to get\u0026#34;), q: str): ... Click to expand and view more Better with Annotated 推荐使用Annotated 如果使用 Annotated, 由于不是用参数默认值来传递 Path()、Query(), 就不需要使用*这种语法\nPYTHON Collapse Copy # Python 3.9+ async def read_items( item_id: Annotated[int, Path(title=\u0026#34;The ID of the item to get\u0026#34;)], q: str ): ... Click to expand and view more Number Validations 数字验证 在 FastAPI 中, 可以通过 Path()、Query() (以及其他参数类) 为数值类型参数添加约数条件, 有以下四种:\ngt: greater than (大于) ge: greater than or equal (大于等于) lt: less than (小于) le: less than or equal (小于等于) 这些验证适用于路径参数(path parameter)和查询参数(query parameter), 并且支持 int 和 float 类型\n整数验证示例 (Path 参数)\n使用 ge=1 表示 item_id 必须是一个大于等于1的整数\nPYTHON Collapse Copy from typing import Annotated from fastapi import FastAPI, Path app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( item_id: Annotated[int, Path(title=\u0026#34;要获取的项目 ID\u0026#34;, ge=1)], q: str ): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q} Click to expand and view more 也可以通过 ge 和 le 同时限制一个整数的区间范围\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( item_id: Annotated[int, Path(title=\u0026#34;要获取的项目 ID\u0026#34;, gt=0, le=1000)], q: str ): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q} Click to expand and view more 浮点数验证示例 (Query 参数)\n浮点类型的校验同样适用. 例如, 使用 gt 可以确保值 严格大于 0\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_items( *, item_id: Annotated[int, Path(title=\u0026#34;项目 ID\u0026#34;, ge=0, le=1000)], q: str, size: Annotated[float, Query(gt=0, lt=10.5)], ): return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q, \u0026#34;size\u0026#34;: size} Click to expand and view more item_id 必须在 [0, 1000] 区间内 size 必须在 (0, 10.5) 区间内 ","title":"FastAPI Parameters and Validations"},{"link":"/posts/fastapi-parameters/","text":"FastAPI 是一个现代、快速（高性能）的 Python Web 框架, 它自动处理参数的解析、验证和文档生成\n本文将介绍 FastAPI 中三类最常用的参数: 路径参数 (Path Parameters)、查询参数 (Query Parameters) 和 请求体(Request Body) 的用法与原理\n1. Path Parameters 路径参数 路径参数是 URL 路径中的动态部分, 使用 {} 包裹表示\nPYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str): return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more 访问 /items/foo 返回:\nPYTHON Collapse Copy {\u0026#34;item_id\u0026#34;: \u0026#34;foo\u0026#34;} Click to expand and view more Data conversion \u0026amp; validation 类型声明与自动转换 可以为路径参数声明类型, FastAPI 会自动解析并验证:\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: int): return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more 访问 /items/3, item_id 会被转换为 int 类型\nRouting orders 路由匹配顺序 路径匹配按声明顺序执行, 例如\nPYTHON Collapse Copy @app.get(\u0026#34;/users/me\u0026#34;) async def read_user_me(): return {\u0026#34;user_id\u0026#34;: \u0026#34;current_user\u0026#34;} @app.get(\u0026#34;/users/{user_id}\u0026#34;) async def read_user(user_id: str): return {\u0026#34;user_id\u0026#34;: user_id} Click to expand and view more 必须先声明 /users/me, 否则会被 /users/{user_id} 捕获\nPredefined enum values 预定义枚举值 使用 Python 的 Enum 定义一组可选的路径参数值\nPYTHON Collapse Copy from enum import Enum class ModelName(str, Enum): alexnet = \u0026#34;alexnet\u0026#34; resnet = \u0026#34;resnet\u0026#34; lenet = \u0026#34;lenet\u0026#34; @app.get(\u0026#34;/models/{model_name}\u0026#34;) async def get_model(model_name: ModelName): return {\u0026#34;model_name\u0026#34;: model_name} Click to expand and view more Swagger 文档会自动显示可选值\nPath parameters containing paths 路径型参数 默认路径参数不能包含斜杠 /, 但可以用 :path 声明允许匹配完整路径\nPYTHON Collapse Copy @app.get(\u0026#34;/files/{file_path:path}\u0026#34;) async def read_file(file_path: str): return {\u0026#34;file_path\u0026#34;: file_path} Click to expand and view more 访问 /files/home/user/file.txt, file_path 会是 \u0026quot;home/user/file.txt\u0026quot;\n2. Query Parameters 查询参数 查询参数是 URL ? 后的键值对, 不属于路径部分\nPYTHON Collapse Copy fake_items_db = [{\u0026#34;item_name\u0026#34;: \u0026#34;Foo\u0026#34;}, {\u0026#34;item_name\u0026#34;: \u0026#34;Bar\u0026#34;}] @app.get(\u0026#34;/items/\u0026#34;) async def read_items(skip: int = 0, limit: int = 10): return fake_items_db[skip : skip + limit] Click to expand and view more 访问 /items/?skip=0\u0026amp;limit=10 时, 会自动把查询参数 skip 和 limit 转成 int\nOptional parameters 可选参数默认值 给查询参数赋默认值即为可选\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str, q: str | None = None): if q: return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;q\u0026#34;: q} return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more q 是可选查询参数, 默认为 None\nQuery parameter type conversion 查询参数类型转换 PYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str, q: str | None = None, short: bool = False): ... Click to expand and view more 支持自动把字符串转换成布尔值, 以下都会被识别为 True\nPLAINTEXT Collapse Copy http://127.0.0.1:8000/items/foo?short=1 Click to expand and view more 或者\n?short=true ?short=on ?short=yes Multiple path and query parameters 多路径查询参数组合 路径参数和查询参数可混合使用, 无需声明顺\nPYTHON Collapse Copy @app.get(\u0026#34;/users/{user_id}/items/{item_id}\u0026#34;) async def read_user_item(user_id: int, item_id: str, q: str | None = None, short: bool = False): ... Click to expand and view more Required query parameters 必填查询参数 未设置默认值的查询参数为必填参数\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_item(item_id: str, needy: str): ... Click to expand and view more 上面的 needy 就是一个必填的 str 类型\n当然也可以定义一些必填参数, 以及有默认值的可选参数\nPYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) async def read_user_item( item_id: str, needy: str, skip: int = 0, limit: int | None = None ): ... Click to expand and view more needy \u0026amp; item_id, 必填 str 类型 skip, 默认值为 0 的类型 limit, 一个可选的类型 [注]\n路径参数永远是必填的, 因为它们来自 URL 本身 PYTHON Collapse Copy @app.get(\u0026#34;/items/{item_id}\u0026#34;) def read(item_id: str = \u0026#34;123\u0026#34;): # 这里写默认值是无效的 ... Click to expand and view more 类型为 Optional[...] 或 type | None 不等于可选参数, 仍然要配合默认值 = None 才是可选 PYTHON Collapse Copy def func(x: int | None): # 必填 def func(x: int | None = None): # 可选 Click to expand and view more 3. Request Body 当通过 API 传送数据的时候, 通常通过 request body 发送\nrequest body 是 client 客户端发送给 API 的数据, 而 response body 是 API 发送给 client 的数据\nPydantic\u0026rsquo;s BaseModel 使用 Pydantic 定义数据模型\nPYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None app = FastAPI() @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item): return item Click to expand and view more Declare it as a parameter 在路由中声明请求体\nPYTHON Collapse Copy @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item): return item Click to expand and view more FastAPI 会:\n读取 request body, 并转换为 JSON 校验字段和类型 返回类型错误时给出详细反馈, 包括数据那里以及导致了什么错误 提供编辑器类型提示 生成模型的 JSON Schema 定义, 也可以在项目中任何位置使用 根据 schema 自动生成文档 Request body + path + query parameters 路径参数、查询参数与请求体同时使用 PYTHON Collapse Copy @app.put(\u0026#34;/items/{item_id}\u0026#34;) async def update_item(item_id: int, item: Item, q: str | None = None): result = {\u0026#34;item_id\u0026#34;: item_id, **item.dict()} if q: result.update({\u0026#34;q\u0026#34;: q}) return result Click to expand and view more 这个函数参数会被以下方式识别:\n如果参数同时在 path 中声明, 被当成 path parameter 如果参数为单一类型, 如 int, float, str 或 bool 等, 将会被解释为 query parameter 如果参数声明为一个 Pydantic Model, 将被解释为 request body ","title":"FastAPI Parameters"},{"link":"/posts/python-tricks/","text":"1. The Self-Replicating Trick 将一个含有空列表的列表乘5, 得到有5个空列表的列表\nPYTHON Collapse Copy x = [[]] * 5 x Click to expand and view more [[], [], [], [], []]\n当使用.append(\u0026quot;x\u0026quot;)方法时, 所有列表都被修改\nPYTHON Collapse Copy x[0].append(\u0026#34;x\u0026#34;) x Click to expand and view more [[\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;], [\u0026ldquo;x\u0026rdquo;]]\n打印其 id 可以看到, id 都相同\nPYTHON Collapse Copy for item in x: print(id(item)) Click to expand and view more 4417579584\n4417579584\n4417579584\n4417579584\n4417579584\n或者使用set()发现 id 唯一\nPYTHON Collapse Copy set(id(item) for item in x) Click to expand and view more {4417579584}\n也就是说, 当使用乘法的时候, 创建了5个内部列表的引用副本\n使用反汇编发现, 只创建了两个列表, 并执行乘5\nPYTHON Collapse Copy dis.dis(\u0026#34;[[]] * 5\u0026#34;) 0 0 RESUME 0 # 用于支持解释器恢复 (py3.11) 1 2 BUILD_LIST 0 # 构造一个空列表[], 压栈 4 BUILD_LIST 1 # 从栈顶取一个对象, 构造列表[[]] 6 LOAD_CONST 0 (5) # 加载常量 5 8 BINARY_OP 5 (*) # 对栈顶两个元素执行乘法 12 RETURN_VALUE # 返回栈顶结果 Click to expand and view more The alternative 如果要构造独立列表, 应改用列表推导式\nPYTHON Collapse Copy x = [[] for _ in range(5)] x Click to expand and view more [[], [], [], [], []]\nPYTHON Collapse Copy for item in x: print(id(item)) Click to expand and view more 4587832384\n4587818752\n4587831168\n4587839168\n4587809152\nPYTHON Collapse Copy set(id(item) for item in x) Click to expand and view more {4587809152, 4587818752, 4587831168, 4587832384, 4587839168}\n2. The Teleportation Trick PYTHON Collapse Copy def add_to_shopping_list(item, shopping_list=[]): shopping_list.append(item) return shopping_list Click to expand and view more 上面函数为一个空列表中添加一个 item, 期望每次创建一个新的空列表, 并添加一个item\nPYTHON Collapse Copy groceries = add_to_shopping_list(\u0026#34;Bread\u0026#34;) groceries Click to expand and view more [\u0026lsquo;Bread\u0026rsquo;]\nPYTHON Collapse Copy books = add_to_shopping_list(\u0026#34;A Brief History of Time\u0026#34;) books Click to expand and view more [\u0026lsquo;Bread\u0026rsquo;, \u0026lsquo;A Brief History of Time\u0026rsquo;]\n然而, \u0026lsquo;Bread\u0026rsquo; 被传送到 books 里面去了\n下面不使用默认参数, 测试一下函数\nPYTHON Collapse Copy cakes = [] cakes = add_to_shopping_list(\u0026#34;Chorolate Cake\u0026#34;, cakes) cakes Click to expand and view more [\u0026lsquo;Chorolate Cake\u0026rsquo;]\nPYTHON Collapse Copy tools = [] tools = add_to_shopping_list(\u0026#34;Snapper\u0026#34;, tools) tools Click to expand and view more [\u0026lsquo;Snapper\u0026rsquo;]\n当传入一个存在的列表时, 没有发生传送行为\n回到函数定义: 默认参数的列表, 在函数定义的时候已经被创建了, 因此每次使用该函数而不传入列表参数的时候, 默认列表shopping_list就会被使用, 且 list 是一个可变类型, 因此每次会修改这个列表\n使用下面方法, 每次打印出使用列表的 id, 会发现不传入列表参数时的 id 都相同\nPYTHON Collapse Copy def add_to_shopping_list(item, shopping_list=[]): print(id(shopping_list)) shopping_list.append(item) return shopping_list Click to expand and view more The alternative 这个 bug 在使用可变类型(mutable)作为默认参数的时候都会发生, 应该避免可变数据类型作为默认参数\n如果想要默认值参数, 可以考虑使用 None 作为参数默认值\nPYTHON Collapse Copy def add_to_shopping_list(item, shopping_list=None): if shopping_list is None: shopping_list = [] shopping_list.append(item) return shopping_list Click to expand and view more The Vanishing Trick 下面是最后一个 trick\nPYTHON Collapse Copy doubles = (number * 2 for number in range(10)) 4 in doubles # True 4 in doubles # False Click to expand and view more 上面结果看起来很矛盾, 4 怎么一会儿在 doubles 中, 一会儿又不再 doubles 中?\n再来看一个例子\nPYTHON Collapse Copy another_doubles = [number * 2 for number in range(10)] 4 in another_doubles # True 4 in another_doubles # True Click to expand and view more 上面这个例子中, 就都是 True\n问题出在, 当使用括号()创建 doubles 的时候, 并不是创建了元组 tuple, 而是一个生成器 generator\nPYTHON Collapse Copy doubles = (number ** 2 for number in range(10)) doubles Click to expand and view more \u0026lt;generator object at 0x111718e10\u0026gt;\n生成器并不会包含所有的值, 而是在使用的时候生成每个值\n例如, 调用 next() 会返回下一个值\nPYTHON Collapse Copy next(doubles) # 0 next(doubles) # 1 next(doubles) # 2 next(doubles) # 4 ... next(doubles) # 18 next(doubles) Click to expand and view more StopIteration Traceback (most recent call last)\n生成器是一次型的数据结构, 当生成下一个数据的时候, 之前的数据不会被保存, 也就是只能遍历数据一次\n一但遍历完成, 就会报StopIteration的错误, 所以当运行4 in doubles的时候, 先得到0, 为 False, 生成器会继续遍历下一个, 直到得到4, 当再次调用的时候, 下一个返回6, 直到遍历结束也无法得到到4\n同样的行为在迭代器 iterator 上也一样\nPYTHON Collapse Copy numbers = [2, 4, 6, 8] numbers_rev = reversed(numbers) numbers_rev # \u0026lt;list_reverseiterator object at 0x......\u0026gt; 4 in numbers_rev # True 4 in numbers_rev # False Click to expand and view more The alternative 如果使用生成器, 要知道只能遍历每个元素一次, 如果要获得一个有所有元素的数据结构, 应该使用元素 tuple 或列表 list\nPYTHON Collapse Copy doubles = (number * 2 for number in range(10)) # generator more_doubles = tuple(number * 2 for number in range(10)) # tuple 4 in more_doubles # True 4 in more_doubles # True Click to expand and view more ","title":"Python Tricks"},{"link":"/posts/executing-arbitrary-python-code-from-a-comment/","text":"通过注释执行任意Python代码\n问题描述 Q: 只能控制一行的.py代码中注释的内容(\\n\\r均会被替换为空字符), 如何执行任意代码?\nA: 在注释#中, 构造一个.zip 文件, python 会将该内容当成一个zip包执行, 触发任意代码执行\n解决方案 从 Python 3.5 起, 可以直接执行一个 .zip 文件\nPYTHON3 Collapse Copy python myapp.zip Click to expand and view more 前提是ZIP 包中包含一个顶层的__main__.py文件, Python 会把它当作 zipapp, 自动解压并运行__main__.py\nPython 会从末尾找到 ZIP 的目录结构, 而不是依赖文件头, 所以前面的“垃圾”字节会被忽略\nPython 源码中的任何行, 只要以 # 开头, 解释器都会忽略后面内容, 因此可以:\n把 ZIP 文件的数据藏在 Python 源码中的注释中（开头加 #） 把 ZIP 数据直接拼接在 Python 文件的后面, 只保证文件头部分是合法 Python ZIP 不关心前缀, Python 只要最前面是有效源码, 也不会管后面 难点 ZIP 文件头包含二进制字段，比如\n偏移量（文件数据相对于 ZIP 开头的位置） 长度（文件名长度、注释长度等） 这些值写死在 header 里, 是十六进制整数 如果这些字节中出现了像 \\x00、\\xFF 等非 ASCII 内容, Python 就不能把它当注释 解决方法: 暴力穷举合法组合\n想办法 调整偏移值和结构位置，使得最终写出来的 ZIP 文件\n所有的字段值都转化为 可打印字符（ASCII 范围内） 所有 binary 字段看起来都像合法的注释字符串 于是用 itertools.product(range(256), repeat=2) 暴力尝试偏移组合，只要碰巧生成的 ZIP 包所有关键字节都在可打印范围内（ASCII 32~126），就认为成功。 下面是generate_polygloy_zip.py代码, 会生成一个符合要求的polygloy.py代码, 最后运行该代码, 可以执行Body里面的内容BODY = b\u0026quot;print('FROM MAIN.py FILE!!!')#\u0026quot;\nPYTHON3 Collapse Copy # struct: 按字节结构打包数据，方便构造 ZIP 文件二进制头 # itertools: 用来暴力枚举 CRC 校验和后缀（确保安全ASCII） # zlib: 计算 CRC32 校验和 import struct, itertools, zlib # 文件开头代码 # encode(): Unicode 字符串 -\u0026gt; bytes 字节串 JUNK_HEAD = \u0026#34;\u0026#34;\u0026#34;print(\u0026#34;Hello World!\u0026#34;) # This is a comment. Here\u0026#39;s another: # \u0026#34;\u0026#34;\u0026#34;.encode() # 文件结尾代码 JUNK_TAIL = \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Thanks for playing!\u0026#34;)\u0026#34;\u0026#34;\u0026#34; # zip 文件核心代码 # b: 字节串 FILENAME = b\u0026#34;__main__.py\u0026#34; BODY = b\u0026#34;print(\u0026#39;FROM MAIN.py FILE!!!\u0026#39;)#\u0026#34; # 校验 CRC 是否为 ASCII-safe def ascii_safe(x: int) -\u0026gt; bool: return all(((x \u0026gt;\u0026gt; (8*i)) \u0026amp; 0x80) == 0 for i in range(4)) # 检查 32 位整数的四个字节，每个字节最高位（0x80）是否为 0，即是否为 ASCII 范围内的字节 def find_suffix(core: bytes, length: int = 4) -\u0026gt; tuple[bytes, int]: \u0026#34;\u0026#34;\u0026#34; - ZIP 文件 CRC32 计算结果必须 ASCII-safe（低于 0x80） - 这里用暴力方法，给 payload 后面加4字节后缀，找到合适的后缀让 CRC32 满足 ASCII-safe 条件 \u0026#34;\u0026#34;\u0026#34; printable = range(0x20, 0x7f) for tail in itertools.product(printable, repeat=length): payload = core + bytes(tail) crc = zlib.crc32(payload) \u0026amp; 0xFFFFFFFF if ascii_safe(crc): return bytes(tail), crc raise RuntimeError(\u0026#34;No ASCII-safe CRC found.\u0026#34;) # 计算最终 payload SUFFIX, CRC = find_suffix(BODY) PAYLOAD = BODY + SUFFIX SIZE = len(PAYLOAD) def le32(x): return struct.pack(\u0026#34;\u0026lt;I\u0026#34;, x) # 4字节小端无符号整数 def le16(x): return struct.pack(\u0026#34;\u0026lt;H\u0026#34;, x) # 2字节小端无符号整数 # ZIP 结构中各签名常量 SIG_LFH = 0x04034B50 # 本地文件头 Local File Header SIG_CDH = 0x02014B50 # 中央目录头 Central Directory Header SIG_EOCD = 0x06054B50 # 结束目录头 End of Central Directory # zip 文件偏移量设置 delta = len(JUNK_HEAD) # 构建 Local File Header \u0026#34;\u0026#34;\u0026#34; Local File Header 是 ZIP 格式中的一部分，告诉解压程序该文件的元信息 - version needed to extract，flags，compression method 等字段置 0 表示无压缩，简单存储 - CRC32、压缩大小、解压大小都是我们计算的 - 文件名长度和文件名 \u0026#34;\u0026#34;\u0026#34; lfh = ( le32(SIG_LFH) + le16(0) + le16(0) + le16(0) + le16(0) + le16(0) + le32(CRC) + le32(SIZE) + le32(SIZE) + le16(len(FILENAME)) + le16(0) + FILENAME ) # 构建 Central Directory Header \u0026#34;\u0026#34;\u0026#34; - Central Directory 是 ZIP 文件目录结构，记录每个文件信息和偏移， - 其中重要的是 relative offset of LFH，也就是 Local File Header 在整个 ZIP 文件里的偏移，必须加上 delta \u0026#34;\u0026#34;\u0026#34; cdh = ( le32(SIG_CDH) + le16(0) + le16(0) + le16(0) + le16(0) + le16(0) + le16(0) + le32(CRC) + le32(SIZE) + le32(SIZE) + le16(len(FILENAME)) + le16(0) + le16(0) + le16(0) + le16(0) + le32(0) + le32(delta) + FILENAME ) # 确保偏移量 ASCII-safe \u0026#34;\u0026#34;\u0026#34; - ZIP 目录偏移需要是 ASCII 字节，否则写入 .py 文件时会出错 - 这里通过填充若干 \\x00 字节，保证偏移合法 \u0026#34;\u0026#34;\u0026#34; cd_offset = delta + len(lfh) + len(PAYLOAD) pad = 0 while not ascii_safe(cd_offset + pad): pad += 1 padding = b\u0026#39;\\x00\u0026#39; * pad cd_offset += pad # 构建 End of Central Directory Header \u0026#34;\u0026#34;\u0026#34; EOCD 记录 ZIP 中央目录大小、偏移及注释长度等信息 \u0026#34;\u0026#34;\u0026#34; eocd = ( le32(SIG_EOCD) + le16(0) + le16(0) + le16(1) + le16(1) + le32(len(cdh)) + le32(cd_offset) + le16(len(JUNK_TAIL)) ) # 拼接完整 ZIP 内容 zip_bytes = lfh + PAYLOAD + padding + cdh + eocd zip_bytes = bytearray(zip_bytes) assert all(b \u0026lt; 0x80 for b in zip_bytes), \u0026#34;非 ASCII 字节存在\u0026#34; # 写入 polyglot.py 文件 with open(\u0026#34;polyglot.py\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(JUNK_HEAD + zip_bytes + JUNK_TAIL.encode()) # 运行提示 print(\u0026#34;✅ polyglot.py 生成完毕。运行它即可执行嵌入的 __main__.py 内容：\u0026#34;) print(\u0026#34; $ python3 polyglot.py\u0026#34;) Click to expand and view more ","title":"Executing arbitrary Python code from a comment"},{"link":"/posts/how-fastapi-works/","text":"FastAPI 的工作原理: 从 routing 到 lifecycle 以及在现实中的使用\nFastAPI FastAPI 是一个现代的 Python Web 框架, 注重高性能和开发效率. 旨在帮助开发者编写结构清晰、可靠的API, 同时尽量减少样板代码 (boilerplate)\n其由以下两个库驱动:\nStarlette: 负责 Web 服务器逻辑、路由、中间件和异步能力 Pydantic: 基于 Python 类型提示, 处理数据验证、解析和序列化 此外, Fastapi 还有输入验证、基于 Swagger UI 的自动文档生成和代码清晰化的基础\nAPI 请求周期 Fastapi 的请求生命周期如下\nPLAINTEXT Collapse Copy 客户端请求 (Client Request) ↓ FastAPI App ↓ 中间件（Middleware） ↓ 路由匹配 (Route Matching) ↓ 依赖注入（Dependency Injection） ↓ 输入验证 (Input Validation) ↓ 端点函数 (Endpoint) ↓ 响应序列化 (Response Serialization) ↓ 客户端响应 (Client Response) Click to expand and view more 请求首先进入 FastAPI 应用 (本质就是一个 Starlette 应用) 所有中间件优先执行 (如: 日志、错误处理、CORS等) 路由器检查路径和方法, 找到对应的处理函数 FastAPI 使用Depends解析依赖 使用 Pydantic 自动解析并验证输入数据 执行端点函数, 参数验证完毕 返回结果被序列化为合适的响应格式 (JSON) 响应返回给客户端 路由 Router 在应用对象上定义\n适合小项目或原型验证 PYTHON Collapse Copy from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/items/{item_id}\u0026#34;) def read_item(): return {\u0026#34;item_id\u0026#34;: item_id} Click to expand and view more 使用 APIRouter 模块化\n适合大项目 PYTHON Collapse Copy from fastapi import FastAPI router = APIRouter(prefix=\u0026#34;/users\u0026#34;, tags=[\u0026#34;users\u0026#34;]) @router.get(\u0026#34;/{user_id}\u0026#34;) def get_user(user_id: int): return {\u0026#34;user_id\u0026#34;: user_id} Click to expand and view more 使用APIRouter可以将相关的端点分组, 添加前缀和标签, 保持代码结构清晰模块化 当某个请求与端点匹配时, FastAPI 内部执行一下步骤:\nStarlette 找到对应路由, 并创建一个APIRouter实例 FastAPI 使用get_router_header()包装端点函数并解析依赖 使用 Pydantic 或基本类型对请求数据解析与验证 装饰函数被调用, 传入验证后的参数 返回值被序列化为响应对象 依赖注入: 干净、可复用的逻辑 FastAPI 有一个轻量且强大的依赖注入系统, 可以进行数据库链接、身份验证信息或配置信息等\nPYTHON Collapse Copy from fastapi import Depends def get_db(): db = create_db_session() try: yield db finally: db.close() @app.get(\u0026#34;/items/\u0026#34;) def read_items(db=Depends(get_db)): return db.query(item).all() Click to expand and view more 使用Depends, FastAPI 会负责调用get_db, 处理生成器生命周期, 并将结果注入到函数中\n原生支持异步 (Async) 不同于一些后加入 async 的框架, FastAPI 一开始就设计为支持 async/await\nPYTHON Collapse Copy from fastapi import FastAPI import asyncio app = FastAPI() @app.get(\u0026#34;/hi\u0026#34;) async def greet(): await asyncio.sleep(1) return \u0026#34;Hello? World?\u0026#34; Click to expand and view more 当 fastapi 收到 /hi 这个 URL 的 GET 请求时，会自动调用 async greet(), 无需在任何地方添加 await\n但是, 对于其他的 async def 函数, 调用的时候必须在前面加上 await\nFastAPI 会运行一个异步事件循环，用于执行异步路径函数(async path functions)，同时也会使用一个线程池来处理同步函数(synchronous path functions), 这样就不需要手动调用 asyncio.gather() 和 asyncio.run() 之类的方法\n示例: CURD API PYTHON Collapse Copy from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str = None price: float tax: float = None @app.post(\u0026#34;/items/\u0026#34;) async def create_item(item: Item): total = item.price + (item.tax or 0) return {\u0026#34;name\u0026#34;: item.name, \u0026#34;total_price\u0026#34;: total} @app.get(\u0026#34;/\u0026#34;) def read_root(): return {\u0026#34;message\u0026#34;: \u0026#34;FastAPI is working!\u0026#34;} Click to expand and view more 运行\nPLAINTEXT Collapse Copy uvicorn main:app --reload Click to expand and view more 还可以使用 Gunicorn 部署4个 Uvicorn 异步服务 PLAINTEXT Collapse Copy gunicorn main:app --workers 4 --worker-class \\ uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000 Click to expand and view more 实际上也可以直接诶使用 uvicorn 运行多个进程, 但是这样无法进行进程管理，因此使用 gunicorn 的方法一般更多被使用 性能提升 如果 API 返回大量数据, 使用 ORJSON 加快序列化速度\nPYTHON Collapse Copy from fastapi import FastAPI from fastapi.responses import ORJSONResponse app = FastAPI(default_response_class=ORJSONResponse) Click to expand and view more ","title":"How FastAPI Works"},{"link":"/posts/blaugust/","text":"🎈 Oh hello, August! It\u0026rsquo;s time for Blaugust.\nBlaugust Begins: Writing as a Develpoer Habit This year, I\u0026rsquo;m joining Blaugust - a month-long blogging challenge that encourage consistent writing throught August. For develpoers, blogging isn\u0026rsquo;t just sharing, it\u0026rsquo;s about orgainzing thoughts, documenting ideas, and creating term references.\nWhat I Plan to Write Here is what I aim to cover this month:\nDaily dev partices: tools, logging, project structure patterns Python ecosystem: FastAPI, Pydantic, Langchain, Pytest and more AI project logs: buliding AI agents and orchestration workflows Architecture notes: async patterns, micorservice, data flow Learning notes \u0026amp; translation of blogs: deep dive into code and quality tech atricles I\u0026rsquo;m not necessarily writing one post per day - some days I might write multiple posts in advance - but the goal is to publish daily with a focus on consistency, reusability, and value.\nWriting Platform and Setup This blog is build with Hugo + Github Pages, using the narrow theme. Markdown keeps things simple, and version control is headled vai Git.\nRSS feed is available (blogroll exchange is welcome!)\nIf you\u0026rsquo;re blogging too or joining Blaugust, feel free to connect 👋 ","title":"Blaugust"}],"tags":[]}