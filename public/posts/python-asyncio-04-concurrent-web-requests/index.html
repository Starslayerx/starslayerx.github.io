<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Python Asyncio 04: Concurrent web requests | Starslayerx&#39; Blog</title>
<meta name="keywords" content="Python, Asyncio">
<meta name="description" content="Introducing aiohttp
aiohttp (Asynchronous HTTP Cilent/Server for asyncio and Python) 是一个解决非阻塞 socket.
aiohttp 是一个 aio-http 开源项目的一部分，其自称 &ldquo;set of asyncio-based libraries built with high quality&rdquo;.
该库包含了完整的 web client/server 的功能，意味着它既可以发送 web 请求，也可以作为 web 服务器。
这里会着重介绍客户端的 aiohttp。
这里会使用到 asynchronous context manager 异步上下文管理器，该方法可以干净地发起和关闭 http 请求。
Asynchronous Context Manager
在任何编程语言中，和资源交互都需要关闭和打开，例如文件。
当处理资源的时候，我们需要小心可能抛出的各种异常。
这是因为如果我们打开了一个资源，然后抛出了错误，我们可能永远无法执行释放的代码。
导致处理资源泄露的状态。
可以使用 finally 解决这个问题，即使不是特别 Pythonic:
file = open(&#39;example.txt&#39;)
try:
    lines = file.readlines()
finally:
    file.close()
这里代码解决了在 file.readlines() 出现异常的问题。
缺点是必须要记住将所有这类操作打包到 try finally 语句中，并且还要记住调用 close() 方法。
Python 有一种叫做 context manager 的语言特性，可以通过该方法抽象关闭逻辑：">
<meta name="author" content="Starslayerx">
<link rel="canonical" href="http://localhost:1313/posts/python-asyncio-04-concurrent-web-requests/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.svg">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon.svg">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon.svg">
<link rel="mask-icon" href="http://localhost:1313/favicon.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/python-asyncio-04-concurrent-web-requests/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="http://localhost:1313/posts/python-asyncio-04-concurrent-web-requests/">
  <meta property="og:site_name" content="Starslayerx&#39; Blog">
  <meta property="og:title" content="Python Asyncio 04: Concurrent web requests">
  <meta property="og:description" content="Introducing aiohttp aiohttp (Asynchronous HTTP Cilent/Server for asyncio and Python) 是一个解决非阻塞 socket. aiohttp 是一个 aio-http 开源项目的一部分，其自称 “set of asyncio-based libraries built with high quality”. 该库包含了完整的 web client/server 的功能，意味着它既可以发送 web 请求，也可以作为 web 服务器。 这里会着重介绍客户端的 aiohttp。
这里会使用到 asynchronous context manager 异步上下文管理器，该方法可以干净地发起和关闭 http 请求。
Asynchronous Context Manager 在任何编程语言中，和资源交互都需要关闭和打开，例如文件。 当处理资源的时候，我们需要小心可能抛出的各种异常。 这是因为如果我们打开了一个资源，然后抛出了错误，我们可能永远无法执行释放的代码。 导致处理资源泄露的状态。
可以使用 finally 解决这个问题，即使不是特别 Pythonic:
file = open(&#39;example.txt&#39;) try: lines = file.readlines() finally: file.close() 这里代码解决了在 file.readlines() 出现异常的问题。 缺点是必须要记住将所有这类操作打包到 try finally 语句中，并且还要记住调用 close() 方法。
Python 有一种叫做 context manager 的语言特性，可以通过该方法抽象关闭逻辑：">
  <meta property="og:locale" content="en-US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-26T08:00:00+01:00">
    <meta property="article:modified_time" content="2026-01-26T08:00:00+01:00">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="Asyncio">
      <meta property="og:image" content="http://localhost:1313/images/og-default.avif">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/og-default.avif">
<meta name="twitter:title" content="Python Asyncio 04: Concurrent web requests">
<meta name="twitter:description" content="Introducing aiohttp
aiohttp (Asynchronous HTTP Cilent/Server for asyncio and Python) 是一个解决非阻塞 socket.
aiohttp 是一个 aio-http 开源项目的一部分，其自称 &ldquo;set of asyncio-based libraries built with high quality&rdquo;.
该库包含了完整的 web client/server 的功能，意味着它既可以发送 web 请求，也可以作为 web 服务器。
这里会着重介绍客户端的 aiohttp。
这里会使用到 asynchronous context manager 异步上下文管理器，该方法可以干净地发起和关闭 http 请求。
Asynchronous Context Manager
在任何编程语言中，和资源交互都需要关闭和打开，例如文件。
当处理资源的时候，我们需要小心可能抛出的各种异常。
这是因为如果我们打开了一个资源，然后抛出了错误，我们可能永远无法执行释放的代码。
导致处理资源泄露的状态。
可以使用 finally 解决这个问题，即使不是特别 Pythonic:
file = open(&#39;example.txt&#39;)
try:
    lines = file.readlines()
finally:
    file.close()
这里代码解决了在 file.readlines() 出现异常的问题。
缺点是必须要记住将所有这类操作打包到 try finally 语句中，并且还要记住调用 close() 方法。
Python 有一种叫做 context manager 的语言特性，可以通过该方法抽象关闭逻辑：">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Python Asyncio 04: Concurrent web requests",
      "item": "http://localhost:1313/posts/python-asyncio-04-concurrent-web-requests/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python Asyncio 04: Concurrent web requests",
  "name": "Python Asyncio 04: Concurrent web requests",
  "description": "Introducing aiohttp aiohttp (Asynchronous HTTP Cilent/Server for asyncio and Python) 是一个解决非阻塞 socket. aiohttp 是一个 aio-http 开源项目的一部分，其自称 \u0026ldquo;set of asyncio-based libraries built with high quality\u0026rdquo;. 该库包含了完整的 web client/server 的功能，意味着它既可以发送 web 请求，也可以作为 web 服务器。 这里会着重介绍客户端的 aiohttp。\n这里会使用到 asynchronous context manager 异步上下文管理器，该方法可以干净地发起和关闭 http 请求。\nAsynchronous Context Manager 在任何编程语言中，和资源交互都需要关闭和打开，例如文件。 当处理资源的时候，我们需要小心可能抛出的各种异常。 这是因为如果我们打开了一个资源，然后抛出了错误，我们可能永远无法执行释放的代码。 导致处理资源泄露的状态。\n可以使用 finally 解决这个问题，即使不是特别 Pythonic:\nfile = open(\u0026#39;example.txt\u0026#39;) try: lines = file.readlines() finally: file.close() 这里代码解决了在 file.readlines() 出现异常的问题。 缺点是必须要记住将所有这类操作打包到 try finally 语句中，并且还要记住调用 close() 方法。\nPython 有一种叫做 context manager 的语言特性，可以通过该方法抽象关闭逻辑：\n",
  "keywords": [
    "Python", "Asyncio"
  ],
  "articleBody": "Introducing aiohttp aiohttp (Asynchronous HTTP Cilent/Server for asyncio and Python) 是一个解决非阻塞 socket. aiohttp 是一个 aio-http 开源项目的一部分，其自称 “set of asyncio-based libraries built with high quality”. 该库包含了完整的 web client/server 的功能，意味着它既可以发送 web 请求，也可以作为 web 服务器。 这里会着重介绍客户端的 aiohttp。\n这里会使用到 asynchronous context manager 异步上下文管理器，该方法可以干净地发起和关闭 http 请求。\nAsynchronous Context Manager 在任何编程语言中，和资源交互都需要关闭和打开，例如文件。 当处理资源的时候，我们需要小心可能抛出的各种异常。 这是因为如果我们打开了一个资源，然后抛出了错误，我们可能永远无法执行释放的代码。 导致处理资源泄露的状态。\n可以使用 finally 解决这个问题，即使不是特别 Pythonic:\nfile = open('example.txt') try: lines = file.readlines() finally: file.close() 这里代码解决了在 file.readlines() 出现异常的问题。 缺点是必须要记住将所有这类操作打包到 try finally 语句中，并且还要记住调用 close() 方法。\nPython 有一种叫做 context manager 的语言特性，可以通过该方法抽象关闭逻辑：\nwith open('example.txt') as file: lines = file.readlines() 这种同步的不支持 coroutine 和 tasks，Python 引入了新的语言特征来支持，叫做 asynchronous context managers 异步上下文管理器。 异步上下文是实现了两种特殊方法的类，__aenter__ 异步请求资源和 __aexit__ 关闭资源。\nimport asyncio import socket from types import TracebackType from typing import Optional, Type class ConnectedSocket: def __init__(self, server_socket): self._connection = None self._server_socket = server_socket async def __aenter__(self): # 进入 block 时调用协程，等待直到 client 连接并返回 print('Entering context manager, waiting for connection') loop = asyncio.get_running_loop() connection, address = await loop.socket_accept(self._server_socket) self._connection = connection print('Accepted a connection') return self._connection async def __aexit__( # 退出 block 时调用协程，清理资源，这里关闭连接 self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[TracebackType], ): print('Existing context manager') self._connection.close() print('Closed connection') async def main(): loop = asyncio.get_running_loop() server_socket = socket.socket() server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_address = ('127.0.0.1', 8000) server_socket.setblocking(False) server_socket.bind(server_address) server_socket.listen() async with ConnectedSocket(server_socket) as connection: # 调用 __aenter__，等待客户端连接 data = await loop.sock_recv(connection, 1024) print(data) # print 之后会调用 __aexit__，然后关闭连接 asyncio.run(main()) 假设使用 Telnet 发送 hi，会看到这样输出：\nEntering context manager, waiting for connection Accepted a connection b'hi\\r\\n' Existing context manager Closed connection 通常并不需要自己编写异步上下文管理器，但了解其工作原理很有帮助。\n注意这里使用了更新的 asyncio.get_running_loop() 而不是 asyncio.get_event_loop()。 前者只会尝试去获取时间循环，后者会在没有事件循环的时候尝试创建事件循环，但这只限于主线程，其不会在子线程中创建事件循环。\nMaking a web request with aiohttp aiohtpp 和一般的网络请求都采用了 session 会话的概念。 在一个会话里面，会维护多个连接，每个连接都可以被重复使用。 这被称为 connection pooling 连接池。 连接池是基于 aiohttp 应用的重要概念，该功能能增加应用性能。 由于创建连接是资源密集的，创建可复用的连接池能够削减资源消耗。 一个 sesion 内部也会保存收到的 cookies，该功能可以自行关闭。\n我们可以使用 async with 语句和 aiohttp.ClientSession 异步管理器：\nimport asyncio import aiohttp from aiohttp import ClientSession from util import async_timed BASE_URL = 'https://hacker-news.firebaseio.com/v0/' @async_timed async def fetch_status(session: ClientSession, url: str) -\u003e int: async with session.get(url, ssl=False) as result: return result.status @async_timed async def main(): async with aiohttp.ClientSession() as session: url = 'https://www.example.com' status = await fetch_status(session, url) print(f'Status for {url} was {status}') asyncio.run(main()) 上面访问 https://www.example.com，返回 200 响应码。 首先通过 async with 语句和 aiohttp.ClientSession() 创建一个会话。 一但创建了客户端会话，就可以发送任意网络请求。 在这个例子中，定义了一个获取状态码的方法 fetch_status，根据输入 session 和 URL，返回状态码。 在该函数内部，定义了另一个 async with 块，并使用 session 运行 GET HTTP 请求。\n注意，ClientSession 默认会创建最多 100 个连接，为上线请求设置了隐性的上限。 要修改上限，需要创建一个 TCPConnector 实例并指定最大连接数量，然后将其传递给 ClientSession。\nSetting timeouts with aiohttp 之前介绍过如何使用 asyncio.wait_for() 设置超时，但更干净的一种做法是使用 aiohttp 提供的功能。 默认情况下，aiohttp 有 5 分钟超时，即没有任何一个操作应该超过这个时间。 如果要修改超时时间，可以对整个 session 的所有操作设置，或者对单独的每个请求设置超时。\n使用 aiohttp 特有的 ClientTimeout 数据结构设置超时。 该结构不仅允许为整个请求指定以秒为单位的超时时间，还允许我们设置建立连接或读取数据的超时时间。\nimport asyncio import aiohttp from aiohttp import ClientSession async def fetch_status(session: ClientSession, url: str) -\u003e int: ten_millis = aiohttp.ClientTimeout(total=.01) # GET 超时 async with session.get(url, timeout=ten_millis) as result: return result.status async def main(): session_timeout = aiohttp.ClientTimeout(total=1, connect=1) # 默认上限，握手限制 async with aiohttp.ClientSession(timeout=session_timeout) as session: await fetch_status(session, 'https://www.example.com') asyncio.run(main()) 这里设置了总超时 1 秒，并明确将连接超时设置为 100 毫秒。 接着，在 fetch_status 函数中，我们针对 get 请求覆盖了这一设置，将总超时时间调整为 10 毫秒。 在这种情况下，如果向 example.com 发出的请求耗时超过 10 毫秒，在等待 fetch_status 时就会触发 asyncio.TimeoutError。 在这个例子下，10 毫秒应该足够让 example.com 的请求完成，因此不太可能看到异常。\nRunning tasks concurrently, revisited 使用之前的函数举例说明如何一次进行多个任务\nimport asyncio from util import async_timed, delay @async_timed() async def main() -\u003e None: delay_times = [3, 3, 3] [await asyncio.create_task(delay(seconds)) for seconds in delay_times] asyncio.run(main()) 这里的问题很微秒，由于在创建 task 的时间就使用了 await。 这意味着，对于每一个我们创建的延迟任务，我们都会暂停列表推导式和主 coroutine 协程，直到该延迟任务完成。 这种情况下，任何给定时间只会运行一个任务，而不是多个。 要修复这个问题，可以在列表推导式中创建任务，并在第二个列表推导式中 await。\nimport asyncio from util import async_timed, delay @async_timed() async def main() -\u003e None: delay_times = [3, 3, 3] tasks = [asyncio.create_task(delay(seconds)) for seconds in delay_times] [await task for task in tasks] asyncio.run(main()) 这段代码正常运行是因为 create_task 会立刻返回。 并在所有的 task 创建成功之前没有 await，因此 create_task 能够立刻返回。 这确保了它最多只需要延迟时间中的最大暂停，运行时间约为 3 秒。\n但这样做仍有一些缺陷：\n含有多行代码，必须显示分离 task 和 awaits 灵活性差，如果某个 coroutine 比其他先完成，则必须要等待其他 coroutine 完成 最大的问题是错误处理，如果某个 coroutine 出现了异常，则会抛出该异常，导致任务终止 Running requests concurrently with gather 一个广泛使用的 asyncio API 函数是 asyncio.gather。 该函数接收一系列 awaitable 对象，然后将他们都打包到一个 task 里面并发运行。 这意味着我们无需将所有东西都分别包装到 asyncio.create_task 中去运行了。\nasyncio.gather 返回一个 awaitable 对象，当我们 await 该对象会暂停直到所有的 task 执行完成。 一但所有的任务完成，asyncio.gather 会返回一个完成的列表。\n下面举一个 1000 个请求的例子，并获取每个响应的响应码。 并使用 @async_timed 来获取每个请求消耗的时间。\nimport asyncio import aiohttp from aiohttp import ClientSession from util import async_timed @async_timed() async def fetch_status(session: ClientSession, url: str) -\u003e int: timeout = aiohttp.ClientSession(total=1) async with session.get(url, timeout=timeout, ssl=False) as result: print(f'status code: {result.status}') return result.status @async_timed() async def main(): async with aiohttp.ClientSession() as session: urls = ['https://example.com' for _ in range(1000)] requests = [fetch_status(session, url) for url in urls] status_code = await asyncio.gather(*requests) asyncio.run(main()) 首先创建大量的请求地址 urls，然后创建对每个地址的获取状态码请求 fetch_status，最后将他们都放到 asyncio.gather() 中。 这将每个 coroutine 包装成一个 task 并开始并发执行。 当执行该代码时，我们会看到 1000 条信息顺序输出，说 fetch_status 协程启动了。 结果会看到类似这样的输出 Finished in 0.5628 second(s)。 一旦获取了所有请求的 URL 内容，就会看到状态码开始打印出来。\n如果要和同步对比，修改 main 函数为阻塞的：\nasync def main(): async def aiohttp.ClientSession() as session: urls = ['http://example.com' for _ in range(1000)] status_codes = [await fetch_status(session, url) for url in urls] print(status_codes) 同步的方式花了足足 221.2207 秒！\n值得注意的一点是 gather 函数可能会按不确定的顺序完成，但好在它返回的结果是有顺序的。 下面通过 delay 函数来证明一下：\nimport asyncio from util import delay async def main(): results = asyncio.gather(delay(3), delay(1)) print(results) asyncio.run(main()) 上面两个 delay() 函数一个消耗 3 秒，一个消耗 1 秒。 按照时间顺序应该是得到结果 [1, 3]，但实际上是根据会得到我们输入顺序的结果 [3, 1]。 在幕后，gather 使用了一种特殊的 future 实现来完成这一操作。\n上面介绍的代码都没有考虑失败的情况，但如果抛出异常了怎么办？\nHandling exceptions with gather 在发送网络请求的时候，有时候可能并不总是能够得到一个结果。 由于网络肯能是不可靠的，我们可能会得到一个异常，可能会有不同的故障情况。\nasyncio.gather 提供了一个可选参数 return_exceptions，其允许指定异常处理方式。 return_exceptions 是一个布尔值，因此有两个可能的值：\nreturn_exceptions=False 这是默认值，这种情况下，如果产生了任何异常，gather 会在 await 的时候抛出一样的异常。 然而，即使某个协程失效了，只要处理了异常，或者异常不会导致事件循环停止并取消任务，其他协程就不会取消，并继续运行。\nreturn_exceptions=True 在这种情况下，gather 会在 await 它时将任何异常作为返回结果列表的一部分返回。调用 gather 本身不会抛出任何异常，可以按照自己意愿处理所有异常。\n这里使用一个错误的 url 地址举例说明：\n@async_timed async def main(): async with aiohttp.ClientSession() as session: urls = ['https://example.com', 'python://example.com'] tasks = [fetch_status(session, url) for url in urls] status_code = await asyncio.gather(*tasks) print(status_code) 由于 url 地址不合法，fetch_status 函数会产生 NonHttpUrlClientError 的报错。 该异常会在 await 的时候抛出，但请求继续执行了。\nStarting with args () {} Starting with args (, 'https://example.com') {} Starting with args (, 'python://example.com') {} Finished in 0.0000 second(s) Finished in 0.0027 second(s) Finished in 0.0030 second(s) Traceback (most recent call last): ... aiohttp.client_exceptions.NonHttpUrlClientError: python://example.com 如果发生错误 asyncio.gather 并不会取消其他任务。 对于许多场景来说，这或许可以接受，但这也是 gather 的缺点之一。\n还有一个潜在问题是，如果代码产生多个异常，将只能看到第一个异常结果。 可以使用 return_exceptions=True 修复这个问题，这会在运行协程的时候返回遇到的所有异常。 然后可以过滤出所有的异常并处理，下面使用之前的例子展示一下：\n@async_timed() async def main(): async with aiohttp.ClientSession() as session: urls = ['https//example.com', 'python://example.com'] tasks = [fetch_status(session, url) for url in urls] results = await asyncio.gather(*tasks, return_exceptions=True) exceptions = [res for res in results if isinstance(res, Exception)] successful_results = [res for res in results if not isinstance(res, Exception)] print() print(f'All results: {results}') print(f'Finished successfully: {successful_results}') print(f'Threw exceptions: {exceptions}') print() 运行结果如下：\nAll results: [200, NonHttpUrlClientError(URL('python://www.example.com'))] Finished successfully: [200] Threw exceptions: [NonHttpUrlClientError(URL('python://www.example.com'))] 这样解决了只能看到一个错误的问题，并且也不用通过 try catch 捕获异常了。 但仍然需要从成功结果中筛选出异常，这显得有些笨拙。\ngather 有一些缺陷，一个是不容易在出现报错的时候取消任务。 另一个是必须等待所有的协程处理完成才能得到结果。 asyncio 提供了解决这两个问题的 API，先来看看如何一有结果就立刻处理的问题。\nProcessing requests as they complete 假如有 100 个请求，其中两个响应很慢，其他都迅速完成了，这时候使用 gather 则需要等所有的请求结束，并获取到结果。 为了应对这种情况，asyncio 有一个 as_completed 函数。 该方法接收一个 awaitable 对象列表，并返回一个未来对象的迭代器。 为了展示该方法如何工作，使用 delay 模型需要不同时间的请求。\nasync def fetch_status(session: ClientSession, url: str, delay: int = 0) -\u003e int: await asyncio.sleep(delay) async with session.get(url, ssl=False) as result: return result.status 并使用 for 循环通过 as_completed 迭代：\nimport asyncio import aiohttp from aiohttp import ClientSession from util import async_timed @async_timed() async def main(): async with aiohttp.ClientSession as session: fetchers = [ fetch_status(session, 'https://www.example.com', 1), fetch_status(session, 'https://www.example.com', 1), fetch_status(session, 'https://www.example.com', 10), ] for finished_task in asyncio.as_completed(fetchers): print(await finished_task) asyncio.run(main()) 在上面的例子中，我们创建了 3 个协程，两个耗时 1 秒，另一个耗时 10 秒。 然后将其传递给 as_completed，在底层，每个协程都被封装在一个 task 中，然后并发运行。 该函数立即返回一个开始循环遍历的迭代器。 当我们进入 for 循环，会遇到 await finished_task。 这里会暂停执行，直到第一个结果返回。 在这个例子中，我们的第一个结果在 1 秒后返回，另一个结果也马上会返回，然后过一会儿运行 10 秒的结果返回。\nStarting with args () {} Starting with args (, 'https://www.example.com', 1) {} Starting with args (, 'https://www.example.com', 1) {} Starting with args (, 'https://www.example.com', 10) {} Finished in 1.6038 second(s) 200 Finished in 1.6136 second(s) 200 Finished in 10.2043 second(s) 200 Finished in 10.2080 second(s) 总的来说，完整耗时仍然是 10 秒，这和使用 asyncio.gather() 相同。 但能够在第一个请求完成后立即执行代码来打印其结果。 这让我们有额外时间来处理第一个成功完成的协程的结果，而其他协程仍在等待完成。 从而使的应用程序更加具有响应性。\n该函数也提供了更好的异常处理机制。 当一个 task 抛出异常，可以在异常抛出后就立刻处理。\nTimeouts with as_completed 任何基于网络的请求都有耗时较长的风险。 服务器可能处于高资源负载状态，或者网络连接不佳。 之前介绍了如何给单个请求设置超时，但要是一堆请求呢？ as_completed 函数支持一个设置超时的位置参数，可以设置超时秒数。 这会去跟踪每个 as_completed 的调用时间，如果比超时时间更长，则会在 await 的时候抛出一个 TimeoutException 异常。\n为了说明这种情况，下面使用之前例子，并为 as_completed 设置 2 秒的超时时间。 一但循环结束，就打印所有的任务结果。\nimport asyncio import aiohttp from aiohttp import ClientSession from util import async_timed @async_timed() async def fetch_status(session: Session, url: str, delay: str) -\u003e int: await asyncio.sleep(delay) async with session.get(url, ssl=False): return result.status @async_timed() async def main(): async with aiohttp.ClientSession() as session: fetchers = [ fetch_status(session, 'https://example.com', 1), fetch_status(session, 'https://example.com', 10), fetch_status(session, 'https://example.com', 10), ] for done_task in asyncio.as_completed(fetchers, timeout=2): try: result = await done_task print(result) except: print('Got an error!') for task in asyncio.tasks.all_tasks(): print(task) asyncio.run(main()) 输出如下：\nFinished in 1.5893 second(s) 200 Got an error! Got an error! as_completed 函数在快速获取结果方面很好用，但也有缺点。 首先，虽然我们能够实时获取结果，但由于顺序完全不确定，无法轻松地看出当前正在等待的是哪个协程或任务。 如果不关心顺序，这可能没问题。 但如果要以某种方式将结果与请求关联起来，就会面临挑战。\n其次是超时时间，虽然能够正确地抛出异常，但任何创建的 tasks 仍然会在后台运行。 由于无法知道是哪些 tasks 还在运行，于是就无法取消它们，这是另一个挑战。 如果这些是需要处理的问题，则需要更细粒度的知道哪些 awaitables 运行结束了，哪些没有。 为了应对这个问题，asyncio 提供了另一个 wait API 函数。\nFiner-grained control with wait gather 和 as_completed 相同的问题是无法轻易地取消在运行中抛出异常的任务。 这种很多情况下或许可以接受，但设想这样一个场景：发起多个协程调用，如果第一个失败其他的也失败。 例如，网络请求传递无效参数或达到 API 速率限制。 这可能导致性能问题，因为我们会运行超出实际所需的任务，从而消耗更多资源。 as_completed 的另一个缺点是，由于迭代顺序不确定，很难去追踪哪个任务完成。\nasyncio 中的 wait 和 gather 类似，其提供了这种情况下更加具体的控制方式。\n",
  "wordCount" : "1317",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/og-default.avif","datePublished": "2026-01-26T08:00:00+01:00",
  "dateModified": "2026-01-26T08:00:00+01:00",
  "author":{
    "@type": "Person",
    "name": "Starslayerx"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/python-asyncio-04-concurrent-web-requests/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Starslayerx' Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.svg"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Starslayerx&#39; Blog (Alt + H)">
                <img src="http://localhost:1313/favicon.svg" alt="" aria-label="logo"
                    height="35">Starslayerx&#39; Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                    <ul class="lang-switch"><li>|</li>
                        <li>
                            <a href="http://localhost:1313/zh-cn/" title="简体中文"
                                aria-label="简体中文">Zh-Cn</a>
                        </li>
                    </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Python Asyncio 04: Concurrent web requests
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2026-01-26 08:00:00 +0100 +0100'>January 26, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1317 words</span>&nbsp;·&nbsp;<span>Starslayerx</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#introducing-aiohttp">Introducing aiohttp</a></li>
    <li><a href="#asynchronous-context-manager">Asynchronous Context Manager</a>
      <ul>
        <li><a href="#making-a-web-request-with-aiohttp">Making a web request with aiohttp</a></li>
        <li><a href="#setting-timeouts-with-aiohttp">Setting timeouts with aiohttp</a></li>
      </ul>
    </li>
    <li><a href="#running-tasks-concurrently-revisited">Running tasks concurrently, revisited</a></li>
    <li><a href="#running-requests-concurrently-with-gather">Running requests concurrently with gather</a></li>
    <li><a href="#handling-exceptions-with-gather">Handling exceptions with gather</a></li>
    <li><a href="#processing-requests-as-they-complete">Processing requests as they complete</a>
      <ul>
        <li><a href="#timeouts-with-as_completed">Timeouts with as_completed</a></li>
      </ul>
    </li>
    <li><a href="#finer-grained-control-with-wait">Finer-grained control with wait</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introducing-aiohttp">Introducing aiohttp<a hidden class="anchor" aria-hidden="true" href="#introducing-aiohttp">#</a></h2>
<p>aiohttp (Asynchronous HTTP Cilent/Server for asyncio and Python) 是一个解决非阻塞 socket.
aiohttp 是一个 aio-http 开源项目的一部分，其自称 &ldquo;set of asyncio-based libraries built with high quality&rdquo;.
该库包含了完整的 web client/server 的功能，意味着它既可以发送 web 请求，也可以作为 web 服务器。
这里会着重介绍客户端的 aiohttp。</p>
<p>这里会使用到 asynchronous context manager 异步上下文管理器，该方法可以干净地发起和关闭 http 请求。</p>
<h2 id="asynchronous-context-manager">Asynchronous Context Manager<a hidden class="anchor" aria-hidden="true" href="#asynchronous-context-manager">#</a></h2>
<p>在任何编程语言中，和资源交互都需要关闭和打开，例如文件。
当处理资源的时候，我们需要小心可能抛出的各种异常。
这是因为如果我们打开了一个资源，然后抛出了错误，我们可能永远无法执行释放的代码。
导致处理资源泄露的状态。</p>
<p>可以使用 <code>finally</code> 解决这个问题，即使不是特别 Pythonic:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;example.txt&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">lines</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><p>这里代码解决了在 <code>file.readlines()</code> 出现异常的问题。
缺点是必须要记住将所有这类操作打包到 <code>try finally</code> 语句中，并且还要记住调用 <code>close()</code> 方法。</p>
<p>Python 有一种叫做 context manager 的语言特性，可以通过该方法抽象关闭逻辑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;example.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">lines</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
</span></span></code></pre></div><p>这种同步的不支持 coroutine 和 tasks，Python 引入了新的语言特征来支持，叫做 asynchronous context managers 异步上下文管理器。
异步上下文是实现了两种特殊方法的类，<code>__aenter__</code> 异步请求资源和 <code>__aexit__</code> 关闭资源。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">socket</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">TracebackType</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Type</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ConnectedSocket</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">server_socket</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">_server_socket</span> <span class="o">=</span> <span class="n">server_socket</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># 进入 block 时调用协程，等待直到 client 连接并返回</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Entering context manager, waiting for connection&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">socket_accept</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_server_socket</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span> <span class="o">=</span> <span class="n">connection</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Accepted a connection&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span>  <span class="c1"># 退出 block 时调用协程，清理资源，这里关闭连接</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">exc_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">]],</span>
</span></span><span class="line"><span class="cl">        <span class="n">exc_val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">        <span class="n">exc_tb</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TracebackType</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Existing context manager&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Closed connection&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_address</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">ConnectedSocket</span><span class="p">(</span><span class="n">server_socket</span><span class="p">)</span> <span class="k">as</span> <span class="n">connection</span><span class="p">:</span>  <span class="c1"># 调用 __aenter__，等待客户端连接</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_recv</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># print 之后会调用 __aexit__，然后关闭连接</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span></code></pre></div><p>假设使用 Telnet 发送 hi，会看到这样输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Entering context manager, waiting for connection
</span></span><span class="line"><span class="cl">Accepted a connection
</span></span><span class="line"><span class="cl">b&#39;hi\r\n&#39;
</span></span><span class="line"><span class="cl">Existing context manager
</span></span><span class="line"><span class="cl">Closed connection
</span></span></code></pre></div><p>通常并不需要自己编写异步上下文管理器，但了解其工作原理很有帮助。</p>
<p>注意这里使用了更新的 <code>asyncio.get_running_loop()</code> 而不是 <code>asyncio.get_event_loop()</code>。
前者只会尝试去获取时间循环，后者会在没有事件循环的时候尝试创建事件循环，但这只限于主线程，其不会在子线程中创建事件循环。</p>
<h3 id="making-a-web-request-with-aiohttp">Making a web request with aiohttp<a hidden class="anchor" aria-hidden="true" href="#making-a-web-request-with-aiohttp">#</a></h3>
<p>aiohtpp 和一般的网络请求都采用了 session 会话的概念。
在一个会话里面，会维护多个连接，每个连接都可以被重复使用。
这被称为 connection pooling 连接池。
连接池是基于 aiohttp 应用的重要概念，该功能能增加应用性能。
由于创建连接是资源密集的，创建可复用的连接池能够削减资源消耗。
一个 sesion 内部也会保存收到的 cookies，该功能可以自行关闭。</p>
<p>我们可以使用 <code>async with</code> 语句和 <code>aiohttp.ClientSession</code> 异步管理器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">aiohttp</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">aiohttp</span> <span class="kn">import</span> <span class="n">ClientSession</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="n">async_timed</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">BASE_URL</span> <span class="o">=</span> <span class="s1">&#39;https://hacker-news.firebaseio.com/v0/&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@async_timed</span>
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">ClientSession</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">result</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@async_timed</span>
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;https://www.example.com&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Status for </span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s1"> was </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span></code></pre></div><p>上面访问 <code>https://www.example.com</code>，返回 200 响应码。
首先通过 <code>async with</code> 语句和 <code>aiohttp.ClientSession()</code> 创建一个会话。
一但创建了客户端会话，就可以发送任意网络请求。
在这个例子中，定义了一个获取状态码的方法 <code>fetch_status</code>，根据输入 session 和 URL，返回状态码。
在该函数内部，定义了另一个 <code>async with</code> 块，并使用 session 运行 <code>GET</code> HTTP 请求。</p>
<p>注意，<code>ClientSession</code> 默认会创建最多 100 个连接，为上线请求设置了隐性的上限。
要修改上限，需要创建一个 <code>TCPConnector</code> 实例并指定最大连接数量，然后将其传递给 <code>ClientSession</code>。</p>
<h3 id="setting-timeouts-with-aiohttp">Setting timeouts with aiohttp<a hidden class="anchor" aria-hidden="true" href="#setting-timeouts-with-aiohttp">#</a></h3>
<p>之前介绍过如何使用 <code>asyncio.wait_for()</code> 设置超时，但更干净的一种做法是使用 aiohttp 提供的功能。
默认情况下，aiohttp 有 5 分钟超时，即没有任何一个操作应该超过这个时间。
如果要修改超时时间，可以对整个 session 的所有操作设置，或者对单独的每个请求设置超时。</p>
<p>使用 aiohttp 特有的 <code>ClientTimeout</code> 数据结构设置超时。
该结构不仅允许为整个请求指定以秒为单位的超时时间，还允许我们设置建立连接或读取数据的超时时间。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">aiohttp</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">aiohttp</span> <span class="kn">import</span> <span class="n">ClientSession</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">ClientSession</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ten_millis</span> <span class="o">=</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientTimeout</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="mf">.01</span><span class="p">)</span>  <span class="c1"># GET 超时</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">ten_millis</span><span class="p">)</span> <span class="k">as</span> <span class="n">result</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">session_timeout</span> <span class="o">=</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientTimeout</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">connect</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 默认上限，握手限制</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">session_timeout</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s1">&#39;https://www.example.com&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span></code></pre></div><p>这里设置了总超时 1 秒，并明确将连接超时设置为 100 毫秒。
接着，在 <code>fetch_status</code> 函数中，我们针对 <strong>get</strong> 请求覆盖了这一设置，将总超时时间调整为 10 毫秒。
在这种情况下，如果向 <code>example.com</code> 发出的请求耗时超过 10 毫秒，在等待 <code>fetch_status</code> 时就会触发 <code>asyncio.TimeoutError</code>。
在这个例子下，10 毫秒应该足够让 <code>example.com</code> 的请求完成，因此不太可能看到异常。</p>
<h2 id="running-tasks-concurrently-revisited">Running tasks concurrently, revisited<a hidden class="anchor" aria-hidden="true" href="#running-tasks-concurrently-revisited">#</a></h2>
<p>使用之前的函数举例说明如何一次进行多个任务</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="n">async_timed</span><span class="p">,</span> <span class="n">delay</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@async_timed</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">delay_times</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">delay</span><span class="p">(</span><span class="n">seconds</span><span class="p">))</span> <span class="k">for</span> <span class="n">seconds</span> <span class="ow">in</span> <span class="n">delay_times</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span></code></pre></div><p>这里的问题很微秒，由于在创建 task 的时间就使用了 <code>await</code>。
这意味着，对于每一个我们创建的延迟任务，我们都会暂停列表推导式和主 coroutine 协程，直到该延迟任务完成。
这种情况下，任何给定时间只会运行一个任务，而不是多个。
要修复这个问题，可以在列表推导式中创建任务，并在第二个列表推导式中 <code>await</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="n">async_timed</span><span class="p">,</span> <span class="n">delay</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@async_timed</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">delay_times</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">delay</span><span class="p">(</span><span class="n">seconds</span><span class="p">))</span> <span class="k">for</span> <span class="n">seconds</span> <span class="ow">in</span> <span class="n">delay_times</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="k">await</span> <span class="n">task</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span></code></pre></div><p>这段代码正常运行是因为 <code>create_task</code> 会立刻返回。
并在所有的 task 创建成功之前没有 <code>await</code>，因此 <code>create_task</code> 能够立刻返回。
这确保了它最多只需要延迟时间中的最大暂停，运行时间约为 3 秒。</p>
<p>但这样做仍有一些缺陷：</p>
<ol>
<li>含有多行代码，必须显示分离 task 和 awaits</li>
<li>灵活性差，如果某个 coroutine 比其他先完成，则必须要等待其他 coroutine 完成</li>
<li>最大的问题是错误处理，如果某个 coroutine 出现了异常，则会抛出该异常，导致任务终止</li>
</ol>
<h2 id="running-requests-concurrently-with-gather">Running requests concurrently with gather<a hidden class="anchor" aria-hidden="true" href="#running-requests-concurrently-with-gather">#</a></h2>
<p>一个广泛使用的 asyncio API 函数是 <code>asyncio.gather</code>。
该函数接收一系列 <code>awaitable</code> 对象，然后将他们都打包到一个 task 里面并发运行。
这意味着我们无需将所有东西都分别包装到 <code>asyncio.create_task</code> 中去运行了。</p>
<p><code>asyncio.gather</code> 返回一个 awaitable 对象，当我们 <code>await</code> 该对象会暂停直到所有的 task 执行完成。
一但所有的任务完成，<code>asyncio.gather</code> 会返回一个完成的列表。</p>
<p>下面举一个 1000 个请求的例子，并获取每个响应的响应码。
并使用 <code>@async_timed</code> 来获取每个请求消耗的时间。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">aiohttp</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">aiohttp</span> <span class="kn">import</span> <span class="n">ClientSession</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="n">async_timed</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@async_timed</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">ClientSession</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">timeout</span> <span class="o">=</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">result</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;status code: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">status</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@async_timed</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">urls</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;https://example.com&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">        <span class="n">requests</span> <span class="o">=</span> <span class="p">[</span><span class="n">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">status_code</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">requests</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span></code></pre></div><p>首先创建大量的请求地址 urls，然后创建对每个地址的获取状态码请求 <code>fetch_status</code>，最后将他们都放到 <code>asyncio.gather()</code> 中。
这将每个 coroutine 包装成一个 task 并开始并发执行。
当执行该代码时，我们会看到 1000 条信息顺序输出，说 <code>fetch_status</code> 协程启动了。
结果会看到类似这样的输出 <code>Finished &lt;function fetch_status at 0x1025fd3a0&gt; in 0.5628 second(s)</code>。
一旦获取了所有请求的 URL 内容，就会看到状态码开始打印出来。</p>
<p>如果要和同步对比，修改 main 函数为阻塞的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">def</span> <span class="nf">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">urls</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;http://example.com&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">        <span class="n">status_codes</span> <span class="o">=</span> <span class="p">[</span><span class="k">await</span> <span class="n">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">status_codes</span><span class="p">)</span>
</span></span></code></pre></div><p>同步的方式花了足足 221.2207 秒！</p>
<p>值得注意的一点是 <code>gather</code> 函数可能会按不确定的顺序完成，但好在它返回的结果是有顺序的。
下面通过 <code>delay</code> 函数来证明一下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="n">delay</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">results</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">delay</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span></code></pre></div><p>上面两个 <code>delay()</code> 函数一个消耗 3 秒，一个消耗 1 秒。
按照时间顺序应该是得到结果 <code>[1, 3]</code>，但实际上是根据会得到我们输入顺序的结果 <code>[3, 1]</code>。
在幕后，<code>gather</code> 使用了一种特殊的 <code>future</code> 实现来完成这一操作。</p>
<p>上面介绍的代码都没有考虑失败的情况，但如果抛出异常了怎么办？</p>
<h2 id="handling-exceptions-with-gather">Handling exceptions with gather<a hidden class="anchor" aria-hidden="true" href="#handling-exceptions-with-gather">#</a></h2>
<p>在发送网络请求的时候，有时候可能并不总是能够得到一个结果。
由于网络肯能是不可靠的，我们可能会得到一个异常，可能会有不同的故障情况。</p>
<p><code>asyncio.gather</code> 提供了一个可选参数 <code>return_exceptions</code>，其允许指定异常处理方式。
<code>return_exceptions</code> 是一个布尔值，因此有两个可能的值：</p>
<ul>
<li>
<p><code>return_exceptions=False</code> 这是默认值，这种情况下，如果产生了任何异常，<code>gather</code> 会在 <code>await</code> 的时候抛出一样的异常。
然而，即使某个协程失效了，只要处理了异常，或者异常不会导致事件循环停止并取消任务，其他协程就不会取消，并继续运行。</p>
</li>
<li>
<p><code>return_exceptions=True</code> 在这种情况下，<code>gather</code> 会在 <code>await</code> 它时将任何异常作为返回结果列表的一部分返回。调用 <code>gather</code> 本身不会抛出任何异常，可以按照自己意愿处理所有异常。</p>
</li>
</ul>
<p>这里使用一个错误的 url 地址举例说明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="nd">@async_timed</span>
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">urls</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;https://example.com&#39;</span><span class="p">,</span> <span class="s1">&#39;python://example.com&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">status_code</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="n">status_code</span><span class="p">)</span>
</span></span></code></pre></div><p>由于 url 地址不合法，<code>fetch_status</code> 函数会产生 <code>NonHttpUrlClientError</code> 的报错。
该异常会在 <code>await</code> 的时候抛出，但请求继续执行了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Starting &lt;function main at 0x10600f420&gt; with args () {}
</span></span><span class="line"><span class="cl">Starting &lt;function fetch_status at 0x104659440&gt; with args (&lt;aiohttp.client.ClientSession object at 0x10617f230&gt;, &#39;https://example.com&#39;) {}
</span></span><span class="line"><span class="cl">Starting &lt;function fetch_status at 0x104659440&gt; with args (&lt;aiohttp.client.ClientSession object at 0x10617f230&gt;, &#39;python://example.com&#39;) {}
</span></span><span class="line"><span class="cl">Finished &lt;function fetch_status at 0x104659440&gt; in 0.0000 second(s)
</span></span><span class="line"><span class="cl">Finished &lt;function fetch_status at 0x104659440&gt; in 0.0027 second(s)
</span></span><span class="line"><span class="cl">Finished &lt;function main at 0x10600f420&gt; in 0.0030 second(s)
</span></span><span class="line"><span class="cl">Traceback (most recent call last):
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">aiohttp.client_exceptions.NonHttpUrlClientError: python://example.com
</span></span></code></pre></div><p>如果发生错误 <code>asyncio.gather</code> 并不会取消其他任务。
对于许多场景来说，这或许可以接受，但这也是 <code>gather</code> 的缺点之一。</p>
<p>还有一个潜在问题是，如果代码产生多个异常，将只能看到第一个异常结果。
可以使用 <code>return_exceptions=True</code> 修复这个问题，这会在运行协程的时候返回遇到的所有异常。
然后可以过滤出所有的异常并处理，下面使用之前的例子展示一下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="nd">@async_timed</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">urls</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;https//example.com&#39;</span><span class="p">,</span> <span class="s1">&#39;python://example.com&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">,</span> <span class="n">return_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">exceptions</span> <span class="o">=</span> <span class="p">[</span><span class="n">res</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">        <span class="n">successful_results</span> <span class="o">=</span> <span class="p">[</span><span class="n">res</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;All results: </span><span class="si">{</span><span class="n">results</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Finished successfully: </span><span class="si">{</span><span class="n">successful_results</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Threw exceptions: </span><span class="si">{</span><span class="n">exceptions</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">()</span>
</span></span></code></pre></div><p>运行结果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">All results: [200, NonHttpUrlClientError(URL(&#39;python://www.example.com&#39;))]
</span></span><span class="line"><span class="cl">Finished successfully: [200]
</span></span><span class="line"><span class="cl">Threw exceptions: [NonHttpUrlClientError(URL(&#39;python://www.example.com&#39;))]
</span></span></code></pre></div><p>这样解决了只能看到一个错误的问题，并且也不用通过 try catch 捕获异常了。
但仍然需要从成功结果中筛选出异常，这显得有些笨拙。</p>
<p><code>gather</code> 有一些缺陷，一个是不容易在出现报错的时候取消任务。
另一个是必须等待所有的协程处理完成才能得到结果。
asyncio 提供了解决这两个问题的 API，先来看看如何一有结果就立刻处理的问题。</p>
<h2 id="processing-requests-as-they-complete">Processing requests as they complete<a hidden class="anchor" aria-hidden="true" href="#processing-requests-as-they-complete">#</a></h2>
<p>假如有 100 个请求，其中两个响应很慢，其他都迅速完成了，这时候使用 <code>gather</code> 则需要等所有的请求结束，并获取到结果。
为了应对这种情况，asyncio 有一个 <code>as_completed</code> 函数。
该方法接收一个 awaitable 对象列表，并返回一个未来对象的迭代器。
为了展示该方法如何工作，使用 <code>delay</code> 模型需要不同时间的请求。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">ClientSession</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">result</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span>
</span></span></code></pre></div><p>并使用 for 循环通过 <code>as_completed</code> 迭代：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">aiohttp</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">aiohttp</span> <span class="kn">import</span> <span class="n">ClientSession</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="n">async_timed</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@async_timed</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">fetchers</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">            <span class="n">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s1">&#39;https://www.example.com&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s1">&#39;https://www.example.com&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s1">&#39;https://www.example.com&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">finished_task</span> <span class="ow">in</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">as_completed</span><span class="p">(</span><span class="n">fetchers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="k">await</span> <span class="n">finished_task</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span></code></pre></div><p>在上面的例子中，我们创建了 3 个协程，两个耗时 1 秒，另一个耗时 10 秒。
然后将其传递给 <code>as_completed</code>，在底层，每个协程都被封装在一个 task 中，然后并发运行。
该函数立即返回一个开始循环遍历的迭代器。
当我们进入 for 循环，会遇到 <code>await finished_task</code>。
这里会暂停执行，直到第一个结果返回。
在这个例子中，我们的第一个结果在 1 秒后返回，另一个结果也马上会返回，然后过一会儿运行 10 秒的结果返回。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Starting &lt;function main at 0x106983420&gt; with args () {}
</span></span><span class="line"><span class="cl">Starting &lt;function fetch_status at 0x105051440&gt; with args (&lt;aiohttp.client.ClientSession object at 0x105162270&gt;, &#39;https://www.example.com&#39;, 1) {}
</span></span><span class="line"><span class="cl">Starting &lt;function fetch_status at 0x105051440&gt; with args (&lt;aiohttp.client.ClientSession object at 0x105162270&gt;, &#39;https://www.example.com&#39;, 1) {}
</span></span><span class="line"><span class="cl">Starting &lt;function fetch_status at 0x105051440&gt; with args (&lt;aiohttp.client.ClientSession object at 0x105162270&gt;, &#39;https://www.example.com&#39;, 10) {}
</span></span><span class="line"><span class="cl">Finished &lt;function fetch_status at 0x105051440&gt; in 1.6038 second(s)
</span></span><span class="line"><span class="cl">200
</span></span><span class="line"><span class="cl">Finished &lt;function fetch_status at 0x105051440&gt; in 1.6136 second(s)
</span></span><span class="line"><span class="cl">200
</span></span><span class="line"><span class="cl">Finished &lt;function fetch_status at 0x105051440&gt; in 10.2043 second(s)
</span></span><span class="line"><span class="cl">200
</span></span><span class="line"><span class="cl">Finished &lt;function main at 0x106983420&gt; in 10.2080 second(s)
</span></span></code></pre></div><p>总的来说，完整耗时仍然是 10 秒，这和使用 <code>asyncio.gather()</code> 相同。
但能够在第一个请求完成后立即执行代码来打印其结果。
这让我们有额外时间来处理第一个成功完成的协程的结果，而其他协程仍在等待完成。
从而使的应用程序更加具有响应性。</p>
<p>该函数也提供了更好的异常处理机制。
当一个 task 抛出异常，可以在异常抛出后就立刻处理。</p>
<h3 id="timeouts-with-as_completed">Timeouts with as_completed<a hidden class="anchor" aria-hidden="true" href="#timeouts-with-as_completed">#</a></h3>
<p>任何基于网络的请求都有耗时较长的风险。
服务器可能处于高资源负载状态，或者网络连接不佳。
之前介绍了如何给单个请求设置超时，但要是一堆请求呢？
<code>as_completed</code> 函数支持一个设置超时的位置参数，可以设置超时秒数。
这会去跟踪每个 <code>as_completed</code> 的调用时间，如果比超时时间更长，则会在 <code>await</code> 的时候抛出一个 <code>TimeoutException</code> 异常。</p>
<p>为了说明这种情况，下面使用之前例子，并为 <code>as_completed</code> 设置 2 秒的超时时间。
一但循环结束，就打印所有的任务结果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">aiohttp</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">aiohttp</span> <span class="kn">import</span> <span class="n">ClientSession</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="n">async_timed</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@async_timed</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">:</span> <span class="n">Session</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">ssl</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@async_timed</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">fetchers</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">            <span class="n">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s1">&#39;https://example.com&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s1">&#39;https://example.com&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">fetch_status</span><span class="p">(</span><span class="n">session</span><span class="p">,</span> <span class="s1">&#39;https://example.com&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">done_task</span> <span class="ow">in</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">as_completed</span><span class="p">(</span><span class="n">fetchers</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">done_task</span>
</span></span><span class="line"><span class="cl">                <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">except</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Got an error!&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">all_tasks</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span></code></pre></div><p>输出如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Finished &lt;function fetch_status at 0x1043a53a0&gt; in 1.5893 second(s)
</span></span><span class="line"><span class="cl">200
</span></span><span class="line"><span class="cl">Got an error!
</span></span><span class="line"><span class="cl">Got an error!
</span></span></code></pre></div><p><code>as_completed</code> 函数在快速获取结果方面很好用，但也有缺点。
首先，虽然我们能够实时获取结果，但由于顺序完全不确定，无法轻松地看出当前正在等待的是哪个协程或任务。
如果不关心顺序，这可能没问题。
但如果要以某种方式将结果与请求关联起来，就会面临挑战。</p>
<p>其次是超时时间，虽然能够正确地抛出异常，但任何创建的 tasks 仍然会在后台运行。
由于无法知道是哪些 tasks 还在运行，于是就无法取消它们，这是另一个挑战。
如果这些是需要处理的问题，则需要更细粒度的知道哪些 awaitables 运行结束了，哪些没有。
为了应对这个问题，asyncio 提供了另一个 <code>wait</code> API 函数。</p>
<h2 id="finer-grained-control-with-wait">Finer-grained control with wait<a hidden class="anchor" aria-hidden="true" href="#finer-grained-control-with-wait">#</a></h2>
<p><code>gather</code> 和 <code>as_completed</code> 相同的问题是无法轻易地取消在运行中抛出异常的任务。
这种很多情况下或许可以接受，但设想这样一个场景：发起多个协程调用，如果第一个失败其他的也失败。
例如，网络请求传递无效参数或达到 API 速率限制。
这可能导致性能问题，因为我们会运行超出实际所需的任务，从而消耗更多资源。
<code>as_completed</code> 的另一个缺点是，由于迭代顺序不确定，很难去追踪哪个任务完成。</p>
<p>asyncio 中的 <code>wait</code> 和 <code>gather</code> 类似，其提供了这种情况下更加具体的控制方式。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/python/">Python</a></li>
      <li><a href="http://localhost:1313/tags/asyncio/">Asyncio</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/python-decorators-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/">
    <span class="title">« Prev</span>
    <br>
    <span>Python Decorators: 从入门到实战</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/sqlalchemy-database-tables/">
    <span class="title">Next »</span>
    <br>
    <span>SQLALchemy - Database Tables</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python Asyncio 04: Concurrent web requests on x"
            href="https://x.com/intent/tweet/?text=Python%20Asyncio%2004%3a%20Concurrent%20web%20requests&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-04-concurrent-web-requests%2f&amp;hashtags=Python%2cAsyncio">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python Asyncio 04: Concurrent web requests on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-04-concurrent-web-requests%2f&amp;title=Python%20Asyncio%2004%3a%20Concurrent%20web%20requests&amp;summary=Python%20Asyncio%2004%3a%20Concurrent%20web%20requests&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-04-concurrent-web-requests%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python Asyncio 04: Concurrent web requests on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-04-concurrent-web-requests%2f&title=Python%20Asyncio%2004%3a%20Concurrent%20web%20requests">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python Asyncio 04: Concurrent web requests on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-04-concurrent-web-requests%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python Asyncio 04: Concurrent web requests on whatsapp"
            href="https://api.whatsapp.com/send?text=Python%20Asyncio%2004%3a%20Concurrent%20web%20requests%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-04-concurrent-web-requests%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python Asyncio 04: Concurrent web requests on telegram"
            href="https://telegram.me/share/url?text=Python%20Asyncio%2004%3a%20Concurrent%20web%20requests&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-04-concurrent-web-requests%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python Asyncio 04: Concurrent web requests on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Python%20Asyncio%2004%3a%20Concurrent%20web%20requests&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-04-concurrent-web-requests%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">Starslayerx&#39; Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
