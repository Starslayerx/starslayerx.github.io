<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Docker - Images | Starslayerx&#39; Blog</title>
<meta name="keywords" content="Docker">
<meta name="description" content="每个 Linux 容器都基于一个镜像, 镜像重新构建运行中容器的底层定义.
要启动一个容器, 需要下载公共镜像或者创建自己的镜像.
每个镜像由一个或多个相互关联的文件系统层 layer 组成, 这些层通常与创建镜像的每个构建步骤大致一一对应.
由于镜像由独立的层构建而成, 这就对 Linux 内核提出了特殊要求: 内核必须提供 Docker 所需的驱动, 以便运行存储后端.
在镜像管理, Docker 高度依赖这个存储后端, 该后端通过与底层 Linux 文件系统通信, 用来构建并管理多个层并将它们组合成一个可用的镜像.
主要支持的后端存储有以下类型:

Overlay2
B-Tree File System
Device Mapper

每一个后端都提供一个快速的 copy-on-write (CoW) 系统用于镜像管理. 包含:

Building images
Uploading (pushing) images to an image registry
Downloading (pulling) images from an image registry
Creating and running containers from an image

Anatomy of a Dockerfile | 剖析 Dockerfile
这个文件描述了所有构建一个容器所需的步骤, 并且通常存储在项目源码的根目录里.
一个典型的 Dockerfile 看起来像下面这样, 这里是创建一个 Node.js 的应用镜像:">
<meta name="author" content="Starslayerx">
<link rel="canonical" href="http://localhost:1313/posts/docker-images/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.svg">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon.svg">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon.svg">
<link rel="mask-icon" href="http://localhost:1313/favicon.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/docker-images/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="http://localhost:1313/posts/docker-images/">
  <meta property="og:site_name" content="Starslayerx&#39; Blog">
  <meta property="og:title" content="Docker - Images">
  <meta property="og:description" content="每个 Linux 容器都基于一个镜像, 镜像重新构建运行中容器的底层定义. 要启动一个容器, 需要下载公共镜像或者创建自己的镜像. 每个镜像由一个或多个相互关联的文件系统层 layer 组成, 这些层通常与创建镜像的每个构建步骤大致一一对应.
由于镜像由独立的层构建而成, 这就对 Linux 内核提出了特殊要求: 内核必须提供 Docker 所需的驱动, 以便运行存储后端. 在镜像管理, Docker 高度依赖这个存储后端, 该后端通过与底层 Linux 文件系统通信, 用来构建并管理多个层并将它们组合成一个可用的镜像. 主要支持的后端存储有以下类型:
Overlay2 B-Tree File System Device Mapper 每一个后端都提供一个快速的 copy-on-write (CoW) 系统用于镜像管理. 包含:
Building images Uploading (pushing) images to an image registry Downloading (pulling) images from an image registry Creating and running containers from an image Anatomy of a Dockerfile | 剖析 Dockerfile 这个文件描述了所有构建一个容器所需的步骤, 并且通常存储在项目源码的根目录里.
一个典型的 Dockerfile 看起来像下面这样, 这里是创建一个 Node.js 的应用镜像:">
  <meta property="og:locale" content="en-US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-09-07T08:00:00+08:00">
    <meta property="article:modified_time" content="2025-09-07T08:00:00+08:00">
    <meta property="article:tag" content="Docker">
      <meta property="og:image" content="http://localhost:1313/images/og-default.avif">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/og-default.avif">
<meta name="twitter:title" content="Docker - Images">
<meta name="twitter:description" content="每个 Linux 容器都基于一个镜像, 镜像重新构建运行中容器的底层定义.
要启动一个容器, 需要下载公共镜像或者创建自己的镜像.
每个镜像由一个或多个相互关联的文件系统层 layer 组成, 这些层通常与创建镜像的每个构建步骤大致一一对应.
由于镜像由独立的层构建而成, 这就对 Linux 内核提出了特殊要求: 内核必须提供 Docker 所需的驱动, 以便运行存储后端.
在镜像管理, Docker 高度依赖这个存储后端, 该后端通过与底层 Linux 文件系统通信, 用来构建并管理多个层并将它们组合成一个可用的镜像.
主要支持的后端存储有以下类型:

Overlay2
B-Tree File System
Device Mapper

每一个后端都提供一个快速的 copy-on-write (CoW) 系统用于镜像管理. 包含:

Building images
Uploading (pushing) images to an image registry
Downloading (pulling) images from an image registry
Creating and running containers from an image

Anatomy of a Dockerfile | 剖析 Dockerfile
这个文件描述了所有构建一个容器所需的步骤, 并且通常存储在项目源码的根目录里.
一个典型的 Dockerfile 看起来像下面这样, 这里是创建一个 Node.js 的应用镜像:">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Docker - Images",
      "item": "http://localhost:1313/posts/docker-images/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker - Images",
  "name": "Docker - Images",
  "description": "每个 Linux 容器都基于一个镜像, 镜像重新构建运行中容器的底层定义. 要启动一个容器, 需要下载公共镜像或者创建自己的镜像. 每个镜像由一个或多个相互关联的文件系统层 layer 组成, 这些层通常与创建镜像的每个构建步骤大致一一对应.\n由于镜像由独立的层构建而成, 这就对 Linux 内核提出了特殊要求: 内核必须提供 Docker 所需的驱动, 以便运行存储后端. 在镜像管理, Docker 高度依赖这个存储后端, 该后端通过与底层 Linux 文件系统通信, 用来构建并管理多个层并将它们组合成一个可用的镜像. 主要支持的后端存储有以下类型:\nOverlay2 B-Tree File System Device Mapper 每一个后端都提供一个快速的 copy-on-write (CoW) 系统用于镜像管理. 包含:\nBuilding images Uploading (pushing) images to an image registry Downloading (pulling) images from an image registry Creating and running containers from an image Anatomy of a Dockerfile | 剖析 Dockerfile 这个文件描述了所有构建一个容器所需的步骤, 并且通常存储在项目源码的根目录里.\n一个典型的 Dockerfile 看起来像下面这样, 这里是创建一个 Node.js 的应用镜像:\n",
  "keywords": [
    "Docker"
  ],
  "articleBody": "每个 Linux 容器都基于一个镜像, 镜像重新构建运行中容器的底层定义. 要启动一个容器, 需要下载公共镜像或者创建自己的镜像. 每个镜像由一个或多个相互关联的文件系统层 layer 组成, 这些层通常与创建镜像的每个构建步骤大致一一对应.\n由于镜像由独立的层构建而成, 这就对 Linux 内核提出了特殊要求: 内核必须提供 Docker 所需的驱动, 以便运行存储后端. 在镜像管理, Docker 高度依赖这个存储后端, 该后端通过与底层 Linux 文件系统通信, 用来构建并管理多个层并将它们组合成一个可用的镜像. 主要支持的后端存储有以下类型:\nOverlay2 B-Tree File System Device Mapper 每一个后端都提供一个快速的 copy-on-write (CoW) 系统用于镜像管理. 包含:\nBuilding images Uploading (pushing) images to an image registry Downloading (pulling) images from an image registry Creating and running containers from an image Anatomy of a Dockerfile | 剖析 Dockerfile 这个文件描述了所有构建一个容器所需的步骤, 并且通常存储在项目源码的根目录里.\n一个典型的 Dockerfile 看起来像下面这样, 这里是创建一个 Node.js 的应用镜像:\nFROM node:18.13.0 ARG emali=\"anna@example.com\" LABEL \"maintainer\"=$email LABEL \"rating\"=\"Five Stars\" \"class\"=\"First Class\" USER root ENV AP=/data/app ENV SCPATH=/etc/supervisor/conf.d # The daemons RUN apt-get -y install supervisor RUN mkdir -p /var/log/supervisor # Supervisor Configuration COPY ./supervisord/conf.d/* $SCPATH/ # Application Code COPY *.js $AP/ WORKDIR $AP RUN npm install CMD [\"supervisord\", \"-n\"] Dockerfile 中的每一行都会创建一个新的镜像层并由 Docker 存储. 该层包含了该命令执行后产生的所有更改, 这意味着当构建新镜像时, Docker 只需构建与先前构建不一致的层: 那些未改变的层可以重复利用.\n虽然可以从一个普通的基础 Linux 镜像构建一个 Node 实例, 但也可以在 Docker Hub 上查找官方的 Node 镜像. 如果想要缩小到某个版本, 可以指定诸如 node:18.13.0 之类的标签, 下面这个基础镜像会提供一个在 Ubuntu Linux 上运行 Node 11.11.x 的环境:\nFROM docker.io/node:18.13.0 其中 ARG 参数可以设置变量及其默认值, 但只在镜像构建过程中可用:\nARG email=\"anna@example.com\" 为镜像和容器添加标签 label, 可以通过键值对的形式为他们附加元数据, 这些元数据之后可以用于搜索和识别 Docker 镜像与容器. 可以使用 docker image inspect 命令查看某个应用的标签. 对于 maintainer 标签, 这里使用了上一行中定义的 email 参数的值. 在构建该镜像时, 可以随时更改这个标签:\nLABEL \"maintainer\"=$email LABEL \"rating\"=\"Five stars\" \"calss\"=\"First Class\" 默认情况下, Docker 使用 root 运行所有容器中的进程, 但是可以使用 USER 命令来修改:\nUSER root CAUTION 注意\n尽管容器与底层操作系统提供了一定程度的隔离, 但他们仍运行在主机的内核之上. 由于安全风险, 在生产环境中应该总是在非特权用户的上下文中运行.\n不同于 ARG 命令, ENV 命令运行你设置 shell 变量, 用于运行中的容器应用设置:\nENV API=/data/app ENV SCPATH=/etc/supervisor/conf.d 在下面的代码中, 使用一系列 RUN 命令安装所需要的依赖, 以及创建所需的文件结构:\nRUN apt-get -y update # The daemons RUN apt-get -y install supervisor RUN mkdir -p /var/log/supervisor WARNING 警告\n虽然上面的展示中更新了容器依赖, 但一般不推荐这么做. 因为爬取最新的仓库列表不同, 在 build 的时候包的版本号不一定都相同, 导致生成的镜像不是可以重复使用的. 相反, 应该使用一个已经包含所需更新的镜像, 这样更快且可重复使用.\nCOPY 命令用于从本地文件系统复制文件到镜像中. 经常会包含应用代码和任何要求的文件.\n# Supervisor Configuration COPY ./supervisord/conf.d/* $SCPATH/ # Application Code COPY *.js* $AP/ TIP 提示\n之前说过, Dockerfile 中的每条命令都会创建一个新的 Docker image layer. 因此将多条命令结合到同一行中是合理的, 甚至可以使用 COPY 复制一个脚本, 然后使用 RUN 命令去运行这个脚本, 这样就使用两行命令实现了复杂的操作.\n通过 WORKDIR 命令, 可以修改镜像的工作目录:\nWORKDIR $AP RUN npm install CAUTION 注意\nDockerfile 中命令的顺序会对后续的构建时间产生非常显著是影响, 应该尽量将那些每次构建都会发生变化的步骤放在 Dockerfile 靠下的位置. 也就是说, 像添加代码这样的步骤应该尽量放到最后, 因为每次构件新镜像时, 从第一个发生变化的层考试, 之后的层都必须重新构建.\n最终, 可以通过 CMD 命令在容器中运行服务了\nCMT [\"supervisord\", \"-n\"] Note 注意\n虽然这不是严格要求, 但一般认为最佳实践是每个容器只运行一个进程. 这里的核心想法是, 一个容器内部应该只提供一个功能, 这样便于水平扩展. 在这个例子中, 使用 supervisord 作为一个进程管理, 从而帮助提升 node 应用的弹性, 保证容器的正常运行. 这样做对于开发其间的错误处理也很有用, 这样可以方便地重启服务, 而不是整个容器.\nBuilding an image 构建一个容器 下面通过一个例子来说明, 首先克隆这个 git 仓库\ngit clone http://github.com/spkane/docker-node-hello.git \\ --config core.autocrlf=input 上面 --config core.autocrlf=input 这个参数用于设置如何处理文本文件的结束符:\nGit 在提交代码时会将行结束符转换为 LF 但在检出代码时不会进行任何转换 之后使用命令显示所有文件\ntree -a -I .git 其中\n-a 表示 all, 显示所有文件. -I .git 表示 Ignore, 忽略 .git 模式的文件或目录 得到如下目录结构\n. ├── .dockerignore ├── .gitignore ├── Dockerfile ├── index.js ├── package.json └── supervisord └── conf.d ├── node.conf └── supervisord.conf .dockerignore 文件定义不想上传到 docker 镜像中的文件或目录, 文件中写了 .git, 这会指示 docker 在 build 的时候, 排除 .git 目录. packages.json 定义了 Node.js 应用并列出了它所依赖的包 index.js 是应用程序的主源代码 supervisord 目录包含用于启动和监控该应用的 supervisord 配置文件 下面运行构建命令\ndocker image build -t example/docker-node-hello:latest . 为了提升构建速度, docker 在认为安全的时候会使用本地缓存. 但有时一些底层的修改, 并不会被检测到. 当看到 ⇒ CACHED [2/8] RUN apt-get -y update 这样的内容, 就说明 docker 在使用缓存. 可以使用 --no-cache 命令禁止使用缓存构建.\nRunning Your Image 运行镜像 一但成功构建镜像, 就可以使用如下命令运行镜像\ndocker container run --rm -d -p 8080:8080 example/docker-node-hello:latest 其中\n--rm: 是使容器退出时自动删除, 避免系统中堆集大量已停止的容器, 适用测试或临时运行容器 -d: detached 模式, 让容器在后台运行 -p 8080:8080: 端口映射 主机端口:容器端口, 这里并不依赖 Dockerfile 里面的 EXPOSE 命令 如果一切正常, Node.js 应用程序就会在宿主机上的容器中运行. 可以通过执行 docker container ls 来检测容器是否在运行.\n通过可以通过以下方式确定 Docker 主机的 IP 地址:\n查看 docker context list 命令输出中带有星号 * 标记的条目 或者检查环境变量 DOCKER_HOST 的值 如果 Docker 端点设置为 Unix socket, 那么 IP 地址就通常是 127.0.0.1\nNAME DESCRIPTION DOCKER ENDPOINT ERROR default Current DOCKER_HOST based configuration unix:///var/run/docker.sock desktop-linux * Docker Desktop unix:///Users/starslayerx/.docker/run/docker.sock 之后访问 http://127.0.0.1:8080 就可以访问服务, 看到以下内容\nHello World. Wish you were here. Build Arguments 构建参数 如果 inspect 检查刚刚构建的镜像, 可以看到 maintainer 的 label 是 anna@example.com:\ndocker image inspect \\ example/docker-node-hello:latest | grep maintainer 如果想要修改 maintainer 这个标签, 可以简单的运行 build 命令, 并使用 --build-arg 参数附带一个新的 email RAG, 例如这样:\ndocker image build --build-arg email=me@example.com \\ -t example/docker-node-hello:latest . 构建完成后可以再次 inspect 会发现 maintainer 的 label 就被修改了\nEnvironment Variables as Configuration 环境变量作为设置 阅读 index.js 文件, 可以看到涉及到了 $WHO 变量, 这里根据环境变量决定 Hello 后面跟什么:\nlet DEFAULT_WHO = \"World\"; let WHO = process.env.WHO || DEFAULT_WHO app.get('/', function(req, res) { res.send('Hello' + WHO + '.Wish you were here.\\n'); }); Note 注意\n可以通过 Go template 来格式化 docker container ls 的输出只感兴趣的部分. 例如 docker container ls --format \"table {{.ID}}\\t{{.Image}}\\t{{.Status}}\". 此外, 还可以使用 docker container ls --quiet 不带 format options 将会限制只输出容器 ID.\n然后, 使用之前输出得到的 container ID 可以停止运行容器:\ndocker container stop bc26bfd2b4a8 TIP 提示\n使用 docker container ls 命令和使用 docker ps 命令在功能上是相同的.\n可以通过 --env 参数重启容器来添加环境变量\ndocker container run --rm -d \\ --publish model=ingress,published=8080,target=8080 \\ --env WHO=\"Sean and Karl\" \\ example/docker-node-hello:latest 这时候刷新浏览器, 应该能够看到这样的内容\nHello Sean and Karl. Wish you were here. Note 注意\n可以这样缩短上面命令\ndocker container run --rm -d -p 8080:8080 \\ -e WHO=\"Sean and Karl\" \\ example/docker-node-hello:latest Custom Base Images 自定义基础镜像 基础镜像经常基于常见 Linux 发行版的 minimal installs, 例如 Ubuntu, Fedora, Alpine Linux. 对于大多数人而言, 使用 Linux 发行版官方基础镜像是一个很好的选择.\n但是, 有时会需要构建自己的基础镜像, 而不是使用现成的. 一个原因就是为了在所有的硬件, 虚拟机, 容器部署保持一样的镜像. 另一个原因是为了降低镜像的大小. 完全没有必要使用完整的 Ubuntu 发行版, 例如 C 或 Go 应用. 你可能会发现, 你只需要一些常用的工具进行调试, 以及其他一些 shell 命令.\n另一种位于中间的方法是使用 Alpine Linux, 该发行版很小, 作为基础镜像十分流行. 为了保持小型化, Alpine Linux 基于现代的轻量库 musl standard library 而不是传统的 GNU C Library (glibc). 由于镜像极小, Alpine Linux 内默认使用 /bin/sh 而不是 /bin/bash. 但如果需要, 也可以自己安装 glibc 和 bash, 这经常在 JVM 容器中发生.\nStoring Images 存储镜像 当构建完镜像后, 往往需要存储该镜像, 以便未来的部署. 一般不会在生产环境服务器上面去构建, 然后运行镜像, 而是从某个地方拉取已经构建好的镜像.\nPublic Registries 公共仓库 Docker 提供一个镜像仓库给社区的共享镜像. 包括官方 Linux 发行版镜像, WordPress 镜像之类.\n如果你要发布一个镜像到互联网上, 最好的仓库是 Docker Hub. 但也有其他一些选择, 例如 Docker 刚刚流行起来, Docker Hub 还不存在时, 为了填补社区的需要, Quay.io 被创建了. 在那之后, Quay.io 被收购了好几次, 现在属于 RedHat. 像 Google, Github 和 SaaS 公司都有他们自己的仓库.\n对于大量使用 Docker 的公司来说, 这些集中化仓库最大的缺点之一就是他们并不在应用部署所在的网络中. 这意味着应用部署时, 每一层镜像都可能需要跨跃整个互联网来传输. 网络延迟会对软件部署产生非常真实的影响, 而这些镜像一但出故障, 就可能严重影响公司按时完成部署. 这个问题可以通过良好的镜像设计来缓解, 例如将镜像分割成精简的层, 以便更容易在互联网上传输.\nPrivate Registries 私有仓库 另一种很多公司采用的方法, 是在内容网络部署 Docker 镜像. 开源的 Distribution 项目提供了基础的功能. 其他私有仓库的竞争者包括 Harbor 和 Red Hat Quay, 他们除了基础功能, 还提供了一套 GUI 界面和其他功能, 例如镜像校验.\nAuthenticating to a Registry 仓库认证 Docker 默认使用 Docker Hub 作为镜像仓库.\nCreating a Docker Hub acount 创建一个 Docker Hub 帐号\n如果只是拉取镜像, 不需要登陆帐号. 但如果要避免限速, 以及上传构建的容器就需要登陆.\n创建帐号后, 可以向 public registry 上传镜像. 在 Account Settings 选项下面有一个 Default Privacy 选项, 可以将可见性修改有私有. WARNING 警告\n为了更好的安全性, 应该使用 access token 登陆 Docker Hub.\nLogging in to a registry 登陆注册中心\n使用下面命令登陆 Docker Hub\ndocker login 当成功登陆后, Docker 会在家目录下面创建一个 dotfile 来缓存信息.\n% cat ${HOME}/.docker/config.json ─────┬───────────────────────────────────────────── │ File: /Users/starslayerx/.docker/config.json ─────┼───────────────────────────────────────────── 1 │ { 2 │ \"auths\": { 3 │ \"https://index.docker.io/v1/\": {} 4 │ }, 5 │ \"credsStore\": \"desktop\", 6 │ \"currentContext\": \"desktop-linux\", 7 │ \"plugins\": { 8 │ \"debug\": { 9 │ \"hooks\": \"exec\" 10 │ }, 11 │ \"scout\": { 12 │ \"hooks\": \"pull,buildx build\" 13 │ } 14 │ }, 15 │ \"features\": { 16 │ \"hooks\": \"true\" 17 │ } 18 │ } ─────┴───────────────────────────────────────────── 可以看到, 该文件以 JSON 格式存储了用户的凭据, 该配置文件支持存储多个镜像仓库的凭据. 从现在起, 当镜像仓库需要身份验证时, Docker 会自动查询该文件, 检查是否存储了主机对应的凭据. 若存在, Docker 将会自动提交这些凭据. 值得注意的是, 这里缺失了\"时间戳\", 这些凭据会永久缓存, 除非主动清楚他们.\n与登录操作类似, 若不再需要缓存某镜像仓库的凭据, 也可以执行注销操作:\ndocker logout 如果要登陆其他非 Docker Hub 的仓库, 需要提供 hostname:\ndocker login someregistry.example.com 这样将会为 ${HOME}/.docker/config.json 文件添加该仓库信息\nPushing images into a repository 推送镜像到仓库\n推送镜像的第一步要确保已经登陆到了 Docker 仓库.\n一但登陆进去, 就可以上传镜像了. 早期使用 docker image build -t example/docker-node-hello:latest . 命令构建镜像, 但实际上 Docker client 将 example/docker-node-hello:latest 视为 docker.io/example/docker-node-hello:latest. 这里 docker.io 表示 registry 名称, 而 example/docker-node-hello 是 registry 里面的 repository, 包含了各种镜像.\n可以使用下面命令来方便的给镜像打标签, 使用你的 Docker Hub 用户名称替换 ${}\ndocker image tag example/docker-node-hello:latest \\ docker.io/${}/docker-node-hello:latest 如果要使用新的命名重新构建镜像, 通过下面命令完成 (-t 参数为镜像打标签)\ndocker image build -t docker.io/${}/docker-node-hello:latest . 第一次构建的时候会花一些时间, 但如果是重新构建, 会非常块. 因为大多数层都已经存在 Docker server 里面了.\n接下来可以使用下面命令推送镜像:\ndocker image push ${}/docker-node-hello:latest Exploring images in Docker Hub\n除了简单的流览 Docker Hub 网络流览镜像, 还可以使用 docker 搜索命令来查找镜像\ndocker search node NAME DESCRIPTION STARS OFFICIAL node Node.js is a JavaScript-based platform for s… 13999 [OK] cimg/node The CircleCI Node.js Docker Convenience Imag… 25 circleci/node Node.js is a JavaScript-based platform for s… 135 bitnami/node Bitnami container image for NodeJS 83 kindest/node https://sigs.k8s.io/kind node image 114 okteto/node 2 eclipse/node Node 0.12.9 1 chainguard/node Build, ship and run secure software with Cha… 0 sitespeedio/node Node base template 3 corpusops/node https://github.com/corpusops/docker-images/ 0 rootpublic/node 0 ubuntu/node Ubuntu-based Node.js image for server-side a… 2 setupphp/node Docker images to run setup-php GitHub Action 0 joxit/node Slim node docker with some utils for dev 1 treehouses/node 2 activestate/node ActiveState's customizable, low-to-no vulner… 12 alpine/node 5 vmware/node Node.js base built on top of Photon OS 0 wayofdev/node 0 vulhub/node 0 systemsdk/node Docker environment with node 16 for Laravel/… 0 openizr/node Safer, non-root, nodeJS environment 0 openeuler/node 0 presearch/node Run a search node in Presearch's decentraliz… 25 iron/node Tiny Node image 28 右侧的 OFFICIAL 表明该镜像是官方认证的镜像.\n这意味着该镜像往往是由该应用开发的公司或者社区维护.\nAUTOMATED 代表该镜像是通过 CI/CD 触发, 自动构建的.\nRunning a Private Registry 运行一个私有的注册中心\n建立一个基础的 registry 并不难, 但对于生产环境中使用, 应该花时间去了解一下可用的配置选项 the open source Docker Registry (Distribution). 下面使用 SSL 和 HTTP 认证构建一个简单的 registry.\n首先克隆一个 Git 仓库:\ngit clone https://github.com/spkane/basic-registry --config core.autocrlf=input 查看仓库文件\nls basic-registry config.yaml config.yml.sample Dockerfile htpasswd.sample README.md registry.crt.sample registry.key.sample 这个 Dockerfile 只是简单的将 Docker Hub 的上游镜像和一些本地配置写入新的镜像.\n作为测试, 可以使用示例文件, 但不要在生产中使用.\n如果在本地直接复制文件即可\ncp config.yaml.sample config.yaml cp registry.key.sample registry.key cp registry.crt.sample registry.crt cp htpasswd.sample htpasswd 如果 Docker server 在远程服务器, 则需要修改一下 config.yaml 文件, 将 ip 地址修改为服务器地址, 例如这样:\nhttp: host: https://172.17.41.10:5000 然后需要为 registry 的 IP 创建一个 SSL keypair, 一种方法是使用 OpenSSL 命令\nopenssl req -x509 -nodes -sha256 -newkey ras:4096 \\ -keyout registry.key -out registry.crt \\ -days 14 -subj '{/CN=172.17.42.10}' 最后复制 htpasswd.sample 文件内容到 htpasswd, 或者也可以使用下面命令来自定义用户名 和密码 docker container run --rm --entrypoint htpasswd g \\ -Bbn ${} ${} \u003e htpasswd 如果一切正确, 就应该能够构建和运行 registry 了 (mac 的 5000 端口可能会被控制中心占用, 这里使用 5001 端口)\ndocker image build -t my-registry . docker container run --rm -d -p 5001:5000 --name registry my-registry docker container logs registry Testing the private registry 测试私有注册中心 运行后首先登陆该 registry\n% docker login 127.0.0.1:5001 Username: myuser Password: Login Succeeded WARNING 警告\n这个 registry 容器内置了一个 SSL 密钥, 且没有使用任何外部存储. 也就是说, 其内部包含一个密钥, 而且当删除正在运行的容器时, 内部存储的镜像也会被删除.\n在生产环境中, 需要让容器从密钥管理系统中获取密钥, 并且使用某种冗余的外部存储. 如果希望在开发环境中, 不同容器之间保留 registry 镜像, 可以在运行 docker 容器时加上类似参数:\n--mount type=bind, source=/tmp/registry-data, target=/var/lib/registry 这里是将宿主机的 /tmp/registry-data 目录映射到容器里的 /var/lib/registry, 这样镜像就会存储到宿主机, 即使容器被删除也不会丢失\n现在来测试能否在本地私有 registry 上传镜像\n% docker image tag my-registry 127.0.0.1:5001/my-registry % docker image push 127.0.0.1:5001/my-registry Using default tag: latest The push refers to repository [127.0.0.1:5001/my-registry] aa2afd4dffb6: Pushed f4596b202dbb: Pushed e971abc09286: Pushed 63c05075324e: Pushed 19c15db2ec23: Pushed 7ad8ac1e6be1: Pushed 97599ee5c821: Pushed 014ffb8901a5: Pushed 171a26c7bc56: Pushed latest: digest: sha256:445f229035a87428b9e9dd1f816a29f7aaf8f8eabab220942d1aeae545e3f2f1 size: 2193 现在就可以 pull 同样的镜像了\n% docker image pull 127.0.0.1:5001/my-registry Using default tag: latest latest: Pulling from my-registry Digest: sha256:445f229035a87428b9e9dd1f816a29f7aaf8f8eabab220942d1aeae545e3f2f1 Status: Image is up to date for 127.0.0.1:5001/my-registry:latest 127.0.0.1:5001/my-registry:latest 可以使用下面命令停止该容器\ndocker container stop registry TIP 提示\n当熟悉 Docker Distribution 后可能考虑流览 Cloud Native Computing Foundation (CNCF) 叫做 Harbor 的项目, 该项目比 Docker Distribution 更加安全可靠.\nOptimizing Images 镜像优化 这一章介绍一些镜像优化技巧, 减少内存使用并提升构建速度\nKeeping Images Small 保持小镜像 从互联网下载 1G 的文件是人们经常担心的问题, 尤其是要部署 100+ 的结点, 且每天要多次部署新发行版的时候. 下载这些大文件很容易造成网络堵塞 network congestion, 并且部署速度慢会对产品有实在的影响.\n为了方便, 大量的 Linux 容器会继承一个最小化的 Linux 发行版的基础镜像. 虽然这样很方便上手, 但并不是必须的. 容器只需要包含在宿主机内核上运行应用所需的文件, 除此之外什么都不要.\nGo 是一门编译语言, 可以很方便地生成静态编译的二进制文件. 作为示例, 这里使用一个 Go 编写的 Web 应用, 该应用可以在 Github 上找到. 运行下面命令, 然后在浏览器打开\ndocker container run --rm -d -p 8080:8080 spkane/scratch-helloworld 一般情况下可能认为容器内会有项目文件, 但实际上并不是这样, 使用下面类似命令将容器打包\ndocker container export 19931dd0fc21 -o web-app.tar 再使用 tar 命令, 检查容器内容\ntar -tvf web-app.tar 首先注意到, 该容器内几乎没有什么文件, 且大部分都是 0 字节. 这些大小为 0 的文件, 在每个 Linux 文件中都存在, 他们在容器第一次创建时, 会自动从宿主机绑定挂载 bind-mount 进来. 除了 .dockerenv 之外, 这些文件都是内核正常运行所必须的文件. 在这个容器中, 唯一真正有实际大小的, 与应用相关的文件就静态编译好的 helloworld 二进制程序.\n从这个实验中可以知道:\n容器只需要包含运行在底层内核之上的最小文件集和, 其他的一切都是不必要的. 不过, 在很多情况下, 为了方便排查问题, 会希望容器内有一个可用的 shell, 因此很多人会折中一下, 选择一个轻量级的 Linux 发行版来构建镜像.\nTIP 提示\n如果需要经常查看镜像文件, 可以尝试一下这个工具 dive, 其提供了一个 CLI 接口便捷地查看镜像内容.\n尽管可以使用 docker container run -ti alpine:latest /bin/sh 查看 apline image, 但对于 spkane/scratch-helloworld 这个镜像不行, 因为这个容器中不含 bash 或者 SSH. 这之前是用 docker container export 命令生成了一个 .tar 文件, 其中包含容器内所有文件的副本, 但本次将直接连接到 Docker 服务器并查看容器自身的 文件系统来检查它. 要做到这一点, 需要找出文件在服务器磁盘上的存放位置, 可以使用下面命令获取:\ndocker image inspect : 下面使用这个例子来演示\ndocker container run --rm -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh alpine 是一个非常小的基础镜像, 只有 4.5 MB, 非常适合在其之上构建容器.\n然而, 可以看到, 即使在还没有基于它构建任何东西之前, 这个容器里仍然包含了不少内容.\n接下来, 让查看 spkane/scratch-helloworld 镜像中的文件. 这种情况下, 查看 docker image inspect 输出中 LowerDir 项的第一个目录, 注意到它第一个名为 diff 的目录名称:\n# ls -lFh /var/lib/docker/overlay2/37…4d/diff total 3520 -rwxr-xr-x 1 root root 3.4M Jul 2 2014 helloworld* # exit 这个目录里只有一个文件, 大小为 3.4 MB, 这个 helloworld 二进制文件是容器中唯一包含的文件, 而且它比 alpine 镜像在添加任何应用文件之前的初始大小还要小.\nNote 注意\n在 Docker 服务上, 可以直接从该目录运行 helloworld 应用程序, 因为它不依赖任何文件, 除了在开发环境里, 绝不应该怎么做. 这样做能够直观地说明, 这对静态编译应用程序有多么实用.\nMultistage Builds 多阶段构建 在很多情况下, 可以通过多阶段构建 (multistage builds) 将容器限制得更小. 这也是构建大多数生产环境容器的推荐方式. 你不必担心构建引入额外资源, 同时你仍然可以运行一个 精简的(lean)生产容器. 多阶段容器还鼓励在 Docker 内部完成构建, 这是实现构建系统可重复性的一种极佳模式.\n正如 [scratch-helloworld] 应用的原作者写的那样, Docker 本身引入对多阶段构建的支持, 使得创建小型容器的过程比过去容易的多.\n在过去, 要实现在多阶段构建, 必须先构建一个镜像来编译代码, 然后提取生成的二进制文件, 再构建第二个不包含构建依赖的镜像, 并把那个二进制文件注入进入. 这种方式往往很难配置, 并且在标准化的部署流水线中也不总是能开箱即用.\n而如今, 只需要一个像下面这样简单的 Dockerfile 就能达到类似的效果\n# Build Container FROM docker.io/golang:apline as builder RUN apk update \u0026\u0026 \\ apk add git \u0026\u0026 \\ CGO_ENABLED=0 go install -a -ldflags '-' \\ github.com/spkane/scratch-helloworld@latest # Production Container FROM scratch COPY --from=builder /go/bin/scratch-helloworld/helloworld EXPOSE 8080 CMD [\"/helloworld\"] 首先注意到, 这个 Dockerfile 看上去像是两个 Dockerfile 拼接起来的. 确实是这样, 但不止如此. 第一条 FROM 命令在构建阶段将变量命名为 builder. 之后的 FROM 语句使用 scratch 这个特殊的特殊的镜像名, 叫做 scratch, 告诉 Docker 从空镜像开始构建, 这将不会包含额外的文件. 下一行 COPY --from=builder /go/bin/scratch-helloworld /helloworld 将 builder 镜像的二进制文件直接复制到当前镜像中.\nEXPOST 8080 这行是为了告诉用户这个服务使用的端口 ports 和协议 protocols.\n这里可以添加更多阶段, 实际上, 多阶段构建之间并非必须要有联系, 他们会按顺序构建. 可以一个阶段构建 Go web API 服务的镜像, 另一个阶段构建 Angular web UI 的镜像. 最后阶段将两个镜像输出结合起来.\nTIP 提示\n当构建更加复杂的镜像时, 可能会发现构建单个上下文很有挑战性. 这个 docker-buildx 插件能够支持多上下文构建, 可以用来支持一些进阶的工作流. (build context 构建上下文是 docker build 时指定的目录内容, Docker 在构建镜像时, 会先把这个目录的文件打包上传给 Docker 引擎, 作为上下文, 之后 Dockerfile 里的指令就只能访问这个 build context 内的文件)\nLayers Are Additive 层具有叠加性 只有深入探究镜像的构建原理, 才会发现一个不显而易见的事实: 组成镜像的文件系统图层在设计上严格遵循叠加原则. 虽然可以通过覆盖/屏蔽先前图层中的文件, 但无法真正删除这些文件. 这意味着无法通过简单删除前期步骤生成的文件来缩小镜像体积.\nNote 注意\n若在 Docker 中启用试验性功能, 可以通过 docker image build --squash 命令将多个层压缩为单一层. 这将使所有在中间层被删除的文件最终从镜像中彻底消失, 从而有效回收被浪费的存储空间. 但问题是这样即使只更新了一行源码, 整个层都需要重新下载.\n可以使用 docker image history 命令查看镜像构建阶段的文件层信息, 例如下面这样:\n% docker image history ... IMAGE CREATED CREATED BY SIZE 543d61c95677 About a minute ago CMD [\"/usr/sbin/httpd\" \"-DFOREGROU…\"] 0B About a minute ago RUN /bin/sh -c dnf install -y httpd … 273MB 6 weeks ago /bin/sh -c #(nop) CMD [\"/bin/bash\"]… 0B 6 weeks ago /bin/sh -c #(nop) ADD file:58865512c… 163MB 3 months ago /bin/sh -c #(nop) ENV DISTTAG=f36co… 0B 15 months ago /bin/sh -c #(nop) LABEL maintainer=… 0B 上面有 3 层没有添加额外的大小, 有两层添加了很多 MB, 对于 ADD 那条命令可以理解, 是添加原始的镜像, 但 RUN 这条命令就比较奇怪了, 为什么添加一个 Apache web server 会占用这么多空间?\n需要理解的核心要点是, 镜像层本质上严格遵守叠加原则. 图层一但建立, 内容就无法移除. 这意味着, 无法通过在后继图层中删除文件来缩限先前图层的体积. 当在后续图层中编辑或删除文件时, 实际上知识在新图层中用修改或删除标记覆盖了旧版本. 因此, 缩小图层体积的唯一方法是在保存图层前移除文件.\n最长将的处理方式是在 Dockerfile 的单行命令中串连多个命令, 通过使用 \u0026\u0026 运算符可以轻松的实现, 该运算符作为布尔 AND 语句使用, 基本上等于\"如果前一个命令执行成功，就执行这个命令\". 此外, 还可以利用 \\ 运算符在命令换行后继续, 这能够提升长命令的可读性.\n掌握这些后可以重写 Dockerfile:\nFROM docker.io/fedora RUN dnf install -y httpd \u0026\u0026 \\ dnf clean all CMD [\"/usr/sbin/httpd\", \"-DFOREGROUND\"] 现在可以重写构建镜像, 再查看大小会发现从 273 MB 缩减到了 44.8 MB. 这是非常大的空间提升, 尤其是当有多个服务器拉取镜像的时候.\nUtilizing the Layer Cache 最后一个要介绍的构建技巧, 是关于如何让构建速度尽可能的块. DevOps 的重要目标之一就是如何保持反馈循环尽量的紧密. 这意味着尽快使问题被发现很重要, 这样开发者就可以专注于问题代码, 而不是等待已经去做其他不相关的任务了.\n在标准构建过程中, Docker 会使用层缓存机制, 尽可能避免重建已经构建且未包含明确变更的层. 由于这个机制, 在Dockerfile 中安排操作指令的顺序会显著影响构建过程的耗时.\n对于需要根据代码安装依赖的项目, 例如 npm, bundle, 可以研究一下如何优化 Docker 在这些平台的构建. 这通常包括锁定依赖版本和存储代码, 这样就无需每次 build 的时候都下载依赖.\nDirectory Caching 目录缓存 BuildKit 增加到镜像构建的一个特性是目录缓存. 目录缓存是一个非常有用的, 能够加速构建速度的工具, 且不保留运行时非必要的文件到镜像中. 其核心原理是, 允许将镜像内某个目录的内容保存在特殊层中, 该层在构建时可通过绑定挂载方式使用, 并在生成镜像快照前解除挂载. 此功能常用于处理 Linux 包管理器 (apt/apk/dnf 等) 和语言依赖处理器 (npm/bundler/pip 等) 存放数据库及归档文件的目录.\nTIP 提示\nbind mount 绑定挂载是指将宿主机上的一个现有文件或目录直接\"映射\"到容器内部的一个路径上. 这是一个非常简单的共享方式. 有以下特点:\n直接访问宿主及文件系统 高性能, 绕过了 Docker 的存储驱动, 直接使用宿主机的文件系统, I/O 性能高 依赖宿主机系统, 需要一个宿主机上的绝对路径, 可移植性差 为了支持目录缓存必须开启 BuildKit (较新版本一般都默认开启). 可以使用环境变量在客户端强制使用 DOCKER_BUILDKIT=1\n无缓存 % time docker build --no-cache -t docker.io/spkane/open-mastermind:latest . [+] Building 49.9s (12/12) FINISHED docker:desktop-linux =\u003e [internal] load build definition from Dockerfile 0.0s =\u003e =\u003e transferring dockerfile: 209B 0.0s =\u003e [internal] load metadata for docker.io/library/python:3.9.15-slim-bullseye 4.4s =\u003e [auth] library/python:pull token for registry-1.docker.io 0.0s =\u003e [internal] load .dockerignore 0.0s =\u003e =\u003e transferring context: 2B 0.0s =\u003e [1/6] FROM docker.io/library/python:3.9.15-slim-bullseye@sha256:ffc6cb648d6993e7c90abb95c2481eb688a6842dfac29bf19e3755454632d 17.6s =\u003e =\u003e resolve docker.io/library/python:3.9.15-slim-bullseye@sha256:ffc6cb648d6993e7c90abb95c2481eb688a6842dfac29bf19e3755454632da 0.0s =\u003e =\u003e sha256:662193c72f528eec2405a0519d470f5ba9091b8f430b22a3b49c55a8447af08a 1.37kB / 1.37kB 0.0s =\u003e =\u003e sha256:34a0c56576530bce4b6eb782044f19c72533a5ae02b2b8df527164f3a3eb0f5b 7.50kB / 7.50kB 0.0s =\u003e =\u003e sha256:6064e7e5b6afa4dc711228eddfd250aebac271830dc184c400ce640020bc2cb0 30.06MB / 30.06MB 16.1s =\u003e =\u003e sha256:23e07e2954939698377b8fe1a859b2d8d0ed4999c7a6da4c983084d50ca4dbe3 1.07MB / 1.07MB 6.4s =\u003e =\u003e sha256:b151283f362b5371164a098a8d4d6d6fdac38a5b1dbd8a89b05e200df14e32c3 11.59MB / 11.59MB 15.9s =\u003e =\u003e sha256:ffc6cb648d6993e7c90abb95c2481eb688a6842dfac29bf19e3755454632daa2 1.86kB / 1.86kB 0.0s =\u003e =\u003e sha256:bc8cbd54c67de1e886c60718641e2ca3d998c39507cf1912dfa7174999ab8497 234B / 234B 7.2s =\u003e =\u003e sha256:41d4a1e4080eccd6dce7443cfcf0bd3555cd73e8a962fd672e4a786434739775 3.18MB / 3.18MB 14.2s =\u003e =\u003e extracting sha256:6064e7e5b6afa4dc711228eddfd250aebac271830dc184c400ce640020bc2cb0 0.9s =\u003e =\u003e extracting sha256:23e07e2954939698377b8fe1a859b2d8d0ed4999c7a6da4c983084d50ca4dbe3 0.1s =\u003e =\u003e extracting sha256:b151283f362b5371164a098a8d4d6d6fdac38a5b1dbd8a89b05e200df14e32c3 0.3s =\u003e =\u003e extracting sha256:bc8cbd54c67de1e886c60718641e2ca3d998c39507cf1912dfa7174999ab8497 0.0s =\u003e =\u003e extracting sha256:41d4a1e4080eccd6dce7443cfcf0bd3555cd73e8a962fd672e4a786434739775 0.2s =\u003e [internal] load build context 0.0s =\u003e =\u003e transferring context: 69.19kB 0.0s =\u003e [2/6] RUN mkdir /app 0.4s =\u003e [3/6] WORKDIR /app 0.0s =\u003e [4/6] COPY . /app 0.0s =\u003e [5/6] RUN pip install -r requirements.txt 26.9s =\u003e [6/6] WORKDIR /app/mastermind 0.0s =\u003e exporting to image 0.5s =\u003e =\u003e exporting layers 0.5s =\u003e =\u003e writing image sha256:d1c84698c57b65e2d4e646c179ad47a15bad22386c6468b3c5c73d88be065dd9 0.0s =\u003e =\u003e naming to docker.io/spkane/open-mastermind:latest 0.0s View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/clviefrt28zp2uvhc9utddc09 What's next: View a summary of image vulnerabilities and recommendations → docker scout quickview docker build --no-cache -t docker.io/spkane/open-mastermind:latest . 0.52s user 0.41s system 1% cpu 50.602 total 有缓存 % time docker build -t docker.io/spkane/open-mastermind:latest . [+] Building 1.1s (11/11) FINISHED docker:desktop-linux =\u003e [internal] load build definition from Dockerfile 0.0s =\u003e =\u003e transferring dockerfile: 209B 0.0s =\u003e [internal] load metadata for docker.io/library/python:3.9.15-slim-bullseye 1.1s =\u003e [internal] load .dockerignore 0.0s =\u003e =\u003e transferring context: 2B 0.0s =\u003e [1/6] FROM docker.io/library/python:3.9.15-slim-bullseye@sha256:ffc6cb648d6993e7c90abb95c2481eb688a6842dfac29bf19e3755454632da 0.0s =\u003e [internal] load build context 0.0s =\u003e =\u003e transferring context: 2.46kB 0.0s =\u003e CACHED [2/6] RUN mkdir /app 0.0s =\u003e CACHED [3/6] WORKDIR /app 0.0s =\u003e CACHED [4/6] COPY . /app 0.0s =\u003e CACHED [5/6] RUN pip install -r requirements.txt 0.0s =\u003e CACHED [6/6] WORKDIR /app/mastermind 0.0s =\u003e exporting to image 0.0s =\u003e =\u003e exporting layers 0.0s =\u003e =\u003e writing image sha256:d1c84698c57b65e2d4e646c179ad47a15bad22386c6468b3c5c73d88be065dd9 0.0s =\u003e =\u003e naming to docker.io/spkane/open-mastermind:latest 0.0s View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/fum8hqxpzp4ezege0qoxrd0q3 What's next: View a summary of image vulnerabilities and recommendations → docker scout quickview docker build -t docker.io/spkane/open-mastermind:latest . 0.25s user 0.53s system 24% cpu 3.223 total 从上面可以看出, 无缓存使用了 50.6 秒, 有缓存使用了 3.2 秒.\n下面将 Docker 修改成这样\n# syntax=docker/dockerfile:1 FROM python:3.9.15-slim-bullseye RUN mkdir /app WORKDIR /app COPY . /app RUN --mount=type=cache,target=/root/.cache pip install -r requirements.txt WORKDIR /app/mastermind CMD [\"python\", \"mastermind.py\"] 这里有两个修改:\n#syntax=docker/dockerfile:1 这个告诉 Docker 使用新版的 Dockerfile frontend, 这个版本提供了对 BuildKit 的新功能. RUN --mount=type=cache,target=/root/.cache pip install -r requirements.txt 这一行告诉 BuildKit 在构建期间, 将缓存层挂载到容器的 /root/.cache 目录. 这样既能让最终生成的镜像不包含该目录内容, 又能在后续构建时重新挂载缓存供 pip 使用. 现在基于这些改动, 完整重新镜像, 生成初始缓存目录内容. 观察构建输出会发现, pip 仍会像之前一样下载所有依赖包:\ntime docker bulid --no-cache -t docker.io/spkane/oper-mastermind:latest 所以, 现在重新打开 requirements.txt 文件并添加一行 py-events\ncolorama pandas flask log symbols py-events 改动之后, 重新构建镜像, 会发现仅下载 py-events 以其依赖项, 其余包都直接用之前构建的缓存, 这些缓存已在构建过程中挂载至镜像.\n由于无需每次重新下载所有依赖, 构建时间得以缩短. 尽管镜像中添加了新依赖, 但镜像体积反而减小了, 这是因为缓存目录不再直接存储在应用镜像中.\nTroubleshooting Borken Builds 在真实世界中, 构建并非总会成功, 下面讨论构建失败时可以做的处理. 会展示两种选择, 一种是使用 pre-BuildKit 的方式, 另一种是通过 BuildKit 的方式.\ngit clone https://github.com/spkane/docker-node-hello.git --config core.autocrlf=input cd docker-node-hello Debugging Pre-BuildKit Images 下面需要一个\"问题样本\", 故意制造一个构建失败的情况, 编辑 Dockerfile 为这样\nRUN apt-get -y update-all 运行 build 命令可以看到下面错误结果:\nStep 6/14 : ENV SCPATH /etc/supervisor/conf.d ---\u003e Running in e903367eaeb8 Removing intermediate container e903367eaeb8 ---\u003e 2a236efc3f06 可以直接进入中间镜像调试\ndocker container run --rm -ti 2a236efc3f06 /bin/bash Debugging BuildKit Images 当使用 BuildKit 时, 需要采用略有不同的方法来定位构建失败的位置, 因为这种模式下不会将任何中间构建层导出到 Docker daemon.\n先将 Dockerfile 恢复, 然后做下面这样的修改:\nRUN npm install 将其改为\nRUN npm installer 然后尝试构建容器\ndocker image build -t example/docker-node-hello:debug --no-cache . 可以看到下面的报错, 但是要如何进入该层调试呢?\n% docker image build -t example/docker-node-hello:debug --no-cache . [+] Building 75.6s (13/13) FINISHED docker:desktop-linux =\u003e [internal] load build definition from Dockerfile 0.0s =\u003e =\u003e transferring dockerfile: 571B 0.0s =\u003e [internal] load metadata for docker.io/library/node:18.13.0 4.3s =\u003e [auth] library/node:pull token for registry-1.docker.io 0.0s =\u003e [internal] load .dockerignore 0.0s =\u003e =\u003e transferring context: 45B 0.0s =\u003e [1/8] FROM docker.io/library/node:18.13.0@sha256:d871edd5b68105ebcbfcde3fe8c79d24cbdbb30430d9bd6251c57c56c7bd7646 59.3s =\u003e =\u003e resolve docker.io/library/node:18.13.0@sha256:d871edd5b68105ebcbfcde3fe8c79d24cbdbb30430d9bd6251c57c56c7bd7646 0.0s =\u003e =\u003e sha256:59f7398d1dba68c2134d2e01668369079ff301c360bfa587fd574de4e2e5eac4 2.21kB / 2.21kB 0.0s =\u003e =\u003e sha256:b0cef62e090109630d42120f3ccde32e9813a8d1309fa6be2ae7131e355d75e1 7.53kB / 7.53kB 0.0s =\u003e =\u003e sha256:7b716680367d1dac0e54c48f75506323e0bb03628542a0fd6db39efeeee9adf5 5.15MB / 5.15MB 10.2s =\u003e =\u003e sha256:c345c9e441f5f49235768af74b8ab37743652d38958afaa000edd56d7b2f0540 53.68MB / 53.68MB 12.0s =\u003e =\u003e sha256:0855378f8903bde22cfbcee08cd239678716cf01f24a3fca9478ef4121a84d91 10.87MB / 10.87MB 19.8s =\u003e =\u003e sha256:d871edd5b68105ebcbfcde3fe8c79d24cbdbb30430d9bd6251c57c56c7bd7646 1.21kB / 1.21kB 0.0s =\u003e =\u003e sha256:4bfb8dc93d4197860c2bff47f2c2f280c2dd8ed699e7b3241aa325ecee53c7d7 54.68MB / 54.68MB 47.1s =\u003e =\u003e extracting sha256:c345c9e441f5f49235768af74b8ab37743652d38958afaa000edd56d7b2f0540 1.5s =\u003e =\u003e sha256:fb726ea60d28211d1e5e9d6fe76eb9ef9546eb38d107263e2a060a99be9ca41c 189.80MB / 189.80MB 53.6s =\u003e =\u003e extracting sha256:7b716680367d1dac0e54c48f75506323e0bb03628542a0fd6db39efeeee9adf5 0.1s =\u003e =\u003e extracting sha256:0855378f8903bde22cfbcee08cd239678716cf01f24a3fca9478ef4121a84d91 0.1s =\u003e =\u003e sha256:02f41717b6ae3dd1225bd22899da6ae2125098a71c9d17d01e126b4afea77912 4.21kB / 4.21kB 20.6s =\u003e =\u003e sha256:6d99896e8af987dac3892a94d2c45e18132570176d2b2353b64412413655b14a 45.15MB / 45.15MB 47.6s =\u003e =\u003e sha256:40cff91b82ae9705b4e5a8467d36f2b9b2216e1f5f3df7286cced961ce3d0a6c 2.28MB / 2.28MB 48.6s =\u003e =\u003e extracting sha256:4bfb8dc93d4197860c2bff47f2c2f280c2dd8ed699e7b3241aa325ecee53c7d7 1.5s =\u003e =\u003e sha256:5301fac16292b6191f762631ba0429ca19dc854320ceb0ab5f9aadbc6e134367 450B / 450B 48.3s =\u003e =\u003e extracting sha256:fb726ea60d28211d1e5e9d6fe76eb9ef9546eb38d107263e2a060a99be9ca41c 3.8s =\u003e =\u003e extracting sha256:02f41717b6ae3dd1225bd22899da6ae2125098a71c9d17d01e126b4afea77912 0.0s =\u003e =\u003e extracting sha256:6d99896e8af987dac3892a94d2c45e18132570176d2b2353b64412413655b14a 1.3s =\u003e =\u003e extracting sha256:40cff91b82ae9705b4e5a8467d36f2b9b2216e1f5f3df7286cced961ce3d0a6c 0.0s =\u003e =\u003e extracting sha256:5301fac16292b6191f762631ba0429ca19dc854320ceb0ab5f9aadbc6e134367 0.0s =\u003e [internal] load build context 0.0s =\u003e =\u003e transferring context: 1.25kB 0.0s =\u003e [2/8] RUN apt-get -y update 7.8s =\u003e [3/8] RUN apt-get -y install supervisor 3.7s =\u003e [4/8] RUN mkdir -p /var/log/supervisor 0.1s =\u003e [5/8] COPY ./supervisord/conf.d/* /etc/supervisor/conf.d/ 0.0s =\u003e [6/8] COPY *.js* /data/app/ 0.0s =\u003e [7/8] WORKDIR /data/app 0.0s =\u003e ERROR [8/8] RUN npm installer 0.3s ------ \u003e [8/8] RUN npm installer: 0.291 Unknown command: \"installer\" 0.291 0.291 Did you mean this? 0.291 npm install # Install a package 0.291 0.291 To see a list of supported npm commands, run: 0.291 npm help ------ Dockerfile:28 -------------------- 26 | WORKDIR $AP 27 | 28 | \u003e\u003e\u003e RUN npm installer 29 | 30 | CMD [\"supervisord\", \"-n\"] -------------------- ERROR: failed to build: failed to solve: process \"/bin/sh -c npm installer\" did not complete successfully: exit code: 1 View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/rbv5sp8i9eiite02u0gpny34p 一种方法是使用分阶段构建和 --target 参数, 对 Dockerfile 做如下修改\nFROM docker.io/node:18.13.0 AS deploy ... FROM deploy RUN npm installer 并告诉 Docker 我们只想构建多阶段 Dockerfile 中的第一个镜像\n% docker image build -t example/docker-node-hello:debug --target deploy . [+] Building 2.2s (13/13) FINISHED docker:desktop-linux =\u003e [internal] load build definition from Dockerfile 0.0s =\u003e =\u003e transferring dockerfile: 594B 0.0s =\u003e [internal] load metadata for docker.io/library/node:18.13.0 2.0s =\u003e [auth] library/node:pull token for registry-1.docker.io 0.0s =\u003e [internal] load .dockerignore 0.0s =\u003e =\u003e transferring context: 45B 0.0s =\u003e [deploy 1/7] FROM docker.io/library/node:18.13.0@sha256:d871edd5b68105ebcbfcde3fe8c79d24cbdbb30430d9bd6251c57c56c7bd7646 0.0s =\u003e [internal] load build context 0.0s =\u003e =\u003e transferring context: 233B 0.0s =\u003e CACHED [deploy 2/7] RUN apt-get -y update 0.0s =\u003e CACHED [deploy 3/7] RUN apt-get -y install supervisor 0.0s =\u003e CACHED [deploy 4/7] RUN mkdir -p /var/log/supervisor 0.0s =\u003e CACHED [deploy 5/7] COPY ./supervisord/conf.d/* /etc/supervisor/conf.d/ 0.0s =\u003e CACHED [deploy 6/7] COPY *.js* /data/app/ 0.0s =\u003e CACHED [deploy 7/7] WORKDIR /data/app 0.0s =\u003e exporting to image 0.1s =\u003e =\u003e exporting layers 0.1s =\u003e =\u003e writing image sha256:ae71d11ef13c04b4f115593fae4ad47653f324aa8eadc14c4198838fa07808ae 0.0s =\u003e =\u003e naming to docker.io/example/docker-node-hello:debug 0.0s View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/b4c9n1kiv17fobm4q5qhndmvw 然后就可以创建该容器, 并进入调试了\n% docker container run --rm -ti docker.io/example/docker-node-hello:debug /bin/bash root@ce6a659c9171:/data/app# ls index.js package.json root@ce6a659c9171:/data/app# npm install npm WARN EBADENGINE Unsupported engine { npm WARN EBADENGINE package: 'formidable@1.0.13', npm WARN EBADENGINE required: { node: '\u003c0.9.0' }, npm WARN EBADENGINE current: { node: 'v18.13.0', npm: '8.19.3' } npm WARN EBADENGINE } npm WARN deprecated mkdirp@0.3.4: Legacy versions of mkdirp are no longer supported. Please update to mkdirp 1.x. (Note that the API surface has changed to use Promises in 1.x.) npm WARN deprecated formidable@1.0.13: Please upgrade to latest, formidable@v2 or formidable@v3! Check these notes: https://bit.ly/2ZEqIau npm WARN deprecated connect@2.7.9: connect 2.x series is deprecated npm WARN deprecated express@3.2.4: No longer maintained. Please upgrade to a stable version. added 18 packages, and audited 19 packages in 4s 8 vulnerabilities (1 low, 1 moderate, 6 high) To address all issues (including breaking changes), run: npm audit fix --force Run `npm audit` for details. npm notice npm notice New major version of npm available! 8.19.3 -\u003e 11.6.1 npm notice Changelog: https://github.com/npm/cli/releases/tag/v11.6.1 npm notice Run npm install -g npm@11.6.1 to update! npm notice root@ce6a659c9171:/data/app# exit exit 一但发现了错误原因, 就可以修改 Dockerfile 里错误的地方了.\nMultiarchitecture Builds 在 Docker 诞生之初, 主流的平台都是 AMR64/X86_64 架构. 然而, 现在越来越多的开发者使用 ARM64/AArch64 架构, 并且由于 ARM 平台更低的计算成本, 云服务商也开始制作基于 ARM 的 VM.\n构建多架构平台的镜像, 即有趣又有挑战性. 如何在支持不同目标架构的同时, 维持一个简洁统一的代码库和流水线?\n幸运的是, Docker 发布了一个名为 buildx 的 docker CLI 插件, 能让这个过程变得相当简单. 在很多情况下 docker-buildx 已经预装在系统上, 使用下面命令验证\n% docker buildx version github.com/docker/buildx v0.28.0-desktop.1 8ad457cf5e291fcb7152ef6946162cc811a2fb29 默认情况下, docker-buildx 会使用 QEMU-based virtualizatoin 和 binfmt_misc 来支持不同系统架构. 运行下面命令来确保 QEMU 文件注册且更新了:\ndocker container run --rm --privileged multiarch/qemu-user-static --reset -p yes 与直接在服务器上运行的原始嵌入 Docker 构建功能不同, BuildKit 在构建镜像时可以利用一个构建容器, 这意味着该构建容器能够提供极大的功能灵活性, 使用下面条命令, 创建名为\"build\" 的 build container:\n% docker buildx create --name builder --drive docker-container --use builder % docker buildx inspect --bootstrap [+] Building 0.4s (1/1) FINISHED =\u003e [internal] booting buildkit 0.4s =\u003e =\u003e starting container buildx_buildkit_builder0 0.4s Name: builder Driver: docker-container Last Activity: 2025-09-25 07:24:07 +0000 UTC Nodes: Name: builder0 Endpoint: desktop-linux Status: running BuildKit daemon flags: --allow-insecure-entitlement=network.host BuildKit version: v0.24.0 Platforms: linux/arm64, linux/amd64, linux/amd64/v2, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/arm/v7, linux/arm/v6 Labels: org.mobyproject.buildkit.worker.executor: oci org.mobyproject.buildkit.worker.hostname: 41f436ea555f org.mobyproject.buildkit.worker.network: host org.mobyproject.buildkit.worker.oci.process-mode: sandbox org.mobyproject.buildkit.worker.selinux.enabled: false org.mobyproject.buildkit.worker.snapshotter: overlayfs GC Policy rule#0: All: false Filters: type==source.local,type==exec.cachemount,type==source.git.checkout Keep Duration: 48h0m0s Max Used Space: 488.3MiB GC Policy rule#1: All: false Keep Duration: 1440h0m0s Reserved Space: 5.588GiB Max Used Space: 43.77GiB Min Free Space: 11.18GiB GC Policy rule#2: All: false Reserved Space: 5.588GiB Max Used Space: 43.77GiB Min Free Space: 11.18GiB GC Policy rule#3: All: true Reserved Space: 5.588GiB Max Used Space: 43.77GiB Min Free Space: 11.18GiB 下面下载 wordchain 的 Git 代码库, 该库包含一个实用工具, 可以生成随机且可确定 (seed) 的词语序列, 可以满足动态命名的需求:\ngit clone https://github.com/spkane/wordchain.git \\ --config core.autocrlf=input 查看里面的 Dockerfile 可以看到这是一个很正常的多阶段构建, 不含有任何关于架构的东西\nFROM golang:1.18-alpine3.15 AS build RUN apk --no-cache add \\ bash \\ gcc \\ musl-dev \\ openssl ENV CGO_ENABLED=0 COPY . /build WORKDIR /build RUN go install github.com/markbates/pkger/cmd/pkger@latest \u0026\u0026 \\ pkger -include /data/words.json \u0026\u0026 \\ go build . FROM alpine:3.15 AS deploy WORKDIR / COPY --from=build /build/wordchain / USER 500 EXPOSE 8080 ENTRYPOINT [\"/wordchain\"] CMD [\"listen\"] 第一步是先构建静态编译好的 go 库, 然后第二步, 将其打包到一个小的镜像部署.\nDockerfile 中的 ENTRYPOINT 指令是一项高级功能, 运行将容器运行的默认进程 ENTRYPOINT 与传递给该进程的命令 CMD 分离开来. 当缺少 ENTRYPOINT 指令时, CMD 指令就需要同时包含进程本身以及其所需要的全部命令行参数.\n现在可以构建镜像, 并运行下面命令侧加载到 Docker daemon 中:\ndocker buildx build --tag wordchain:test --load . 如果要构建多种架构的, 只需要简单的添加 --platform 参数即可.\ndocker buildx build --platform linux/amd64, linux/arm64 --tag wordchain:test . 由于在为非本地架构构建镜像时需要模拟运行, 某些步骤比正常情况下花费的时间要长得多, 这是由于模拟运行带来的额外计算开销, 这是正常现象. 可以通过配置 Docker, 使其在具有匹配架构的工作节点上构建每个镜像, 这在许多情况下应该能显著加快构建速度. Docker 博客的这篇文章有相关信息.\n",
  "wordCount" : "3803",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/og-default.avif","datePublished": "2025-09-07T08:00:00+08:00",
  "dateModified": "2025-09-07T08:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "Starslayerx"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/docker-images/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Starslayerx' Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.svg"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Starslayerx&#39; Blog (Alt + H)">
                <img src="http://localhost:1313/favicon.svg" alt="" aria-label="logo"
                    height="35">Starslayerx&#39; Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                    <ul class="lang-switch"><li>|</li>
                        <li>
                            <a href="http://localhost:1313/zh-cn/" title="简体中文"
                                aria-label="简体中文">Zh-Cn</a>
                        </li>
                    </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Docker - Images
    </h1>
    <div class="post-meta"><span title='2025-09-07 08:00:00 +0800 CST'>September 7, 2025</span>&nbsp;·&nbsp;<span>18 min</span>&nbsp;·&nbsp;<span>3803 words</span>&nbsp;·&nbsp;<span>Starslayerx</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#anatomy-of-a-dockerfile--剖析-dockerfile">Anatomy of a Dockerfile | 剖析 Dockerfile</a></li>
        <li><a href="#building-an-image-构建一个容器">Building an image 构建一个容器</a></li>
        <li><a href="#running-your-image-运行镜像">Running Your Image 运行镜像</a>
          <ul>
            <li><a href="#build-arguments-构建参数">Build Arguments 构建参数</a></li>
            <li><a href="#environment-variables-as-configuration-环境变量作为设置">Environment Variables as Configuration 环境变量作为设置</a></li>
          </ul>
        </li>
        <li><a href="#custom-base-images-自定义基础镜像">Custom Base Images 自定义基础镜像</a></li>
        <li><a href="#storing-images-存储镜像">Storing Images 存储镜像</a>
          <ul>
            <li><a href="#public-registries-公共仓库">Public Registries 公共仓库</a></li>
            <li><a href="#private-registries-私有仓库">Private Registries 私有仓库</a></li>
            <li><a href="#authenticating-to-a-registry-仓库认证">Authenticating to a Registry 仓库认证</a></li>
            <li><a href="#testing-the-private-registry-测试私有注册中心">Testing the private registry 测试私有注册中心</a></li>
          </ul>
        </li>
        <li><a href="#optimizing-images-镜像优化">Optimizing Images 镜像优化</a>
          <ul>
            <li><a href="#keeping-images-small-保持小镜像">Keeping Images Small 保持小镜像</a></li>
            <li><a href="#multistage-builds-多阶段构建">Multistage Builds 多阶段构建</a></li>
            <li><a href="#layers-are-additive-层具有叠加性">Layers Are Additive 层具有叠加性</a></li>
            <li><a href="#utilizing-the-layer-cache">Utilizing the Layer Cache</a></li>
            <li><a href="#directory-caching-目录缓存">Directory Caching 目录缓存</a></li>
          </ul>
        </li>
        <li><a href="#troubleshooting-borken-builds">Troubleshooting Borken Builds</a>
          <ul>
            <li><a href="#debugging-pre-buildkit-images">Debugging Pre-BuildKit Images</a></li>
            <li><a href="#debugging-buildkit-images">Debugging BuildKit Images</a></li>
          </ul>
        </li>
        <li><a href="#multiarchitecture-builds">Multiarchitecture Builds</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>每个 Linux 容器都基于一个镜像, 镜像重新构建运行中容器的底层定义.
要启动一个容器, 需要下载公共镜像或者创建自己的镜像.
每个镜像由一个或多个相互关联的文件系统层 layer 组成, 这些层通常与创建镜像的每个构建步骤大致一一对应.</p>
<p>由于镜像由独立的层构建而成, 这就对 Linux 内核提出了特殊要求: 内核必须提供 Docker 所需的驱动, 以便运行存储后端.
在镜像管理, Docker 高度依赖这个存储后端, 该后端通过与底层 Linux 文件系统通信, 用来构建并管理多个层并将它们组合成一个可用的镜像.
主要支持的后端存储有以下类型:</p>
<ul>
<li>Overlay2</li>
<li>B-Tree File System</li>
<li>Device Mapper</li>
</ul>
<p>每一个后端都提供一个快速的 copy-on-write (CoW) 系统用于镜像管理. 包含:</p>
<ul>
<li>Building images</li>
<li>Uploading (pushing) images to an image registry</li>
<li>Downloading (pulling) images from an image registry</li>
<li>Creating and running containers from an image</li>
</ul>
<h3 id="anatomy-of-a-dockerfile--剖析-dockerfile">Anatomy of a Dockerfile | 剖析 Dockerfile<a hidden class="anchor" aria-hidden="true" href="#anatomy-of-a-dockerfile--剖析-dockerfile">#</a></h3>
<p>这个文件描述了所有构建一个容器所需的步骤, 并且通常存储在项目源码的根目录里.</p>
<p>一个典型的 Dockerfile 看起来像下面这样, 这里是创建一个 <code>Node.js</code> 的应用镜像:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="w"> </span><span class="s">node:18.13.0</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">ARG</span> <span class="nv">emali</span><span class="o">=</span><span class="s2">&#34;anna@example.com&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">LABEL</span> <span class="s2">&#34;maintainer&#34;</span><span class="o">=</span><span class="nv">$email</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">LABEL</span> <span class="s2">&#34;rating&#34;</span><span class="o">=</span><span class="s2">&#34;Five Stars&#34;</span> <span class="s2">&#34;class&#34;</span><span class="o">=</span><span class="s2">&#34;First Class&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">USER</span><span class="w"> </span><span class="s">root</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">ENV</span> <span class="nv">AP</span><span class="o">=</span>/data/app<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">ENV</span> <span class="nv">SCPATH</span><span class="o">=</span>/etc/supervisor/conf.d<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="c"># The daemons</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">RUN</span> apt-get -y install supervisor<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">RUN</span> mkdir -p /var/log/supervisor<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="c"># Supervisor Configuration</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">COPY</span> ./supervisord/conf.d/* <span class="nv">$SCPATH</span>/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="c"># Application Code</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">COPY</span> *.js <span class="nv">$AP</span>/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">WORKDIR</span><span class="w"> </span><span class="s">$AP</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">RUN</span> npm install<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;supervisord&#34;</span><span class="p">,</span> <span class="s2">&#34;-n&#34;</span><span class="p">]</span><span class="err">
</span></span></span></code></pre></div><p>Dockerfile 中的每一行都会创建一个新的镜像层并由 Docker 存储.
该层包含了该命令执行后产生的所有更改, 这意味着当构建新镜像时, Docker 只需构建与先前构建不一致的层: 那些未改变的层可以重复利用.</p>
<p>虽然可以从一个普通的基础 Linux 镜像构建一个 Node 实例, 但也可以在 Docker Hub 上查找官方的 Node 镜像.
如果想要缩小到某个版本, 可以指定诸如 <code>node:18.13.0</code> 之类的标签, 下面这个基础镜像会提供一个在 Ubuntu Linux 上运行 Node 11.11.x 的环境:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="w"> </span><span class="s">docker.io/node:18.13.0</span><span class="err">
</span></span></span></code></pre></div><p>其中 ARG 参数可以设置变量及其默认值, 但只在镜像构建过程中可用:</p>
<pre tabindex="0"><code class="language-Dockerfiles" data-lang="Dockerfiles">ARG email=&#34;anna@example.com&#34;
</code></pre><p>为镜像和容器添加标签 label, 可以通过键值对的形式为他们附加元数据, 这些元数据之后可以用于搜索和识别 Docker 镜像与容器.
可以使用 <code>docker image inspect</code> 命令查看某个应用的标签.
对于 maintainer 标签, 这里使用了上一行中定义的 <code>email</code> 参数的值. 在构建该镜像时, 可以随时更改这个标签:</p>
<pre tabindex="0"><code>LABEL &#34;maintainer&#34;=$email
LABEL &#34;rating&#34;=&#34;Five stars&#34; &#34;calss&#34;=&#34;First Class&#34;
</code></pre><p>默认情况下, Docker 使用 root 运行所有容器中的进程, 但是可以使用 <code>USER</code> 命令来修改:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">USER</span><span class="w"> </span><span class="s">root</span><span class="err">
</span></span></span></code></pre></div><blockquote>
<p>CAUTION 注意</p>
</blockquote>
<p>尽管容器与底层操作系统提供了一定程度的隔离, 但他们仍运行在主机的内核之上.
由于安全风险, 在生产环境中应该总是在非特权用户的上下文中运行.</p>
<p>不同于 <code>ARG</code> 命令, <code>ENV</code> 命令运行你设置 shell 变量, 用于运行中的容器应用设置:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">ENV</span> <span class="nv">API</span><span class="o">=</span>/data/app<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">ENV</span> <span class="nv">SCPATH</span><span class="o">=</span>/etc/supervisor/conf.d<span class="err">
</span></span></span></code></pre></div><p>在下面的代码中, 使用一系列 <code>RUN</code> 命令安装所需要的依赖, 以及创建所需的文件结构:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">RUN</span> apt-get -y update<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="c"># The daemons</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">RUN</span> apt-get -y install supervisor<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">RUN</span> mkdir -p /var/log/supervisor<span class="err">
</span></span></span></code></pre></div><blockquote>
<p>WARNING 警告</p>
</blockquote>
<p>虽然上面的展示中更新了容器依赖, 但一般不推荐这么做.
因为爬取最新的仓库列表不同, 在 build 的时候包的版本号不一定都相同, 导致生成的镜像不是可以重复使用的.
相反, 应该使用一个已经包含所需更新的镜像, 这样更快且可重复使用.</p>
<p><code>COPY</code> 命令用于从本地文件系统复制文件到镜像中. 经常会包含应用代码和任何要求的文件.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="c"># Supervisor Configuration</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">COPY</span> ./supervisord/conf.d/* <span class="nv">$SCPATH</span>/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="c"># Application Code</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">COPY</span> *.js* <span class="nv">$AP</span>/<span class="err">
</span></span></span></code></pre></div><blockquote>
<p>TIP 提示</p>
</blockquote>
<p>之前说过, Dockerfile 中的每条命令都会创建一个新的 Docker image layer.
因此将多条命令结合到同一行中是合理的, 甚至可以使用 <code>COPY</code> 复制一个脚本, 然后使用 <code>RUN</code> 命令去运行这个脚本, 这样就使用两行命令实现了复杂的操作.</p>
<p>通过 <code>WORKDIR</code> 命令, 可以修改镜像的工作目录:</p>
<pre tabindex="0"><code>WORKDIR $AP
RUN npm install
</code></pre><blockquote>
<p>CAUTION 注意</p>
</blockquote>
<p>Dockerfile 中命令的顺序会对后续的构建时间产生非常显著是影响,
应该尽量将那些每次构建都会发生变化的步骤放在 Dockerfile 靠下的位置.
也就是说, 像添加代码这样的步骤应该尽量放到最后, 因为每次构件新镜像时,
从第一个发生变化的层考试, 之后的层都必须重新构建.</p>
<p>最终, 可以通过 <code>CMD</code> 命令在容器中运行服务了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl">CMT <span class="o">[</span><span class="s2">&#34;supervisord&#34;</span>, <span class="s2">&#34;-n&#34;</span><span class="o">]</span><span class="err">
</span></span></span></code></pre></div><blockquote>
<p>Note 注意</p>
</blockquote>
<p>虽然这不是严格要求, 但一般认为最佳实践是每个容器只运行一个进程.
这里的核心想法是, 一个容器内部应该只提供一个功能, 这样便于水平扩展.
在这个例子中, 使用 supervisord 作为一个进程管理, 从而帮助提升 node 应用的弹性, 保证容器的正常运行.
这样做对于开发其间的错误处理也很有用, 这样可以方便地重启服务, 而不是整个容器.</p>
<h3 id="building-an-image-构建一个容器">Building an image 构建一个容器<a hidden class="anchor" aria-hidden="true" href="#building-an-image-构建一个容器">#</a></h3>
<p>下面通过一个例子来说明, 首先克隆这个 git 仓库</p>
<pre tabindex="0"><code>git clone http://github.com/spkane/docker-node-hello.git \
--config core.autocrlf=input
</code></pre><p>上面 <code>--config core.autocrlf=input</code> 这个参数用于设置如何处理文本文件的结束符:</p>
<ul>
<li>Git 在提交代码时会将行结束符转换为 LF</li>
<li>但在检出代码时不会进行任何转换</li>
</ul>
<p>之后使用命令显示所有文件</p>
<pre tabindex="0"><code>tree -a -I .git
</code></pre><p>其中</p>
<ul>
<li><code>-a</code> 表示 all, 显示所有文件.</li>
<li><code>-I .git</code> 表示 Ignore, 忽略 <code>.git</code> 模式的文件或目录</li>
</ul>
<p>得到如下目录结构</p>
<pre tabindex="0"><code>.
├── .dockerignore
├── .gitignore
├── Dockerfile
├── index.js
├── package.json
└── supervisord
    └── conf.d
        ├── node.conf
        └── supervisord.conf
</code></pre><ul>
<li><code>.dockerignore</code> 文件定义不想上传到 docker 镜像中的文件或目录, 文件中写了 <code>.git</code>, 这会指示 docker 在 build 的时候, 排除 <code>.git</code> 目录.</li>
<li><code>packages.json</code> 定义了 Node.js 应用并列出了它所依赖的包</li>
<li><code>index.js</code> 是应用程序的主源代码</li>
<li><code>supervisord</code> 目录包含用于启动和监控该应用的 supervisord 配置文件</li>
</ul>
<p>下面运行构建命令</p>
<pre tabindex="0"><code>docker image build -t example/docker-node-hello:latest .
</code></pre><p>为了提升构建速度, docker 在认为安全的时候会使用本地缓存.
但有时一些底层的修改, 并不会被检测到.
当看到 <code>⇒ CACHED [2/8] RUN apt-get -y update</code> 这样的内容, 就说明 docker 在使用缓存.
可以使用 <code>--no-cache</code> 命令禁止使用缓存构建.</p>
<h3 id="running-your-image-运行镜像">Running Your Image 运行镜像<a hidden class="anchor" aria-hidden="true" href="#running-your-image-运行镜像">#</a></h3>
<p>一但成功构建镜像, 就可以使用如下命令运行镜像</p>
<pre tabindex="0"><code>docker container run --rm -d -p 8080:8080 example/docker-node-hello:latest
</code></pre><p>其中</p>
<ul>
<li><code>--rm</code>: 是使容器退出时自动删除, 避免系统中堆集大量已停止的容器, 适用测试或临时运行容器</li>
<li><code>-d</code>: detached 模式, 让容器在后台运行</li>
<li><code>-p 8080:8080</code>: 端口映射 <code>主机端口:容器端口</code>, 这里并不依赖 Dockerfile 里面的 EXPOSE 命令</li>
</ul>
<p>如果一切正常, Node.js 应用程序就会在宿主机上的容器中运行.
可以通过执行 <code>docker container ls</code> 来检测容器是否在运行.</p>
<p>通过可以通过以下方式确定 Docker 主机的 IP 地址:</p>
<ul>
<li>查看 <code>docker context list</code> 命令输出中带有星号 <code>*</code> 标记的条目</li>
<li>或者检查环境变量 <code>DOCKER_HOST</code> 的值</li>
</ul>
<p>如果 Docker 端点设置为 Unix socket, 那么 IP 地址就通常是 <code>127.0.0.1</code></p>
<pre tabindex="0"><code>NAME              DESCRIPTION                               DOCKER ENDPOINT                                     ERROR
default           Current DOCKER_HOST based configuration   unix:///var/run/docker.sock
desktop-linux *   Docker Desktop                            unix:///Users/starslayerx/.docker/run/docker.sock
</code></pre><p>之后访问 <a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a> 就可以访问服务, 看到以下内容</p>
<pre tabindex="0"><code>Hello World. Wish you were here.
</code></pre><h4 id="build-arguments-构建参数">Build Arguments 构建参数<a hidden class="anchor" aria-hidden="true" href="#build-arguments-构建参数">#</a></h4>
<p>如果 inspect 检查刚刚构建的镜像, 可以看到 maintainer 的 label 是 <a href="mailto:anna@example.com">anna@example.com</a>:</p>
<pre tabindex="0"><code>docker image inspect \
    example/docker-node-hello:latest | grep maintainer
</code></pre><p>如果想要修改 maintainer 这个标签, 可以简单的运行 build 命令, 并使用 <code>--build-arg</code> 参数附带一个新的 email RAG, 例如这样:</p>
<pre tabindex="0"><code>docker image build --build-arg email=me@example.com \
    -t example/docker-node-hello:latest .
</code></pre><p>构建完成后可以再次 inspect 会发现 maintainer 的 label 就被修改了</p>
<h4 id="environment-variables-as-configuration-环境变量作为设置">Environment Variables as Configuration 环境变量作为设置<a hidden class="anchor" aria-hidden="true" href="#environment-variables-as-configuration-环境变量作为设置">#</a></h4>
<p>阅读 <code>index.js</code> 文件, 可以看到涉及到了 <code>$WHO</code> 变量, 这里根据环境变量决定 Hello 后面跟什么:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Javascript" data-lang="Javascript"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">DEFAULT_WHO</span> <span class="o">=</span> <span class="s2">&#34;World&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">WHO</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">WHO</span> <span class="o">||</span> <span class="nx">DEFAULT_WHO</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span> <span class="o">+</span> <span class="nx">WHO</span> <span class="o">+</span> <span class="s1">&#39;.Wish you were here.\n&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><blockquote>
<p>Note 注意</p>
</blockquote>
<p>可以通过 <a href="https://developer.hashicorp.com/nomad/tutorials/archive/go-template-syntax">Go template</a> 来格式化 <code>docker container ls</code> 的输出只感兴趣的部分.
例如 <code>docker container ls --format &quot;table {{.ID}}\t{{.Image}}\t{{.Status}}&quot;</code>.
此外, 还可以使用 <code>docker container ls --quiet</code> 不带 format options 将会限制只输出容器 ID.</p>
<p>然后, 使用之前输出得到的 container ID 可以停止运行容器:</p>
<pre tabindex="0"><code>docker container stop bc26bfd2b4a8
</code></pre><blockquote>
<p>TIP 提示</p>
</blockquote>
<p>使用 <code>docker container ls</code> 命令和使用 <code>docker ps</code> 命令在功能上是相同的.</p>
<p>可以通过 <code>--env</code> 参数重启容器来添加环境变量</p>
<pre tabindex="0"><code>docker container run --rm -d \
    --publish model=ingress,published=8080,target=8080 \
    --env WHO=&#34;Sean and Karl&#34; \
    example/docker-node-hello:latest
</code></pre><p>这时候刷新浏览器, 应该能够看到这样的内容</p>
<pre tabindex="0"><code>Hello Sean and Karl. Wish you were here.
</code></pre><blockquote>
<p>Note 注意</p>
</blockquote>
<p>可以这样缩短上面命令</p>
<pre tabindex="0"><code>docker container run --rm -d -p 8080:8080 \
    -e WHO=&#34;Sean and Karl&#34; \
    example/docker-node-hello:latest
</code></pre><h3 id="custom-base-images-自定义基础镜像">Custom Base Images 自定义基础镜像<a hidden class="anchor" aria-hidden="true" href="#custom-base-images-自定义基础镜像">#</a></h3>
<p>基础镜像经常基于常见 Linux 发行版的 minimal installs, 例如 Ubuntu, Fedora, Alpine Linux.
对于大多数人而言, 使用 Linux 发行版官方基础镜像是一个很好的选择.</p>
<p>但是, 有时会需要构建自己的基础镜像, 而不是使用现成的.
一个原因就是为了在所有的硬件, 虚拟机, 容器部署保持一样的镜像.
另一个原因是为了降低镜像的大小.
完全没有必要使用完整的 Ubuntu 发行版, 例如 C 或 Go 应用.
你可能会发现, 你只需要一些常用的工具进行调试, 以及其他一些 shell 命令.</p>
<p>另一种位于中间的方法是使用 Alpine Linux, 该发行版很小, 作为基础镜像十分流行.
为了保持小型化, Alpine Linux 基于现代的轻量库 <a href="https://musl.libc.org/">musl standard library</a> 而不是传统的 <a href="https://www.gnu.org/software/libc">GNU C Library (glibc)</a>.
由于镜像极小, Alpine Linux 内默认使用 <code>/bin/sh</code> 而不是 <code>/bin/bash</code>.
但如果需要, 也可以自己安装 glibc 和 bash, 这经常在 JVM 容器中发生.</p>
<h3 id="storing-images-存储镜像">Storing Images 存储镜像<a hidden class="anchor" aria-hidden="true" href="#storing-images-存储镜像">#</a></h3>
<p>当构建完镜像后, 往往需要存储该镜像, 以便未来的部署.
一般不会在生产环境服务器上面去构建, 然后运行镜像, 而是从某个地方拉取已经构建好的镜像.</p>
<h4 id="public-registries-公共仓库">Public Registries 公共仓库<a hidden class="anchor" aria-hidden="true" href="#public-registries-公共仓库">#</a></h4>
<p>Docker 提供一个镜像仓库给社区的共享镜像.
包括官方 Linux 发行版镜像, WordPress 镜像之类.</p>
<p>如果你要发布一个镜像到互联网上, 最好的仓库是 <a href="https://hub.docker.com/">Docker Hub</a>.
但也有其他一些选择, 例如 Docker 刚刚流行起来, Docker Hub 还不存在时, 为了填补社区的需要, <a href="https://quay.io/">Quay.io</a> 被创建了.
在那之后, Quay.io 被收购了好几次, 现在属于 RedHat.
像 Google, Github 和 SaaS 公司都有他们自己的仓库.</p>
<p>对于大量使用 Docker 的公司来说, 这些集中化仓库最大的缺点之一就是他们并不在应用部署所在的网络中. 这意味着应用部署时, 每一层镜像都可能需要跨跃整个互联网来传输. 网络延迟会对软件部署产生非常真实的影响, 而这些镜像一但出故障, 就可能严重影响公司按时完成部署. 这个问题可以通过良好的镜像设计来缓解, 例如将镜像分割成精简的层, 以便更容易在互联网上传输.</p>
<h4 id="private-registries-私有仓库">Private Registries 私有仓库<a hidden class="anchor" aria-hidden="true" href="#private-registries-私有仓库">#</a></h4>
<p>另一种很多公司采用的方法, 是在内容网络部署 Docker 镜像.
开源的 <a href="https://github.com/distribution/distribution">Distribution</a> 项目提供了基础的功能.
其他私有仓库的竞争者包括 <a href="https://goharbor.io/">Harbor</a> 和 <a href="https://www.redhat.com/en/technologies/cloud-computing/quay">Red Hat Quay</a>, 他们除了基础功能, 还提供了一套 GUI 界面和其他功能, 例如镜像校验.</p>
<h4 id="authenticating-to-a-registry-仓库认证">Authenticating to a Registry 仓库认证<a hidden class="anchor" aria-hidden="true" href="#authenticating-to-a-registry-仓库认证">#</a></h4>
<p>Docker 默认使用 Docker Hub 作为镜像仓库.</p>
<ul>
<li>Creating a Docker Hub acount 创建一个 Docker Hub 帐号<br>
如果只是拉取镜像, 不需要登陆帐号. 但如果要避免限速, 以及上传构建的容器就需要登陆.<br>
创建帐号后, 可以向 public registry 上传镜像. 在 <a href="https://hub.docker.com/settings/default-privacy">Account Settings</a> 选项下面有一个 Default Privacy 选项, 可以将可见性修改有私有.</li>
</ul>
<blockquote>
<p>WARNING 警告</p>
</blockquote>
<p>为了更好的安全性, 应该使用 <a href="https://docs.docker.com/security/access-tokens/">access token</a> 登陆 Docker Hub.</p>
<ul>
<li>
<p>Logging in to a registry 登陆注册中心</p>
<p>使用下面命令登陆 Docker Hub</p>
<pre tabindex="0"><code>docker login
</code></pre><p>当成功登陆后, Docker 会在家目录下面创建一个 dotfile 来缓存信息.</p>
<pre tabindex="0"><code>% cat ${HOME}/.docker/config.json
─────┬─────────────────────────────────────────────
     │ File: /Users/starslayerx/.docker/config.json
─────┼─────────────────────────────────────────────
  1  │ {
  2  │     &#34;auths&#34;: {
  3  │         &#34;https://index.docker.io/v1/&#34;: {}
  4  │     },
  5  │     &#34;credsStore&#34;: &#34;desktop&#34;,
  6  │     &#34;currentContext&#34;: &#34;desktop-linux&#34;,
  7  │     &#34;plugins&#34;: {
  8  │         &#34;debug&#34;: {
  9  │             &#34;hooks&#34;: &#34;exec&#34;
 10  │         },
 11  │         &#34;scout&#34;: {
 12  │             &#34;hooks&#34;: &#34;pull,buildx build&#34;
 13  │         }
 14  │     },
 15  │     &#34;features&#34;: {
 16  │         &#34;hooks&#34;: &#34;true&#34;
 17  │     }
 18  │ }
─────┴─────────────────────────────────────────────
</code></pre><p>可以看到, 该文件以 JSON 格式存储了用户的凭据, 该配置文件支持存储多个镜像仓库的凭据. 从现在起, 当镜像仓库需要身份验证时, Docker 会自动查询该文件, 检查是否存储了主机对应的凭据. 若存在, Docker 将会自动提交这些凭据. 值得注意的是, 这里缺失了&quot;时间戳&quot;, 这些凭据会永久缓存, 除非主动清楚他们.<br>
与登录操作类似, 若不再需要缓存某镜像仓库的凭据, 也可以执行注销操作:</p>
<pre tabindex="0"><code>docker logout
</code></pre><p>如果要登陆其他非 Docker Hub 的仓库, 需要提供 hostname:</p>
<pre tabindex="0"><code>docker login someregistry.example.com
</code></pre><p>这样将会为 <code>${HOME}/.docker/config.json</code> 文件添加该仓库信息</p>
</li>
<li>
<p>Pushing images into a repository 推送镜像到仓库</p>
<p>推送镜像的第一步要确保已经登陆到了 Docker 仓库.<br>
一但登陆进去, 就可以上传镜像了.
早期使用 <code>docker image build -t example/docker-node-hello:latest .</code> 命令构建镜像, 但实际上 Docker client 将 <code>example/docker-node-hello:latest</code> 视为 <code>docker.io/example/docker-node-hello:latest</code>. 这里 <code>docker.io</code> 表示 registry 名称, 而 <code>example/docker-node-hello</code> 是 registry 里面的 repository, 包含了各种镜像.</p>
<p>可以使用下面命令来方便的给镜像打标签, 使用你的 Docker Hub 用户名称替换 <code>${&lt;myuser&gt;}</code></p>
<pre tabindex="0"><code>docker image tag example/docker-node-hello:latest \
    docker.io/${&lt;myuser&gt;}/docker-node-hello:latest
</code></pre><p>如果要使用新的命名重新构建镜像, 通过下面命令完成 (<code>-t</code> 参数为镜像打标签)</p>
<pre tabindex="0"><code>docker image build -t docker.io/${&lt;myuser&gt;}/docker-node-hello:latest .
</code></pre><p>第一次构建的时候会花一些时间, 但如果是重新构建, 会非常块.
因为大多数层都已经存在 Docker server 里面了.</p>
<p>接下来可以使用下面命令推送镜像:</p>
<pre tabindex="0"><code>docker image push ${&lt;myuser&gt;}/docker-node-hello:latest
</code></pre></li>
<li>
<p>Exploring images in Docker Hub<br>
除了简单的流览 Docker Hub 网络流览镜像, 还可以使用 docker 搜索命令来查找镜像</p>
<pre tabindex="0"><code>docker search node

NAME               DESCRIPTION                                     STARS     OFFICIAL
node               Node.js is a JavaScript-based platform for s…   13999     [OK]
cimg/node          The CircleCI Node.js Docker Convenience Imag…   25
circleci/node      Node.js is a JavaScript-based platform for s…   135
bitnami/node       Bitnami container image for NodeJS              83
kindest/node       https://sigs.k8s.io/kind node image             114
okteto/node                                                        2
eclipse/node       Node 0.12.9                                     1
chainguard/node    Build, ship and run secure software with Cha…   0
sitespeedio/node   Node base template                              3
corpusops/node     https://github.com/corpusops/docker-images/     0
rootpublic/node                                                    0
ubuntu/node        Ubuntu-based Node.js image for server-side a…   2
setupphp/node      Docker images to run setup-php GitHub Action    0
joxit/node         Slim node docker with some utils for dev        1
treehouses/node                                                    2
activestate/node   ActiveState&#39;s customizable, low-to-no vulner…   12
alpine/node                                                        5
vmware/node        Node.js base built on top of Photon OS          0
wayofdev/node                                                      0
vulhub/node                                                        0
systemsdk/node     Docker environment with node 16 for Laravel/…   0
openizr/node       Safer, non-root, nodeJS environment             0
openeuler/node                                                     0
presearch/node     Run a search node in Presearch&#39;s decentraliz…   25
iron/node          Tiny Node image                                 28
</code></pre><p>右侧的 OFFICIAL 表明该镜像是官方认证的镜像.<br>
这意味着该镜像往往是由该应用开发的公司或者社区维护.<br>
AUTOMATED 代表该镜像是通过 CI/CD 触发, 自动构建的.</p>
</li>
<li>
<p>Running a Private Registry 运行一个私有的注册中心<br>
建立一个基础的 registry 并不难, 但对于生产环境中使用, 应该花时间去了解一下可用的配置选项 <a href="https://docs.docker.com/retired/">the open source Docker Registry (Distribution)</a>. 下面使用 SSL 和 HTTP 认证构建一个简单的 registry.</p>
<p>首先克隆一个 Git 仓库:</p>
<pre tabindex="0"><code>git clone https://github.com/spkane/basic-registry --config core.autocrlf=input
</code></pre><p>查看仓库文件</p>
<pre tabindex="0"><code>ls basic-registry

config.yaml  config.yml.sample  Dockerfile  htpasswd.sample  README.md  registry.crt.sample  registry.key.sample
</code></pre><p>这个 Dockerfile 只是简单的将 Docker Hub 的上游镜像和一些本地配置写入新的镜像.<br>
作为测试, 可以使用示例文件, 但不要在生产中使用.<br>
如果在本地直接复制文件即可</p>
<pre tabindex="0"><code>cp config.yaml.sample config.yaml
cp registry.key.sample registry.key
cp registry.crt.sample registry.crt
cp htpasswd.sample htpasswd
</code></pre><p>如果 Docker server 在远程服务器, 则需要修改一下 <code>config.yaml</code> 文件, 将 ip 地址修改为服务器地址, 例如这样:</p>
<pre tabindex="0"><code>http:
  host: https://172.17.41.10:5000
</code></pre><p>然后需要为 registry 的 IP 创建一个 SSL keypair, 一种方法是使用 OpenSSL 命令</p>
<pre tabindex="0"><code>openssl req -x509 -nodes -sha256 -newkey ras:4096 \
    -keyout registry.key -out registry.crt \
    -days 14 -subj &#39;{/CN=172.17.42.10}&#39;
</code></pre><p>最后复制 <code>htpasswd.sample</code> 文件内容到 <code>htpasswd</code>, 或者也可以使用下面命令来自定义用户名 <code>&lt;username&gt;</code> 和密码 <code>&lt;password&gt;</code></p>
<pre tabindex="0"><code>docker container run --rm --entrypoint htpasswd g \
    -Bbn ${&lt;username&gt;} ${&lt;password&gt;} &gt; htpasswd
</code></pre><p>如果一切正确, 就应该能够构建和运行 registry 了 (mac 的 5000 端口可能会被控制中心占用, 这里使用 5001 端口)</p>
<pre tabindex="0"><code>docker image build -t my-registry .
docker container run --rm -d -p 5001:5000 --name registry my-registry
docker container logs registry
</code></pre></li>
</ul>
<h4 id="testing-the-private-registry-测试私有注册中心">Testing the private registry 测试私有注册中心<a hidden class="anchor" aria-hidden="true" href="#testing-the-private-registry-测试私有注册中心">#</a></h4>
<p>运行后首先登陆该 registry</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">% docker login 127.0.0.1:5001
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Username: myuser
</span></span><span class="line"><span class="cl">Password:
</span></span><span class="line"><span class="cl">Login Succeeded
</span></span></code></pre></div><blockquote>
<p>WARNING 警告</p>
</blockquote>
<p>这个 registry 容器内置了一个 SSL 密钥, 且没有使用任何外部存储.
也就是说, 其内部包含一个密钥, 而且当删除正在运行的容器时, 内部存储的镜像也会被删除.</p>
<p>在生产环境中, 需要让容器从密钥管理系统中获取密钥, 并且使用某种冗余的外部存储.
如果希望在开发环境中, 不同容器之间保留 registry 镜像, 可以在运行 docker 容器时加上类似参数:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">--mount <span class="nv">type</span><span class="o">=</span>bind, <span class="nv">source</span><span class="o">=</span>/tmp/registry-data, <span class="nv">target</span><span class="o">=</span>/var/lib/registry
</span></span></code></pre></div><p>这里是将宿主机的 <code>/tmp/registry-data</code> 目录映射到容器里的 <code>/var/lib/registry</code>, 这样镜像就会存储到宿主机, 即使容器被删除也不会丢失</p>
<p>现在来测试能否在本地私有 registry 上传镜像</p>
<pre tabindex="0"><code>% docker image tag my-registry 127.0.0.1:5001/my-registry

% docker image push 127.0.0.1:5001/my-registry
Using default tag: latest
The push refers to repository [127.0.0.1:5001/my-registry]
aa2afd4dffb6: Pushed
f4596b202dbb: Pushed
e971abc09286: Pushed
63c05075324e: Pushed
19c15db2ec23: Pushed
7ad8ac1e6be1: Pushed
97599ee5c821: Pushed
014ffb8901a5: Pushed
171a26c7bc56: Pushed
latest: digest: sha256:445f229035a87428b9e9dd1f816a29f7aaf8f8eabab220942d1aeae545e3f2f1 size: 2193
</code></pre><p>现在就可以 pull 同样的镜像了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">% docker image pull 127.0.0.1:5001/my-registry
</span></span><span class="line"><span class="cl">Using default tag: latest
</span></span><span class="line"><span class="cl">latest: Pulling from my-registry
</span></span><span class="line"><span class="cl">Digest: sha256:445f229035a87428b9e9dd1f816a29f7aaf8f8eabab220942d1aeae545e3f2f1
</span></span><span class="line"><span class="cl">Status: Image is up to date <span class="k">for</span> 127.0.0.1:5001/my-registry:latest
</span></span><span class="line"><span class="cl">127.0.0.1:5001/my-registry:latest
</span></span></code></pre></div><p>可以使用下面命令停止该容器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker container stop registry
</span></span></code></pre></div><blockquote>
<p>TIP 提示</p>
</blockquote>
<p>当熟悉 Docker Distribution 后可能考虑流览 Cloud Native Computing Foundation (CNCF) 叫做 <a href="https://goharbor.io/">Harbor</a> 的项目, 该项目比 Docker Distribution 更加安全可靠.</p>
<h3 id="optimizing-images-镜像优化">Optimizing Images 镜像优化<a hidden class="anchor" aria-hidden="true" href="#optimizing-images-镜像优化">#</a></h3>
<p>这一章介绍一些镜像优化技巧, 减少内存使用并提升构建速度</p>
<h4 id="keeping-images-small-保持小镜像">Keeping Images Small 保持小镜像<a hidden class="anchor" aria-hidden="true" href="#keeping-images-small-保持小镜像">#</a></h4>
<p>从互联网下载 1G 的文件是人们经常担心的问题, 尤其是要部署 100+ 的结点, 且每天要多次部署新发行版的时候.
下载这些大文件很容易造成网络堵塞 network congestion, 并且部署速度慢会对产品有实在的影响.</p>
<p>为了方便, 大量的 Linux 容器会继承一个最小化的 Linux 发行版的基础镜像.
虽然这样很方便上手, 但并不是必须的.
容器只需要包含在宿主机内核上运行应用所需的文件, 除此之外什么都不要.</p>
<p>Go 是一门编译语言, 可以很方便地生成静态编译的二进制文件.
作为示例, 这里使用一个 Go 编写的 Web 应用, 该应用可以在 <a href="https://github.com/spkane/scratch-helloworld">Github</a> 上找到.
运行下面命令, 然后在浏览器打开</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker container run --rm -d -p 8080:8080 spkane/scratch-helloworld
</span></span></code></pre></div><p>一般情况下可能认为容器内会有项目文件, 但实际上并不是这样, 使用下面类似命令将容器打包</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker container <span class="nb">export</span> 19931dd0fc21 -o web-app.tar
</span></span></code></pre></div><p>再使用 tar 命令, 检查容器内容</p>
<pre tabindex="0"><code>tar -tvf web-app.tar
</code></pre><p>首先注意到, 该容器内几乎没有什么文件, 且大部分都是 0 字节.
这些大小为 0 的文件, 在每个 Linux 文件中都存在, 他们在容器第一次创建时, 会自动从宿主机绑定挂载 bind-mount 进来.
除了 <code>.dockerenv</code> 之外, 这些文件都是内核正常运行所必须的文件.
在这个容器中, 唯一真正有实际大小的, 与应用相关的文件就静态编译好的 helloworld 二进制程序.</p>
<p>从这个实验中可以知道:<br>
容器只需要包含运行在底层内核之上的最小文件集和, 其他的一切都是不必要的.
不过, 在很多情况下, 为了方便排查问题, 会希望容器内有一个可用的 shell, 因此很多人会折中一下, 选择一个轻量级的 Linux 发行版来构建镜像.</p>
<blockquote>
<p>TIP 提示</p>
</blockquote>
<p>如果需要经常查看镜像文件, 可以尝试一下这个工具 <a href="https://github.com/wagoodman/dive">dive</a>, 其提供了一个 CLI 接口便捷地查看镜像内容.</p>
<p>尽管可以使用 <code>docker container run -ti alpine:latest /bin/sh</code> 查看 apline image, 但对于 <code>spkane/scratch-helloworld</code> 这个镜像不行, 因为这个容器中不含 bash 或者 SSH. 这之前是用 <code>docker container export</code> 命令生成了一个 <code>.tar</code> 文件, 其中包含容器内所有文件的副本, 但本次将直接连接到 Docker 服务器并查看容器自身的 文件系统来检查它. 要做到这一点, 需要找出文件在服务器磁盘上的存放位置, 可以使用下面命令获取:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker image inspect &lt;container_name&gt;:&lt;container_tag&gt;
</span></span></code></pre></div><p>下面使用这个例子来演示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker container run --rm -it --privileged --pid<span class="o">=</span>host debian nsenter -t <span class="m">1</span> -m -u -n -i sh
</span></span></code></pre></div><p>alpine 是一个非常小的基础镜像, 只有 4.5 MB, 非常适合在其之上构建容器.<br>
然而, 可以看到, 即使在还没有基于它构建任何东西之前, 这个容器里仍然包含了不少内容.</p>
<p>接下来, 让查看 <code>spkane/scratch-helloworld</code> 镜像中的文件. 这种情况下, 查看 <code>docker image inspect</code> 输出中 LowerDir 项的第一个目录, 注意到它第一个名为 <code>diff</code> 的目录名称:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># ls -lFh /var/lib/docker/overlay2/37…4d/diff</span>
</span></span><span class="line"><span class="cl">total <span class="m">3520</span>
</span></span><span class="line"><span class="cl">-rwxr-xr-x    <span class="m">1</span> root     root        3.4M Jul  <span class="m">2</span>  <span class="m">2014</span> helloworld*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># exit</span>
</span></span></code></pre></div><p>这个目录里只有一个文件, 大小为 3.4 MB, 这个 helloworld 二进制文件是容器中唯一包含的文件, 而且它比 alpine 镜像在添加任何应用文件之前的初始大小还要小.</p>
<blockquote>
<p>Note 注意</p>
</blockquote>
<p>在 Docker 服务上, 可以直接从该目录运行 helloworld 应用程序, 因为它不依赖任何文件, 除了在开发环境里, 绝不应该怎么做.
这样做能够直观地说明, 这对静态编译应用程序有多么实用.</p>
<h4 id="multistage-builds-多阶段构建">Multistage Builds 多阶段构建<a hidden class="anchor" aria-hidden="true" href="#multistage-builds-多阶段构建">#</a></h4>
<p>在很多情况下, 可以通过多阶段构建 (multistage builds) 将容器限制得更小.
这也是构建大多数生产环境容器的推荐方式.
你不必担心构建引入额外资源, 同时你仍然可以运行一个 精简的(lean)生产容器.
多阶段容器还鼓励在 Docker 内部完成构建, 这是实现构建系统可重复性的一种极佳模式.</p>
<p>正如 [scratch-helloworld] 应用的原作者写的那样, Docker 本身引入对多阶段构建的支持, 使得创建小型容器的过程比过去容易的多.</p>
<p>在过去, 要实现在多阶段构建, 必须先构建一个镜像来编译代码, 然后提取生成的二进制文件, 再构建第二个不包含构建依赖的镜像, 并把那个二进制文件注入进入. 这种方式往往很难配置, 并且在标准化的部署流水线中也不总是能开箱即用.</p>
<p>而如今, 只需要一个像下面这样简单的 Dockerfile 就能达到类似的效果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="c"># Build Container</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">FROM</span><span class="w"> </span><span class="s">docker.io/golang:apline</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="s">builder</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">RUN</span> apk update <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl">    apk add git <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl">    <span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span> go install -a -ldflags <span class="s1">&#39;-&#39;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl">    github.com/spkane/scratch-helloworld@latest<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="c"># Production Container</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">FROM</span><span class="w"> </span><span class="s">scratch</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">COPY</span> --from<span class="o">=</span>builder /go/bin/scratch-helloworld/helloworld<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">EXPOSE</span><span class="w"> </span><span class="s">8080</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;/helloworld&#34;</span><span class="p">]</span><span class="err">
</span></span></span></code></pre></div><p>首先注意到, 这个 Dockerfile 看上去像是两个 Dockerfile 拼接起来的.
确实是这样, 但不止如此. 第一条 FROM 命令在构建阶段将变量命名为 <em>builder</em>.
之后的 FROM 语句使用 scratch 这个特殊的特殊的镜像名, 叫做 scratch, 告诉 Docker 从空镜像开始构建, 这将不会包含额外的文件.
下一行 <code>COPY --from=builder /go/bin/scratch-helloworld /helloworld</code> 将 <em>builder</em> 镜像的二进制文件直接复制到当前镜像中.</p>
<p><code>EXPOST 8080</code> 这行是为了告诉用户这个服务使用的端口 ports 和协议 protocols.</p>
<p>这里可以添加更多阶段, 实际上, 多阶段构建之间并非必须要有联系, 他们会按顺序构建.
可以一个阶段构建 Go web API 服务的镜像, 另一个阶段构建 Angular web UI 的镜像.
最后阶段将两个镜像输出结合起来.</p>
<blockquote>
<p>TIP 提示</p>
</blockquote>
<p>当构建更加复杂的镜像时, 可能会发现构建单个上下文很有挑战性.
这个 docker-buildx 插件能够支持多上下文构建, 可以用来支持一些进阶的工作流.
(build context 构建上下文是 <code>docker build</code> 时指定的目录内容, Docker 在构建镜像时, 会先把这个目录的文件打包上传给 Docker 引擎, 作为上下文, 之后 Dockerfile 里的指令就只能访问这个 <code>build context</code> 内的文件)</p>
<h4 id="layers-are-additive-层具有叠加性">Layers Are Additive 层具有叠加性<a hidden class="anchor" aria-hidden="true" href="#layers-are-additive-层具有叠加性">#</a></h4>
<p>只有深入探究镜像的构建原理, 才会发现一个不显而易见的事实: 组成镜像的文件系统图层在设计上严格遵循叠加原则.
虽然可以通过覆盖/屏蔽先前图层中的文件, 但无法真正删除这些文件.
这意味着无法通过简单删除前期步骤生成的文件来缩小镜像体积.</p>
<blockquote>
<p>Note 注意</p>
</blockquote>
<p>若在 Docker 中启用试验性功能, 可以通过 <code>docker image build --squash</code> 命令将多个层压缩为单一层.
这将使所有在中间层被删除的文件最终从镜像中彻底消失, 从而有效回收被浪费的存储空间.
但问题是这样即使只更新了一行源码, 整个层都需要重新下载.</p>
<p>可以使用 <code>docker image history &lt;image&gt;</code> 命令查看镜像构建阶段的文件层信息, 例如下面这样:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">% docker image <span class="nb">history</span> ...
</span></span><span class="line"><span class="cl">IMAGE        CREATED            CREATED BY                             SIZE
</span></span><span class="line"><span class="cl">543d61c95677 About a minute ago CMD <span class="o">[</span><span class="s2">&#34;/usr/sbin/httpd&#34;</span> <span class="s2">&#34;-DFOREGROU…&#34;</span><span class="o">]</span>  0B
</span></span><span class="line"><span class="cl">&lt;missing&gt;    About a minute ago RUN /bin/sh -c dnf install -y httpd …  273MB
</span></span><span class="line"><span class="cl">&lt;missing&gt;    <span class="m">6</span> weeks ago        /bin/sh -c <span class="c1">#(nop)  CMD [&#34;/bin/bash&#34;]…  0B</span>
</span></span><span class="line"><span class="cl">&lt;missing&gt;    <span class="m">6</span> weeks ago        /bin/sh -c <span class="c1">#(nop)  ADD file:58865512c… 163MB</span>
</span></span><span class="line"><span class="cl">&lt;missing&gt;    <span class="m">3</span> months ago       /bin/sh -c <span class="c1">#(nop)  ENV DISTTAG=f36co…  0B</span>
</span></span><span class="line"><span class="cl">&lt;missing&gt;    <span class="m">15</span> months ago      /bin/sh -c <span class="c1">#(nop)  LABEL maintainer=…  0B</span>
</span></span></code></pre></div><p>上面有 3 层没有添加额外的大小, 有两层添加了很多 MB, 对于 ADD 那条命令可以理解, 是添加原始的镜像, 但 RUN 这条命令就比较奇怪了, 为什么添加一个 Apache web server 会占用这么多空间?</p>
<p>需要理解的核心要点是, 镜像层本质上严格遵守叠加原则. 图层一但建立, 内容就无法移除.
这意味着, 无法通过在后继图层中删除文件来缩限先前图层的体积.
当在后续图层中编辑或删除文件时, 实际上知识在新图层中用修改或删除标记覆盖了旧版本.
因此, 缩小图层体积的唯一方法是在保存图层前移除文件.</p>
<p>最长将的处理方式是在 Dockerfile 的单行命令中串连多个命令, 通过使用 <code>&amp;&amp;</code> 运算符可以轻松的实现, 该运算符作为布尔 AND 语句使用, 基本上等于&quot;如果前一个命令执行成功，就执行这个命令&quot;. 此外, 还可以利用 <code>\</code> 运算符在命令换行后继续, 这能够提升长命令的可读性.</p>
<p>掌握这些后可以重写 Dockerfile:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="w"> </span><span class="s">docker.io/fedora</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">RUN</span> dnf install -y httpd <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl">    dnf clean all<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;/usr/sbin/httpd&#34;</span><span class="p">,</span> <span class="s2">&#34;-DFOREGROUND&#34;</span><span class="p">]</span><span class="err">
</span></span></span></code></pre></div><p>现在可以重写构建镜像, 再查看大小会发现从 273 MB 缩减到了 44.8 MB.
这是非常大的空间提升, 尤其是当有多个服务器拉取镜像的时候.</p>
<h4 id="utilizing-the-layer-cache">Utilizing the Layer Cache<a hidden class="anchor" aria-hidden="true" href="#utilizing-the-layer-cache">#</a></h4>
<p>最后一个要介绍的构建技巧, 是关于如何让构建速度尽可能的块.
DevOps 的重要目标之一就是如何保持反馈循环尽量的紧密.
这意味着尽快使问题被发现很重要, 这样开发者就可以专注于问题代码, 而不是等待已经去做其他不相关的任务了.</p>
<p>在标准构建过程中, Docker 会使用层缓存机制, 尽可能避免重建已经构建且未包含明确变更的层.
由于这个机制, 在Dockerfile 中安排操作指令的顺序会显著影响构建过程的耗时.</p>
<p>对于需要根据代码安装依赖的项目, 例如 npm, bundle, 可以研究一下如何优化 Docker 在这些平台的构建.
这通常包括锁定依赖版本和存储代码, 这样就无需每次 build 的时候都下载依赖.</p>
<h4 id="directory-caching-目录缓存">Directory Caching 目录缓存<a hidden class="anchor" aria-hidden="true" href="#directory-caching-目录缓存">#</a></h4>
<p>BuildKit 增加到镜像构建的一个特性是目录缓存.
目录缓存是一个非常有用的, 能够加速构建速度的工具, 且不保留运行时非必要的文件到镜像中.
其核心原理是, 允许将镜像内某个目录的内容保存在特殊层中, 该层在构建时可通过绑定挂载方式使用, 并在生成镜像快照前解除挂载.
此功能常用于处理 Linux 包管理器 (apt/apk/dnf 等) 和语言依赖处理器 (npm/bundler/pip 等) 存放数据库及归档文件的目录.</p>
<blockquote>
<p>TIP 提示</p>
</blockquote>
<p><a href="https://docs.docker.com/engine/storage/bind-mounts/">bind mount</a> 绑定挂载是指将宿主机上的一个现有文件或目录直接&quot;映射&quot;到容器内部的一个路径上. 这是一个非常简单的共享方式. 有以下特点:</p>
<ul>
<li>直接访问宿主及文件系统</li>
<li>高性能, 绕过了 Docker 的存储驱动, 直接使用宿主机的文件系统, I/O 性能高</li>
<li>依赖宿主机系统, 需要一个宿主机上的绝对路径, 可移植性差</li>
</ul>
<p>为了支持目录缓存必须开启 BuildKit (较新版本一般都默认开启).
可以使用环境变量在客户端强制使用 <code>DOCKER_BUILDKIT=1</code></p>
<ul>
<li>无缓存</li>
</ul>
<pre tabindex="0"><code>% time docker build --no-cache -t docker.io/spkane/open-mastermind:latest .
[+] Building 49.9s (12/12) FINISHED                                                                                 docker:desktop-linux
 =&gt; [internal] load build definition from Dockerfile                                                                                0.0s
 =&gt; =&gt; transferring dockerfile: 209B                                                                                                0.0s
 =&gt; [internal] load metadata for docker.io/library/python:3.9.15-slim-bullseye                                                      4.4s
 =&gt; [auth] library/python:pull token for registry-1.docker.io                                                                       0.0s
 =&gt; [internal] load .dockerignore                                                                                                   0.0s
 =&gt; =&gt; transferring context: 2B                                                                                                     0.0s
 =&gt; [1/6] FROM docker.io/library/python:3.9.15-slim-bullseye@sha256:ffc6cb648d6993e7c90abb95c2481eb688a6842dfac29bf19e3755454632d  17.6s
 =&gt; =&gt; resolve docker.io/library/python:3.9.15-slim-bullseye@sha256:ffc6cb648d6993e7c90abb95c2481eb688a6842dfac29bf19e3755454632da  0.0s
 =&gt; =&gt; sha256:662193c72f528eec2405a0519d470f5ba9091b8f430b22a3b49c55a8447af08a 1.37kB / 1.37kB                                      0.0s
 =&gt; =&gt; sha256:34a0c56576530bce4b6eb782044f19c72533a5ae02b2b8df527164f3a3eb0f5b 7.50kB / 7.50kB                                      0.0s
 =&gt; =&gt; sha256:6064e7e5b6afa4dc711228eddfd250aebac271830dc184c400ce640020bc2cb0 30.06MB / 30.06MB                                   16.1s
 =&gt; =&gt; sha256:23e07e2954939698377b8fe1a859b2d8d0ed4999c7a6da4c983084d50ca4dbe3 1.07MB / 1.07MB                                      6.4s
 =&gt; =&gt; sha256:b151283f362b5371164a098a8d4d6d6fdac38a5b1dbd8a89b05e200df14e32c3 11.59MB / 11.59MB                                   15.9s
 =&gt; =&gt; sha256:ffc6cb648d6993e7c90abb95c2481eb688a6842dfac29bf19e3755454632daa2 1.86kB / 1.86kB                                      0.0s
 =&gt; =&gt; sha256:bc8cbd54c67de1e886c60718641e2ca3d998c39507cf1912dfa7174999ab8497 234B / 234B                                          7.2s
 =&gt; =&gt; sha256:41d4a1e4080eccd6dce7443cfcf0bd3555cd73e8a962fd672e4a786434739775 3.18MB / 3.18MB                                     14.2s
 =&gt; =&gt; extracting sha256:6064e7e5b6afa4dc711228eddfd250aebac271830dc184c400ce640020bc2cb0                                           0.9s
 =&gt; =&gt; extracting sha256:23e07e2954939698377b8fe1a859b2d8d0ed4999c7a6da4c983084d50ca4dbe3                                           0.1s
 =&gt; =&gt; extracting sha256:b151283f362b5371164a098a8d4d6d6fdac38a5b1dbd8a89b05e200df14e32c3                                           0.3s
 =&gt; =&gt; extracting sha256:bc8cbd54c67de1e886c60718641e2ca3d998c39507cf1912dfa7174999ab8497                                           0.0s
 =&gt; =&gt; extracting sha256:41d4a1e4080eccd6dce7443cfcf0bd3555cd73e8a962fd672e4a786434739775                                           0.2s
 =&gt; [internal] load build context                                                                                                   0.0s
 =&gt; =&gt; transferring context: 69.19kB                                                                                                0.0s
 =&gt; [2/6] RUN mkdir /app                                                                                                            0.4s
 =&gt; [3/6] WORKDIR /app                                                                                                              0.0s
 =&gt; [4/6] COPY . /app                                                                                                               0.0s
 =&gt; [5/6] RUN pip install -r requirements.txt                                                                                      26.9s
 =&gt; [6/6] WORKDIR /app/mastermind                                                                                                   0.0s
 =&gt; exporting to image                                                                                                              0.5s
 =&gt; =&gt; exporting layers                                                                                                             0.5s
 =&gt; =&gt; writing image sha256:d1c84698c57b65e2d4e646c179ad47a15bad22386c6468b3c5c73d88be065dd9                                        0.0s
 =&gt; =&gt; naming to docker.io/spkane/open-mastermind:latest                                                                            0.0s

View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/clviefrt28zp2uvhc9utddc09

What&#39;s next:
    View a summary of image vulnerabilities and recommendations → docker scout quickview
docker build --no-cache -t docker.io/spkane/open-mastermind:latest .  0.52s user 0.41s system 1% cpu 50.602 total
</code></pre><ul>
<li>有缓存</li>
</ul>
<pre tabindex="0"><code>% time docker build -t docker.io/spkane/open-mastermind:latest .
[+] Building 1.1s (11/11) FINISHED                                                                                  docker:desktop-linux
 =&gt; [internal] load build definition from Dockerfile                                                                                0.0s
 =&gt; =&gt; transferring dockerfile: 209B                                                                                                0.0s
 =&gt; [internal] load metadata for docker.io/library/python:3.9.15-slim-bullseye                                                      1.1s
 =&gt; [internal] load .dockerignore                                                                                                   0.0s
 =&gt; =&gt; transferring context: 2B                                                                                                     0.0s
 =&gt; [1/6] FROM docker.io/library/python:3.9.15-slim-bullseye@sha256:ffc6cb648d6993e7c90abb95c2481eb688a6842dfac29bf19e3755454632da  0.0s
 =&gt; [internal] load build context                                                                                                   0.0s
 =&gt; =&gt; transferring context: 2.46kB                                                                                                 0.0s
 =&gt; CACHED [2/6] RUN mkdir /app                                                                                                     0.0s
 =&gt; CACHED [3/6] WORKDIR /app                                                                                                       0.0s
 =&gt; CACHED [4/6] COPY . /app                                                                                                        0.0s
 =&gt; CACHED [5/6] RUN pip install -r requirements.txt                                                                                0.0s
 =&gt; CACHED [6/6] WORKDIR /app/mastermind                                                                                            0.0s
 =&gt; exporting to image                                                                                                              0.0s
 =&gt; =&gt; exporting layers                                                                                                             0.0s
 =&gt; =&gt; writing image sha256:d1c84698c57b65e2d4e646c179ad47a15bad22386c6468b3c5c73d88be065dd9                                        0.0s
 =&gt; =&gt; naming to docker.io/spkane/open-mastermind:latest                                                                            0.0s

View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/fum8hqxpzp4ezege0qoxrd0q3

What&#39;s next:
    View a summary of image vulnerabilities and recommendations → docker scout quickview
docker build -t docker.io/spkane/open-mastermind:latest .  0.25s user 0.53s system 24% cpu 3.223 total
</code></pre><p>从上面可以看出, 无缓存使用了 50.6 秒, 有缓存使用了 3.2 秒.</p>
<p>下面将 Docker 修改成这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="c"># syntax=docker/dockerfile:1</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">FROM</span><span class="w"> </span><span class="s">python:3.9.15-slim-bullseye</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">RUN</span> mkdir /app<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">WORKDIR</span><span class="w"> </span><span class="s">/app</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">COPY</span> . /app<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">RUN</span> --mount<span class="o">=</span><span class="nv">type</span><span class="o">=</span>cache,target<span class="o">=</span>/root/.cache pip install -r requirements.txt<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">WORKDIR</span><span class="w"> </span><span class="s">/app/mastermind</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;python&#34;</span><span class="p">,</span> <span class="s2">&#34;mastermind.py&#34;</span><span class="p">]</span><span class="err">
</span></span></span></code></pre></div><p>这里有两个修改:</p>
<ul>
<li><code>#syntax=docker/dockerfile:1</code> 这个告诉 Docker 使用新版的 <a href="https://hub.docker.com/r/docker/dockerfile">Dockerfile frontend</a>, 这个版本提供了对 BuildKit 的新功能.</li>
<li><code>RUN --mount=type=cache,target=/root/.cache pip install -r requirements.txt</code> 这一行告诉 BuildKit 在构建期间, 将缓存层挂载到容器的 <code>/root/.cache</code> 目录. 这样既能让最终生成的镜像不包含该目录内容, 又能在后续构建时重新挂载缓存供 pip 使用.</li>
</ul>
<p>现在基于这些改动, 完整重新镜像, 生成初始缓存目录内容.
观察构建输出会发现, pip 仍会像之前一样下载所有依赖包:</p>
<pre tabindex="0"><code>time docker bulid --no-cache -t docker.io/spkane/oper-mastermind:latest
</code></pre><p>所以, 现在重新打开 <code>requirements.txt</code> 文件并添加一行 <code>py-events</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">colorama
</span></span><span class="line"><span class="cl">pandas
</span></span><span class="line"><span class="cl">flask
</span></span><span class="line"><span class="cl">log symbols
</span></span><span class="line"><span class="cl">py-events
</span></span></code></pre></div><p>改动之后, 重新构建镜像, 会发现仅下载 <code>py-events</code> 以其依赖项, 其余包都直接用之前构建的缓存, 这些缓存已在构建过程中挂载至镜像.</p>
<p>由于无需每次重新下载所有依赖, 构建时间得以缩短.
尽管镜像中添加了新依赖, 但镜像体积反而减小了, 这是因为缓存目录不再直接存储在应用镜像中.</p>
<h3 id="troubleshooting-borken-builds">Troubleshooting Borken Builds<a hidden class="anchor" aria-hidden="true" href="#troubleshooting-borken-builds">#</a></h3>
<p>在真实世界中, 构建并非总会成功, 下面讨论构建失败时可以做的处理.
会展示两种选择, 一种是使用 pre-BuildKit 的方式, 另一种是通过 BuildKit 的方式.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git clone https://github.com/spkane/docker-node-hello.git --config core.autocrlf<span class="o">=</span>input
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> docker-node-hello
</span></span></code></pre></div><h4 id="debugging-pre-buildkit-images">Debugging Pre-BuildKit Images<a hidden class="anchor" aria-hidden="true" href="#debugging-pre-buildkit-images">#</a></h4>
<p>下面需要一个&quot;问题样本&quot;, 故意制造一个构建失败的情况, 编辑 Dockerfile 为这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">RUN</span> apt-get -y update-all<span class="err">
</span></span></span></code></pre></div><p>运行 build 命令可以看到下面错误结果:</p>
<pre tabindex="0"><code>Step 6/14 : ENV SCPATH /etc/supervisor/conf.d
 ---&gt; Running in e903367eaeb8
Removing intermediate container e903367eaeb8
 ---&gt; 2a236efc3f06
</code></pre><p>可以直接进入中间镜像调试</p>
<pre tabindex="0"><code>docker container run --rm -ti 2a236efc3f06 /bin/bash
</code></pre><h4 id="debugging-buildkit-images">Debugging BuildKit Images<a hidden class="anchor" aria-hidden="true" href="#debugging-buildkit-images">#</a></h4>
<p>当使用 BuildKit 时, 需要采用略有不同的方法来定位构建失败的位置, 因为这种模式下不会将任何中间构建层导出到 Docker daemon.</p>
<p>先将 Dockerfile 恢复, 然后做下面这样的修改:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">RUN</span> npm install<span class="err">
</span></span></span></code></pre></div><p>将其改为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">RUN</span> npm installer<span class="err">
</span></span></span></code></pre></div><p>然后尝试构建容器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker image build -t example/docker-node-hello:debug --no-cache .
</span></span></code></pre></div><p>可以看到下面的报错, 但是要如何进入该层调试呢?</p>
<pre tabindex="0"><code>% docker image build -t example/docker-node-hello:debug --no-cache .
[+] Building 75.6s (13/13) FINISHED                                                                                 docker:desktop-linux
 =&gt; [internal] load build definition from Dockerfile                                                                                0.0s
 =&gt; =&gt; transferring dockerfile: 571B                                                                                                0.0s
 =&gt; [internal] load metadata for docker.io/library/node:18.13.0                                                                     4.3s
 =&gt; [auth] library/node:pull token for registry-1.docker.io                                                                         0.0s
 =&gt; [internal] load .dockerignore                                                                                                   0.0s
 =&gt; =&gt; transferring context: 45B                                                                                                    0.0s
 =&gt; [1/8] FROM docker.io/library/node:18.13.0@sha256:d871edd5b68105ebcbfcde3fe8c79d24cbdbb30430d9bd6251c57c56c7bd7646              59.3s
 =&gt; =&gt; resolve docker.io/library/node:18.13.0@sha256:d871edd5b68105ebcbfcde3fe8c79d24cbdbb30430d9bd6251c57c56c7bd7646               0.0s
 =&gt; =&gt; sha256:59f7398d1dba68c2134d2e01668369079ff301c360bfa587fd574de4e2e5eac4 2.21kB / 2.21kB                                      0.0s
 =&gt; =&gt; sha256:b0cef62e090109630d42120f3ccde32e9813a8d1309fa6be2ae7131e355d75e1 7.53kB / 7.53kB                                      0.0s
 =&gt; =&gt; sha256:7b716680367d1dac0e54c48f75506323e0bb03628542a0fd6db39efeeee9adf5 5.15MB / 5.15MB                                     10.2s
 =&gt; =&gt; sha256:c345c9e441f5f49235768af74b8ab37743652d38958afaa000edd56d7b2f0540 53.68MB / 53.68MB                                   12.0s
 =&gt; =&gt; sha256:0855378f8903bde22cfbcee08cd239678716cf01f24a3fca9478ef4121a84d91 10.87MB / 10.87MB                                   19.8s
 =&gt; =&gt; sha256:d871edd5b68105ebcbfcde3fe8c79d24cbdbb30430d9bd6251c57c56c7bd7646 1.21kB / 1.21kB                                      0.0s
 =&gt; =&gt; sha256:4bfb8dc93d4197860c2bff47f2c2f280c2dd8ed699e7b3241aa325ecee53c7d7 54.68MB / 54.68MB                                   47.1s
 =&gt; =&gt; extracting sha256:c345c9e441f5f49235768af74b8ab37743652d38958afaa000edd56d7b2f0540                                           1.5s
 =&gt; =&gt; sha256:fb726ea60d28211d1e5e9d6fe76eb9ef9546eb38d107263e2a060a99be9ca41c 189.80MB / 189.80MB                                 53.6s
 =&gt; =&gt; extracting sha256:7b716680367d1dac0e54c48f75506323e0bb03628542a0fd6db39efeeee9adf5                                           0.1s
 =&gt; =&gt; extracting sha256:0855378f8903bde22cfbcee08cd239678716cf01f24a3fca9478ef4121a84d91                                           0.1s
 =&gt; =&gt; sha256:02f41717b6ae3dd1225bd22899da6ae2125098a71c9d17d01e126b4afea77912 4.21kB / 4.21kB                                     20.6s
 =&gt; =&gt; sha256:6d99896e8af987dac3892a94d2c45e18132570176d2b2353b64412413655b14a 45.15MB / 45.15MB                                   47.6s
 =&gt; =&gt; sha256:40cff91b82ae9705b4e5a8467d36f2b9b2216e1f5f3df7286cced961ce3d0a6c 2.28MB / 2.28MB                                     48.6s
 =&gt; =&gt; extracting sha256:4bfb8dc93d4197860c2bff47f2c2f280c2dd8ed699e7b3241aa325ecee53c7d7                                           1.5s
 =&gt; =&gt; sha256:5301fac16292b6191f762631ba0429ca19dc854320ceb0ab5f9aadbc6e134367 450B / 450B                                         48.3s
 =&gt; =&gt; extracting sha256:fb726ea60d28211d1e5e9d6fe76eb9ef9546eb38d107263e2a060a99be9ca41c                                           3.8s
 =&gt; =&gt; extracting sha256:02f41717b6ae3dd1225bd22899da6ae2125098a71c9d17d01e126b4afea77912                                           0.0s
 =&gt; =&gt; extracting sha256:6d99896e8af987dac3892a94d2c45e18132570176d2b2353b64412413655b14a                                           1.3s
 =&gt; =&gt; extracting sha256:40cff91b82ae9705b4e5a8467d36f2b9b2216e1f5f3df7286cced961ce3d0a6c                                           0.0s
 =&gt; =&gt; extracting sha256:5301fac16292b6191f762631ba0429ca19dc854320ceb0ab5f9aadbc6e134367                                           0.0s
 =&gt; [internal] load build context                                                                                                   0.0s
 =&gt; =&gt; transferring context: 1.25kB                                                                                                 0.0s
 =&gt; [2/8] RUN apt-get -y update                                                                                                     7.8s
 =&gt; [3/8] RUN apt-get -y install supervisor                                                                                         3.7s
 =&gt; [4/8] RUN mkdir -p /var/log/supervisor                                                                                          0.1s
 =&gt; [5/8] COPY ./supervisord/conf.d/* /etc/supervisor/conf.d/                                                                       0.0s
 =&gt; [6/8] COPY *.js* /data/app/                                                                                                     0.0s
 =&gt; [7/8] WORKDIR /data/app                                                                                                         0.0s
 =&gt; ERROR [8/8] RUN npm installer                                                                                                   0.3s
------
 &gt; [8/8] RUN npm installer:
0.291 Unknown command: &#34;installer&#34;
0.291
0.291 Did you mean this?
0.291     npm install # Install a package
0.291
0.291 To see a list of supported npm commands, run:
0.291   npm help
------
Dockerfile:28
--------------------
  26 |     WORKDIR $AP
  27 |
  28 | &gt;&gt;&gt; RUN npm installer
  29 |
  30 |     CMD [&#34;supervisord&#34;, &#34;-n&#34;]
--------------------
ERROR: failed to build: failed to solve: process &#34;/bin/sh -c npm installer&#34; did not complete successfully: exit code: 1

View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/rbv5sp8i9eiite02u0gpny34p
</code></pre><p>一种方法是使用分阶段构建和 <code>--target</code> 参数, 对 Dockerfile 做如下修改</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="w"> </span><span class="s">docker.io/node:18.13.0</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">deploy</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl">...<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">FROM</span><span class="w"> </span><span class="s">deploy</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">RUN</span> npm installer<span class="err">
</span></span></span></code></pre></div><p>并告诉 Docker 我们只想构建多阶段 Dockerfile 中的第一个镜像</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">% docker image build -t example/docker-node-hello:debug --target deploy .
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Building 2.2s <span class="o">(</span>13/13<span class="o">)</span> FINISHED                                                                                  docker:desktop-linux
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">[</span>internal<span class="o">]</span> load build definition from Dockerfile                                                                                0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">=</span>&gt; transferring dockerfile: 594B                                                                                                0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">[</span>internal<span class="o">]</span> load metadata <span class="k">for</span> docker.io/library/node:18.13.0                                                                     2.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">[</span>auth<span class="o">]</span> library/node:pull token <span class="k">for</span> registry-1.docker.io                                                                         0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">[</span>internal<span class="o">]</span> load .dockerignore                                                                                                   0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">=</span>&gt; transferring context: 45B                                                                                                    0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">[</span>deploy 1/7<span class="o">]</span> FROM docker.io/library/node:18.13.0@sha256:d871edd5b68105ebcbfcde3fe8c79d24cbdbb30430d9bd6251c57c56c7bd7646        0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">[</span>internal<span class="o">]</span> load build context                                                                                                   0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">=</span>&gt; transferring context: 233B                                                                                                   0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; CACHED <span class="o">[</span>deploy 2/7<span class="o">]</span> RUN apt-get -y update                                                                                       0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; CACHED <span class="o">[</span>deploy 3/7<span class="o">]</span> RUN apt-get -y install supervisor                                                                           0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; CACHED <span class="o">[</span>deploy 4/7<span class="o">]</span> RUN mkdir -p /var/log/supervisor                                                                            0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; CACHED <span class="o">[</span>deploy 5/7<span class="o">]</span> COPY ./supervisord/conf.d/* /etc/supervisor/conf.d/                                                         0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; CACHED <span class="o">[</span>deploy 6/7<span class="o">]</span> COPY *.js* /data/app/                                                                                       0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; CACHED <span class="o">[</span>deploy 7/7<span class="o">]</span> WORKDIR /data/app                                                                                           0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; exporting to image                                                                                                              0.1s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">=</span>&gt; exporting layers                                                                                                             0.1s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">=</span>&gt; writing image sha256:ae71d11ef13c04b4f115593fae4ad47653f324aa8eadc14c4198838fa07808ae                                        0.0s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">=</span>&gt; naming to docker.io/example/docker-node-hello:debug                                                                          0.0s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/b4c9n1kiv17fobm4q5qhndmvw
</span></span></code></pre></div><p>然后就可以创建该容器, 并进入调试了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">% docker container run --rm -ti docker.io/example/docker-node-hello:debug /bin/bash
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">root@ce6a659c9171:/data/app# ls
</span></span><span class="line"><span class="cl">index.js  package.json
</span></span><span class="line"><span class="cl">root@ce6a659c9171:/data/app# npm install
</span></span><span class="line"><span class="cl">npm WARN EBADENGINE Unsupported engine <span class="o">{</span>
</span></span><span class="line"><span class="cl">npm WARN EBADENGINE   package: <span class="s1">&#39;formidable@1.0.13&#39;</span>,
</span></span><span class="line"><span class="cl">npm WARN EBADENGINE   required: <span class="o">{</span> node: <span class="s1">&#39;&lt;0.9.0&#39;</span> <span class="o">}</span>,
</span></span><span class="line"><span class="cl">npm WARN EBADENGINE   current: <span class="o">{</span> node: <span class="s1">&#39;v18.13.0&#39;</span>, npm: <span class="s1">&#39;8.19.3&#39;</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">npm WARN EBADENGINE <span class="o">}</span>
</span></span><span class="line"><span class="cl">npm WARN deprecated mkdirp@0.3.4: Legacy versions of mkdirp are no longer supported. Please update to mkdirp 1.x. <span class="o">(</span>Note that the API surface has changed to use Promises in 1.x.<span class="o">)</span>
</span></span><span class="line"><span class="cl">npm WARN deprecated formidable@1.0.13: Please upgrade to latest, formidable@v2 or formidable@v3! Check these notes: https://bit.ly/2ZEqIau
</span></span><span class="line"><span class="cl">npm WARN deprecated connect@2.7.9: connect 2.x series is deprecated
</span></span><span class="line"><span class="cl">npm WARN deprecated express@3.2.4: No longer maintained. Please upgrade to a stable version.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">added <span class="m">18</span> packages, and audited <span class="m">19</span> packages in 4s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">8</span> vulnerabilities <span class="o">(</span><span class="m">1</span> low, <span class="m">1</span> moderate, <span class="m">6</span> high<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">To address all issues <span class="o">(</span>including breaking changes<span class="o">)</span>, run:
</span></span><span class="line"><span class="cl">  npm audit fix --force
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Run <span class="sb">`</span>npm audit<span class="sb">`</span> <span class="k">for</span> details.
</span></span><span class="line"><span class="cl">npm notice
</span></span><span class="line"><span class="cl">npm notice New major version of npm available! 8.19.3 -&gt; 11.6.1
</span></span><span class="line"><span class="cl">npm notice Changelog: https://github.com/npm/cli/releases/tag/v11.6.1
</span></span><span class="line"><span class="cl">npm notice Run npm install -g npm@11.6.1 to update!
</span></span><span class="line"><span class="cl">npm notice
</span></span><span class="line"><span class="cl">root@ce6a659c9171:/data/app# <span class="nb">exit</span>
</span></span><span class="line"><span class="cl"><span class="nb">exit</span>
</span></span></code></pre></div><p>一但发现了错误原因, 就可以修改 Dockerfile 里错误的地方了.</p>
<h3 id="multiarchitecture-builds">Multiarchitecture Builds<a hidden class="anchor" aria-hidden="true" href="#multiarchitecture-builds">#</a></h3>
<p>在 Docker 诞生之初, 主流的平台都是 AMR64/X86_64 架构.
然而, 现在越来越多的开发者使用 ARM64/AArch64 架构, 并且由于 ARM 平台更低的计算成本, 云服务商也开始制作基于 ARM 的 VM.</p>
<p>构建多架构平台的镜像, 即有趣又有挑战性.
如何在支持不同目标架构的同时, 维持一个简洁统一的代码库和流水线?</p>
<p>幸运的是, Docker 发布了一个名为 buildx 的 docker CLI 插件, 能让这个过程变得相当简单.
在很多情况下 docker-buildx 已经预装在系统上, 使用下面命令验证</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">% docker buildx version
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">github.com/docker/buildx v0.28.0-desktop.1 8ad457cf5e291fcb7152ef6946162cc811a2fb29
</span></span></code></pre></div><p>默认情况下, docker-buildx 会使用 <a href="https://www.qemu.org/">QEMU-based virtualizatoin</a> 和 <a href="https://docs.kernel.org/admin-guide/binfmt-misc.html">binfmt_misc</a> 来支持不同系统架构.
运行下面命令来确保 QEMU 文件注册且更新了:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker container run --rm --privileged multiarch/qemu-user-static --reset -p yes
</span></span></code></pre></div><p>与直接在服务器上运行的原始嵌入 Docker 构建功能不同, BuildKit 在构建镜像时可以利用一个构建容器, 这意味着该构建容器能够提供极大的功能灵活性, 使用下面条命令, 创建名为&quot;build&quot; 的 build container:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">% docker buildx create --name builder --drive docker-container --use
</span></span><span class="line"><span class="cl">builder
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">% docker buildx inspect --bootstrap
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>+<span class="o">]</span> Building 0.4s <span class="o">(</span>1/1<span class="o">)</span> <span class="nv">FINISHED</span>
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">[</span>internal<span class="o">]</span> booting buildkit                                                                                                     0.4s
</span></span><span class="line"><span class="cl"> <span class="o">=</span>&gt; <span class="o">=</span>&gt; starting container buildx_buildkit_builder0                                                                                  0.4s
</span></span><span class="line"><span class="cl">Name:          builder
</span></span><span class="line"><span class="cl">Driver:        docker-container
</span></span><span class="line"><span class="cl">Last Activity: 2025-09-25 07:24:07 +0000 UTC
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Nodes:
</span></span><span class="line"><span class="cl">Name:                  builder0
</span></span><span class="line"><span class="cl">Endpoint:              desktop-linux
</span></span><span class="line"><span class="cl">Status:                running
</span></span><span class="line"><span class="cl">BuildKit daemon flags: --allow-insecure-entitlement<span class="o">=</span>network.host
</span></span><span class="line"><span class="cl">BuildKit version:      v0.24.0
</span></span><span class="line"><span class="cl">Platforms:             linux/arm64, linux/amd64, linux/amd64/v2, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/arm/v7, linux/arm/v6
</span></span><span class="line"><span class="cl">Labels:
</span></span><span class="line"><span class="cl"> org.mobyproject.buildkit.worker.executor:         oci
</span></span><span class="line"><span class="cl"> org.mobyproject.buildkit.worker.hostname:         41f436ea555f
</span></span><span class="line"><span class="cl"> org.mobyproject.buildkit.worker.network:          host
</span></span><span class="line"><span class="cl"> org.mobyproject.buildkit.worker.oci.process-mode: sandbox
</span></span><span class="line"><span class="cl"> org.mobyproject.buildkit.worker.selinux.enabled:  <span class="nb">false</span>
</span></span><span class="line"><span class="cl"> org.mobyproject.buildkit.worker.snapshotter:      overlayfs
</span></span><span class="line"><span class="cl">GC Policy rule#0:
</span></span><span class="line"><span class="cl"> All:            <span class="nb">false</span>
</span></span><span class="line"><span class="cl"> Filters:        <span class="nv">type</span><span class="o">==</span>source.local,type<span class="o">==</span>exec.cachemount,type<span class="o">==</span>source.git.checkout
</span></span><span class="line"><span class="cl"> Keep Duration:  48h0m0s
</span></span><span class="line"><span class="cl"> Max Used Space: 488.3MiB
</span></span><span class="line"><span class="cl">GC Policy rule#1:
</span></span><span class="line"><span class="cl"> All:            <span class="nb">false</span>
</span></span><span class="line"><span class="cl"> Keep Duration:  1440h0m0s
</span></span><span class="line"><span class="cl"> Reserved Space: 5.588GiB
</span></span><span class="line"><span class="cl"> Max Used Space: 43.77GiB
</span></span><span class="line"><span class="cl"> Min Free Space: 11.18GiB
</span></span><span class="line"><span class="cl">GC Policy rule#2:
</span></span><span class="line"><span class="cl"> All:            <span class="nb">false</span>
</span></span><span class="line"><span class="cl"> Reserved Space: 5.588GiB
</span></span><span class="line"><span class="cl"> Max Used Space: 43.77GiB
</span></span><span class="line"><span class="cl"> Min Free Space: 11.18GiB
</span></span><span class="line"><span class="cl">GC Policy rule#3:
</span></span><span class="line"><span class="cl"> All:            <span class="nb">true</span>
</span></span><span class="line"><span class="cl"> Reserved Space: 5.588GiB
</span></span><span class="line"><span class="cl"> Max Used Space: 43.77GiB
</span></span><span class="line"><span class="cl"> Min Free Space: 11.18GiB
</span></span></code></pre></div><p>下面下载 wordchain 的 Git 代码库, 该库包含一个实用工具, 可以生成随机且可确定 (seed) 的词语序列, 可以满足动态命名的需求:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git clone https://github.com/spkane/wordchain.git <span class="se">\
</span></span></span><span class="line"><span class="cl">    --config core.autocrlf<span class="o">=</span>input
</span></span></code></pre></div><p>查看里面的 Dockerfile 可以看到这是一个很正常的多阶段构建, 不含有任何关于架构的东西</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="w"> </span><span class="s">golang:1.18-alpine3.15</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">build</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">RUN</span> apk --no-cache add <span class="se">\
</span></span></span><span class="line"><span class="cl">    bash <span class="se">\
</span></span></span><span class="line"><span class="cl">    gcc <span class="se">\
</span></span></span><span class="line"><span class="cl">    musl-dev <span class="se">\
</span></span></span><span class="line"><span class="cl">    openssl<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">ENV</span> <span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">COPY</span> . /build<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">WORKDIR</span><span class="w"> </span><span class="s">/build</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">RUN</span> go install github.com/markbates/pkger/cmd/pkger@latest <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl">    pkger -include /data/words.json <span class="o">&amp;&amp;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl">    go build .<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">FROM</span><span class="w"> </span><span class="s">alpine:3.15</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">deploy</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl">WORKDIR /<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">COPY</span> --from<span class="o">=</span>build /build/wordchain /<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">USER</span><span class="w"> </span><span class="s">500</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">EXPOSE</span><span class="w"> </span><span class="s">8080</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&#34;/wordchain&#34;</span><span class="p">]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;listen&#34;</span><span class="p">]</span><span class="err">
</span></span></span></code></pre></div><p>第一步是先构建静态编译好的 go 库, 然后第二步, 将其打包到一个小的镜像部署.</p>
<p>Dockerfile 中的 <code>ENTRYPOINT</code> 指令是一项高级功能, 运行将容器运行的默认进程 ENTRYPOINT 与传递给该进程的命令 CMD 分离开来.
当缺少 ENTRYPOINT 指令时, CMD 指令就需要同时包含进程本身以及其所需要的全部命令行参数.</p>
<p>现在可以构建镜像, 并运行下面命令侧加载到 Docker daemon 中:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker buildx build --tag wordchain:test --load .
</span></span></code></pre></div><p>如果要构建多种架构的, 只需要简单的添加 <code>--platform</code> 参数即可.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker buildx build --platform linux/amd64, linux/arm64 --tag wordchain:test .
</span></span></code></pre></div><p>由于在为非本地架构构建镜像时需要模拟运行, 某些步骤比正常情况下花费的时间要长得多, 这是由于模拟运行带来的额外计算开销, 这是正常现象.
可以通过配置 Docker, 使其在具有匹配架构的工作节点上构建每个镜像, 这在许多情况下应该能显著加快构建速度.
Docker 博客的<a href="https://www.docker.com/blog/speed-up-building-with-docker-buildx-and-graviton2-ec2/">这篇文章</a>有相关信息.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/docker/">Docker</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/dealing-with-grabage-in-python/">
    <span class="title">« Prev</span>
    <br>
    <span>Dealing With Grabage in Python</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/docker-workflow/">
    <span class="title">Next »</span>
    <br>
    <span>Docker - Workflow</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Images on x"
            href="https://x.com/intent/tweet/?text=Docker%20-%20Images&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-images%2f&amp;hashtags=Docker">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Images on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-images%2f&amp;title=Docker%20-%20Images&amp;summary=Docker%20-%20Images&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-images%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Images on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-images%2f&title=Docker%20-%20Images">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Images on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-images%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Images on whatsapp"
            href="https://api.whatsapp.com/send?text=Docker%20-%20Images%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-images%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Images on telegram"
            href="https://telegram.me/share/url?text=Docker%20-%20Images&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-images%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Images on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Docker%20-%20Images&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-images%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">Starslayerx&#39; Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
