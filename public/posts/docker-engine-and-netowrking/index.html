<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Docker - Engine and Netowrking | Starslayerx&#39; Blog</title>
<meta name="keywords" content="Docker">
<meta name="description" content="Docker 引擎(Docker Engine), 顾名思意，是 Docker 的核心.
它为 Docker 提供动力, 并承担所有繁重的工作.
本文将深入探讨这一关键组件的内部运作, 以便了解 Docker 在内核下是如何工作的.
The Evolution of the Docker Engine | Docker 引擎的演进
Docker 最初是一个巨大的单体(monolith), 所有代码都塞在同一个项目里.
对于 dotCloud来说, 这种方式一开始是可行的.
实际上, 这个方向运作得非常好, 以至于他们放弃了其他服务、把所有赌注都押在 Docker 上, 甚至把公司重命名为 Docker, Inc.
一开始, Docker 是一个又大又混乱的单体应用.
随着时间推移, Docker, Inc. 发现这种做法不可持续, 他们需要把系统拆分出来:

各个部分可以独立成长
更容易升级某些部分 - 可以替换旧组件而不影响整体
让社区更容易参与贡献 - 更小的组件意味着更多人能参与进来
更易跨平台 - 他们想要 Docker 在每个平台上运行, 而不只是 Linux

拆分的第一步是把客户端 client 剥离出来.
把客户端从大应用中抽出, 赋予它新职责: 把用户命令翻译成 Docker 引擎能理解的指令(也就是原来单体里&quot;内核部分&quot;的接口)
此时, Docker 引擎主要有两部分:">
<meta name="author" content="Starslayerx">
<link rel="canonical" href="http://localhost:1313/posts/docker-engine-and-netowrking/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.svg">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon.svg">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon.svg">
<link rel="mask-icon" href="http://localhost:1313/favicon.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/docker-engine-and-netowrking/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="http://localhost:1313/posts/docker-engine-and-netowrking/">
  <meta property="og:site_name" content="Starslayerx&#39; Blog">
  <meta property="og:title" content="Docker - Engine and Netowrking">
  <meta property="og:description" content="Docker 引擎(Docker Engine), 顾名思意，是 Docker 的核心. 它为 Docker 提供动力, 并承担所有繁重的工作. 本文将深入探讨这一关键组件的内部运作, 以便了解 Docker 在内核下是如何工作的.
The Evolution of the Docker Engine | Docker 引擎的演进 Docker 最初是一个巨大的单体(monolith), 所有代码都塞在同一个项目里. 对于 dotCloud来说, 这种方式一开始是可行的. 实际上, 这个方向运作得非常好, 以至于他们放弃了其他服务、把所有赌注都押在 Docker 上, 甚至把公司重命名为 Docker, Inc.
一开始, Docker 是一个又大又混乱的单体应用. 随着时间推移, Docker, Inc. 发现这种做法不可持续, 他们需要把系统拆分出来:
各个部分可以独立成长 更容易升级某些部分 - 可以替换旧组件而不影响整体 让社区更容易参与贡献 - 更小的组件意味着更多人能参与进来 更易跨平台 - 他们想要 Docker 在每个平台上运行, 而不只是 Linux 拆分的第一步是把客户端 client 剥离出来. 把客户端从大应用中抽出, 赋予它新职责: 把用户命令翻译成 Docker 引擎能理解的指令(也就是原来单体里&#34;内核部分&#34;的接口)
此时, Docker 引擎主要有两部分:">
  <meta property="og:locale" content="en-US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-09-04T08:00:00+08:00">
    <meta property="article:modified_time" content="2025-09-04T08:00:00+08:00">
    <meta property="article:tag" content="Docker">
      <meta property="og:image" content="http://localhost:1313/images/og-default.avif">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/og-default.avif">
<meta name="twitter:title" content="Docker - Engine and Netowrking">
<meta name="twitter:description" content="Docker 引擎(Docker Engine), 顾名思意，是 Docker 的核心.
它为 Docker 提供动力, 并承担所有繁重的工作.
本文将深入探讨这一关键组件的内部运作, 以便了解 Docker 在内核下是如何工作的.
The Evolution of the Docker Engine | Docker 引擎的演进
Docker 最初是一个巨大的单体(monolith), 所有代码都塞在同一个项目里.
对于 dotCloud来说, 这种方式一开始是可行的.
实际上, 这个方向运作得非常好, 以至于他们放弃了其他服务、把所有赌注都押在 Docker 上, 甚至把公司重命名为 Docker, Inc.
一开始, Docker 是一个又大又混乱的单体应用.
随着时间推移, Docker, Inc. 发现这种做法不可持续, 他们需要把系统拆分出来:

各个部分可以独立成长
更容易升级某些部分 - 可以替换旧组件而不影响整体
让社区更容易参与贡献 - 更小的组件意味着更多人能参与进来
更易跨平台 - 他们想要 Docker 在每个平台上运行, 而不只是 Linux

拆分的第一步是把客户端 client 剥离出来.
把客户端从大应用中抽出, 赋予它新职责: 把用户命令翻译成 Docker 引擎能理解的指令(也就是原来单体里&quot;内核部分&quot;的接口)
此时, Docker 引擎主要有两部分:">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Docker - Engine and Netowrking",
      "item": "http://localhost:1313/posts/docker-engine-and-netowrking/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker - Engine and Netowrking",
  "name": "Docker - Engine and Netowrking",
  "description": "Docker 引擎(Docker Engine), 顾名思意，是 Docker 的核心. 它为 Docker 提供动力, 并承担所有繁重的工作. 本文将深入探讨这一关键组件的内部运作, 以便了解 Docker 在内核下是如何工作的.\nThe Evolution of the Docker Engine | Docker 引擎的演进 Docker 最初是一个巨大的单体(monolith), 所有代码都塞在同一个项目里. 对于 dotCloud来说, 这种方式一开始是可行的. 实际上, 这个方向运作得非常好, 以至于他们放弃了其他服务、把所有赌注都押在 Docker 上, 甚至把公司重命名为 Docker, Inc.\n一开始, Docker 是一个又大又混乱的单体应用. 随着时间推移, Docker, Inc. 发现这种做法不可持续, 他们需要把系统拆分出来:\n各个部分可以独立成长 更容易升级某些部分 - 可以替换旧组件而不影响整体 让社区更容易参与贡献 - 更小的组件意味着更多人能参与进来 更易跨平台 - 他们想要 Docker 在每个平台上运行, 而不只是 Linux 拆分的第一步是把客户端 client 剥离出来. 把客户端从大应用中抽出, 赋予它新职责: 把用户命令翻译成 Docker 引擎能理解的指令(也就是原来单体里\u0026quot;内核部分\u0026quot;的接口)\n此时, Docker 引擎主要有两部分:\n",
  "keywords": [
    "Docker"
  ],
  "articleBody": "Docker 引擎(Docker Engine), 顾名思意，是 Docker 的核心. 它为 Docker 提供动力, 并承担所有繁重的工作. 本文将深入探讨这一关键组件的内部运作, 以便了解 Docker 在内核下是如何工作的.\nThe Evolution of the Docker Engine | Docker 引擎的演进 Docker 最初是一个巨大的单体(monolith), 所有代码都塞在同一个项目里. 对于 dotCloud来说, 这种方式一开始是可行的. 实际上, 这个方向运作得非常好, 以至于他们放弃了其他服务、把所有赌注都押在 Docker 上, 甚至把公司重命名为 Docker, Inc.\n一开始, Docker 是一个又大又混乱的单体应用. 随着时间推移, Docker, Inc. 发现这种做法不可持续, 他们需要把系统拆分出来:\n各个部分可以独立成长 更容易升级某些部分 - 可以替换旧组件而不影响整体 让社区更容易参与贡献 - 更小的组件意味着更多人能参与进来 更易跨平台 - 他们想要 Docker 在每个平台上运行, 而不只是 Linux 拆分的第一步是把客户端 client 剥离出来. 把客户端从大应用中抽出, 赋予它新职责: 把用户命令翻译成 Docker 引擎能理解的指令(也就是原来单体里\"内核部分\"的接口)\n此时, Docker 引擎主要有两部分:\nDaemon 守护进程: 处理容器、网络和卷 LXC: Docker 与 Linux 内核之间的中间层 Breaking Things for the Better 为了更好的架构而拆分 然而, 这个架构存在问题:\nLXC 仅限于 Linux, 若要支持 Windows 或 macOS 这就难办了 守护进程负担过重, 它做的事情太多, 需要\"放轻松\" 因此, Docker 放弃了 LXC, 缓存更灵活, 冯举平台适应性的 libcontainer. 同时, 他们也减轻了守护进程的职责, 把守护进程做成更简单的 API 接口, 供客户端与之通信.\n但这还不是终点. libcontainer 本身仍然太大、太笨重. 于是 Docker 把它进一步拆成更小的部分: docker-init、runc、containerd 和 shim, 每个组件只做一件事, 这带来了:\n更好的分工协作: 社区可以专注于特定组件 自由试验: 开发者可以像搭积木一样替换或组合部件 更清晰的设计: 不再是纠结在一起的杂乱代码 Specs and Standards 规范与标准 Docker 引擎严格遵循开放容器倡议 OCI 的协议和标准, 意味着你用 Docker 引擎构建的镜像, 只要目标平台也遵循 OCI 标准, 就能在别的容器平台上运行.\nDocker 引擎帮助你 build 构建、ship 分发和 run 运行符合 OCI 的镜像, 这三个阶段由三大标准引导:\nImage Specification 镜像规范: 该规范定义了容器镜像如何被创建, 相当于容器内部包含内容(依赖、配置等)的详细蓝图 Distribution Specification 分发规范: 该规范规定了容器镜像如何共享与传输, 相当于定义了一套\"运输网络\"的规则, 确保镜像能从 A 点到 B 点顺利传输 Runtime Specification 运行时规范: 该规范描述容器如何被执行和管理, 从启动/停止到与宿主系统交互, 即运行时的行为规则 历史部分就到这, 下面进入重点: 逐块剖析 Docker 的当前架构, 看看它们如何协同\nHow a Command is Processed in the Docker System? 一个命令是如何被处理的? 现在来拆解一下, 当运行如下命令时发生是事情:\ndocker start my-container 这实际上是在和 Docker CLI (client) 打交道, CLI 就像是翻译器, 将输入的命令转换成 Docker daemon 守护进程能懂的东西.\n流程大致如下:\nCommand Translation 命令翻译: Docker CLI 将命令转换为一个 API 调用, 例如 REST 或 gRPC, CLI 会将输入命令翻译成这两种格式之一 Sending the Request 发送请求: 翻译完成后 CLI 将请求发送给 Docker daemon, 即守护进程, 是操作中心, 它接受请求、处理请求, 并在幕后完成实际工作 因此, 当输入 docker start my-container 的时候, CLI 会告诉守护进程, 守护进程收到后就开始工作, 协调一切将容器启动起来\nThe Daemon 守护进程 守护进程就像 Docker 的前台接待员, 它为客户端 (例如 Docker CLI) 提供一个接口, 通过高级抽象与 Docker 引擎交互. 当守护进程接到请求时, 他会验证并处理该命令, 然后将请求翻译为更低一级的指令, 交给另一个模块 containerd\ncontainerd 顺带一提: c 小写是风格选择; d 表示 daemon\nDocker 引擎的模块化设计意味着它被拆分为更小的组件, 模块化的好处是灵活与可扩展: 可以替换、更新或者扩展单个部件, 而不是修改整个系统\ncontainerd 是一个高层运行时(high-level runtime), 复杂从容器声明周期的整体角度进行管理, 就像项目经理:\n创建、启动、停止并删除容器 管理网络与卷 (volumes) 拉取镜像 (pull images) 处理容器级别的其他需求 当守护进程将命令发送给 containerd 时, containerd 会准备容器, 但不直接执行容器的实际进程, 它依赖一个更低层次的专用运行时 runc 来完成具体工作.\nrunc r 小写是 Unix 风格, c 指 container 容器\nrunc 的职责非常单一: 运行 OCI 容器, 这里的 OCI 指的是行业标准的容器和镜像协议, 为了兼容与互操作而存在.\n创建容器环境 启动容器进程 确保容器在宿主环境的边界内运行 虽然 runc 很重要, 但 containerd 与它的交互方式引入了额外的一些灵活性, containerd 并不直接与 runc 强耦合: 它通过一个抽象, shim 来与 runc 交互.\nShims 桥接进程 在 containerd 的上下文中, shim 是一个轻量级的进程, 位于 containerd 和实际的容器运行时之间. 它的主要作用是将 containerd 与运行时解耦, 保证灵活性与独立性, 这允许 containerd 管理容器, 而无需紧密耦合到特定运行时.\n当 containerd 启动一个容器时, 他会启动一个 shim 进程, shim 则调用运行时来设置容器. runc 完成诸如设置命名空间和 cgroups, 挂载文件系统, 启动容器化等\"重活\". 但一旦容器启动, runc 就会退出, 留下 shim 来管理容器的声明周期交互. shim 功能如下:\n流程管理: 保持容器进程存活并处理信号 I/O 流: 保持日志并转发容器与 containerd 之间的输入/输出 声明周期事件: 监控并上报诸如容器终止等事件 如果所有底层运行时都遵循 OCI 运行时规范, 为什么 containerd 还需要 shim? 单胺是模块化和关注点分离:\n解耦: shim 抽象出容器特定的操作, 使 containerd 能专注于管理多个容器以及他们的网络与卷, 而不必处理每个容器的细节 灵活性: 有了 shim 就可以比较容易替换掉 runc, 改用同样遵守 OCI 的其他运行时, 架构因此能使用新技术 简化: 每个 shim 只处理一个容器, 这种分离确保单个应用容器的问题不会波及到其他容器 From Shim to Docker-init 当 shim 接手后, 它继续管理容器的生命周期. 不过, Docker 引擎还需要与容器内的进程交互, 比如确保日志、信号和资源得到适当处理. 这就是 docker-init 的作用, 它在容器内部充当 PID 1 的角色, 管理并清理容器化应用的资源.\nDocker-init: The Unsung Hero of Containers / 容器中的无明英雄 在每个容器内部, PID 1 是最关键的首个进程. 容器只要 PID 1 运行, 就存活. 所以, PID 1 的容器生命周期的基石. 当 containerd 需要停止或终止容器时, 他会依赖 PID 1 来确保容器内的所有子进程被正确清理. 如果 PID 1 退出, 所有关联的子进程会自动被终止.\ndocker-init 的关键作用之一是清理僵尸进程 zombie processes, 那些执行完没有被父进程回收的\"被遗忘\"的子进程. 这类进程若放任不管, 会逐渐占用系统资源. docker-init 会及时回收它们, 保持容器环境整洁与高效.\n另一项重要任务是处理系统信号(例如 SIGTERM 或 SIGINT), 许多容器化应用本身并不善于处理这些信号, 可能导致不完整或粗暴的关闭. docker-init 会捕捉这些信号, 并适当地转发, 保证容器内的应用能优雅地退出.\n作为 PID 1, docker-init 也为容器化应用提供了一个可预期且稳定的运行基础. 它的存在简化了容器生命周期的管理, 使容器更加稳定可靠.\n总之, docker-init 确保容器保持干净, 响应迅速并得到良好管理. 它不一定显眼, 但正是这些细小的贡献让容器变得可靠且高效.\nNetwork Ports and Unix Sockets 网络端口和Unix套节字 Docker CLI 和 docker daemon 可以通过 Unix Sockets 和 network ports 沟通. Docker, Inc. 已经向 Internet Assigned Numbers Authority(IANA)注册了3个端口, 用于Docker daemon 和 client:\nTCP port 2375 用于未加密连接 port 2376 用于 SSL 加密连接 port 2377 用于 Docker Swarm mode 在需要使用不同设置的场景下, 更换端口配置很容易. Docker 安装程序的默认设置是只使用 Unix 套接字与本地 Docker 守护进程通信. 这样做可以确保系统默认采用尽可能安全的安装方式. 这个选项同样可以方便地修改, 但强烈建议不要用网络端口来暴露 Docker, 因为 Docker 守护进程内部并没有用户认证和基于角色的访问控制. Unix 套接字在不同操作系统的路径可能不同, 但在大多数情况下可以在 /var/run/docker.sock 找到.\nContainer Networking 容器网络 尽管 Linux 容器在很大程度上是宿主机上运行的进程, 但在网络层他们通常表现得与其他进程很不一样. Docker 最初只支持一种网络模型, 但现在提供了多种稳健的配置, 可以曼珠大多数应用的需求. 大多数人以默认配置运行容器, 这称为桥接模式 Bridge Mode.\n要理解桥接模式, 最容易是把每个 Linux 容器看作是在私有网络上的一台主机. Docker 服务器充当一个虚拟桥 virtual bridge, 容器则是作为桥后的客户端. 桥只是一个把一侧流量转发到另一侧的网络设备. 因此, 可以将它想象成一个虚拟网络, 每个容器像附着在该网络上的主机. 实际上是: 每个容器都有一个虚拟以太网接口连接到 Docker 桥, 并未该虚拟接口分配一个 IP 地址. Docker 运行在宿主机上绑定并暴露单个或一组端口到容器, 以便外部世界可以通过这些端口访问容器, 流量很大程度上由 vpnkit 库来管理.\nDocker 从 未使用的 RFC 1918 私有子网块中分配私有子网, 它检测主机上有哪些网络块未被使用, 并把其中一个分配给虚拟网络. 该网络通过服务器上的一个名为 docker0 的接口桥接到宿主机的本地网络. 这意味着默认情况下, 所有容器都在同一个网络中, 可以直接相互通信. 但要达到宿主机或外部网络, 他们会通过 docker0 虚拟桥接接口转发出去.\n有多种方式配置 Docker 的网络层, 从分配自己的网络块到配置自定义桥接接口, 方式繁多让人眼花缭乱. 人们通常使用默认机制, 但有时需要更复杂或更贴合应用的配置.\nSummary 总结 Docker 引擎不仅仅是一款软件, 它是一套精心设计的模块化组件系统, 这些组件协同工作以实现容器的高效、可扩展与可移植. 从 CLI 中敲下命令, 到 runc、shim、docker-init 所处理的底层操作, 每个元素都扮演者明确且重要的角色.\n通过遵守严格的 OCI 标准, Docker 确保其生态系统不仅强大, 且具备通用兼容性. 这种遵循标准的做法建立了信任, 为开发者与企业提供了稳定的基础, 模块化架构简化了容器管理, 并鼓励创新, 允许每个组件独立演进与改善.\n理解 Docker 引擎不仅是知道容器如何工作, 更是认识其背后经过深思熟虑的工程设计. 正是这种工程让现代软件开发更快、更高效、更容易上手.\n",
  "wordCount" : "653",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/og-default.avif","datePublished": "2025-09-04T08:00:00+08:00",
  "dateModified": "2025-09-04T08:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "Starslayerx"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/docker-engine-and-netowrking/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Starslayerx' Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.svg"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Starslayerx&#39; Blog (Alt + H)">
                <img src="http://localhost:1313/favicon.svg" alt="" aria-label="logo"
                    height="35">Starslayerx&#39; Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                    <ul class="lang-switch"><li>|</li>
                        <li>
                            <a href="http://localhost:1313/zh-cn/" title="简体中文"
                                aria-label="简体中文">Zh-Cn</a>
                        </li>
                    </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Docker - Engine and Netowrking
    </h1>
    <div class="post-meta"><span title='2025-09-04 08:00:00 +0800 CST'>September 4, 2025</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>653 words</span>&nbsp;·&nbsp;<span>Starslayerx</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#the-evolution-of-the-docker-engine--docker-引擎的演进">The Evolution of the Docker Engine | Docker 引擎的演进</a></li>
        <li><a href="#breaking-things-for-the-better-为了更好的架构而拆分">Breaking Things for the Better 为了更好的架构而拆分</a></li>
        <li><a href="#specs-and-standards-规范与标准">Specs and Standards 规范与标准</a></li>
        <li><a href="#how-a-command-is-processed-in-the-docker-system-一个命令是如何被处理的">How a Command is Processed in the Docker System? 一个命令是如何被处理的?</a>
          <ul>
            <li><a href="#the-daemon-守护进程">The Daemon 守护进程</a></li>
            <li><a href="#containerd">containerd</a></li>
            <li><a href="#runc">runc</a></li>
            <li><a href="#shims-桥接进程">Shims 桥接进程</a></li>
            <li><a href="#from-shim-to-docker-init">From Shim to Docker-init</a></li>
            <li><a href="#docker-init-the-unsung-hero-of-containers--容器中的无明英雄">Docker-init: The Unsung Hero of Containers / 容器中的无明英雄</a></li>
          </ul>
        </li>
        <li><a href="#network-ports-and-unix-sockets-网络端口和unix套节字">Network Ports and Unix Sockets 网络端口和Unix套节字</a></li>
        <li><a href="#container-networking-容器网络">Container Networking 容器网络</a></li>
        <li><a href="#summary-总结">Summary 总结</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>Docker 引擎(Docker Engine), 顾名思意，是 Docker 的核心.
它为 Docker 提供动力, 并承担所有繁重的工作.
本文将深入探讨这一关键组件的内部运作, 以便了解 Docker 在内核下是如何工作的.</p>
<h3 id="the-evolution-of-the-docker-engine--docker-引擎的演进">The Evolution of the Docker Engine | Docker 引擎的演进<a hidden class="anchor" aria-hidden="true" href="#the-evolution-of-the-docker-engine--docker-引擎的演进">#</a></h3>
<p>Docker 最初是一个巨大的单体(monolith), 所有代码都塞在同一个项目里.
对于 dotCloud来说, 这种方式一开始是可行的.
实际上, 这个方向运作得非常好, 以至于他们放弃了其他服务、把所有赌注都押在 Docker 上, 甚至把公司重命名为 Docker, Inc.</p>
<p>一开始, Docker 是一个又大又混乱的单体应用.
随着时间推移, Docker, Inc. 发现这种做法不可持续, 他们需要把系统拆分出来:</p>
<ul>
<li>各个部分可以独立成长</li>
<li>更容易升级某些部分 - 可以替换旧组件而不影响整体</li>
<li>让社区更容易参与贡献 - 更小的组件意味着更多人能参与进来</li>
<li>更易跨平台 - 他们想要 Docker 在每个平台上运行, 而不只是 Linux</li>
</ul>
<p>拆分的第一步是把客户端 client 剥离出来.
把客户端从大应用中抽出, 赋予它新职责: 把用户命令翻译成 Docker 引擎能理解的指令(也就是原来单体里&quot;内核部分&quot;的接口)</p>
<p>此时, Docker 引擎主要有两部分:</p>
<ul>
<li>Daemon 守护进程: 处理容器、网络和卷</li>
<li>LXC: Docker 与 Linux 内核之间的中间层</li>
</ul>
<h3 id="breaking-things-for-the-better-为了更好的架构而拆分">Breaking Things for the Better 为了更好的架构而拆分<a hidden class="anchor" aria-hidden="true" href="#breaking-things-for-the-better-为了更好的架构而拆分">#</a></h3>
<p>然而, 这个架构存在问题:</p>
<ul>
<li>LXC 仅限于 Linux, 若要支持 Windows 或 macOS 这就难办了</li>
<li>守护进程负担过重, 它做的事情太多, 需要&quot;放轻松&quot;</li>
</ul>
<p>因此, Docker 放弃了 LXC, 缓存更灵活, 冯举平台适应性的 libcontainer.
同时, 他们也减轻了守护进程的职责, 把守护进程做成更简单的 API 接口, 供客户端与之通信.</p>
<p>但这还不是终点. libcontainer 本身仍然太大、太笨重.
于是 Docker 把它进一步拆成更小的部分: <code>docker-init</code>、<code>runc</code>、<code>containerd</code> 和 <code>shim</code>, 每个组件只做一件事, 这带来了:</p>
<ul>
<li>更好的分工协作: 社区可以专注于特定组件</li>
<li>自由试验: 开发者可以像搭积木一样替换或组合部件</li>
<li>更清晰的设计: 不再是纠结在一起的杂乱代码</li>
</ul>
<p><img alt="docker-archtecture" loading="lazy" src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7p8ocAyGKabL-_AdI5rvA.png"></p>
<h3 id="specs-and-standards-规范与标准">Specs and Standards 规范与标准<a hidden class="anchor" aria-hidden="true" href="#specs-and-standards-规范与标准">#</a></h3>
<p>Docker 引擎严格遵循开放容器倡议 OCI 的协议和标准, 意味着你用 Docker 引擎构建的镜像, 只要目标平台也遵循 OCI 标准, 就能在别的容器平台上运行.<br>
Docker 引擎帮助你 build 构建、ship 分发和 run 运行符合 OCI 的镜像, 这三个阶段由三大标准引导:</p>
<ul>
<li>Image Specification 镜像规范: 该规范定义了容器镜像如何被创建, 相当于容器内部包含内容(依赖、配置等)的详细蓝图</li>
<li>Distribution Specification 分发规范: 该规范规定了容器镜像如何共享与传输, 相当于定义了一套&quot;运输网络&quot;的规则, 确保镜像能从 A 点到 B 点顺利传输</li>
<li>Runtime Specification 运行时规范: 该规范描述容器如何被执行和管理, 从启动/停止到与宿主系统交互, 即运行时的行为规则</li>
</ul>
<p>历史部分就到这, 下面进入重点: 逐块剖析 Docker 的当前架构, 看看它们如何协同</p>
<h3 id="how-a-command-is-processed-in-the-docker-system-一个命令是如何被处理的">How a Command is Processed in the Docker System? 一个命令是如何被处理的?<a hidden class="anchor" aria-hidden="true" href="#how-a-command-is-processed-in-the-docker-system-一个命令是如何被处理的">#</a></h3>
<p>现在来拆解一下, 当运行如下命令时发生是事情:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker start my-container
</span></span></code></pre></div><p>这实际上是在和 Docker CLI (client) 打交道, CLI 就像是翻译器, 将输入的命令转换成 Docker daemon 守护进程能懂的东西.<br>
流程大致如下:</p>
<ul>
<li>Command Translation 命令翻译: Docker CLI 将命令转换为一个 API 调用, 例如 REST 或 gRPC, CLI 会将输入命令翻译成这两种格式之一</li>
<li>Sending the Request 发送请求: 翻译完成后 CLI 将请求发送给 Docker daemon, 即守护进程, 是操作中心, 它接受请求、处理请求, 并在幕后完成实际工作</li>
</ul>
<p>因此, 当输入 <code>docker start my-container</code> 的时候, CLI 会告诉守护进程, 守护进程收到后就开始工作, 协调一切将容器启动起来</p>
<h4 id="the-daemon-守护进程">The Daemon 守护进程<a hidden class="anchor" aria-hidden="true" href="#the-daemon-守护进程">#</a></h4>
<p>守护进程就像 Docker 的前台接待员, 它为客户端 (例如 Docker CLI) 提供一个接口, 通过高级抽象与 Docker 引擎交互.
当守护进程接到请求时, 他会验证并处理该命令, 然后将请求翻译为更低一级的指令, 交给另一个模块 <code>containerd</code></p>
<h4 id="containerd">containerd<a hidden class="anchor" aria-hidden="true" href="#containerd">#</a></h4>
<p>顺带一提: <code>c</code> 小写是风格选择; <code>d</code> 表示 daemon<br>
Docker 引擎的模块化设计意味着它被拆分为更小的组件, 模块化的好处是灵活与可扩展: 可以替换、更新或者扩展单个部件, 而不是修改整个系统</p>
<p><code>containerd</code> 是一个高层运行时(high-level runtime), 复杂从容器声明周期的整体角度进行管理, 就像项目经理:</p>
<ul>
<li>创建、启动、停止并删除容器</li>
<li>管理网络与卷 (volumes)</li>
<li>拉取镜像 (pull images)</li>
<li>处理容器级别的其他需求</li>
</ul>
<p>当守护进程将命令发送给 containerd 时, containerd 会准备容器, 但不直接执行容器的实际进程, 它依赖一个更低层次的专用运行时 <code>runc</code> 来完成具体工作.</p>
<h4 id="runc">runc<a hidden class="anchor" aria-hidden="true" href="#runc">#</a></h4>
<p><code>r</code> 小写是 Unix 风格, <code>c</code> 指 container 容器<br>
<code>runc</code> 的职责非常单一: 运行 OCI 容器, 这里的 OCI 指的是行业标准的容器和镜像协议, 为了兼容与互操作而存在.</p>
<ul>
<li>创建容器环境</li>
<li>启动容器进程</li>
<li>确保容器在宿主环境的边界内运行</li>
</ul>
<p>虽然 runc 很重要, 但 containerd 与它的交互方式引入了额外的一些灵活性, containerd 并不直接与 runc 强耦合: 它通过一个抽象, shim 来与 runc 交互.</p>
<h4 id="shims-桥接进程">Shims 桥接进程<a hidden class="anchor" aria-hidden="true" href="#shims-桥接进程">#</a></h4>
<p>在 containerd 的上下文中, shim 是一个轻量级的进程, 位于 containerd 和实际的容器运行时之间. 它的主要作用是将 containerd 与运行时解耦, 保证灵活性与独立性, 这允许 containerd 管理容器, 而无需紧密耦合到特定运行时.</p>
<p>当 containerd 启动一个容器时, 他会启动一个 shim 进程, shim 则调用运行时来设置容器. runc 完成诸如设置命名空间和 cgroups, 挂载文件系统, 启动容器化等&quot;重活&quot;. 但一旦容器启动, runc 就会退出, 留下 shim 来管理容器的声明周期交互. shim 功能如下:</p>
<ul>
<li>流程管理: 保持容器进程存活并处理信号</li>
<li>I/O 流: 保持日志并转发容器与 containerd 之间的输入/输出</li>
<li>声明周期事件: 监控并上报诸如容器终止等事件</li>
</ul>
<p>如果所有底层运行时都遵循 OCI 运行时规范, 为什么 containerd 还需要 shim? 单胺是模块化和关注点分离:</p>
<ul>
<li>解耦: shim 抽象出容器特定的操作, 使 containerd 能专注于管理多个容器以及他们的网络与卷, 而不必处理每个容器的细节</li>
<li>灵活性: 有了 shim 就可以比较容易替换掉 runc, 改用同样遵守 OCI 的其他运行时, 架构因此能使用新技术</li>
<li>简化: 每个 shim 只处理一个容器, 这种分离确保单个应用容器的问题不会波及到其他容器</li>
</ul>
<h4 id="from-shim-to-docker-init">From Shim to Docker-init<a hidden class="anchor" aria-hidden="true" href="#from-shim-to-docker-init">#</a></h4>
<p>当 shim 接手后, 它继续管理容器的生命周期. 不过, Docker 引擎还需要与容器内的进程交互, 比如确保日志、信号和资源得到适当处理. 这就是 docker-init 的作用, 它在容器内部充当 PID 1 的角色, 管理并清理容器化应用的资源.</p>
<h4 id="docker-init-the-unsung-hero-of-containers--容器中的无明英雄">Docker-init: The Unsung Hero of Containers / 容器中的无明英雄<a hidden class="anchor" aria-hidden="true" href="#docker-init-the-unsung-hero-of-containers--容器中的无明英雄">#</a></h4>
<p>在每个容器内部, PID 1 是最关键的首个进程. 容器只要 PID 1 运行, 就存活. 所以, PID 1 的容器生命周期的基石.
当 containerd 需要停止或终止容器时, 他会依赖 PID 1 来确保容器内的所有子进程被正确清理.
如果 PID 1 退出, 所有关联的子进程会自动被终止.</p>
<p>docker-init 的关键作用之一是清理僵尸进程 zombie processes, 那些执行完没有被父进程回收的&quot;被遗忘&quot;的子进程.
这类进程若放任不管, 会逐渐占用系统资源. docker-init 会及时回收它们, 保持容器环境整洁与高效.</p>
<p>另一项重要任务是处理系统信号(例如 SIGTERM 或 SIGINT), 许多容器化应用本身并不善于处理这些信号, 可能导致不完整或粗暴的关闭.
docker-init 会捕捉这些信号, 并适当地转发, 保证容器内的应用能优雅地退出.</p>
<p>作为 PID 1, docker-init 也为容器化应用提供了一个可预期且稳定的运行基础. 它的存在简化了容器生命周期的管理, 使容器更加稳定可靠.</p>
<p>总之, docker-init 确保容器保持干净, 响应迅速并得到良好管理. 它不一定显眼, 但正是这些细小的贡献让容器变得可靠且高效.</p>
<h3 id="network-ports-and-unix-sockets-网络端口和unix套节字">Network Ports and Unix Sockets 网络端口和Unix套节字<a hidden class="anchor" aria-hidden="true" href="#network-ports-and-unix-sockets-网络端口和unix套节字">#</a></h3>
<p>Docker CLI 和 docker daemon 可以通过 Unix Sockets 和 network ports 沟通. Docker, Inc. 已经向 Internet Assigned Numbers Authority(IANA)注册了3个端口, 用于Docker daemon 和 client:</p>
<ul>
<li>TCP port 2375 用于未加密连接</li>
<li>port 2376 用于 SSL 加密连接</li>
<li>port 2377 用于 Docker Swarm mode</li>
</ul>
<p>在需要使用不同设置的场景下, 更换端口配置很容易.
Docker 安装程序的默认设置是只使用 Unix 套接字与本地 Docker 守护进程通信.
这样做可以确保系统默认采用尽可能安全的安装方式.
这个选项同样可以方便地修改, 但强烈建议不要用网络端口来暴露 Docker, 因为 Docker 守护进程内部并没有用户认证和基于角色的访问控制.
Unix 套接字在不同操作系统的路径可能不同, 但在大多数情况下可以在 <code>/var/run/docker.sock</code> 找到.</p>
<h3 id="container-networking-容器网络">Container Networking 容器网络<a hidden class="anchor" aria-hidden="true" href="#container-networking-容器网络">#</a></h3>
<p>尽管 Linux 容器在很大程度上是宿主机上运行的进程, 但在网络层他们通常表现得与其他进程很不一样.
Docker 最初只支持一种网络模型, 但现在提供了多种稳健的配置, 可以曼珠大多数应用的需求.
大多数人以默认配置运行容器, 这称为桥接模式 Bridge Mode.</p>
<p>要理解桥接模式, 最容易是把每个 Linux 容器看作是在私有网络上的一台主机.
Docker 服务器充当一个虚拟桥 virtual bridge, 容器则是作为桥后的客户端.
桥只是一个把一侧流量转发到另一侧的网络设备.
因此, 可以将它想象成一个虚拟网络, 每个容器像附着在该网络上的主机.
实际上是: 每个容器都有一个虚拟以太网接口连接到 Docker 桥, 并未该虚拟接口分配一个 IP 地址.
Docker 运行在宿主机上绑定并暴露单个或一组端口到容器, 以便外部世界可以通过这些端口访问容器, 流量很大程度上由 vpnkit 库来管理.</p>
<p>Docker 从 未使用的 RFC 1918 私有子网块中分配私有子网, 它检测主机上有哪些网络块未被使用, 并把其中一个分配给虚拟网络.
该网络通过服务器上的一个名为 docker0 的接口桥接到宿主机的本地网络.
这意味着默认情况下, 所有容器都在同一个网络中, 可以直接相互通信.
但要达到宿主机或外部网络, 他们会通过 docker0 虚拟桥接接口转发出去.</p>
<p><img alt="docker container network" loading="lazy" src="../render-image/2025-09-04_docker-container-network.png"></p>
<p>有多种方式配置 Docker 的网络层, 从分配自己的网络块到配置自定义桥接接口, 方式繁多让人眼花缭乱.
人们通常使用默认机制, 但有时需要更复杂或更贴合应用的配置.</p>
<h3 id="summary-总结">Summary 总结<a hidden class="anchor" aria-hidden="true" href="#summary-总结">#</a></h3>
<p>Docker 引擎不仅仅是一款软件, 它是一套精心设计的模块化组件系统, 这些组件协同工作以实现容器的高效、可扩展与可移植.
从 CLI 中敲下命令, 到 runc、shim、docker-init 所处理的底层操作, 每个元素都扮演者明确且重要的角色.</p>
<p>通过遵守严格的 OCI 标准, Docker 确保其生态系统不仅强大, 且具备通用兼容性. 这种遵循标准的做法建立了信任, 为开发者与企业提供了稳定的基础, 模块化架构简化了容器管理, 并鼓励创新, 允许每个组件独立演进与改善.</p>
<p>理解 Docker 引擎不仅是知道容器如何工作, 更是认识其背后经过深思熟虑的工程设计. 正是这种工程让现代软件开发更快、更高效、更容易上手.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/docker/">Docker</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/docker-images-and-registeries/">
    <span class="title">« Prev</span>
    <br>
    <span>Docker - Images and Registeries</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/docker-history/">
    <span class="title">Next »</span>
    <br>
    <span>Docker - History</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Engine and Netowrking on x"
            href="https://x.com/intent/tweet/?text=Docker%20-%20Engine%20and%20Netowrking&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-engine-and-netowrking%2f&amp;hashtags=Docker">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Engine and Netowrking on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-engine-and-netowrking%2f&amp;title=Docker%20-%20Engine%20and%20Netowrking&amp;summary=Docker%20-%20Engine%20and%20Netowrking&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-engine-and-netowrking%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Engine and Netowrking on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-engine-and-netowrking%2f&title=Docker%20-%20Engine%20and%20Netowrking">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Engine and Netowrking on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-engine-and-netowrking%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Engine and Netowrking on whatsapp"
            href="https://api.whatsapp.com/send?text=Docker%20-%20Engine%20and%20Netowrking%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-engine-and-netowrking%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Engine and Netowrking on telegram"
            href="https://telegram.me/share/url?text=Docker%20-%20Engine%20and%20Netowrking&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-engine-and-netowrking%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker - Engine and Netowrking on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Docker%20-%20Engine%20and%20Netowrking&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fdocker-engine-and-netowrking%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">Starslayerx&#39; Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
