<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Python asyncio 03: A first asyncio application | Starslayerx&#39; Blog</title>
<meta name="keywords" content="Python, Asyncio">
<meta name="description" content="Working with blocking sockets
socket 是在网络中读取和写入数据的一种方式。
可以将 socket 看成一个邮件，将信封放到里面后运送到接收者的地址。
下面使用 Python 的内置 socket 模块来创建一个简单的 server
import socket

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
这里，给 socket 函数指定了两个参数，第一个是 socket.AF_INET，这个告诉我们要与什么类型的地址进行交互，在这个例子中是 hostname 和 phonenumber。
第二个是 socket.SO_REUSEADDR，这个参数是说我们使用 TCP 协议进行交互。
然后使用 socket.setsockopt 方法将 socket.SOL_SOCKET 标志设置为 1。这将允许在关闭和快速重启应用，避免 address already in use 这类错误，如果不这样做将会消耗操作系统一段时间来解除与 port 的绑定。
使用 socket.socket 创建 socket 后，并不能开始沟通，因为还没有将其绑定到任何地址上面。
在本例中，将使用电脑本地地址 127.0.0.1 和任意 port 8000
server_address = (&#39;127.0.0.1&#39;, 8000)
server_socket.bind(server_address)
这里将地址设置为 127.0.0.1:8000，这意味着 client 将能够使用该地址向服务器发送数据，如果要向 client 发送数据，也会看到该地址为来源地址。
接下来，在套接字上调用 listen 方法，主动监听来自客户端的连接请求。
随后，通过调用 accept 方法等待连接建立。
该方法会保持阻塞状态直至接收到连接请求，当连接成功时，将返回一个连接对象及客户端地址。
这个连接对象本质上是一个新的套接字，可以用于与客户端进行双向数据通信
server_socket.listen()
connection, client_address = server_socket.accept()
有了这些组件，我们便掌握了创建基于套接字的服务器应用所需的所有基础模块。
该应用将等待连接，并在建立连接后打印提示信息。">
<meta name="author" content="Starslayerx">
<link rel="canonical" href="http://localhost:1313/posts/python-asyncio-03-a-first-asyncio-application/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.svg">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon.svg">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon.svg">
<link rel="mask-icon" href="http://localhost:1313/favicon.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/python-asyncio-03-a-first-asyncio-application/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="http://localhost:1313/posts/python-asyncio-03-a-first-asyncio-application/">
  <meta property="og:site_name" content="Starslayerx&#39; Blog">
  <meta property="og:title" content="Python asyncio 03: A first asyncio application">
  <meta property="og:description" content="Working with blocking sockets socket 是在网络中读取和写入数据的一种方式。 可以将 socket 看成一个邮件，将信封放到里面后运送到接收者的地址。
下面使用 Python 的内置 socket 模块来创建一个简单的 server
import socket server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) 这里，给 socket 函数指定了两个参数，第一个是 socket.AF_INET，这个告诉我们要与什么类型的地址进行交互，在这个例子中是 hostname 和 phonenumber。 第二个是 socket.SO_REUSEADDR，这个参数是说我们使用 TCP 协议进行交互。
然后使用 socket.setsockopt 方法将 socket.SOL_SOCKET 标志设置为 1。这将允许在关闭和快速重启应用，避免 address already in use 这类错误，如果不这样做将会消耗操作系统一段时间来解除与 port 的绑定。
使用 socket.socket 创建 socket 后，并不能开始沟通，因为还没有将其绑定到任何地址上面。 在本例中，将使用电脑本地地址 127.0.0.1 和任意 port 8000
server_address = (&#39;127.0.0.1&#39;, 8000) server_socket.bind(server_address) 这里将地址设置为 127.0.0.1:8000，这意味着 client 将能够使用该地址向服务器发送数据，如果要向 client 发送数据，也会看到该地址为来源地址。
接下来，在套接字上调用 listen 方法，主动监听来自客户端的连接请求。 随后，通过调用 accept 方法等待连接建立。 该方法会保持阻塞状态直至接收到连接请求，当连接成功时，将返回一个连接对象及客户端地址。 这个连接对象本质上是一个新的套接字，可以用于与客户端进行双向数据通信
server_socket.listen() connection, client_address = server_socket.accept() 有了这些组件，我们便掌握了创建基于套接字的服务器应用所需的所有基础模块。 该应用将等待连接，并在建立连接后打印提示信息。">
  <meta property="og:locale" content="en-US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-12-01T08:00:00+08:00">
    <meta property="article:modified_time" content="2025-12-01T08:00:00+08:00">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="Asyncio">
      <meta property="og:image" content="http://localhost:1313/images/og-default.avif">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/og-default.avif">
<meta name="twitter:title" content="Python asyncio 03: A first asyncio application">
<meta name="twitter:description" content="Working with blocking sockets
socket 是在网络中读取和写入数据的一种方式。
可以将 socket 看成一个邮件，将信封放到里面后运送到接收者的地址。
下面使用 Python 的内置 socket 模块来创建一个简单的 server
import socket

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
这里，给 socket 函数指定了两个参数，第一个是 socket.AF_INET，这个告诉我们要与什么类型的地址进行交互，在这个例子中是 hostname 和 phonenumber。
第二个是 socket.SO_REUSEADDR，这个参数是说我们使用 TCP 协议进行交互。
然后使用 socket.setsockopt 方法将 socket.SOL_SOCKET 标志设置为 1。这将允许在关闭和快速重启应用，避免 address already in use 这类错误，如果不这样做将会消耗操作系统一段时间来解除与 port 的绑定。
使用 socket.socket 创建 socket 后，并不能开始沟通，因为还没有将其绑定到任何地址上面。
在本例中，将使用电脑本地地址 127.0.0.1 和任意 port 8000
server_address = (&#39;127.0.0.1&#39;, 8000)
server_socket.bind(server_address)
这里将地址设置为 127.0.0.1:8000，这意味着 client 将能够使用该地址向服务器发送数据，如果要向 client 发送数据，也会看到该地址为来源地址。
接下来，在套接字上调用 listen 方法，主动监听来自客户端的连接请求。
随后，通过调用 accept 方法等待连接建立。
该方法会保持阻塞状态直至接收到连接请求，当连接成功时，将返回一个连接对象及客户端地址。
这个连接对象本质上是一个新的套接字，可以用于与客户端进行双向数据通信
server_socket.listen()
connection, client_address = server_socket.accept()
有了这些组件，我们便掌握了创建基于套接字的服务器应用所需的所有基础模块。
该应用将等待连接，并在建立连接后打印提示信息。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Python asyncio 03: A first asyncio application",
      "item": "http://localhost:1313/posts/python-asyncio-03-a-first-asyncio-application/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python asyncio 03: A first asyncio application",
  "name": "Python asyncio 03: A first asyncio application",
  "description": "Working with blocking sockets socket 是在网络中读取和写入数据的一种方式。 可以将 socket 看成一个邮件，将信封放到里面后运送到接收者的地址。\n下面使用 Python 的内置 socket 模块来创建一个简单的 server\nimport socket server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) 这里，给 socket 函数指定了两个参数，第一个是 socket.AF_INET，这个告诉我们要与什么类型的地址进行交互，在这个例子中是 hostname 和 phonenumber。 第二个是 socket.SO_REUSEADDR，这个参数是说我们使用 TCP 协议进行交互。\n然后使用 socket.setsockopt 方法将 socket.SOL_SOCKET 标志设置为 1。这将允许在关闭和快速重启应用，避免 address already in use 这类错误，如果不这样做将会消耗操作系统一段时间来解除与 port 的绑定。\n使用 socket.socket 创建 socket 后，并不能开始沟通，因为还没有将其绑定到任何地址上面。 在本例中，将使用电脑本地地址 127.0.0.1 和任意 port 8000\nserver_address = (\u0026#39;127.0.0.1\u0026#39;, 8000) server_socket.bind(server_address) 这里将地址设置为 127.0.0.1:8000，这意味着 client 将能够使用该地址向服务器发送数据，如果要向 client 发送数据，也会看到该地址为来源地址。\n接下来，在套接字上调用 listen 方法，主动监听来自客户端的连接请求。 随后，通过调用 accept 方法等待连接建立。 该方法会保持阻塞状态直至接收到连接请求，当连接成功时，将返回一个连接对象及客户端地址。 这个连接对象本质上是一个新的套接字，可以用于与客户端进行双向数据通信\nserver_socket.listen() connection, client_address = server_socket.accept() 有了这些组件，我们便掌握了创建基于套接字的服务器应用所需的所有基础模块。 该应用将等待连接，并在建立连接后打印提示信息。\n",
  "keywords": [
    "Python", "Asyncio"
  ],
  "articleBody": "Working with blocking sockets socket 是在网络中读取和写入数据的一种方式。 可以将 socket 看成一个邮件，将信封放到里面后运送到接收者的地址。\n下面使用 Python 的内置 socket 模块来创建一个简单的 server\nimport socket server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) 这里，给 socket 函数指定了两个参数，第一个是 socket.AF_INET，这个告诉我们要与什么类型的地址进行交互，在这个例子中是 hostname 和 phonenumber。 第二个是 socket.SO_REUSEADDR，这个参数是说我们使用 TCP 协议进行交互。\n然后使用 socket.setsockopt 方法将 socket.SOL_SOCKET 标志设置为 1。这将允许在关闭和快速重启应用，避免 address already in use 这类错误，如果不这样做将会消耗操作系统一段时间来解除与 port 的绑定。\n使用 socket.socket 创建 socket 后，并不能开始沟通，因为还没有将其绑定到任何地址上面。 在本例中，将使用电脑本地地址 127.0.0.1 和任意 port 8000\nserver_address = ('127.0.0.1', 8000) server_socket.bind(server_address) 这里将地址设置为 127.0.0.1:8000，这意味着 client 将能够使用该地址向服务器发送数据，如果要向 client 发送数据，也会看到该地址为来源地址。\n接下来，在套接字上调用 listen 方法，主动监听来自客户端的连接请求。 随后，通过调用 accept 方法等待连接建立。 该方法会保持阻塞状态直至接收到连接请求，当连接成功时，将返回一个连接对象及客户端地址。 这个连接对象本质上是一个新的套接字，可以用于与客户端进行双向数据通信\nserver_socket.listen() connection, client_address = server_socket.accept() 有了这些组件，我们便掌握了创建基于套接字的服务器应用所需的所有基础模块。 该应用将等待连接，并在建立连接后打印提示信息。\n在收到请求后，将会打印一条信息并退出，下面使用 telnet cli 来发送请求。\nConnecting to a server with Telnet Telnet 是 “teletype network” 的缩写，telnet 会与指定的服务器和主机建立一个 TCP 连接。 可以使用下面命令连接服务器\ntelnet localhost 8000 将会看到下面这样输出\nTrying ::1... Connection failed: Connection refused Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. Connection closed by foreign host. 服务器会输出，表明已经建立了连接\nI got a connection from ('127.0.0.1', 61137)! Reading and writing data to and from a socket socket 有一个 recv 方法能够从中获取数据，该方法提供一个整数，代表在一段时间内想要读取的字节数。 这一点很重要，因为我们不能一次从 socket 中读取所有的数据，我们需要缓冲直到达到输入末尾。\n当用户用 telnet 输入内容并按 Enter 时，telnet 会自动在你的输入后面追加两个字符\n`\\r\\n` # 回车(carriage return) + 换行(line feed) 这里将 socket.recv 的缓冲区设得很小，这样更容易看到消息分片、拆包问题，从而观察 TCP 的行为。 实际开发中，recv 一般写成 1024，大的缓冲区更符合生产环境的性能要求。 使用较大的 buffer（比如 1024 bytes）可以减少应用程序反复调用 recv 的次数，TCP 数据会先在内核的 socket buffer 中缓存。\nimport socket # AF_INET: IPv4 # SOCK_STREAM: 面向连接的字节流套接字，即 TCP server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Create a TCP server socket # SOL_SOCKET: 表示操作的是通用套接字级别的选项 # SO_REUSEADDR: 端口快速重用选项 # 1 表示启用 server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_address = ('127.0.0.1', 8000) # 将 socket 地址设置为 127.0.0.1:8000 server_socket.bind(server_address) # 监听连接 server_socket.listen() try: connection, client_address = server_socket.accept() # 等待连接并为客户端分配一个信封邮箱 print(f\"I got a connection from {client_address}!\") buffer = b'' while buffer[-2:] != b'\\r\\n': data = connection.recv(2) # 连接已被对端关闭，返回空字节串 b'' if not data: break else: print(f\"I got data: {data}!\") buffer += data print(f\"All the data is: {buffer}\") finally: server_socket.close() 上面去循环检查 buffer 最后两个字节码是不是 \\r\\n，如果不是就读取两个字节码到缓存里面，直到读取最后的 \\r\\n。 socket 有一个 sendall 方法，该方法接受一条数据并将其写回客户端。\nbuffer = b'' while buffer[-2:] != b'\\r\\n': data = connection.recv(2) if not data: break else: print(f\"I got data: {data}!\") buffer += data print(f\"All the data is: {buffer}\") # 返回数据给客户端 connection.sendall(b\"Buffer: \" + buffer) 现在应该在输入内容后，能够看到 Buffer: 的内容，这样就完成了一个基础的 echo server。\n现在这个应用每次能处理一个客户端，但是多个客户端可能会连接到单个 server socket。 下面来修改这个示例，从而允许多个客户端同时连接。\nAllowing multiple connections and the dangers of blocking 在监听模式下的 socket 同时运行多个 client 连接。 这意味着我们可以重复调用 socket.accept，并且每次客户端连接时， 都会获得一个新的连接套接字，用于与该客户端进行数据读写交互。 根据上面的知识，我们可以直接使用之前的例子来处理多个客户端。 一直循环调用 socket.accept 来监听新的连接。 每次得到一个新的连接，就将其插入到一个连接列表中，并遍历每个链接，接收输入的数据，并将数据写回客户端连接。\nimport socket server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_address = ('127.0.0.1', 8000) server_socket.bind(server_address) server_socket.listen() connections = [] try: while True: connection, client_address = server_socket.accept() print(f\"I got a connection from {client_address}\") connections.append(connection) for connection in connections: buffer = b'' while buffer[-2:] != b'\\r\\n': data = connection.recv(2) if not data: break else: print(f\"I got data: {data}!\") buffer += data print(f\"All the data is: {buffer}\") connection.send(buffer) finally: server_socket.close() 尝试运行上面代码，并使用 telnet 建立两个连接，会立刻发现一个问题。 第一个客户端运行正常，消息按预期返回，但第二个客户端却接收不到任何回显。 这是由于 socket 的默认注释行为导致的，accept 和 recv 方法会一直阻塞，直到接收到数据为止。\n这意味着，一但第一个客户端连接后，我们将会阻塞并等待第一条 echo message。 这导致其他客户端被阻塞，等待循环的下一次迭代，这种情况只有在第一个客户端发送数据后才会发生。\n这明显不是用户希望的结果，用户超过一个人后很难扩展。 可以通过将 sockets 设置为 non-blocking 模式来解决这个问题。 将 socket 设置为非阻塞后，其方法将不会阻塞等待数据，而是继续执行后面的代码。\nWorking with non-blocking sockets 在非阻塞模式下，如果套接字有数据准备就绪，那么我们将像使用阻塞套接字一样获得返回的数据。 如果没有，套接字会立即告诉我们它没有任何数据准备就绪，我们可以自由地继续执行其他代码。\nimport socket server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_socket.bind('127.0.0.1', 8000) server_socket.listen() server_socket.setblocking(False) 使用阻塞和非阻塞的 socket 本质上并没有什么不同，除了要设置 setblocking(False)\nimport socket server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_address = ('127.0.0.1', 8000) server_socket.bind(server_address) server_socket.listen() server_socket.setblocking(False) # non-blocking connections = [] try: while True: connection, client_address = server_socket.accept() connection.setblocking(False) # non-blocking print(f\"I got a connection from {client_address}\") connections.append(connection) for connection in connections: buffer = b'' while buffer[-2:] != b'\\r\\n': data = connection.recv(2) if not data: break else: print(f\"I got data: {data}!\") buffer += data print(f\"All the data is: {buffer}\") connection.sendall(buffer) finally: server_socket.close() 但直接运行会产生一个 BlockingIOError 错误，因为服务器还未建立连接，因此还没有数据要处理\nFile \"/Users/starslayerx/GitHub/book_asyncio/socket_server.py\", line 16, in connection, client_address = server_socket.accept() ^^^^^^^^^^^^^^^^^^^^^^ File \"/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/socket.py\", line 295, in accept fd, addr = self._accept() ^^^^^^^^^^^^^^ BlockingIOError: [Errno 35] Resource temporarily unavailable 这是套接字一种有点反直觉的表达方式，意思是说：“我现在没有任何数据，你等会儿再来调用我。” 这里没有简单的方法来判断 socket 是否有数据，所以一种解决方案就是捕获这个异常，把它忽略掉，然后不断循环，直到拿到数据。 采用这种策略，将会以尽可能快的速度不断检查是否有新的连接和数据。\nimport socket server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_address = ('127.0.0.1', 8000) server_socket.bind(server_address) server_socket.listen() server_socket.setblocking(False) # non-blocking connections = [] try: while True: try: connection, client_address = server_socket.accept() connection.setblocking(False) # non-blocking print(f\"I got a connection from {client_address}\") connections.append(connection) except BlockingIOError: pass for connection in connections: try: buffer = b'' while buffer[-2:] != '\\r\\n': data = connection.recv(2) if not data: break else: print(f\"I got data: {data}\") buffer += data print(f\"All the data is: {buffer}\") connection.send(buffer) except BlockingIOError: pass finally: server_socket.close() 这样 accept 和 recv 就不会阻塞了，并且每次要么忽略，要么处理对应的数据。 循环的每次迭代都迅速完成，且从不依赖任何外部数据来推进下一行代码的执行。 这解决了阻塞服务器的问题，使得多个客户端能够同时连接并发送数据。\n这种方法能够工作，但是有代价的。\n每当可能尚未获取数据时就捕获异常，不仅会使代码变得冗长，还可能容易出错。 第二个是资源问题，这个程序会使用几乎 100% 的 CPU 处理能力，因为不断的循环和获取报错导致 CPU 较高的工作负载。 在之前提到过操作系统特有的事件通知系统，它能在 socket 有数据可操作的时候通知我们。 这些系统依赖于硬件层面的通知机制，而非刚才使用了轮询循环。 Python 内置了一个库来调用这种事件循环通知系统，下面将用其来解决 CPU 占用率问题，并构建一个套节字事件的小型事件循环。\nUsing the selector module to build a socket event loop 操作系统提供了高效的 API，允许我们监听 socket 以接收数据和其他事件。 虽然具体的 API 取决于系统（例如 kqeueu、epoll 和 IOCP），但这些 I/O 通知系统都基于相似的概念运行。 我们向系统提供一个需要监控事件的套节字列表，操作系统在套节字有数据时会明确通知我们，而不是去不断轮询检查每个套接字是否有数据。\n由于这是硬件层面实现的，在监控中需要很少的 CPU 利用率，产生高效的资源利用。 这些通知系统是 asyncio 实现并发的核心，理解其工作原理能够帮助我们理解 asyncio 的工作方式。\n这些 event notification system 在不同的系统中是不同的。 好在 Python 的 selectors 模块将底层抽象，无论在那个系统上运行，都能正确获取事件。\n该库暴露一个抽象基类型 BaseSelector，该类型对不同的事件通知系统有着不同的实现。 同时，库中还包含 DefaultSelector 类，能够自动为当前系统选择最高效的实现方案。\nBaseSelector 类有一些重要的概念：\nregistration: 注册，当我们有一个感兴趣的套接字，希望获取其通知时，我们会将其注册到选择器中，并告之需要关注哪些事件。 这些事件有 read 和 write，相反，也可以取消不感兴趣的注册。 select: select 选择器会阻塞直到有事件发生，一但事件触发，该调用将返回一个包含带处理的列表以及它触发的事件。 它还支持超时设置，在指定时间后若无事件则返回空的事件集和。 通过上面的方法，我们能够创建一个不会压垮 CPU 的非阻塞 echo server。 一旦我们创建了服务器套接字，就会将其注册到默认的选择器 selector 中，该选择器将监听来自客户端的任何连接。 之后在任何时间某人连接到我们的 server socket，我们将会注册客户端 connection socket，并使用 selector 观察任何数据发送。\n如果获取到任何不是来自 server socket 的数据，我们就知道是 client 发送了数据，然后我们收到数据并将其写入客户端。\nimport selectors import socket from selectors import SelectorKey selector = selectors.DefaultSelector() server_socket = socket.socket() server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_address = (\"127.0.0.1\", 8000) server_socket.setblocking(False) server_socket.bind(server_address) server_socket.listen() selector.register(server_socket, selectors.EVENT_READ) while True: # 创建 1 秒过期的选择器 events: list[tuple[SelectorKey, int]] = selector.select(timeout=1) # 没有事件 if len(events) == 0: print(\"No events, waiting a bit more!\") for event, _ in events: # 获取 socket event event_socket = event.fileobj if event_socket == server_socket: connection, address = server_socket.accept() connection.setblocking(False) print(f\"I got a connection from {address}\") selector.register(connection, selectors.EVENT_READ) else: data = event_socket.recv(1024) print(f\"I got some data: {data}\") event_socket.send(data) 这样实现的 echo server 的 CPU 利用率就少了很多，虽然仍然是死循环，但是循环内部的 selector() 会让线程进入内核的阻塞睡眠状态，直到超时才会 print() 一条语句，是典型的事件驱动。\n而 try except 轮询会不间断的轮询，且内部会不断抛出异常、处理异常、重试等，CPU 占用很高。\n上面构建的部分和 asyncio 底层的大部分工作方式类似。 在这个例子中，events 是 sockets 接收数据。 无论是我们的事件循环还是 asyncio 的事件循环，它们的每一次迭代都是由两种情况触发的：要么有某个 socket 事件发生，要么是超时导致事件循环继续运行。\n在 asyncio 的事件循环里，只要发生了这两种情况中的任意一种，所有正在等待调度的协程都会运行，直到它们结束，或者它们遇到下一个 await 语句为止。\n当协程执行到一个基于非阻塞 socket 的 await 时，该 socket 会被注册到系统的 selector 中，同时事件循环会记录该协程已暂停并正在等待这个 socket 的结果。\n我们可以把这个概念翻译成伪代码来展示。\npaused = [] ready = [] while True: paused, new_sockets = run_ready_tasks(ready) selector.register(new_sockets) timeout = calculate_timeout() events = selector.select(timeout) ready = process_events(events) 我们会运行所有“已经准备好的协程”，直到他们在某个 await 语句上暂停，并把这些协程放到 paused 列表中。 同时，还会记录这些协程运行过程中产生的所有新 socket，并将他们注册到 selector 中。 之后，我们需要计算下一次调用 select 时的超时时间。 这个 timeout 的计算方式比较复杂，但通常取决于在未来某个时间点或者等待某个持续时间后要执行的任务。 例如 asyncio.sleep() 就会影响这个 timeout。\n接着，调用 select 并等待 socket 事件或超时。 当其中一个发生时，会处理这些事件，并将其转化为一个可立即继续执行的协程列表。\n虽然上面的 event loop 只是用于 socket 的，但其展示了使用 selectors 注册 sockets 的主要思想， 即只在我们关心的事件发生后才启动。\n然而，如果我们仅使用 selectors 来构建应用程序，就需要自行实现事件循环才能达到与 asyncio 相同的功能。 下面介绍如何使用 async/await 来实现上面功能。\nAn echo server on the asyncio event loop 使用 select 对于很多应用来说有些太底层了。 我们可能希望在等待 socket 的时候，让代码在后台运行，或者我们可能希望按计划执行后台任务。 如果只使用 selectors 来实现这个，我们将需要构建自己的事件循环，与此同时，asyncio 有一个完整的实现可以使用。 此外，coroutines 和 tasks 在 selectors 之上提供了抽象层，这使得我们代码更易于实现和维护，无需考虑 selectors 细节。\n下面通过 asyncio 的 coroutines 和 tasks 再次实现前面的 echo server。 这里仍然会通过底层 API 来实现，这些 API 会返回 coroutines 和 tasks。\nEvent loop coroutines for sockets 考虑到 sockets 的一个相对底层的概念，处理他们的方法是通过 asyncio 的事件循环。 下面会使用三种主要的协程处理：\nsock_accept sock_recv sock_sendall 这些方法和之前的很类似，不同在于这些方法会将 socket 作为一个参数输入，这样我们可以 await 返回的协程，直到我们得到可以作用于其上的数据。\n下面先从 sock_accept 开始，这个协程类似之前的 socket.accept 方法。\n该方法返回一个 tuple: (socket_connection, client_address)，传入感兴趣的 socket，然后 await 等待连接返回。 一但接受该协程就能获取到连接与地址，这个 socket 必须是非阻塞的，并和一个端口绑定起来：\nconnection, addresss = await loop.socke_accept(socket) sock_recv 和 sock_sendall 也是类似的，输入一个 socket，然后 await 等待结果。\nsock_recv 会等待直到有可以处理的字节 sock_sendall 同时接受一个 socket 和要发送的 data，它会等待直到所有数据成功发送至 socket，并在成功后返回 None data = await loop.sock_recv(socket) success = await loop.sock_sendall(socket, data) Designing an asyncio echo server 之前介绍了 coroutines 和 tasks，那么什么时候使用 coroutine，什么时候使用 task 呢？ 让我们来审视一下，我们希望应用程序如何表现以做出这一判断。\n我们从如何监听应用连接开始。 当监听应用连接的时候，一次将只能处理一个连接，因为 socket.accept 只会给客户端一个连接。 如果有多个连接到达，后续的连接会被存储到一个被称作 backlog 的队列里面。\n由于不需要并发处理多个连接，单个协程循环就足够了。 这样能够让其他代码在等待连接的时候并发执行。 这里定义一个一直循环的协程 listen_for_connections\nasync def listen_for_connections(server_socket: socket, loop: AbstractEventLoop): while True: connection, address = await loop.sock_accept(server_socket) connection.setblocking(False) print(f\"Got a connection from {address}\") 这样就有了一个监听连接的协程，由于要并发处理多个 connection，因此这里要为每个 connection 创建一个 task 来读写数据。\n这里将创建负责处理数据的协程 echo，这个协程会一直循环来接收来自 client 的数据，一但其收到数据，就写会到 client 中去。 然后在 listen_for_connections 里，创建一个 task 来包装 echo 协程。\nimport asyncio import socket from asyncio import AbstractEventLoop async def echo(connection: socket, loop: AbstractEventLoop) -\u003e None: while data := await loop.sock_recv(connection, 1024): await loop.sock_sendall(connection, data) async def listen_for_connections(server_socket: socket, loop: AbstractEventLoop): while True: connection, address = await loop.sock_accept(server_socket) connection.setblocking(False) print(f\"Got a connection from {address}\") asyncio.create_task(echo(connection, loop)) async def main(): server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_address = (\"127.0.0.1\", 8000) server_socket.setblocking(False) server_socket.bind(server_address) server_socket.listen() await listen_for_connections(server_socket, asyncio.get_event_loop()) asyncio.run(main()) 架构如下：\n协程 listen_for_connections 持续监听连接，收到连接后该协程就会切换到 echo task 去处理每个连接 Client 1 echo task \u003c–Read/Write–\u003e Client 1 Client 2 echo task \u003c–Read/Write–\u003e Client 2 Client 3 echo task \u003c–Read/Write–\u003e Client 3 这样设计的 echo server 实际上有一个问题，下面来解决\nHandling errors in tasks 网络连接通常都是不可靠的，我们可能得到非预期的报错。 下面修改 echo 的实现，添加一个错误处理的代码：\nasync def echo(connection: socket, loop: AbstractEventLoop) -\u003e None: while data := await loop.recv(connection, 1024): if data == b\"boom\\r\\n\": raise Exception(\"Unexcepted network error\") await loop.sock_sendall(connection, data) 现在只要发送 boom 就会导致下面这样的报错：\nGot a connection from ('127.0.0.1', 49470) Task exception was never retrieved future: exception=Exception('Unexcepted network error')\u003e Traceback (most recent call last): File \"/Users/starslayerx/GitHub/book_asyncio/asyncio_echo_server.py\", line 7, in echo raise Exception(\"Unexcepted network error\") 这里的重点在于 Task exception was never retrieved。 当一个异常在 task 内部被抛出时，这个任务会被视为已完成，并且它的“结果”就是这个异常。 这意味着异常不会沿着调用栈向上传递。 此外，这里没有任何清理逻辑。 如果该异常被抛出，则无法对任务失败做出反应，因为从未获取 retrieve 这个异常。\n要让异常真正传递，必须在 await 表达式中使用 task。 当 await 一个失败的 task 时，异常会在 await 的地方重新抛出，其 traceback 也会在该位置体现。 如果在程序中从未 await 一个 task，就有可能永远看不到这个 task 抛出的异常。\n下面演示，与其忽略在 listen_for_connection 里面创建的 echo tasks，我们通过列表来跟踪他们\ntasks = [] async def listen_for_connection(server_socket: socket, loop: AbstractEventLoop): while True: connection, address = await loop.socket_accept(server_socket) connection.setblocking(False) print(f\"Got a connection from {address}\") tasks.append( asyncio.create_task(echo(connection, loop)) ) 看上去可能会和之前一样，如果输入 boom 应该会看到警告被打印出来，同时伴随着从未获取任务异常的警告。 然而，实际上并不是这样，除非强制终止程序，否则什么都看不到。\n这样因为我们保留了 task 的引用，asyncio 只有在任务被垃圾回收的之后才能打印出 traceback 或 failed task 相关信息。 这是因为无法判断该任务是否会在应用程序的其他某个时刻被等待，从而可能引发异常。 鉴于这种复杂性，要么 await tasks，要么处理所有可能的异常。\n在 echo server 中，首先可以做的是使用 try/catch 语法，记录下异常并关闭连接：\nimport logging async def echo(connection: socket, loop: AbstractEventLoop) -\u003e None: try: while data := await loop.sock_recv(connection, 1024): print(\"got data!\") if data == b\"boom\\r\\n\": raise Exception(\"Unexcepted network error\") await loop.sock_sendall(connection, data) except Exception as ex: logging.exception(ex) finally: connection.close() 这将解决因异常导致的直接问题，即服务器会报错任务异常未被捕获，因为我们在协程内部已自行处理。 这也将在 finally 块中正确关闭 socket，因此不会留下一个未关闭的悬空异常。\n该实现会在应用程序关闭时，正确关闭所有已建立的客户端连接。 在之前章节说过，asyncio.run 会取消未完成的 tasks。 如果 await 这个 task 则会产生一个 CancelledError。\n这里的重点是要注意异常是在何处产生的。 如果你的任务是在等待一个类似 await loop.sock_recv 的语句，并且取消那个 task，这行就会产生一个 CancelledError。 这意味着对于上述代码，在任务被取消时 finally 块依然会执行，因为取消任务时我们就在 await 语句上抛出了一个异常。 如果我们修改 except 代码，使其捕获并记录 CancelledError，你将会看到每个任务都会产生一个 CancelledError。\n上面已经解决了 echo tasks 失败的情况，那如果应用程序关闭后要如何处理这些失败的 tasks 呢？ 下面介绍 asyncio signal handlers\nShutting down gracefully 如果我们想要关闭我们的应用程序怎么办？ 我们可以向应用添加自定义关闭逻辑，任何还在运行中的 tasks 都能在几秒内发送需要的信息。\n本篇内容不适用 Windows 系统: [https:// stackoverflow.com/questions/35772001](https:// stackoverflow.com/questions/35772001)\nListening for signals Singals 信号是一个 Unix 系统的概念。 例如使用 Ctrl-C 来关闭一个命令行工具就是发送了信号 SIGINT (singal interrupt)，这和在 Python 中捕获 KeyboardInterput 异常一样。 另一个常见的信号是 SIGTERM，这是使用 kill 命令杀死某个进程的信号。\n为了实现自定义关闭逻辑，将会监听 SIGINT 和 SIGTERM 信号。 并在监听器中实现允许任何 echo tasks 能够在几秒内完成。\nasyncio 事件循环允许我们通过 add_signal_handler 方法直接监听任何事件。 这与 signal 模块中的 signal.signal 函数设置的信号处理器不同。 add_signal_handler 能够安全地与事件循环交互。 该函数接收一个信号和一个函数，当监听到相应信号后会调用传入的函数。\n下面编写一个 signal handler 来取消所有运行中的 tasks。 asyncio 有个方便的 tasks 叫做 asyncio.all_tasks。\n# Adding a signal handler to cancel all tasks import asyncio import signal from asyncio import AbstractEventLoop from util.delay_functions import delay def cancel_tasks(): print(\"Got a SIGNAL!\") tasks: set[asyncio.Task] = asyncio.all_tasks() print(f\"Cancelling {len(tasks)} task(s).\") [task.cancel() for task in tasks] async def main(): loop: AbstractEventLoop = asyncio.get_running_loop() loop.add_signal_handler(signal.SIGINT, cancel_tasks) await delay(10) asyncio.run(main()) 从 Python 3.11 版本开始，asyncio.run() 的设计趋于严格，不再允许 asyncio.run() 管理的事件训练里添加信号处理器。\n因此不同版本行为会不一致，上面代码在 Python 3.12 需要这样写\nimport asyncio import signal from util.delay_functions import delay def cancel_tasks(): print(\"Got a Signal!\") for task in asyncio.all_tasks(): task.cancel() async def main(): try: await delay(10) except asyncio.CancelledError: print(\"Main task cancelled.\") loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) loop.add_signal_handler(signal.SIGINT, cancel_tasks) loop.run_until_complete(main()) loop.close() Waiting for pending tasks ot finish 在原始的问题里，希望 echo server 的 tasks 能够在关闭前再运行几秒钟。 一种实现方式就是使用 wait_for 包装并 await 所有的 tasks。 如果任务超时，则会产生一个 TimeoutError，之后就可以终止程序。\n在 shutdown handler 里的一个问题是，这是一个普通的函数，无法在其内部 await。 一种解决方法就是创建一个协程来处理关闭逻辑，并将其包装成一个 task：\nasync def await_all_tasks(): tasks = asyncio.all_tasks() [await task for task in tasks] async def main(): loop = asyncio.get_event_loop() # Warp into a task loop.add_signal_handler(singal.SIGINT, lambda: asyncio.create_task(await_all_tasks())) 这样虽然能工作，但问题是如果 await_all_tasks 内触发了一个异常，将会产生一个孤儿 task，并抛出 “exception was never retrieved” （异常未捕获）的警告，可能隐藏潜在的错误。\n我们可以通过抛出一个自定义异常来停止主协程的运行，从而处理这个问题。 这样，当运行主协程时，我们可以捕获这个异常并执行任何关闭逻辑。 要实现这个功能，需要我们自定义事件循环，而不是使用 asyncio.run。 这是因为在 asyncio.run 中会取消所有在运行中的 tasks，这意味着我们不能将 echo tasks 给 wrap 包装进 wait_for 中：\nclass GracefulExit(SystemExit): pass def shutdown(): raise GracefulExit loop = asyncio.get_event_loop() loop.add_signal_handler(signal.SIGINT, shutdown) try: loop.run_until_complete(main()) except GracefulExit: loop.run_until_complete(close_echo_tasks(echo_tasks)) finally: loop.close() 顺着上面的思路来编写关闭逻辑\nasync def close_echo_tasks(echo_tasks: list[asyncio.Task]): waiters = [asyncio.wait_for(task, 2) for task in echo_tasks] for task in waiters: try: await task except asyncio.exceptions.TimeoutError: # Except a timeout error here pass 在 close_echo_tasks 中，我们使用一个 echo tasks 的列表，并将其包装到 wait_for task 里，设置 2 秒的超时时间。 这意味着，在我们取消这些任务前，他们将会有 2 秒时间结束任务。 我们捕获在这两秒任务中任何的 TimeoutErrors。\n结合上面说的所有逻辑，echo server 的关闭逻辑总体如下：\nimport asyncio from asyncio import AbstractEventLoop import socket import logging import signal async def echo(connection: socket.socket, loop: AbstractEventLoop) -\u003e None: try: while data := await loop.sock_recv(connection, 1024): print(\"got data!\") if data == b\"boom\\r\\n\": raise Exception(\"Unexpected network error\") await loop.sock_sendall(connection, data) except Exception as ex: logging.exception(ex) finally: connection.close() echo_tasks = [] async def connection_listener(server_socket, loop): while True: connection, address = await loop.sock_accept(server_socket) connection.setblocking(False) print(f\"Got a connection from {address}\") echo_task = asyncio.create_task(echo(connection, loop)) echo_tasks.append(echo_task) class GracefulExit(SystemExit): pass def shutdown(): raise GracefulExit() async def close_echo_tasks(echo_tasks: list[asyncio.Task]): waiters = [asyncio.wait_for(task, 2) for task in echo_tasks] # 这里实际上会串行等待 for task in waiters: try: await task except asyncio.exceptions.TimeoutError: pass # 并行等待 # results = await asyncio.gather(*waiters, return_exceptions=True) async def main(): server_socket = socket.socket() try: server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_address = (\"127.0.0.1\", 8002) server_socket.setblocking(False) server_socket.bind(server_address) server_socket.listen() for signame in {\"SIGINT\", \"SIGTERM\"}: loop.add_signal_handler(getattr(signal, signame), shutdown) await connection_listener(server_socket, loop) finally: server_socket.close() loop = asyncio.new_event_loop() try: loop.run_until_complete(main()) except GracefulExit: loop.run_until_complete(close_echo_tasks(echo_tasks)) finally: loop.close() 这段代码是一个支持优雅关闭 Graceful Shutdown 的异步 TCP Echo Server。\n核心思想：当收到关闭信号时，不是立刻终止，而是给正在处理的连接一些时间来完成工作。\necho: Echo 处理函数，接收数据原样返回，当接收到 “boom\\r\\n” 时模拟网络错误 cancel_listener: 连接管理器，异步等待新连接，为每个连接创建一个 task shutdown: 优雅关闭机制，通过自定义异常实现优雅关闭 close_echo_tasks: 任务清理函数，给每个任务最多 2 秒时间完成，超时后捕获 TimeoutError 并忽略 main: 主函数，允许端口重用，并注册关闭信号 现在通过 telnet localhost 8002 发送连接后，按 Ctrl-C 会等待两秒才关闭。\n但这段代码并不适合生产环境：\n首先是在等待 echo tasks 完成的时候，我们不会关闭 connection_listener。 即在关闭的时候，可能会有一个新的请求过来，这个新请求将无法被加入 2 秒的优雅关闭逻辑中。\n另一个原因是，每个 echo task 的关闭逻辑只会捕获 TimeoutExceptions。 这意味着，如果我们的某个任务抛出了其他类型的异常，我们将捕获该异常，而其他后续任务中可能出现的任何异常都将被忽略。\nSummary 在本章，展示了如何使用 blocking 和 non-blocking sockets，并更加深入了 asyncio 事件循环。 并使用 asyncio 创建了一个高并发的 echo server。 并展示了如何在 tasks 中处理错误，并添加自定义的关闭逻辑。\n",
  "wordCount" : "1975",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/og-default.avif","datePublished": "2025-12-01T08:00:00+08:00",
  "dateModified": "2025-12-01T08:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "Starslayerx"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/python-asyncio-03-a-first-asyncio-application/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Starslayerx' Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.svg"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Starslayerx&#39; Blog (Alt + H)">
                <img src="http://localhost:1313/favicon.svg" alt="" aria-label="logo"
                    height="35">Starslayerx&#39; Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                    <ul class="lang-switch"><li>|</li>
                        <li>
                            <a href="http://localhost:1313/zh-cn/" title="简体中文"
                                aria-label="简体中文">Zh-Cn</a>
                        </li>
                    </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Python asyncio 03: A first asyncio application
    </h1>
    <div class="post-meta"><span title='2025-12-01 08:00:00 +0800 CST'>December 1, 2025</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>1975 words</span>&nbsp;·&nbsp;<span>Starslayerx</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#working-with-blocking-sockets">Working with blocking sockets</a></li>
    <li><a href="#connecting-to-a-server-with-telnet">Connecting to a server with Telnet</a>
      <ul>
        <li><a href="#reading-and-writing-data-to-and-from-a-socket">Reading and writing data to and from a socket</a></li>
        <li><a href="#allowing-multiple-connections-and-the-dangers-of-blocking">Allowing multiple connections and the dangers of blocking</a></li>
        <li><a href="#working-with-non-blocking-sockets">Working with non-blocking sockets</a></li>
      </ul>
    </li>
    <li><a href="#using-the-selector-module-to-build-a-socket-event-loop">Using the selector module to build a socket event loop</a></li>
    <li><a href="#an-echo-server-on-the-asyncio-event-loop">An echo server on the asyncio event loop</a>
      <ul>
        <li><a href="#event-loop-coroutines-for-sockets">Event loop coroutines for sockets</a></li>
        <li><a href="#designing-an-asyncio-echo-server">Designing an asyncio echo server</a></li>
        <li><a href="#handling-errors-in-tasks">Handling errors in tasks</a></li>
      </ul>
    </li>
    <li><a href="#shutting-down-gracefully">Shutting down gracefully</a>
      <ul>
        <li><a href="#listening-for-signals">Listening for signals</a></li>
        <li><a href="#waiting-for-pending-tasks-ot-finish">Waiting for pending tasks ot finish</a></li>
      </ul>
    </li>
    <li><a href="#summary">Summary</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="working-with-blocking-sockets">Working with blocking sockets<a hidden class="anchor" aria-hidden="true" href="#working-with-blocking-sockets">#</a></h2>
<p>socket 是在网络中读取和写入数据的一种方式。
可以将 socket 看成一个邮件，将信封放到里面后运送到接收者的地址。</p>
<p>下面使用 Python 的内置 socket 模块来创建一个简单的 server</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">socket</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span></code></pre></div><p>这里，给 socket 函数指定了两个参数，第一个是 <code>socket.AF_INET</code>，这个告诉我们要与什么类型的地址进行交互，在这个例子中是 hostname 和 phonenumber。
第二个是 <code>socket.SO_REUSEADDR</code>，这个参数是说我们使用 TCP 协议进行交互。</p>
<p>然后使用 <code>socket.setsockopt</code> 方法将 <code>socket.SOL_SOCKET</code> 标志设置为 1。这将允许在关闭和快速重启应用，避免 <em>address already in use</em> 这类错误，如果不这样做将会消耗操作系统一段时间来解除与 port 的绑定。</p>
<p>使用 <code>socket.socket</code> 创建 socket 后，并不能开始沟通，因为还没有将其绑定到任何地址上面。
在本例中，将使用电脑本地地址 <code>127.0.0.1</code> 和任意 port 8000</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">server_address</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
</span></span></code></pre></div><p>这里将地址设置为 <code>127.0.0.1:8000</code>，这意味着 client 将能够使用该地址向服务器发送数据，如果要向 client 发送数据，也会看到该地址为来源地址。</p>
<p>接下来，在套接字上调用 <code>listen</code> 方法，主动监听来自客户端的连接请求。
随后，通过调用 <code>accept</code> 方法等待连接建立。
该方法会保持阻塞状态直至接收到连接请求，当连接成功时，将返回一个连接对象及客户端地址。
这个连接对象本质上是一个新的套接字，可以用于与客户端进行双向数据通信</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">connection</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="n">server_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
</span></span></code></pre></div><p>有了这些组件，我们便掌握了创建基于套接字的服务器应用所需的所有基础模块。
该应用将等待连接，并在建立连接后打印提示信息。</p>
<p>在收到请求后，将会打印一条信息并退出，下面使用 telnet cli 来发送请求。</p>
<h2 id="connecting-to-a-server-with-telnet">Connecting to a server with Telnet<a hidden class="anchor" aria-hidden="true" href="#connecting-to-a-server-with-telnet">#</a></h2>
<p>Telnet 是 &ldquo;teletype network&rdquo; 的缩写，telnet 会与指定的服务器和主机建立一个 TCP 连接。
可以使用下面命令连接服务器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">telnet localhost <span class="m">8000</span>
</span></span></code></pre></div><p>将会看到下面这样输出</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Trying ::1...
</span></span><span class="line"><span class="cl">Connection failed: Connection refused
</span></span><span class="line"><span class="cl">Trying 127.0.0.1...
</span></span><span class="line"><span class="cl">Connected to localhost.
</span></span><span class="line"><span class="cl">Escape character is <span class="s1">&#39;^]&#39;</span>.
</span></span><span class="line"><span class="cl">Connection closed by foreign host.
</span></span></code></pre></div><p>服务器会输出，表明已经建立了连接</p>
<pre tabindex="0"><code>I got a connection from (&#39;127.0.0.1&#39;, 61137)!
</code></pre><h3 id="reading-and-writing-data-to-and-from-a-socket">Reading and writing data to and from a socket<a hidden class="anchor" aria-hidden="true" href="#reading-and-writing-data-to-and-from-a-socket">#</a></h3>
<p>socket 有一个 <code>recv</code> 方法能够从中获取数据，该方法提供一个整数，代表在一段时间内想要读取的字节数。
这一点很重要，因为我们不能一次从 socket 中读取所有的数据，我们需要缓冲直到达到输入末尾。</p>
<p>当用户用 telnet 输入内容并按 Enter 时，telnet 会自动在你的输入后面追加两个字符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="err">`</span>\<span class="n">r</span>\<span class="n">n</span><span class="err">`</span> <span class="c1"># 回车(carriage return) + 换行(line feed)</span>
</span></span></code></pre></div><p>这里将 <code>socket.recv</code> 的缓冲区设得很小，这样更容易看到消息分片、拆包问题，从而观察 TCP 的行为。
实际开发中，recv 一般写成 1024，大的缓冲区更符合生产环境的性能要求。
使用较大的 buffer（比如 1024 bytes）可以减少应用程序反复调用 recv 的次数，TCP 数据会先在内核的 socket buffer 中缓存。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">socket</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># AF_INET: IPv4</span>
</span></span><span class="line"><span class="cl"><span class="c1"># SOCK_STREAM: 面向连接的字节流套接字，即 TCP</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>  <span class="c1"># Create a TCP server socket</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># SOL_SOCKET: 表示操作的是通用套接字级别的选项</span>
</span></span><span class="line"><span class="cl"><span class="c1"># SO_REUSEADDR: 端口快速重用选项</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1 表示启用</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">server_address</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>  <span class="c1"># 将 socket 地址设置为 127.0.0.1:8000</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>  <span class="c1"># 监听连接</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">connection</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="n">server_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>  <span class="c1"># 等待连接并为客户端分配一个信封邮箱</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;I got a connection from </span><span class="si">{</span><span class="n">client_address</span><span class="si">}</span><span class="s2">!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">buffer</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">buffer</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 连接已被对端关闭，返回空字节串 b&#39;&#39;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;I got data: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">buffer</span> <span class="o">+=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;All the data is: </span><span class="si">{</span><span class="n">buffer</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><p>上面去循环检查 buffer 最后两个字节码是不是 <code>\r\n</code>，如果不是就读取两个字节码到缓存里面，直到读取最后的 <code>\r\n</code>。
socket 有一个 <code>sendall</code> 方法，该方法接受一条数据并将其写回客户端。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl">    <span class="n">buffer</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">buffer</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;I got data: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">buffer</span> <span class="o">+=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;All the data is: </span><span class="si">{</span><span class="n">buffer</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 返回数据给客户端</span>
</span></span><span class="line"><span class="cl">    <span class="n">connection</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;Buffer: &#34;</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">)</span>
</span></span></code></pre></div><p>现在应该在输入内容后，能够看到 <code>Buffer: &lt;input&gt;</code> 的内容，这样就完成了一个基础的 echo server。</p>
<p>现在这个应用每次能处理一个客户端，但是多个客户端可能会连接到单个 server socket。
下面来修改这个示例，从而允许多个客户端同时连接。</p>
<h3 id="allowing-multiple-connections-and-the-dangers-of-blocking">Allowing multiple connections and the dangers of blocking<a hidden class="anchor" aria-hidden="true" href="#allowing-multiple-connections-and-the-dangers-of-blocking">#</a></h3>
<p>在监听模式下的 socket 同时运行多个 client 连接。
这意味着我们可以重复调用 <code>socket.accept</code>，并且每次客户端连接时，
都会获得一个新的连接套接字，用于与该客户端进行数据读写交互。
根据上面的知识，我们可以直接使用之前的例子来处理多个客户端。
一直循环调用 <code>socket.accept</code> 来监听新的连接。
每次得到一个新的连接，就将其插入到一个连接列表中，并遍历每个链接，接收输入的数据，并将数据写回客户端连接。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">socket</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">server_address</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">connections</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="n">server_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;I got a connection from </span><span class="si">{</span><span class="n">client_address</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">buffer</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="n">buffer</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">data</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;I got data: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">buffer</span> <span class="o">+=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;All the data is: </span><span class="si">{</span><span class="n">buffer</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><p>尝试运行上面代码，并使用 telnet 建立两个连接，会立刻发现一个问题。
第一个客户端运行正常，消息按预期返回，但第二个客户端却接收不到任何回显。
这是由于 socket 的默认注释行为导致的，<code>accept</code> 和 <code>recv</code> 方法会一直阻塞，直到接收到数据为止。</p>
<p>这意味着，一但第一个客户端连接后，我们将会阻塞并等待第一条 echo message。
这导致其他客户端被阻塞，等待循环的下一次迭代，这种情况只有在第一个客户端发送数据后才会发生。</p>
<p>这明显不是用户希望的结果，用户超过一个人后很难扩展。
可以通过将 sockets 设置为 non-blocking 模式来解决这个问题。
将 socket 设置为非阻塞后，其方法将不会阻塞等待数据，而是继续执行后面的代码。</p>
<h3 id="working-with-non-blocking-sockets">Working with non-blocking sockets<a hidden class="anchor" aria-hidden="true" href="#working-with-non-blocking-sockets">#</a></h3>
<p>在非阻塞模式下，如果套接字有数据准备就绪，那么我们将像使用阻塞套接字一样获得返回的数据。
如果没有，套接字会立即告诉我们它没有任何数据准备就绪，我们可以自由地继续执行其他代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">socket</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span></code></pre></div><p>使用阻塞和非阻塞的 socket 本质上并没有什么不同，除了要设置 <code>setblocking(False)</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">socket</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">server_address</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># non-blocking</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">connections</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="n">server_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># non-blocking</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;I got a connection from </span><span class="si">{</span><span class="n">client_address</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">buffer</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="n">buffer</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">data</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;I got data: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">buffer</span> <span class="o">+=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;All the data is: </span><span class="si">{</span><span class="n">buffer</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><p>但直接运行会产生一个 <code>BlockingIOError</code> 错误，因为服务器还未建立连接，因此还没有数据要处理</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">  File <span class="s2">&#34;/Users/starslayerx/GitHub/book_asyncio/socket_server.py&#34;</span>, line 16, in &lt;module&gt;
</span></span><span class="line"><span class="cl">    connection, <span class="nv">client_address</span> <span class="o">=</span> server_socket.accept<span class="o">()</span>
</span></span><span class="line"><span class="cl">                                 ^^^^^^^^^^^^^^^^^^^^^^
</span></span><span class="line"><span class="cl">  File <span class="s2">&#34;/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/socket.py&#34;</span>, line 295, in accept
</span></span><span class="line"><span class="cl">    fd, <span class="nv">addr</span> <span class="o">=</span> self._accept<span class="o">()</span>
</span></span><span class="line"><span class="cl">               ^^^^^^^^^^^^^^
</span></span><span class="line"><span class="cl">BlockingIOError: <span class="o">[</span>Errno 35<span class="o">]</span> Resource temporarily unavailable
</span></span></code></pre></div><p>这是套接字一种有点反直觉的表达方式，意思是说：“我现在没有任何数据，你等会儿再来调用我。”
这里没有简单的方法来判断 socket 是否有数据，所以一种解决方案就是捕获这个异常，把它忽略掉，然后不断循环，直到拿到数据。
采用这种策略，将会以尽可能快的速度不断检查是否有新的连接和数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">socket</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">server_address</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># non-blocking</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">connections</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">connection</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="n">server_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="n">connection</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># non-blocking</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;I got a connection from </span><span class="si">{</span><span class="n">client_address</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">buffer</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">while</span> <span class="n">buffer</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">data</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="k">break</span>
</span></span><span class="line"><span class="cl">                    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;I got data: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="n">buffer</span> <span class="o">+=</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl">                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;All the data is: </span><span class="si">{</span><span class="n">buffer</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">connection</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">pass</span>
</span></span><span class="line"><span class="cl"><span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><p>这样 <code>accept</code> 和 <code>recv</code> 就不会阻塞了，并且每次要么忽略，要么处理对应的数据。
循环的每次迭代都迅速完成，且从不依赖任何外部数据来推进下一行代码的执行。
这解决了阻塞服务器的问题，使得多个客户端能够同时连接并发送数据。</p>
<p>这种方法能够工作，但是有代价的。</p>
<ul>
<li>每当可能尚未获取数据时就捕获异常，不仅会使代码变得冗长，还可能容易出错。</li>
<li>第二个是资源问题，这个程序会使用几乎 100% 的 CPU 处理能力，因为不断的循环和获取报错导致 CPU 较高的工作负载。</li>
</ul>
<p>在之前提到过操作系统特有的事件通知系统，它能在 socket 有数据可操作的时候通知我们。
这些系统依赖于硬件层面的通知机制，而非刚才使用了轮询循环。
Python 内置了一个库来调用这种事件循环通知系统，下面将用其来解决 CPU 占用率问题，并构建一个套节字事件的小型事件循环。</p>
<h2 id="using-the-selector-module-to-build-a-socket-event-loop">Using the selector module to build a socket event loop<a hidden class="anchor" aria-hidden="true" href="#using-the-selector-module-to-build-a-socket-event-loop">#</a></h2>
<p>操作系统提供了高效的 API，允许我们监听 socket 以接收数据和其他事件。
虽然具体的 API 取决于系统（例如 kqeueu、epoll 和 IOCP），但这些 I/O 通知系统都基于相似的概念运行。
我们向系统提供一个需要监控事件的套节字列表，操作系统在套节字有数据时会明确通知我们，而不是去不断轮询检查每个套接字是否有数据。</p>
<p>由于这是硬件层面实现的，在监控中需要很少的 CPU 利用率，产生高效的资源利用。
这些通知系统是 asyncio 实现并发的核心，理解其工作原理能够帮助我们理解 asyncio 的工作方式。</p>
<p>这些 event notification system 在不同的系统中是不同的。
好在 Python 的 <code>selectors</code> 模块将底层抽象，无论在那个系统上运行，都能正确获取事件。</p>
<p>该库暴露一个抽象基类型 <code>BaseSelector</code>，该类型对不同的事件通知系统有着不同的实现。
同时，库中还包含 <code>DefaultSelector</code> 类，能够自动为当前系统选择最高效的实现方案。</p>
<p><code>BaseSelector</code> 类有一些重要的概念：</p>
<ol>
<li><em>registration</em>: 注册，当我们有一个感兴趣的套接字，希望获取其通知时，我们会将其注册到选择器中，并告之需要关注哪些事件。
这些事件有 read 和 write，相反，也可以取消不感兴趣的注册。</li>
<li><em>select</em>: select 选择器会阻塞直到有事件发生，一但事件触发，该调用将返回一个包含带处理的列表以及它触发的事件。
它还支持超时设置，在指定时间后若无事件则返回空的事件集和。</li>
</ol>
<p>通过上面的方法，我们能够创建一个不会压垮 CPU 的非阻塞 echo server。
一旦我们创建了服务器套接字，就会将其注册到默认的选择器 selector 中，该选择器将监听来自客户端的任何连接。
之后在任何时间某人连接到我们的 server socket，我们将会注册客户端 connection socket，并使用 selector 观察任何数据发送。</p>
<p>如果获取到任何不是来自 server socket 的数据，我们就知道是 client 发送了数据，然后我们收到数据并将其写入客户端。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">selectors</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">socket</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">selectors</span> <span class="kn">import</span> <span class="n">SelectorKey</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">selector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">DefaultSelector</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">server_address</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&#34;127.0.0.1&#34;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">server_socket</span><span class="p">,</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_READ</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 创建 1 秒过期的选择器</span>
</span></span><span class="line"><span class="cl">    <span class="n">events</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">SelectorKey</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 没有事件</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;No events, waiting a bit more!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 获取 socket event</span>
</span></span><span class="line"><span class="cl">        <span class="n">event_socket</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">fileobj</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">event_socket</span> <span class="o">==</span> <span class="n">server_socket</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">connection</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="n">server_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="n">connection</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;I got a connection from </span><span class="si">{</span><span class="n">address</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_READ</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">data</span> <span class="o">=</span> <span class="n">event_socket</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;I got some data: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">event_socket</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span></span></code></pre></div><p>这样实现的 echo server 的 CPU 利用率就少了很多，虽然仍然是死循环，但是循环内部的 <code>selector()</code> 会让线程进入内核的阻塞睡眠状态，直到超时才会 print() 一条语句，是典型的事件驱动。</p>
<p>而 try except 轮询会不间断的轮询，且内部会不断抛出异常、处理异常、重试等，CPU 占用很高。</p>
<hr>
<p>上面构建的部分和 asyncio 底层的大部分工作方式类似。
在这个例子中，events 是 sockets 接收数据。
无论是我们的事件循环还是 asyncio 的事件循环，它们的每一次迭代都是由两种情况触发的：要么有某个 socket 事件发生，要么是超时导致事件循环继续运行。</p>
<p>在 asyncio 的事件循环里，只要发生了这两种情况中的任意一种，所有正在等待调度的协程都会运行，直到它们结束，或者它们遇到下一个 await 语句为止。</p>
<p>当协程执行到一个基于非阻塞 socket 的 await 时，该 socket 会被注册到系统的 selector 中，同时事件循环会记录该协程已暂停并正在等待这个 socket 的结果。</p>
<p>我们可以把这个概念翻译成伪代码来展示。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">paused</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="n">ready</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">paused</span><span class="p">,</span> <span class="n">new_sockets</span> <span class="o">=</span> <span class="n">run_ready_tasks</span><span class="p">(</span><span class="n">ready</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">new_sockets</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">timeout</span> <span class="o">=</span> <span class="n">calculate_timeout</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">events</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">ready</span> <span class="o">=</span> <span class="n">process_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
</span></span></code></pre></div><p>我们会运行所有“已经准备好的协程”，直到他们在某个 await 语句上暂停，并把这些协程放到 paused 列表中。
同时，还会记录这些协程运行过程中产生的所有新 socket，并将他们注册到 selector 中。
之后，我们需要计算下一次调用 select 时的超时时间。
这个 timeout 的计算方式比较复杂，但通常取决于在未来某个时间点或者等待某个持续时间后要执行的任务。
例如 asyncio.sleep() 就会影响这个 timeout。</p>
<p>接着，调用 select 并等待 socket 事件或超时。
当其中一个发生时，会处理这些事件，并将其转化为一个可立即继续执行的协程列表。</p>
<hr>
<p>虽然上面的 event loop 只是用于 socket 的，但其展示了使用 selectors 注册 sockets 的主要思想，
即只在我们关心的事件发生后才启动。</p>
<p>然而，如果我们仅使用 selectors 来构建应用程序，就需要自行实现事件循环才能达到与 asyncio 相同的功能。
下面介绍如何使用 async/await 来实现上面功能。</p>
<h2 id="an-echo-server-on-the-asyncio-event-loop">An echo server on the asyncio event loop<a hidden class="anchor" aria-hidden="true" href="#an-echo-server-on-the-asyncio-event-loop">#</a></h2>
<p>使用 <code>select</code> 对于很多应用来说有些太底层了。
我们可能希望在等待 socket 的时候，让代码在后台运行，或者我们可能希望按计划执行后台任务。
如果只使用 selectors 来实现这个，我们将需要构建自己的事件循环，与此同时，asyncio 有一个完整的实现可以使用。
此外，coroutines 和 tasks 在 selectors 之上提供了抽象层，这使得我们代码更易于实现和维护，无需考虑 selectors 细节。</p>
<p>下面通过 asyncio 的 coroutines 和 tasks 再次实现前面的 echo server。
这里仍然会通过底层 API 来实现，这些 API 会返回 coroutines 和 tasks。</p>
<h3 id="event-loop-coroutines-for-sockets">Event loop coroutines for sockets<a hidden class="anchor" aria-hidden="true" href="#event-loop-coroutines-for-sockets">#</a></h3>
<p>考虑到 sockets 的一个相对底层的概念，处理他们的方法是通过 asyncio 的事件循环。
下面会使用三种主要的协程处理：</p>
<ul>
<li><code>sock_accept</code></li>
<li><code>sock_recv</code></li>
<li><code>sock_sendall</code></li>
</ul>
<p>这些方法和之前的很类似，不同在于这些方法会将 socket 作为一个参数输入，这样我们可以 <code>await</code> 返回的协程，直到我们得到可以作用于其上的数据。</p>
<p>下面先从 <code>sock_accept</code> 开始，这个协程类似之前的 <code>socket.accept</code> 方法。</p>
<p>该方法返回一个 tuple: <code>(socket_connection, client_address)</code>，传入感兴趣的 socket，然后 <code>await</code> 等待连接返回。
一但接受该协程就能获取到连接与地址，这个 socket 必须是非阻塞的，并和一个端口绑定起来：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">connection</span><span class="p">,</span> <span class="n">addresss</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">socke_accept</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
</span></span></code></pre></div><p><code>sock_recv</code> 和 <code>sock_sendall</code> 也是类似的，输入一个 socket，然后 <code>await</code> 等待结果。</p>
<ul>
<li><code>sock_recv</code> 会等待直到有可以处理的字节</li>
<li><code>sock_sendall</code> 同时接受一个 socket 和要发送的 data，它会等待直到所有数据成功发送至 socket，并在成功后返回 <code>None</code></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_recv</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">success</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_sendall</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="designing-an-asyncio-echo-server">Designing an asyncio echo server<a hidden class="anchor" aria-hidden="true" href="#designing-an-asyncio-echo-server">#</a></h3>
<p>之前介绍了 coroutines 和 tasks，那么什么时候使用 coroutine，什么时候使用 task 呢？
让我们来审视一下，我们希望应用程序如何表现以做出这一判断。</p>
<p>我们从如何监听应用连接开始。
当监听应用连接的时候，一次将只能处理一个连接，因为 <code>socket.accept</code> 只会给客户端一个连接。
如果有多个连接到达，后续的连接会被存储到一个被称作 <code>backlog</code> 的队列里面。</p>
<p>由于不需要并发处理多个连接，单个协程循环就足够了。
这样能够让其他代码在等待连接的时候并发执行。
这里定义一个一直循环的协程 <code>listen_for_connections</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">listen_for_connections</span><span class="p">(</span><span class="n">server_socket</span><span class="p">:</span> <span class="n">socket</span><span class="p">,</span> <span class="n">loop</span><span class="p">:</span> <span class="n">AbstractEventLoop</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_accept</span><span class="p">(</span><span class="n">server_socket</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Got a connection from </span><span class="si">{</span><span class="n">address</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>这样就有了一个监听连接的协程，由于要并发处理多个 connection，因此这里要为每个 connection 创建一个 task 来读写数据。</p>
<p>这里将创建负责处理数据的协程 <code>echo</code>，这个协程会一直循环来接收来自 client 的数据，一但其收到数据，就写会到 client 中去。
然后在 <code>listen_for_connections</code> 里，创建一个 task 来包装 <code>echo</code> 协程。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">socket</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">asyncio</span> <span class="kn">import</span> <span class="n">AbstractEventLoop</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">connection</span><span class="p">:</span> <span class="n">socket</span><span class="p">,</span> <span class="n">loop</span><span class="p">:</span> <span class="n">AbstractEventLoop</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">data</span> <span class="o">:=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_recv</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="mi">1024</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_sendall</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">listen_for_connections</span><span class="p">(</span><span class="n">server_socket</span><span class="p">:</span> <span class="n">socket</span><span class="p">,</span> <span class="n">loop</span><span class="p">:</span> <span class="n">AbstractEventLoop</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_accept</span><span class="p">(</span><span class="n">server_socket</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Got a connection from </span><span class="si">{</span><span class="n">address</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">echo</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">loop</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">server_address</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&#34;127.0.0.1&#34;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">await</span> <span class="n">listen_for_connections</span><span class="p">(</span><span class="n">server_socket</span><span class="p">,</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span></code></pre></div><p>架构如下：</p>
<ul>
<li>协程 <code>listen_for_connections</code> 持续监听连接，收到连接后该协程就会切换到 <code>echo</code> task 去处理每个连接
<ul>
<li>Client 1 echo task &lt;&ndash;Read/Write&ndash;&gt; Client 1</li>
<li>Client 2 echo task &lt;&ndash;Read/Write&ndash;&gt; Client 2</li>
<li>Client 3 echo task &lt;&ndash;Read/Write&ndash;&gt; Client 3</li>
</ul>
</li>
</ul>
<p>这样设计的 echo server 实际上有一个问题，下面来解决</p>
<h3 id="handling-errors-in-tasks">Handling errors in tasks<a hidden class="anchor" aria-hidden="true" href="#handling-errors-in-tasks">#</a></h3>
<p>网络连接通常都是不可靠的，我们可能得到非预期的报错。
下面修改 echo 的实现，添加一个错误处理的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">connection</span><span class="p">:</span> <span class="n">socket</span><span class="p">,</span> <span class="n">loop</span><span class="p">:</span> <span class="n">AbstractEventLoop</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">data</span> <span class="o">:=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="mi">1024</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">&#34;boom</span><span class="se">\r\n</span><span class="s2">&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&#34;Unexcepted network error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_sendall</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span></span></code></pre></div><p>现在只要发送 boom 就会导致下面这样的报错：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Got a connection from (&#39;127.0.0.1&#39;, 49470)
</span></span><span class="line"><span class="cl">Task exception was never retrieved
</span></span><span class="line"><span class="cl">future: &lt;Task finished name=&#39;Task-2&#39; coro=&lt;echo() done, defined at /Users/starslayerx/GitHub/book_asyncio/asyncio_echo_server.py:4&gt; exception=Exception(&#39;Unexcepted network error&#39;)&gt;
</span></span><span class="line"><span class="cl">Traceback (most recent call last):
</span></span><span class="line"><span class="cl">  File &#34;/Users/starslayerx/GitHub/book_asyncio/asyncio_echo_server.py&#34;, line 7, in echo
</span></span><span class="line"><span class="cl">    raise Exception(&#34;Unexcepted network error&#34;)
</span></span></code></pre></div><p>这里的重点在于 <code>Task exception was never retrieved</code>。
当一个异常在 task 内部被抛出时，这个任务会被视为已完成，并且它的“结果”就是这个异常。
这意味着异常不会沿着调用栈向上传递。
此外，这里没有任何清理逻辑。
如果该异常被抛出，则无法对任务失败做出反应，因为从未获取 retrieve 这个异常。</p>
<p>要让异常真正传递，必须在 await 表达式中使用 task。
当 await 一个失败的 task 时，异常会在 await 的地方重新抛出，其 traceback 也会在该位置体现。
如果在程序中从未 await 一个 task，就有可能永远看不到这个 task 抛出的异常。</p>
<p>下面演示，与其忽略在 <code>listen_for_connection</code> 里面创建的 echo tasks，我们通过列表来跟踪他们</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">tasks</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">listen_for_connection</span><span class="p">(</span><span class="n">server_socket</span><span class="p">:</span> <span class="n">socket</span><span class="p">,</span> <span class="n">loop</span><span class="p">:</span> <span class="n">AbstractEventLoop</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">socket_accept</span><span class="p">(</span><span class="n">server_socket</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Got a connection from </span><span class="si">{</span><span class="n">address</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">echo</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">loop</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span></code></pre></div><p>看上去可能会和之前一样，如果输入 boom 应该会看到警告被打印出来，同时伴随着从未获取任务异常的警告。
然而，实际上并不是这样，除非强制终止程序，否则什么都看不到。</p>
<p>这样因为我们保留了 task 的引用，asyncio 只有在任务被垃圾回收的之后才能打印出 traceback 或 failed task 相关信息。
这是因为无法判断该任务是否会在应用程序的其他某个时刻被等待，从而可能引发异常。
鉴于这种复杂性，要么 await tasks，要么处理所有可能的异常。</p>
<p>在 echo server 中，首先可以做的是使用 try/catch 语法，记录下异常并关闭连接：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">logging</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">connection</span><span class="p">:</span> <span class="n">socket</span><span class="p">,</span> <span class="n">loop</span><span class="p">:</span> <span class="n">AbstractEventLoop</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="n">data</span> <span class="o">:=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_recv</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="mi">1024</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;got data!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">&#34;boom</span><span class="se">\r\n</span><span class="s2">&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&#34;Unexcepted network error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_sendall</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><p>这将解决因异常导致的直接问题，即服务器会报错任务异常未被捕获，因为我们在协程内部已自行处理。
这也将在 finally 块中正确关闭 socket，因此不会留下一个未关闭的悬空异常。</p>
<p>该实现会在应用程序关闭时，正确关闭所有已建立的客户端连接。
在之前章节说过，asyncio.run 会取消未完成的 tasks。
如果 await 这个 task 则会产生一个 CancelledError。</p>
<p>这里的重点是要注意异常是在何处产生的。
如果你的任务是在等待一个类似 <code>await loop.sock_recv</code> 的语句，并且取消那个 task，这行就会产生一个 <code>CancelledError</code>。
这意味着对于上述代码，在任务被取消时 finally 块依然会执行，因为取消任务时我们就在 await 语句上抛出了一个异常。
如果我们修改 except 代码，使其捕获并记录 CancelledError，你将会看到每个任务都会产生一个 CancelledError。</p>
<p>上面已经解决了 echo tasks 失败的情况，那如果应用程序关闭后要如何处理这些失败的 tasks 呢？
下面介绍 asyncio signal handlers</p>
<h2 id="shutting-down-gracefully">Shutting down gracefully<a hidden class="anchor" aria-hidden="true" href="#shutting-down-gracefully">#</a></h2>
<p>如果我们想要关闭我们的应用程序怎么办？
我们可以向应用添加自定义关闭逻辑，任何还在运行中的 tasks 都能在几秒内发送需要的信息。</p>
<blockquote>
<p>本篇内容不适用 Windows 系统:
[https:// stackoverflow.com/questions/35772001](https:// stackoverflow.com/questions/35772001)</p>
</blockquote>
<h3 id="listening-for-signals">Listening for signals<a hidden class="anchor" aria-hidden="true" href="#listening-for-signals">#</a></h3>
<p>Singals 信号是一个 Unix 系统的概念。
例如使用 Ctrl-C 来关闭一个命令行工具就是发送了信号 SIGINT (singal interrupt)，这和在 Python 中捕获 KeyboardInterput 异常一样。
另一个常见的信号是 SIGTERM，这是使用 kill 命令杀死某个进程的信号。</p>
<p>为了实现自定义关闭逻辑，将会监听 SIGINT 和 SIGTERM 信号。
并在监听器中实现允许任何 echo tasks 能够在几秒内完成。</p>
<p>asyncio 事件循环允许我们通过 <code>add_signal_handler</code> 方法直接监听任何事件。
这与 signal 模块中的 <code>signal.signal</code> 函数设置的信号处理器不同。
<code>add_signal_handler</code> 能够安全地与事件循环交互。
该函数接收一个信号和一个函数，当监听到相应信号后会调用传入的函数。</p>
<p>下面编写一个 signal handler 来取消所有运行中的 tasks。
asyncio 有个方便的 tasks 叫做 <code>asyncio.all_tasks</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="c1"># Adding a signal handler to cancel all tasks</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">signal</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">asyncio</span> <span class="kn">import</span> <span class="n">AbstractEventLoop</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">util.delay_functions</span> <span class="kn">import</span> <span class="n">delay</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">cancel_tasks</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Got a SIGNAL!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">tasks</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">]</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">all_tasks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Cancelling </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span><span class="si">}</span><span class="s2"> task(s).&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="p">:</span> <span class="n">AbstractEventLoop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">cancel_tasks</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">await</span> <span class="n">delay</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span></code></pre></div><p>从 Python 3.11 版本开始，<code>asyncio.run()</code> 的设计趋于严格，不再允许 <code>asyncio.run()</code> 管理的事件训练里添加信号处理器。</p>
<p>因此不同版本行为会不一致，上面代码在 Python 3.12 需要这样写</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">signal</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">util.delay_functions</span> <span class="kn">import</span> <span class="n">delay</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">cancel_tasks</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Got a Signal!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">all_tasks</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="n">task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">delay</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Main task cancelled.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">asyncio</span><span class="o">.</span><span class="n">set_event_loop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">cancel_tasks</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><h3 id="waiting-for-pending-tasks-ot-finish">Waiting for pending tasks ot finish<a hidden class="anchor" aria-hidden="true" href="#waiting-for-pending-tasks-ot-finish">#</a></h3>
<p>在原始的问题里，希望 echo server 的 tasks 能够在关闭前再运行几秒钟。
一种实现方式就是使用 <code>wait_for</code> 包装并 await 所有的 tasks。
如果任务超时，则会产生一个 TimeoutError，之后就可以终止程序。</p>
<p>在 shutdown handler 里的一个问题是，这是一个普通的函数，无法在其内部 await。
一种解决方法就是创建一个协程来处理关闭逻辑，并将其包装成一个 task：</p>
<pre tabindex="0"><code>async def await_all_tasks():
    tasks = asyncio.all_tasks()
    [await task for task in tasks]

async def main():
    loop = asyncio.get_event_loop()
    # Warp into a task
    loop.add_signal_handler(singal.SIGINT, lambda: asyncio.create_task(await_all_tasks()))
</code></pre><p>这样虽然能工作，但问题是如果 await_all_tasks 内触发了一个异常，将会产生一个孤儿 task，并抛出 &ldquo;exception was never retrieved&rdquo; （异常未捕获）的警告，可能隐藏潜在的错误。</p>
<p>我们可以通过抛出一个自定义异常来停止主协程的运行，从而处理这个问题。
这样，当运行主协程时，我们可以捕获这个异常并执行任何关闭逻辑。
要实现这个功能，需要我们自定义事件循环，而不是使用 asyncio.run。
这是因为在 asyncio.run 中会取消所有在运行中的 tasks，这意味着我们不能将 echo tasks 给 wrap 包装进 <code>wait_for</code> 中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GracefulExit</span><span class="p">(</span><span class="ne">SystemExit</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">shutdown</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">raise</span> <span class="n">GracefulExit</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">shutdown</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="n">GracefulExit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">close_echo_tasks</span><span class="p">(</span><span class="n">echo_tasks</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><p>顺着上面的思路来编写关闭逻辑</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">close_echo_tasks</span><span class="p">(</span><span class="n">echo_tasks</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">    <span class="n">waiters</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">echo_tasks</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">waiters</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">await</span> <span class="n">task</span>
</span></span><span class="line"><span class="cl">        <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Except a timeout error here</span>
</span></span><span class="line"><span class="cl">            <span class="k">pass</span>
</span></span></code></pre></div><p>在 <code>close_echo_tasks</code> 中，我们使用一个 echo tasks 的列表，并将其包装到 <code>wait_for</code> task 里，设置 2 秒的超时时间。
这意味着，在我们取消这些任务前，他们将会有 2 秒时间结束任务。
我们捕获在这两秒任务中任何的 TimeoutErrors。</p>
<p>结合上面说的所有逻辑，echo server 的关闭逻辑总体如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">asyncio</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">asyncio</span> <span class="kn">import</span> <span class="n">AbstractEventLoop</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">socket</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">logging</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">signal</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">connection</span><span class="p">:</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">,</span> <span class="n">loop</span><span class="p">:</span> <span class="n">AbstractEventLoop</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="n">data</span> <span class="o">:=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_recv</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="mi">1024</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;got data!&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">&#34;boom</span><span class="se">\r\n</span><span class="s2">&#34;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&#34;Unexpected network error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_sendall</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">echo_tasks</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">connection_listener</span><span class="p">(</span><span class="n">server_socket</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="p">,</span> <span class="n">address</span>  <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">sock_accept</span><span class="p">(</span><span class="n">server_socket</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">connection</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Got a connection from </span><span class="si">{</span><span class="n">address</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">echo_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">echo</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">loop</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">echo_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">echo_task</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">GracefulExit</span><span class="p">(</span><span class="ne">SystemExit</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">shutdown</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="k">raise</span> <span class="n">GracefulExit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">close_echo_tasks</span><span class="p">(</span><span class="n">echo_tasks</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">]):</span>
</span></span><span class="line"><span class="cl">    <span class="n">waiters</span> <span class="o">=</span> <span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">echo_tasks</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 这里实际上会串行等待</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">waiters</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">await</span> <span class="n">task</span>
</span></span><span class="line"><span class="cl">        <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">pass</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 并行等待</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># results = await asyncio.gather(*waiters, return_exceptions=True)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">server_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">server_address</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&#34;127.0.0.1&#34;</span><span class="p">,</span> <span class="mi">8002</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">server_socket</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">signame</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&#34;SIGINT&#34;</span><span class="p">,</span> <span class="s2">&#34;SIGTERM&#34;</span><span class="p">}:</span>
</span></span><span class="line"><span class="cl">            <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signame</span><span class="p">),</span> <span class="n">shutdown</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">await</span> <span class="n">connection_listener</span><span class="p">(</span><span class="n">server_socket</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">server_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="k">except</span> <span class="n">GracefulExit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">close_echo_tasks</span><span class="p">(</span><span class="n">echo_tasks</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="k">finally</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span></span></code></pre></div><p>这段代码是一个支持优雅关闭 Graceful Shutdown 的异步 TCP Echo Server。</p>
<p>核心思想：当收到关闭信号时，不是立刻终止，而是给正在处理的连接一些时间来完成工作。</p>
<ul>
<li><code>echo</code>: Echo 处理函数，接收数据原样返回，当接收到 &ldquo;boom\r\n&rdquo; 时模拟网络错误</li>
<li><code>cancel_listener</code>: 连接管理器，异步等待新连接，为每个连接创建一个 task</li>
<li><code>shutdown</code>: 优雅关闭机制，通过自定义异常实现优雅关闭</li>
<li><code>close_echo_tasks</code>: 任务清理函数，给每个任务最多 2 秒时间完成，超时后捕获 TimeoutError 并忽略</li>
<li><code>main</code>: 主函数，允许端口重用，并注册关闭信号</li>
</ul>
<p>现在通过 <code>telnet localhost 8002</code> 发送连接后，按 Ctrl-C 会等待两秒才关闭。</p>
<p>但这段代码并不适合生产环境：</p>
<p>首先是在等待 echo tasks 完成的时候，我们不会关闭 connection_listener。
即在关闭的时候，可能会有一个新的请求过来，这个新请求将无法被加入 2 秒的优雅关闭逻辑中。</p>
<p>另一个原因是，每个 echo task 的关闭逻辑只会捕获 TimeoutExceptions。
这意味着，如果我们的某个任务抛出了其他类型的异常，我们将捕获该异常，而其他后续任务中可能出现的任何异常都将被忽略。</p>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>在本章，展示了如何使用 blocking 和 non-blocking sockets，并更加深入了 asyncio 事件循环。
并使用 asyncio 创建了一个高并发的 echo server。
并展示了如何在 tasks 中处理错误，并添加自定义的关闭逻辑。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/python/">Python</a></li>
      <li><a href="http://localhost:1313/tags/asyncio/">Asyncio</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/writing-a-good-claude.md/">
    <span class="title">« Prev</span>
    <br>
    <span>Writing a good CLAUDE.md</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/docker-context/">
    <span class="title">Next »</span>
    <br>
    <span>Docker Context</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python asyncio 03: A first asyncio application on x"
            href="https://x.com/intent/tweet/?text=Python%20asyncio%2003%3a%20A%20first%20asyncio%20application&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-03-a-first-asyncio-application%2f&amp;hashtags=Python%2cAsyncio">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python asyncio 03: A first asyncio application on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-03-a-first-asyncio-application%2f&amp;title=Python%20asyncio%2003%3a%20A%20first%20asyncio%20application&amp;summary=Python%20asyncio%2003%3a%20A%20first%20asyncio%20application&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-03-a-first-asyncio-application%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python asyncio 03: A first asyncio application on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-03-a-first-asyncio-application%2f&title=Python%20asyncio%2003%3a%20A%20first%20asyncio%20application">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python asyncio 03: A first asyncio application on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-03-a-first-asyncio-application%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python asyncio 03: A first asyncio application on whatsapp"
            href="https://api.whatsapp.com/send?text=Python%20asyncio%2003%3a%20A%20first%20asyncio%20application%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-03-a-first-asyncio-application%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python asyncio 03: A first asyncio application on telegram"
            href="https://telegram.me/share/url?text=Python%20asyncio%2003%3a%20A%20first%20asyncio%20application&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-03-a-first-asyncio-application%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Python asyncio 03: A first asyncio application on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Python%20asyncio%2003%3a%20A%20first%20asyncio%20application&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpython-asyncio-03-a-first-asyncio-application%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">Starslayerx&#39; Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
