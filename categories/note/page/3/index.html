<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Note | Starslayerx' Blog</title><meta name=keywords content><meta name=description content="A personal blog about technology, programming, and daily notes"><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/categories/note/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://starslayerx.github.io/categories/note/index.xml title=rss><link rel=alternate hreflang=en href=https://starslayerx.github.io/categories/note/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/categories/note/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Note"><meta property="og:description" content="A personal blog about technology, programming, and daily notes"><meta property="og:locale" content="en-US"><meta property="og:type" content="website"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Note"><meta name=twitter:description content="A personal blog about technology, programming, and daily notes"></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/categories/>Categories</a></div><h1>Note
<a href=/categories/note/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Redis Bitmap</h2></header><div class=entry-content><p>Bitmap 位图 Redis 的位图 bitmap 是由多个二进制位组成的数组, 数组中的每个二进制都有与之对应的偏移量(索引), 用户通过这些偏移量可以对位图中指定的一个或多个二进制位进行操作.
Redis 为位图提供了一系列操作命令, 通过这些命令, 用户可以:
设置或获取索引位上的二进制值 统计位图中有多少个二进制位被设置成了1 查找位图中, 第一个被设置为指定值的二进制位, 并返回其偏移量 对一个或多个位图执行逻辑并、逻辑或、逻辑异或以及逻辑非运算 将指定类型的整数存储到位图中 SETBIT: 设置二进制位的值 SETBIT bitmap offset value 为位图指定偏移量上的二进制位设置值, 该命令会返回二进制位被设置之前的旧值作为结果.
当执行 SETBIT 时, 如果位图不存在, 或者位图当前的大小无法满足用户想要执行的设置操作, 那么 Redis 将对被设置的位图进行扩展, 使得位图可以满足用户的设置请求. 由于位图的扩展以字节为单位, 所以扩展后的位图包含的二进制数量可能会比用户要求的稍多一些. 且在扩展的同时, 会将未设置的二进制位初始化为 0.
与一些可以使用负数的 Redis 命令不同, SETBIT 命令只能使用正数偏移量, 尝试输入负数作为偏移量将引发一个错误
复杂度: O(1) GETBIT: 获取二进制位的值 GETBIT bitmap offset 与 SETBIT 命令一样, GETBIT 命令也只能接受正数作为偏移量.
对于偏移量超过位图索引的命令, GETBIT 命令将返回 0 作为结果.
复杂度: O(1) BITOCUNT: 统计被设置的二进制数量 BITCOUNT key 对于值为 10010100 的位图 bitmap001, 可以通过执行以下命令来统计有多少个二进制位被设置成了1:
...</p></div><footer class=entry-footer><span title='2025-09-19 08:00:00 +0800 +0800'>September 19, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>1009 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Redis Bitmap" href=https://starslayerx.github.io/posts/redis-bitmap/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Redis HyperLogLog</h2></header><div class=entry-content><p>之前曾介绍过使用 Redis 集和构建唯一计数器, 并将这个计数器用于计算网站的唯一房客 IP. 虽然使用集和实现唯一计数器可以实现该功能, 但这个方法有一个明显的缺陷: 随着被计数元素的不断增多, 唯一计数器占用的内存也会越来越大; 计数器越多, 他们的体积越大, 这一情况就会越严峻.
以计算唯一访客 IP 为例:
存储一个 IPv4 格式的 IP 地址最多需要 15 个字节 根据网站的规模不同, 每天出现的唯一 IP 可能会有数十万、数百万个 为了记录网站在不同时期的访客, 并进行相关的数据分析, 网站可能需要次序地记录每天的唯一访客 IP 数量 综上, 如果一个网站想要长时间记录访客 IP, 就必须创建多个唯一计数器. 如果访客比较多, 那么它创建的每个唯一计数器都将包含大量元素, 并因此占用相当一部分内存.
为了高效解决计算机唯一访客 IP 数量这类问题, 其中一种方法就是 HyperLogLog.
HyperLogLog 简介 HyperLogLog 是一个专门为了计算集和的基数而创建的概率算法, 对于一个给定的集和, HyperLogLog 可以计算出这个集合的近似基数: 近似基数并非集和的实际基数, 它可能会比实际的基数大一点或者小一点, 但误差会在一个合理范围内. 因此, 那些不需要知道实际基数的程序就可以把这个近似基数当作集合的基数来使用.
HyperLogLog 的优点在于计算近似基础所需的内存并不会因为集和的大小而改变, 无论集和包含元素有多少个, HyperLogLog 进行计算所需的内存总是固定的, 无论集和包含元素多少个, HyperLogLog 进行计算所需的内存总是固定的, 并且是非常少的.
PFADD: 对集和元素进行计数 PFADD hyperloglog element [element ...] 根据给定元素是否已经进行过计数, PFADD 命令可能返回0, 也可能返回1:
...</p></div><footer class=entry-footer><span title='2025-09-18 08:00:00 +0800 +0800'>September 18, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>456 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Redis HyperLogLog" href=https://starslayerx.github.io/posts/redis-hyperloglog/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Morden Javascript Tutorial Chapter 2 - Fundamentals: 06~10</h2></header><div class=entry-content><p>2.6 Interaction: alert, prompt, confirm Will introduce alert, prompt and confirm in this chapter.
alert It shows a message and waits for the user to press “OK”.
alert("Hello"); prompt This function prompt accepts two arguments
result = prompt(title, [default]); It shows a modal window with a text message, an input field for the visitor, and the buttons OK/Cancel.
title: The text to show the visitor. default: An optional second parameter, the initial value for the input field.
...</p></div><footer class=entry-footer><span title='2025-09-17 08:00:00 +0800 +0800'>September 17, 2025</span>&nbsp;·&nbsp;<span>15 min</span>&nbsp;·&nbsp;<span>3118 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Morden Javascript Tutorial Chapter 2 - Fundamentals: 06~10" href=https://starslayerx.github.io/posts/morden-javascript-tutorial-chapter-2-fundamentals-06~10/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Morden Javascript Tutorial Chapter 2 - Fundamentals: 01~05</h2></header><div class=entry-content><p>2.1 Hellow Wrold Firtly, let’s see how to attach a script to a webpage. For server-side environments (like Node.js), you can execute this script with a command like node my.js
The “script” tag JavaScript programs can be inserted almost anywhere into an HTML docuemnt using the &lt;script> tag
&lt;!DOCTYPE html> &lt;html> &lt;body> &lt;p>Before this script...&lt;/p> &lt;script> alert("Hello, World!"); &lt;/script> &lt;p>...After the script...&lt;/p> &lt;/body> &lt;/html> The &lt;script> tag contains JavaScript code which is automatically executed when the browser process the tag.
...</p></div><footer class=entry-footer><span title='2025-09-16 08:00:00 +0800 +0800'>September 16, 2025</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>3234 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Morden Javascript Tutorial Chapter 2 - Fundamentals: 01~05" href=https://starslayerx.github.io/posts/morden-javascript-tutorial-chapter-2-fundamentals-01~05/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Morden Javascript Tutorial Chapter 1 - An Introduction</h2></header><div class=entry-content><p>An Introduction to JavaScript Let’s see what’s so special about JavaScript, what we can achieve with it, and what other technologies play well with it.
Why is it call JavaScript? JavaScript initially called “Live Script”. But Java was popular at that time, so it was decided that positioning a new language as a “younger brother” of Java would help. But as it evolved, JavaScript became a fully independent language with its won specification called ECMAScript, and now it has no relation to Java at all.
...</p></div><footer class=entry-footer><span title='2025-09-15 08:00:00 +0800 +0800'>September 15, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>622 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Morden Javascript Tutorial Chapter 1 - An Introduction" href=https://starslayerx.github.io/posts/morden-javascript-tutorial-chapter-1-an-introduction/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Service Implementation Patterns for Microservice</h2></header><div class=entry-content><p>Hexagonal architectures for microservices 微服务的六边形架构 六边形架构 Hexagonal Architecture 也被称为接口与适配器架构 Prots and Adapters Architecture, 是一种软件架构模式, 旨在实现高内聚、低耦合和可测试性的应用程序设计. 该架构由 Alistair Cockburn 发明, 他是敏捷宣言的签署者之一. 该架构是说, 在任何应用程序中, 都有一个核心逻辑实现服务, 并且在该服务周围"附加"上一些接口, 用于核心与外部组件的交互.
例如, 一个 web API 就是一个适配器 adapter, 帮助核心逻辑与互联网上的 web 客户端交流. 对于数据库也是一样的, 其也是一个外部组件, 帮助服务维护数据. 如果我们需要, 应该要能迁移到其他的数据库, 并且服务仍然是相同的. 因此, 数据库也是一个适配器 adapter.
上述架构可通过在核心业务逻辑层与适配器之间构建接口 ports 来实现.
在处理核心业务逻辑与适配器之间的关系时, 应用依赖反转原则 dependency inversion principle:
高层模块不应该依赖底层细节.
相反, 两者都应该依赖抽象. 以数据存储为例, 我们应当通过统一的接口进行操作, 无需理解数据库的具体实现细节. 无论是 SQL 数据库、NoSQL 数据库还是缓存存储系统, 都应该使用相同的接口规范.
抽象不应依赖于具体实现, 而具体实现应依赖于抽象.
以业务层与数据层之间的接口设计为例, 必须确保接口不会因数据库实现细节的变动而修改, 相反地, 我们通过调整数据层实现来适配接口规范.这意味着数据层依赖于接口定义, 而非接口依赖于数据层实现.
依赖反转的概念经常同控制反转与依赖注入的概念一同出现, 这些是相关但是不同的概念.
...</p></div><footer class=entry-footer><span title='2025-09-10 08:00:00 +0800 +0800'>September 10, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>76 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Service Implementation Patterns for Microservice" href=https://starslayerx.github.io/posts/service-implementation-patterns-for-microservice/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Docker - Images</h2></header><div class=entry-content><p>每个 Linux 容器都基于一个镜像, 镜像重新构建运行中容器的底层定义. 要启动一个容器, 需要下载公共镜像或者创建自己的镜像. 每个镜像由一个或多个相互关联的文件系统层 layer 组成, 这些层通常与创建镜像的每个构建步骤大致一一对应.
由于镜像由独立的层构建而成, 这就对 Linux 内核提出了特殊要求: 内核必须提供 Docker 所需的驱动, 以便运行存储后端. 在镜像管理, Docker 高度依赖这个存储后端, 该后端通过与底层 Linux 文件系统通信, 用来构建并管理多个层并将它们组合成一个可用的镜像. 主要支持的后端存储有以下类型:
Overlay2 B-Tree File System Device Mapper 每一个后端都提供一个快速的 copy-on-write (CoW) 系统用于镜像管理. 包含:
Building images Uploading (pushing) images to an image registry Downloading (pulling) images from an image registry Creating and running containers from an image Anatomy of a Dockerfile | 剖析 Dockerfile 这个文件描述了所有构建一个容器所需的步骤, 并且通常存储在项目源码的根目录里.
一个典型的 Dockerfile 看起来像下面这样, 这里是创建一个 Node.js 的应用镜像:
...</p></div><footer class=entry-footer><span title='2025-09-07 08:00:00 +0800 +0800'>September 7, 2025</span>&nbsp;·&nbsp;<span>18 min</span>&nbsp;·&nbsp;<span>3803 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Docker - Images" href=https://starslayerx.github.io/posts/docker-images/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Docker - Workflow</h2></header><div class=entry-content><p>The Docker Workflow 这篇文章介绍 Docker 工作流
Revision Control 版本控制 Docker 有两种版本控制方式. 一个是用来跟踪文件系统层 layers (每个镜像的组成), 另一个是 tagging 标签系统.
Filesystem layers 文件系统层 Linux 容器由堆叠文件系统层组成, 每一层由一个唯一的哈希标记, 每次 build 都在之前的修改之上. 这意味着, 每次 build 只需要重新构建修改过的层. 这节省了时间和网络带宽.
Image Tags 镜像标签 第二种版本控制回答了一个问题: 之前部署的应用版本是? 非容器化应用的解决方案有很多种, 从 Git 发布标签到部署日志. Docker 有一个内置的处理机制: 每次 build 都有一个镜像标签. latest 经常被用来表示最新版本, 但由于这是一个浮动的标签, 因此在生产中使用并不好. 正确的做法应该是使用一个特定的版本.
Building 构建镜像 Docker 的命令行工具包含一个 build 标志, 它会读取 Dockerfile 并产生一个 Docker 镜像. Dockerfile 中的每一条指令都会在镜像中生成一个新的层, 因此仅通过查看 Dockerfile 就能比较容易的推断出构建会做什么. 这样标准化的好处是, 任何熟悉 Dockerfile 的工程师都可以直接上手并修改任何其他应用的构建. Dockerfile 通常会提交到版本控制系统, 这也简化了对构建变更的追踪, 现代的多阶段构建还运行将构建环境与最终镜像分离, 为构建环境提供了像生产容器那样强大的可配置性.
...</p></div><footer class=entry-footer><span title='2025-09-06 08:00:00 +0800 +0800'>September 6, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>368 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Docker - Workflow" href=https://starslayerx.github.io/posts/docker-workflow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Docker - Images and Registeries</h2></header><div class=entry-content><p>The Docker Images | Docker 镜像 Image、OCI Image、Docker Image、Container Image 都是指同一个概念镜像的不容叫法.
镜像是一个轻量、只读且不可变的蓝图, 指定了应用运行所谁要的一切, 以及在 Docker 系统上如何运行. 就像是一份配方, 包括所有必要的原料, 诸如依赖、配置、环境设置和你的应用代码, 以及确保应用每次都能稳定运行的详细指令.
可以把镜像类比为面向对象编程中的类: 定义结构和行为, 但不能直接与类交互, 需要创建实例.
Pulling and Inspecting an Image 拉取并查看镜像 镜像其实就是一个 JSON 对象, 可以这样拉取一个镜像
% docker pull celery:latest latest: Pulling from library/celery ef0380f84d05: Pull complete ada810c79ed7: Pull complete 4608a1c4fe47: Pull complete 58086cbb21fb: Pull complete a7bccb4a3faa: Pull complete 9de06a08ec25: Pull complete ad6feb8c6a6b: Pull complete 7568ca85d492: Pull complete 2d6f458f7411: Pull complete Digest: sha256:5c236059192a0389a2be21fc42d8db59411d953b7af5457faf501d4eec32dc31 Status: Downloaded newer image for celery:latest docker.io/library/celery:latest What's next: View a summary of image vulnerabilities and recommendations → docker scout quickview celery:latest 现在查看镜像信息
...</p></div><footer class=entry-footer><span title='2025-09-05 08:00:00 +0800 +0800'>September 5, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>890 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Docker - Images and Registeries" href=https://starslayerx.github.io/posts/docker-images-and-registeries/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Docker - Engine and Netowrking</h2></header><div class=entry-content><p>Docker 引擎(Docker Engine), 顾名思意，是 Docker 的核心. 它为 Docker 提供动力, 并承担所有繁重的工作. 本文将深入探讨这一关键组件的内部运作, 以便了解 Docker 在内核下是如何工作的.
The Evolution of the Docker Engine | Docker 引擎的演进 Docker 最初是一个巨大的单体(monolith), 所有代码都塞在同一个项目里. 对于 dotCloud来说, 这种方式一开始是可行的. 实际上, 这个方向运作得非常好, 以至于他们放弃了其他服务、把所有赌注都押在 Docker 上, 甚至把公司重命名为 Docker, Inc.
一开始, Docker 是一个又大又混乱的单体应用. 随着时间推移, Docker, Inc. 发现这种做法不可持续, 他们需要把系统拆分出来:
各个部分可以独立成长 更容易升级某些部分 - 可以替换旧组件而不影响整体 让社区更容易参与贡献 - 更小的组件意味着更多人能参与进来 更易跨平台 - 他们想要 Docker 在每个平台上运行, 而不只是 Linux 拆分的第一步是把客户端 client 剥离出来. 把客户端从大应用中抽出, 赋予它新职责: 把用户命令翻译成 Docker 引擎能理解的指令(也就是原来单体里"内核部分"的接口)
此时, Docker 引擎主要有两部分:
...</p></div><footer class=entry-footer><span title='2025-09-04 08:00:00 +0800 +0800'>September 4, 2025</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>653 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Docker - Engine and Netowrking" href=https://starslayerx.github.io/posts/docker-engine-and-netowrking/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://starslayerx.github.io/categories/note/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://starslayerx.github.io/categories/note/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>