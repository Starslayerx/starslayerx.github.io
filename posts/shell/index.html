<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Shell | Starslayerx' Blog</title><meta name=keywords content="Linux"><meta name=description content="Terminal
终端是提供文本用户界面的程序，早期终端是集成设备，键盘和屏幕集成在一起，现在终端知识简单的应用程序。
除了基本的输入输出外，终端还支持将所谓转义序列或转移码，用于光标和屏幕处理，并可能支持颜色。
例如，使用 Ctrl-h 会删除前面一个字符。
环境变量 TERM 可能使用了终端模拟器，其配置可以通过 infocmp 获得
#       Reconstructed via infocmp from file: /usr/share/terminfo/74/tmux-256color
tmux-256color|tmux with 256 colors,
        am, hs, km, mir, msgr, xenl,
        colors#256, cols#80, it#8, lines#24, pairs#32767,
        acsc=++\,\,--..00``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
        bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z, civis=\E[?25l,
        clear=\E[H\E[J, cnorm=\E[34h\E[?25h, cr=^M,
        ...
显示内容看上去很混乱，这些是
Shell
shell 是一个运行在终端内部的程序，充当命令解释器。
shell 通过流提供输入和输出处理，支持变量，有一些内置命令，处理命令执行和状态，支持交互式和脚本使用。
最初的 shell 叫做 Bourne shell sh，即作者名字命名，现在通常被 bash 替代，即 &ldquo;Bourne Again Shell&rdquo; 的缩写。
file -h /bin/sh
Stream
shell 为每个进程提供了三个默认的文件描述符 (FD)，用于输入和输出："><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/posts/shell/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://starslayerx.github.io/posts/shell/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/posts/shell/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Shell"><meta property="og:description" content="Terminal 终端是提供文本用户界面的程序，早期终端是集成设备，键盘和屏幕集成在一起，现在终端知识简单的应用程序。 除了基本的输入输出外，终端还支持将所谓转义序列或转移码，用于光标和屏幕处理，并可能支持颜色。 例如，使用 Ctrl-h 会删除前面一个字符。
环境变量 TERM 可能使用了终端模拟器，其配置可以通过 infocmp 获得
# Reconstructed via infocmp from file: /usr/share/terminfo/74/tmux-256color tmux-256color|tmux with 256 colors, am, hs, km, mir, msgr, xenl, colors#256, cols#80, it#8, lines#24, pairs#32767, acsc=++\,\,--..00``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~, bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z, civis=\E[?25l, clear=\E[H\E[J, cnorm=\E[34h\E[?25h, cr=^M, ... 显示内容看上去很混乱，这些是
Shell shell 是一个运行在终端内部的程序，充当命令解释器。 shell 通过流提供输入和输出处理，支持变量，有一些内置命令，处理命令执行和状态，支持交互式和脚本使用。 最初的 shell 叫做 Bourne shell sh，即作者名字命名，现在通常被 bash 替代，即 “Bourne Again Shell” 的缩写。
file -h /bin/sh Stream shell 为每个进程提供了三个默认的文件描述符 (FD)，用于输入和输出："><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-18T08:00:00+08:00"><meta property="article:modified_time" content="2025-12-18T08:00:00+08:00"><meta property="article:tag" content="Linux"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Shell"><meta name=twitter:description content="Terminal
终端是提供文本用户界面的程序，早期终端是集成设备，键盘和屏幕集成在一起，现在终端知识简单的应用程序。
除了基本的输入输出外，终端还支持将所谓转义序列或转移码，用于光标和屏幕处理，并可能支持颜色。
例如，使用 Ctrl-h 会删除前面一个字符。
环境变量 TERM 可能使用了终端模拟器，其配置可以通过 infocmp 获得
#       Reconstructed via infocmp from file: /usr/share/terminfo/74/tmux-256color
tmux-256color|tmux with 256 colors,
        am, hs, km, mir, msgr, xenl,
        colors#256, cols#80, it#8, lines#24, pairs#32767,
        acsc=++\,\,--..00``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
        bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z, civis=\E[?25l,
        clear=\E[H\E[J, cnorm=\E[34h\E[?25h, cr=^M,
        ...
显示内容看上去很混乱，这些是
Shell
shell 是一个运行在终端内部的程序，充当命令解释器。
shell 通过流提供输入和输出处理，支持变量，有一些内置命令，处理命令执行和状态，支持交互式和脚本使用。
最初的 shell 叫做 Bourne shell sh，即作者名字命名，现在通常被 bash 替代，即 &ldquo;Bourne Again Shell&rdquo; 的缩写。
file -h /bin/sh
Stream
shell 为每个进程提供了三个默认的文件描述符 (FD)，用于输入和输出："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://starslayerx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Shell","item":"https://starslayerx.github.io/posts/shell/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Shell","name":"Shell","description":"Terminal 终端是提供文本用户界面的程序，早期终端是集成设备，键盘和屏幕集成在一起，现在终端知识简单的应用程序。 除了基本的输入输出外，终端还支持将所谓转义序列或转移码，用于光标和屏幕处理，并可能支持颜色。 例如，使用 Ctrl-h 会删除前面一个字符。\n环境变量 TERM 可能使用了终端模拟器，其配置可以通过 infocmp 获得\n# Reconstructed via infocmp from file: /usr/share/terminfo/74/tmux-256color tmux-256color|tmux with 256 colors, am, hs, km, mir, msgr, xenl, colors#256, cols#80, it#8, lines#24, pairs#32767, acsc=++\\,\\,--..00``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~, bel=^G, blink=\\E[5m, bold=\\E[1m, cbt=\\E[Z, civis=\\E[?25l, clear=\\E[H\\E[J, cnorm=\\E[34h\\E[?25h, cr=^M, ... 显示内容看上去很混乱，这些是\nShell shell 是一个运行在终端内部的程序，充当命令解释器。 shell 通过流提供输入和输出处理，支持变量，有一些内置命令，处理命令执行和状态，支持交互式和脚本使用。 最初的 shell 叫做 Bourne shell sh，即作者名字命名，现在通常被 bash 替代，即 \u0026ldquo;Bourne Again Shell\u0026rdquo; 的缩写。\nfile -h /bin/sh Stream shell 为每个进程提供了三个默认的文件描述符 (FD)，用于输入和输出：\n","keywords":["Linux"],"articleBody":"Terminal 终端是提供文本用户界面的程序，早期终端是集成设备，键盘和屏幕集成在一起，现在终端知识简单的应用程序。 除了基本的输入输出外，终端还支持将所谓转义序列或转移码，用于光标和屏幕处理，并可能支持颜色。 例如，使用 Ctrl-h 会删除前面一个字符。\n环境变量 TERM 可能使用了终端模拟器，其配置可以通过 infocmp 获得\n# Reconstructed via infocmp from file: /usr/share/terminfo/74/tmux-256color tmux-256color|tmux with 256 colors, am, hs, km, mir, msgr, xenl, colors#256, cols#80, it#8, lines#24, pairs#32767, acsc=++\\,\\,--..00``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~, bel=^G, blink=\\E[5m, bold=\\E[1m, cbt=\\E[Z, civis=\\E[?25l, clear=\\E[H\\E[J, cnorm=\\E[34h\\E[?25h, cr=^M, ... 显示内容看上去很混乱，这些是\nShell shell 是一个运行在终端内部的程序，充当命令解释器。 shell 通过流提供输入和输出处理，支持变量，有一些内置命令，处理命令执行和状态，支持交互式和脚本使用。 最初的 shell 叫做 Bourne shell sh，即作者名字命名，现在通常被 bash 替代，即 “Bourne Again Shell” 的缩写。\nfile -h /bin/sh Stream shell 为每个进程提供了三个默认的文件描述符 (FD)，用于输入和输出：\nstdin (FD 0) stdout (FD 1) stderr (FD 2) 默认情况下，这些 FD 分别连接到屏幕和键盘，即默认从键盘获取输入 stdin，并将输出 stdout 传递到屏幕。 如果不希望屏幕输出 stderr，则可以使用 $FD\u003e 或 \u003c$FD重定向流。 例如，2\u003e 表示重定向 stderr，1\u003e 和 \u003e 是相同的，都是 stdout，如果想两个都重定向，使用 \u0026\u003e。 当想摆脱一个流时，使用 /dev/null。\n# 丢弃所有输出 curl https:example.com \u0026\u003e /dev/null # 将 curl 的标准输出（网页内容）保存到文件 # 将 curl 的标准错误（进度信息）保存到另一个文件 curl https:example.com \u003e content.txt 2\u003e curl_status.txt # 创建交互式输入文件 cat \u003e temp.txt # 大写替换为小写 tr \u003c curl_status [A-Z] [a-z] 其中 tr 命令用于文本转换、删除和压缩，专门处理单个字符串，而不是整行文本。\n使用 \u003c 重定向的一般是文件，如果是一条命令或者字符串，使用 Here String，比如下面这样\ncat \u003c\u003c\u003c \"Hello World\" nvim \u003c\u003c\u003c$(curl https://example.com) 而 \u003c() 的来源的进程输出，例如比较两个目录内容\ndiff \u003c(ls dir1) \u003c(ls dir2) shell 通常会理解一些特殊字符：\n与字符 \u0026\n置于命令的末尾，在后台执行命令\n反斜杠 \\\n用于继续下一行的命令，提高长命令的可读性\n管道连接符 |\n连接一个进程的 stdout 与下一个进程的 stdin，允许传递数据，而不必将其存储在文件中\n例如下面命令统计收到的网页数据有多少行\ncurl https://example.com 2\u003e /dev/null | wc -l 其中 wc 是一个常用的文本统计命令，全称 word count，下面是一些常用参数：\n-l 统计行数 -w 统计单词数 -c 统计字节数 -m 统计字符数 -L 统计最长行的长度 Variable 在 shell 中经常遇到的术语是变量，当不能蝇编码时，可以使用变量来存储和更改值，可以使用变量来存储和更改值。\n要区分两种变量：\nshell 变量\n作用域为当前 shell 会话，不会传递给子进程，使用 set 设置 shell 变量或显示环境变量\n环境变量\n作用域为 shell 及其所有子进程，会自动传递给子进程。\n在 bash 中可以使用 export 创建环境变量，env 查看环境变量，当想访问一个变量时在它前面放一个 $ 符号，当想摆脱它时，使用 unset\n# 设置 shell 变量 set MY_VAR=42 # 查看 shell 变量 set | grep MY_VAR # 设置环境变量 export MY_GLOBAL_VAR=\"fun with vars\" # 查看所有变量 set | grep \"MY_*\" # 查看环境变量 env | grep \"MY_*\" 下面是一些常见的 shell 和环境变量\n变量 变量类型 语义 EDITOR 环境变量 默认情况下用于编辑文件的程序路径 HOME POSIX 当前用户的主目录路径 HOSTNAME bash shell 当前主机的名称 IFS POSIX 用于分隔字段的字符列表，当 shell 在展开拆分单词时使用 PATH POSIX shell 在其中查找可执行程序（二进制文件或脚本）的目录列表 PS1 环境变量 正在使用的主要提示符字符串 PMD 环境变量 工作目录的完整路径（应为 PWD） OLDPWD bash shell 最后一个 cd 命令之前的目录的完整路径（应为 OLDPWD） RANDOM bash shell 0～32 767 之间的随机整数 SHELL 环境变量 包含当前使用的 shell TERM 环境变量 所使用的终端模拟器 UID 环境变量 当前用户唯一 ID（整数值） USER 环境变量 当前用户名 - bash shell 前一个命令在前台执行的最后一个参数 ? bash shell 退出状态，参见下文“退出状态” $ bash shell 当前进程的 ID（整数值） @ bash shell 当前进程的名称 shell 使用所谓退出状态命令执行的完成传递给调用者，通常 linux 命令在终止时会返回一个状态。 这可以是一个正常终止，也可以是异常终止。 0 表示命令成功运行，没有错误，1~255 之间非零表示失败，可以使用 echo $? 命令查询退出状态。\n内置命令 shell 有许多内置命令，例如 yes, echo, cat 或 read，有些命令不是内置的，位于 /usr/bin。 可以使用 help 命令列出内置程序，使用下面命令找到可执行文件地址\nwhich ls # /usr/bin/ls type ls # ls is aliased to `ls --color=auto' Job Control 很多 shell 支持一个特性叫作业控制。 默认情况下，输入一个命令时，它会控制屏幕和键盘，通常称为前台运行。 但如果不想交互式运行某些东西，可以在命令后面加上 \u0026 将前台进程发送到后台，也可以按 Ctrl-z。\n# 每 5 秒执行一次 ls，并放到后台 watch -n 5 \"ls\" \u0026 # 列出所有作业 jobs # 将后台任务放到前台 fg 下面是一些常用 shell 快捷键：\nCtrl-_: 撤消 Ctrl-r: 搜索历史记录 Ctrl-g: 取消搜索 这些快捷键都是基于 Emacs 的，可以使用 set -o vi 将其变为 vi 模式（感觉命令行下还是 emacs 模式好用）。\n文件内容管理 # 覆盖重定向 echo \"First line\" \u003e file.txt cat file.txt # 追加重定向 echo \"Second line\" \u003e\u003e file.txt cat file.txt # 将第一行的小写替换为大写 sed 's/line/LINE/' file.txt # 全部替换 sed 's/line/LINE/g' file.txt # Here document cat \u003c\u003c 'EOF' \u003e otherfile.txt Fisrt line Second line Third line EOF # 对比两个文件差异 diff -y file.txt otherfile.txt \u003c\u003c 'EOF' 是 Here Document 的开始标记，\u003e otherfile.txt 是将输出重定向到文件，中间三行是文档内容，最后的 EOF 是结束标记。\n查看长文件 对于长文件，使用 less 或 tail。\n# 循环向文件 tempfile 写入行 for i in {1..100}; do echo $i \u003e\u003e tempfile; done # 查看前 5 行 head -5 tempfile 对于一个不断增长的文件的实时更新，可以使用：\nsudo tail -f /var/log/mail.log 日期和处理时间 date 命令是生成唯一文件名的有用方法，能够生成各种格式的日期，包括 UNIX 时间戳，以及在不同的日期和时间格式之间进行转换。\ndate +%s # 1766296727 date -d @1766296727 '+%m/%d/%Y:%H:%M:%S' # 12/21/2025:05:58:47 UNIX 是自 1970-01-01T00:00:00Z 以来经过的秒数，UNIX 时间将每天精确地视为 86400 秒。 如果将 UNIX 时间存储在有符号 32 位整数中，那需要注意，这回导致在 2038-01-19 出现问题，计数器将会溢出。\nZsh Z-shell 或 zsh 是一个类 Bourne shell，具有强大的补全系统和丰富的主题支持。 zsh 使用 5 个启动文件，如下：\n$ZDOTDIR/.zshenv # 每次启动时加载，设置环境变量 $ZDOTDIR/.zprofile # 登陆 shell 时执行一次 $ZDOTDIR/.zshrc # 交互式 shel 时加载 $ZDOTDIR/.zlogin # 登陆 shell 时执行 $ZDOTDIR/.zlogout # 退出登陆时执行 如果没有设置 $ZDOTDIR 将使用 $HOME。\n终端多路复用器 screen\nscreen 是最初的终端多路复用器，除非登陆环境且不能安装其他多路复用器，否则不应该使用 sreen。\ntmux\ntmux 是一个灵活的终端多路复用器，在 tmux 中有 3 种核心元素交互，从粗颗粒度单元到细颗粒度单元：\n会话 session\n一个逻辑单元，可以将其视为特定任务的工作环境，他是其他所有单元的容器\n窗口 window\n可以将窗口看作浏览器中的一个标签页，每个会话只有一个窗口\n窗格 pane\n这里主要使用的地方，内部运行一个 shell 实例。 窗格是窗口的一部分，可以水平或垂直分割他，并根据需要进行展开和折叠。\ntmux new -s test 上面命令创建一个名为 test 的新会话，tmux 使用 Ctrl-b 作为默认的前置键，也称前缀触发器。 可以使用 Ctrl-b d 暂时分离当前会话，回到终端系统，使用 tmux ls 查看所有会话，之后使用 tmux attach -t 会话名 来回到任意一个会话。\n注意这和 Ctrl-z 完全不同，Ctrl-z 会将当前进程挂起，冻结进程并返回到 shell，而 tmux 的 Ctrl-b d 会将会话置于后台运行，不会中断。\n要列出 tmux 的所有会话窗口，使用 Ctrl-b w，这条命令会列出一个列表选择窗口。\n下面是常用命令表，trigger 默认是 Ctrl-b\n会话相关命令\n任务 命令 新创建 :new -s NAME 重命名 trigger + $ 列出所有会话 trigger + s 关闭 trigger + d 或 :kill-session 窗口相关命令\n任务 命令 新创建 trigger + c 重命名 trigger + , 切换到 trigger + 1…9 列出所有窗口 trigger + w 关闭 trigger + \u0026 窗格相关命令\n任务 命令 水平分割 trigger + \" 垂直分割 trigger + % 切换 trigger + z 关闭 trigger + x tmux 是一个很好的选择，但还有一些其他终端多路复用器可供选择。\ntmuxinator: 管理 tmux 会话的元工具\nByobu: screen 或 tmux 包装器\nZellij: 自称为终端工作空间，使用 Rust 编写！并超越了 tmux 所提供的功能，包括一个布局引擎和一个强大的插件系统\ndvtm: 将窗口平铺管理的概念引入终端，功能强大，但和 tmux 一样需要学习\n3mux: 一个使用 Go 语言编写的简单终端多路复用器，易于使用，但没有 tmux 强大\nScripts 输入 shell 通常将所有东西作为字符串处理，但他确实支持一些复杂数据类型（可能不应该使用 shell 脚本），例如数组。\n# 定义数组 as=('linux', 'macOS', 'Windows') # 访问第一个元素 echo \"${as[0]}\" # 获取数组长度 numberofos = \"${#as[0]}\" 流程控制运行在 shell 脚本中进行分支 (if) 或重复 (for, while)\n# 输出 /temp/ 下面文件名 for afile in /tmp/* ; do ehco \"$afiel\" done # 范围循环 for i in {1..10}; do echo $i done # 无限循环 while true; do ... done 函数可以编写更多的模块化和可重复使用的脚本，必须在使用前定义，因为 shell 是从上到下解释脚本的。\nsayhi() { echo \"Hi $1, I hope you are well!\" } sayhi \"Jess\" 函数定义通过 $n 隐式传递\n如果读取，可以从 stdin 中读取用户输入，可以用他来获得运行时的输入。 此外，与其使用 echo，不如使用 printf，它允许对输入进行精细的控制，包括颜色。\n# 从用户输入中读取数值 read name # 输出上一步读取的值 printf \"Hello %s\" \"$name\" 通过两步将一个文本文件变成一个可执行的、能被 shell 运行的脚本（这里扩展名并不重要，.sh 只是一种惯例）\n文本文件需要在第一行声明解释器，使用所谓的 shebang: #!interpreter [arguments]\n然后使用 chomod +x 来使脚本可执行，或者 750，则符合最小权限原则。\n一个可移植的 bash shell 脚本骨架如下：\n#! /usr/bin/env bash set -o errexit # 遇到错误时立即退出脚本 set -o nounset # 遇到未定义的变量时报错 set -o pipefail # 管道中任意命令失败，整个管道都视为失败 firstarguments=\"${1:-somedefaultvalue}\" echo \"$firstarguments\" 在开发的时候，如果要检查脚本，确保正确使用命令和指令，可以使用 ShellCheck，并考虑 shfmt 格式化代码。 此外，在脚本提交到仓库前，使用 bats 进行基准测试，bats 是 Bash Automated Testing System 的缩写，运行将测试文件定义为带有测试用例特殊语法的 Bash 脚本。 每个用例都是一个带有描述的 bash 函数，通常会调用这些脚本作为 CI 管道的一部分，作为一个 GitHub 动作。\n下面是一个获取 GitHub 用户信息的脚本示例\n#!/usr/bin/env bash set -o errexit # 控制错误追踪 # - 在函数内部或子 shell 中发生的错误也会触发 ERR 信号 # - 相应的错误处理代码（通过 trap 设置的）会被执行 set -o errtrace set -o nounset # Command line parameter targetuser=\"${1:-starslayerx}\" # 获取第一个参数，默认使用 starslayerx # Check if your dependencies are met: if ! [ -x \"$(command -v jq)\" ] # 依赖检查：js (JSON 解释器) 是否已安装，-x 检查是否可执行 then echo \"jq is not installed\" \u003e\u00262 exit 1 fi # Main githubapi=\"https://api.github.com/users/\" tmpuserdump=\"/tmp/ghuserdump_$targetuser.json\" # 获取数据 result=$(curl -s $githubapi$targetuser) # curl -s 静默模式调用 GitHub api echo $result \u003e $tmpuserdump # 保存到临时文件 # 数据处理 name=$(jq .name $tmpuserdump -r) # 从 JSON 提取用户名 created_at=$(jq .created_at $tmpuserdump -r) # 提取创建时间 # 格式化输出 joinyear=$(echo $created_at | cut -f1 -d\"-\") # 格式化日期 echo $name joined GitHub in $joinyear 输出如下\nStarslayerx joined GitHub in 2019 ","wordCount":"995","inLanguage":"en","image":"https://starslayerx.github.io/images/og-default.avif","datePublished":"2025-12-18T08:00:00+08:00","dateModified":"2025-12-18T08:00:00+08:00","author":{"@type":"Person","name":"Starslayerx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://starslayerx.github.io/posts/shell/"},"publisher":{"@type":"Organization","name":"Starslayerx' Blog","logo":{"@type":"ImageObject","url":"https://starslayerx.github.io/favicon.svg"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Shell</h1><div class=post-meta><span title='2025-12-18 08:00:00 +0800 +0800'>December 18, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>995 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#terminal>Terminal</a></li><li><a href=#shell>Shell</a><ul><li><a href=#stream>Stream</a></li><li><a href=#variable>Variable</a></li><li><a href=#内置命令>内置命令</a></li><li><a href=#job-control>Job Control</a></li><li><a href=#文件内容管理>文件内容管理</a></li><li><a href=#查看长文件>查看长文件</a></li><li><a href=#日期和处理时间>日期和处理时间</a></li><li><a href=#zsh>Zsh</a></li></ul></li><li><a href=#终端多路复用器>终端多路复用器</a></li><li><a href=#scripts>Scripts</a></li><li></li></ul></nav></div></details></div><div class=post-content><h2 id=terminal>Terminal<a hidden class=anchor aria-hidden=true href=#terminal>#</a></h2><p>终端是提供文本用户界面的程序，早期终端是集成设备，键盘和屏幕集成在一起，现在终端知识简单的应用程序。
除了基本的输入输出外，终端还支持将所谓转义序列或转移码，用于光标和屏幕处理，并可能支持颜色。
例如，使用 <code>Ctrl-h</code> 会删除前面一个字符。</p><p>环境变量 TERM 可能使用了终端模拟器，其配置可以通过 <code>infocmp</code> 获得</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>#       Reconstructed via infocmp from file: /usr/share/terminfo/74/tmux-256color
</span></span><span class=line><span class=cl>tmux-256color|tmux with 256 colors,
</span></span><span class=line><span class=cl>        am, hs, km, mir, msgr, xenl,
</span></span><span class=line><span class=cl>        colors#256, cols#80, it#8, lines#24, pairs#32767,
</span></span><span class=line><span class=cl>        acsc=++\,\,--..00``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
</span></span><span class=line><span class=cl>        bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z, civis=\E[?25l,
</span></span><span class=line><span class=cl>        clear=\E[H\E[J, cnorm=\E[34h\E[?25h, cr=^M,
</span></span><span class=line><span class=cl>        ...
</span></span></code></pre></div><p>显示内容看上去很混乱，这些是</p><h2 id=shell>Shell<a hidden class=anchor aria-hidden=true href=#shell>#</a></h2><p>shell 是一个运行在终端内部的程序，充当命令解释器。
shell 通过流提供输入和输出处理，支持变量，有一些内置命令，处理命令执行和状态，支持交互式和脚本使用。
最初的 shell 叫做 Bourne shell sh，即作者名字命名，现在通常被 bash 替代，即 &ldquo;Bourne Again Shell&rdquo; 的缩写。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>file -h /bin/sh
</span></span></code></pre></div><h3 id=stream>Stream<a hidden class=anchor aria-hidden=true href=#stream>#</a></h3><p>shell 为每个进程提供了三个默认的文件描述符 (FD)，用于输入和输出：</p><ul><li>stdin (FD 0)</li><li>stdout (FD 1)</li><li>stderr (FD 2)</li></ul><p>默认情况下，这些 FD 分别连接到屏幕和键盘，即默认从键盘获取输入 stdin，并将输出 stdout 传递到屏幕。
如果不希望屏幕输出 stderr，则可以使用 <code>$FD></code> 或 <code>&lt;$FD</code>重定向流。
例如，<code>2></code> 表示重定向 stderr，<code>1></code> 和 <code>></code> 是相同的，都是 stdout，如果想两个都重定向，使用 <code>&></code>。
当想摆脱一个流时，使用 <code>/dev/null</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 丢弃所有输出</span>
</span></span><span class=line><span class=cl>curl https:example.com <span class=p>&amp;</span>&gt; /dev/null
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将 curl 的标准输出（网页内容）保存到文件</span>
</span></span><span class=line><span class=cl><span class=c1># 将 curl 的标准错误（进度信息）保存到另一个文件</span>
</span></span><span class=line><span class=cl>curl https:example.com &gt; content.txt 2&gt; curl_status.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 创建交互式输入文件</span>
</span></span><span class=line><span class=cl>cat &gt; temp.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 大写替换为小写</span>
</span></span><span class=line><span class=cl>tr &lt; curl_status <span class=o>[</span>A-Z<span class=o>]</span> <span class=o>[</span>a-z<span class=o>]</span>
</span></span></code></pre></div><p>其中 <code>tr</code> 命令用于文本转换、删除和压缩，专门处理单个字符串，而不是整行文本。</p><p>使用 <code>&lt;</code> 重定向的一般是文件，如果是一条命令或者字符串，使用 Here String，比如下面这样</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cat <span class=o>&lt;&lt;&lt;</span> <span class=s2>&#34;Hello World&#34;</span>
</span></span><span class=line><span class=cl>nvim <span class=o>&lt;&lt;&lt;</span><span class=k>$(</span>curl https://example.com<span class=k>)</span>
</span></span></code></pre></div><p>而 <code>&lt;()</code> 的来源的进程输出，例如比较两个目录内容</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>diff &lt;<span class=o>(</span>ls dir1<span class=o>)</span> &lt;<span class=o>(</span>ls dir2<span class=o>)</span>
</span></span></code></pre></div><p>shell 通常会理解一些特殊字符：</p><ul><li><p>与字符 <code>&</code></p><p>置于命令的末尾，在后台执行命令</p></li><li><p>反斜杠 <code>\</code></p><p>用于继续下一行的命令，提高长命令的可读性</p></li><li><p>管道连接符 <code>|</code></p><p>连接一个进程的 stdout 与下一个进程的 stdin，允许传递数据，而不必将其存储在文件中</p></li></ul><p>例如下面命令统计收到的网页数据有多少行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl https://example.com 2&gt; /dev/null <span class=p>|</span> wc -l
</span></span></code></pre></div><p>其中 <code>wc</code> 是一个常用的文本统计命令，全称 word count，下面是一些常用参数：</p><ul><li><code>-l</code> 统计行数</li><li><code>-w</code> 统计单词数</li><li><code>-c</code> 统计字节数</li><li><code>-m</code> 统计字符数</li><li><code>-L</code> 统计最长行的长度</li></ul><h3 id=variable>Variable<a hidden class=anchor aria-hidden=true href=#variable>#</a></h3><p>在 shell 中经常遇到的术语是变量，当不能蝇编码时，可以使用变量来存储和更改值，可以使用变量来存储和更改值。</p><p>要区分两种变量：</p><ul><li><p>shell 变量</p><p>作用域为当前 shell 会话，不会传递给子进程，使用 <code>set</code> 设置 shell 变量或显示环境变量</p></li><li><p>环境变量</p><p>作用域为 shell 及其所有子进程，会自动传递给子进程。</p><p>在 bash 中可以使用 <code>export</code> 创建环境变量，<code>env</code> 查看环境变量，当想访问一个变量时在它前面放一个 <code>$</code> 符号，当想摆脱它时，使用 <code>unset</code></p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 设置 shell 变量</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> <span class=nv>MY_VAR</span><span class=o>=</span><span class=m>42</span>
</span></span><span class=line><span class=cl><span class=c1># 查看 shell 变量</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> <span class=p>|</span> grep MY_VAR
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 设置环境变量</span>
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>MY_GLOBAL_VAR</span><span class=o>=</span><span class=s2>&#34;fun with vars&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看所有变量</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> <span class=p>|</span> grep <span class=s2>&#34;MY_*&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看环境变量</span>
</span></span><span class=line><span class=cl>env <span class=p>|</span> grep <span class=s2>&#34;MY_*&#34;</span>
</span></span></code></pre></div><p>下面是一些常见的 shell 和环境变量</p><table><thead><tr><th>变量</th><th>变量类型</th><th>语义</th></tr></thead><tbody><tr><td>EDITOR</td><td>环境变量</td><td>默认情况下用于编辑文件的程序路径</td></tr><tr><td>HOME</td><td>POSIX</td><td>当前用户的主目录路径</td></tr><tr><td>HOSTNAME</td><td>bash shell</td><td>当前主机的名称</td></tr><tr><td>IFS</td><td>POSIX</td><td>用于分隔字段的字符列表，当 shell 在展开拆分单词时使用</td></tr><tr><td>PATH</td><td>POSIX</td><td>shell 在其中查找可执行程序（二进制文件或脚本）的目录列表</td></tr><tr><td>PS1</td><td>环境变量</td><td>正在使用的主要提示符字符串</td></tr><tr><td>PMD</td><td>环境变量</td><td>工作目录的完整路径（应为 <code>PWD</code>）</td></tr><tr><td>OLDPWD</td><td>bash shell</td><td>最后一个 cd 命令之前的目录的完整路径（应为 <code>OLDPWD</code>）</td></tr><tr><td>RANDOM</td><td>bash shell</td><td>0～32 767 之间的随机整数</td></tr><tr><td>SHELL</td><td>环境变量</td><td>包含当前使用的 shell</td></tr><tr><td>TERM</td><td>环境变量</td><td>所使用的终端模拟器</td></tr><tr><td>UID</td><td>环境变量</td><td>当前用户唯一 ID（整数值）</td></tr><tr><td>USER</td><td>环境变量</td><td>当前用户名</td></tr><tr><td>-</td><td>bash shell</td><td>前一个命令在前台执行的最后一个参数</td></tr><tr><td>?</td><td>bash shell</td><td>退出状态，参见下文“退出状态”</td></tr><tr><td>$</td><td>bash shell</td><td>当前进程的 ID（整数值）</td></tr><tr><td>@</td><td>bash shell</td><td>当前进程的名称</td></tr></tbody></table><p>shell 使用所谓退出状态命令执行的完成传递给调用者，通常 linux 命令在终止时会返回一个状态。
这可以是一个正常终止，也可以是异常终止。
0 表示命令成功运行，没有错误，1~255 之间非零表示失败，可以使用 <code>echo $?</code> 命令查询退出状态。</p><h3 id=内置命令>内置命令<a hidden class=anchor aria-hidden=true href=#内置命令>#</a></h3><p>shell 有许多内置命令，例如 yes, echo, cat 或 read，有些命令不是内置的，位于 <code>/usr/bin</code>。
可以使用 help 命令列出内置程序，使用下面命令找到可执行文件地址</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>which ls  <span class=c1># /usr/bin/ls</span>
</span></span><span class=line><span class=cl><span class=nb>type</span> ls   <span class=c1># ls is aliased to `ls --color=auto&#39;</span>
</span></span></code></pre></div><h3 id=job-control>Job Control<a hidden class=anchor aria-hidden=true href=#job-control>#</a></h3><p>很多 shell 支持一个特性叫<a href=https://www.digitalocean.com/community/tutorials/how-to-use-bash-s-job-control-to-manage-foreground-and-background-processes>作业控制</a>。
默认情况下，输入一个命令时，它会控制屏幕和键盘，通常称为前台运行。
但如果不想交互式运行某些东西，可以在命令后面加上 <code>&</code> 将前台进程发送到后台，也可以按 <code>Ctrl-z</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 每 5 秒执行一次 ls，并放到后台</span>
</span></span><span class=line><span class=cl>watch -n <span class=m>5</span> <span class=s2>&#34;ls&#34;</span> <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 列出所有作业</span>
</span></span><span class=line><span class=cl><span class=nb>jobs</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将后台任务放到前台</span>
</span></span><span class=line><span class=cl><span class=nb>fg</span>
</span></span></code></pre></div><hr><p>下面是一些常用 shell 快捷键：</p><ul><li><code>Ctrl-_</code>: 撤消</li><li><code>Ctrl-r</code>: 搜索历史记录</li><li><code>Ctrl-g</code>: 取消搜索</li></ul><p>这些快捷键都是基于 Emacs 的，可以使用 <code>set -o vi</code> 将其变为 vi 模式（感觉命令行下还是 emacs 模式好用）。</p><h3 id=文件内容管理>文件内容管理<a hidden class=anchor aria-hidden=true href=#文件内容管理>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 覆盖重定向</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;First line&#34;</span> &gt; file.txt
</span></span><span class=line><span class=cl>cat file.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 追加重定向</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;Second line&#34;</span> &gt;&gt; file.txt
</span></span><span class=line><span class=cl>cat file.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将第一行的小写替换为大写</span>
</span></span><span class=line><span class=cl>sed <span class=s1>&#39;s/line/LINE/&#39;</span> file.txt
</span></span><span class=line><span class=cl><span class=c1># 全部替换</span>
</span></span><span class=line><span class=cl>sed <span class=s1>&#39;s/line/LINE/g&#39;</span> file.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Here document</span>
</span></span><span class=line><span class=cl>cat <span class=s>&lt;&lt; &#39;EOF&#39; &gt; otherfile.txt
</span></span></span><span class=line><span class=cl><span class=s>Fisrt line
</span></span></span><span class=line><span class=cl><span class=s>Second line
</span></span></span><span class=line><span class=cl><span class=s>Third line
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 对比两个文件差异</span>
</span></span><span class=line><span class=cl>diff -y file.txt otherfile.txt
</span></span></code></pre></div><p><code>&lt;&lt; 'EOF'</code> 是 Here Document 的开始标记，<code>> otherfile.txt</code> 是将输出重定向到文件，中间三行是文档内容，最后的 <code>EOF</code> 是结束标记。</p><h3 id=查看长文件>查看长文件<a hidden class=anchor aria-hidden=true href=#查看长文件>#</a></h3><p>对于长文件，使用 less 或 tail。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 循环向文件 tempfile 写入行</span>
</span></span><span class=line><span class=cl><span class=k>for</span> i in <span class=o>{</span>1..100<span class=o>}</span><span class=p>;</span> <span class=k>do</span> <span class=nb>echo</span> <span class=nv>$i</span> &gt;&gt; tempfile<span class=p>;</span> <span class=k>done</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看前 5 行</span>
</span></span><span class=line><span class=cl>head -5 tempfile
</span></span></code></pre></div><p>对于一个不断增长的文件的实时更新，可以使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tail -f /var/log/mail.log
</span></span></code></pre></div><h3 id=日期和处理时间>日期和处理时间<a hidden class=anchor aria-hidden=true href=#日期和处理时间>#</a></h3><p>date 命令是生成唯一文件名的有用方法，能够生成各种格式的日期，包括 UNIX 时间戳，以及在不同的日期和时间格式之间进行转换。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>date +%s  <span class=c1># 1766296727</span>
</span></span><span class=line><span class=cl>date -d @1766296727 <span class=s1>&#39;+%m/%d/%Y:%H:%M:%S&#39;</span>  <span class=c1># 12/21/2025:05:58:47</span>
</span></span></code></pre></div><p>UNIX 是自 1970-01-01T00:00:00Z 以来经过的秒数，UNIX 时间将每天精确地视为 86400 秒。
如果将 UNIX 时间存储在有符号 32 位整数中，那需要注意，这回导致在 2038-01-19 出现问题，计数器将会溢出。</p><h3 id=zsh>Zsh<a hidden class=anchor aria-hidden=true href=#zsh>#</a></h3><p>Z-shell 或 zsh 是一个类 Bourne shell，具有强大的补全系统和丰富的主题支持。
zsh 使用 5 个启动文件，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>$ZDOTDIR</span>/.zshenv   <span class=c1># 每次启动时加载，设置环境变量</span>
</span></span><span class=line><span class=cl><span class=nv>$ZDOTDIR</span>/.zprofile <span class=c1># 登陆 shell 时执行一次</span>
</span></span><span class=line><span class=cl><span class=nv>$ZDOTDIR</span>/.zshrc    <span class=c1># 交互式 shel 时加载</span>
</span></span><span class=line><span class=cl><span class=nv>$ZDOTDIR</span>/.zlogin   <span class=c1># 登陆 shell 时执行</span>
</span></span><span class=line><span class=cl><span class=nv>$ZDOTDIR</span>/.zlogout  <span class=c1># 退出登陆时执行</span>
</span></span></code></pre></div><p>如果没有设置 <code>$ZDOTDIR</code> 将使用 <code>$HOME</code>。</p><h2 id=终端多路复用器>终端多路复用器<a hidden class=anchor aria-hidden=true href=#终端多路复用器>#</a></h2><ul><li><p>screen</p><p>screen 是最初的终端多路复用器，除非登陆环境且不能安装其他多路复用器，否则不应该使用 sreen。</p></li><li><p>tmux</p><p>tmux 是一个灵活的终端多路复用器，在 tmux 中有 3 种核心元素交互，从粗颗粒度单元到细颗粒度单元：</p><ul><li><p>会话 session</p><p>一个逻辑单元，可以将其视为特定任务的工作环境，他是其他所有单元的容器</p></li><li><p>窗口 window</p><p>可以将窗口看作浏览器中的一个标签页，每个会话只有一个窗口</p></li><li><p>窗格 pane</p><p>这里主要使用的地方，内部运行一个 shell 实例。
窗格是窗口的一部分，可以水平或垂直分割他，并根据需要进行展开和折叠。</p></li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>tmux new -s <span class=nb>test</span>
</span></span></code></pre></div><p>上面命令创建一个名为 test 的新会话，tmux 使用 <code>Ctrl-b</code> 作为默认的前置键，也称前缀触发器。
可以使用 <code>Ctrl-b d</code> 暂时分离当前会话，回到终端系统，使用 <code>tmux ls</code> 查看所有会话，之后使用 <code>tmux attach -t 会话名</code> 来回到任意一个会话。</p><p>注意这和 <code>Ctrl-z</code> 完全不同，<code>Ctrl-z</code> 会将当前进程挂起，冻结进程并返回到 shell，而 tmux 的 <code>Ctrl-b d</code> 会将会话置于后台运行，不会中断。</p><p>要列出 tmux 的所有会话窗口，使用 <code>Ctrl-b w</code>，这条命令会列出一个列表选择窗口。</p><p>下面是常用命令表，trigger 默认是 <code>Ctrl-b</code></p><p>会话相关命令</p><table><thead><tr><th style=text-align:left>任务</th><th style=text-align:left>命令</th></tr></thead><tbody><tr><td style=text-align:left>新创建</td><td style=text-align:left><code>:new -s NAME</code></td></tr><tr><td style=text-align:left>重命名</td><td style=text-align:left><code>trigger + $</code></td></tr><tr><td style=text-align:left>列出所有会话</td><td style=text-align:left><code>trigger + s</code></td></tr><tr><td style=text-align:left>关闭</td><td style=text-align:left><code>trigger + d</code> 或 <code>:kill-session</code></td></tr></tbody></table><p>窗口相关命令</p><table><thead><tr><th style=text-align:left>任务</th><th style=text-align:left>命令</th></tr></thead><tbody><tr><td style=text-align:left>新创建</td><td style=text-align:left><code>trigger + c</code></td></tr><tr><td style=text-align:left>重命名</td><td style=text-align:left><code>trigger + ,</code></td></tr><tr><td style=text-align:left>切换到</td><td style=text-align:left><code>trigger + 1…9</code></td></tr><tr><td style=text-align:left>列出所有窗口</td><td style=text-align:left><code>trigger + w</code></td></tr><tr><td style=text-align:left>关闭</td><td style=text-align:left><code>trigger + &</code></td></tr></tbody></table><p>窗格相关命令</p><table><thead><tr><th style=text-align:left>任务</th><th style=text-align:left>命令</th></tr></thead><tbody><tr><td style=text-align:left>水平分割</td><td style=text-align:left><code>trigger + "</code></td></tr><tr><td style=text-align:left>垂直分割</td><td style=text-align:left><code>trigger + %</code></td></tr><tr><td style=text-align:left>切换</td><td style=text-align:left><code>trigger + z</code></td></tr><tr><td style=text-align:left>关闭</td><td style=text-align:left><code>trigger + x</code></td></tr></tbody></table><p>tmux 是一个很好的选择，但还有一些其他终端多路复用器可供选择。</p><ul><li><p>tmuxinator: 管理 tmux 会话的元工具</p></li><li><p>Byobu: screen 或 tmux 包装器</p></li><li><p>Zellij: 自称为终端工作空间，使用 Rust 编写！并超越了 tmux 所提供的功能，包括一个布局引擎和一个强大的插件系统</p></li><li><p>dvtm: 将窗口平铺管理的概念引入终端，功能强大，但和 tmux 一样需要学习</p></li><li><p>3mux: 一个使用 Go 语言编写的简单终端多路复用器，易于使用，但没有 tmux 强大</p></li></ul><h2 id=scripts>Scripts<a hidden class=anchor aria-hidden=true href=#scripts>#</a></h2><p>输入 shell 通常将所有东西作为字符串处理，但他确实支持一些复杂数据类型（可能不应该使用 shell 脚本），例如数组。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 定义数组</span>
</span></span><span class=line><span class=cl><span class=nv>as</span><span class=o>=(</span><span class=s1>&#39;linux&#39;</span>, <span class=s1>&#39;macOS&#39;</span>, <span class=s1>&#39;Windows&#39;</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=c1># 访问第一个元素</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>as</span><span class=p>[0]</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># 获取数组长度</span>
</span></span><span class=line><span class=cl><span class=nv>numberofos</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=si>${#</span><span class=nv>as</span><span class=p>[0]</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span></code></pre></div><hr><p>流程控制运行在 shell 脚本中进行分支 (if) 或重复 (for, while)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 输出 /temp/ 下面文件名</span>
</span></span><span class=line><span class=cl><span class=k>for</span> afile in /tmp/* <span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    ehco <span class=s2>&#34;</span><span class=nv>$afiel</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 范围循环</span>
</span></span><span class=line><span class=cl><span class=k>for</span> i in <span class=o>{</span>1..10<span class=o>}</span><span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=nv>$i</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 无限循环</span>
</span></span><span class=line><span class=cl><span class=k>while</span> true<span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><hr><p>函数可以编写更多的模块化和可重复使用的脚本，必须在使用前定义，因为 shell 是从上到下解释脚本的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sayhi<span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;Hi </span><span class=nv>$1</span><span class=s2>, I hope you are well!&#34;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sayhi <span class=s2>&#34;Jess&#34;</span>
</span></span></code></pre></div><p>函数定义通过 <code>$n</code> 隐式传递</p><hr><p>如果读取，可以从 stdin 中读取用户输入，可以用他来获得运行时的输入。
此外，与其使用 echo，不如使用 printf，它允许对输入进行精细的控制，包括颜色。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 从用户输入中读取数值</span>
</span></span><span class=line><span class=cl><span class=nb>read</span> name
</span></span><span class=line><span class=cl><span class=c1># 输出上一步读取的值</span>
</span></span><span class=line><span class=cl><span class=nb>printf</span> <span class=s2>&#34;Hello %s&#34;</span> <span class=s2>&#34;</span><span class=nv>$name</span><span class=s2>&#34;</span>
</span></span></code></pre></div><p>通过两步将一个文本文件变成一个可执行的、能被 shell 运行的脚本（这里扩展名并不重要，<code>.sh</code> 只是一种惯例）</p><ul><li><p>文本文件需要在第一行声明解释器，使用所谓的 shebang: <code>#!interpreter [arguments]</code></p></li><li><p>然后使用 <code>chomod +x</code> 来使脚本可执行，或者 750，则符合最小权限原则。</p></li></ul><p>一个可移植的 bash shell 脚本骨架如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#! /usr/bin/env bash
</span></span></span><span class=line><span class=cl><span class=nb>set</span> -o errexit  <span class=c1># 遇到错误时立即退出脚本</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -o nounset  <span class=c1># 遇到未定义的变量时报错</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -o pipefail <span class=c1># 管道中任意命令失败，整个管道都视为失败</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>firstarguments</span><span class=o>=</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>1</span><span class=k>:-</span><span class=nv>somedefaultvalue</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$firstarguments</span><span class=s2>&#34;</span>
</span></span></code></pre></div><p>在开发的时候，如果要检查脚本，确保正确使用命令和指令，可以使用 ShellCheck，并考虑 shfmt 格式化代码。
此外，在脚本提交到仓库前，使用 bats 进行基准测试，bats 是 Bash Automated Testing System 的缩写，运行将测试文件定义为带有测试用例特殊语法的 Bash 脚本。
每个用例都是一个带有描述的 bash 函数，通常会调用这些脚本作为 CI 管道的一部分，作为一个 GitHub 动作。</p><p>下面是一个获取 GitHub 用户信息的脚本示例</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/usr/bin/env bash
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>set</span> -o errexit
</span></span><span class=line><span class=cl><span class=c1># 控制错误追踪</span>
</span></span><span class=line><span class=cl><span class=c1># - 在函数内部或子 shell 中发生的错误也会触发 ERR 信号</span>
</span></span><span class=line><span class=cl><span class=c1># - 相应的错误处理代码（通过 trap 设置的）会被执行</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> -o errtrace
</span></span><span class=line><span class=cl><span class=nb>set</span> -o nounset
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Command line parameter</span>
</span></span><span class=line><span class=cl><span class=nv>targetuser</span><span class=o>=</span><span class=s2>&#34;</span><span class=si>${</span><span class=nv>1</span><span class=k>:-</span><span class=nv>starslayerx</span><span class=si>}</span><span class=s2>&#34;</span> <span class=c1># 获取第一个参数，默认使用 starslayerx</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Check if your dependencies are met:</span>
</span></span><span class=line><span class=cl><span class=k>if</span> ! <span class=o>[</span> -x <span class=s2>&#34;</span><span class=k>$(</span><span class=nb>command</span> -v jq<span class=k>)</span><span class=s2>&#34;</span> <span class=o>]</span>  <span class=c1># 依赖检查：js (JSON 解释器) 是否已安装，-x 检查是否可执行</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>  <span class=nb>echo</span> <span class=s2>&#34;jq is not installed&#34;</span> &gt;<span class=p>&amp;</span><span class=m>2</span>
</span></span><span class=line><span class=cl>  <span class=nb>exit</span> <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Main</span>
</span></span><span class=line><span class=cl><span class=nv>githubapi</span><span class=o>=</span><span class=s2>&#34;https://api.github.com/users/&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>tmpuserdump</span><span class=o>=</span><span class=s2>&#34;/tmp/ghuserdump_</span><span class=nv>$targetuser</span><span class=s2>.json&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 获取数据</span>
</span></span><span class=line><span class=cl><span class=nv>result</span><span class=o>=</span><span class=k>$(</span>curl -s <span class=nv>$githubapi$targetuser</span><span class=k>)</span>  <span class=c1># curl -s 静默模式调用 GitHub api</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$result</span> &gt; <span class=nv>$tmpuserdump</span>  <span class=c1># 保存到临时文件</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 数据处理</span>
</span></span><span class=line><span class=cl><span class=nv>name</span><span class=o>=</span><span class=k>$(</span>jq .name <span class=nv>$tmpuserdump</span> -r<span class=k>)</span>  <span class=c1># 从 JSON 提取用户名</span>
</span></span><span class=line><span class=cl><span class=nv>created_at</span><span class=o>=</span><span class=k>$(</span>jq .created_at <span class=nv>$tmpuserdump</span> -r<span class=k>)</span>  <span class=c1># 提取创建时间</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 格式化输出</span>
</span></span><span class=line><span class=cl><span class=nv>joinyear</span><span class=o>=</span><span class=k>$(</span><span class=nb>echo</span> <span class=nv>$created_at</span> <span class=p>|</span> cut -f1 -d<span class=s2>&#34;-&#34;</span><span class=k>)</span>  <span class=c1># 格式化日期</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$name</span> joined GitHub in <span class=nv>$joinyear</span>
</span></span></code></pre></div><p>输出如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Starslayerx joined GitHub in 2019
</span></span></code></pre></div><h2></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://starslayerx.github.io/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://starslayerx.github.io/posts/python-tricks-part-4-objects-types-and-protocols/><span class=title>« Prev</span><br><span>Python Tricks Part 4: Objects, Types and Protocols</span>
</a><a class=next href=https://starslayerx.github.io/posts/python-tricks-part-3-program-structure-and-control-flow/><span class=title>Next »</span><br><span>Python Tricks Part 3: Program Structure and Control Flow</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell on x" href="https://x.com/intent/tweet/?text=Shell&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fshell%2f&amp;hashtags=Linux"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fshell%2f&amp;title=Shell&amp;summary=Shell&amp;source=https%3a%2f%2fstarslayerx.github.io%2fposts%2fshell%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fshell%2f&title=Shell"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fshell%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell on whatsapp" href="https://api.whatsapp.com/send?text=Shell%20-%20https%3a%2f%2fstarslayerx.github.io%2fposts%2fshell%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell on telegram" href="https://telegram.me/share/url?text=Shell&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fshell%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell on ycombinator" href="https://news.ycombinator.com/submitlink?t=Shell&u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fshell%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>