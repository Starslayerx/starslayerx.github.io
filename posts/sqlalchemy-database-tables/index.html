<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>SQLALchemy - Database Tables | Starslayerx&#39; Blog</title>
<meta name="keywords" content="Python, Database">
<meta name="description" content="SQLALchemy Core and SQLALchemy ORM
SQLALchemy 分位两个模块：Core 和 ORM (Object-Relational Mapping)。
Core 模块包含对所有受支持数据库方言的集成逻辑，一组用于描述数据库表的类，用于 Python 语言生成 SQL 语句。
ORM 模块在 Python 应用程序中引入了一层抽象，使得许多数据库操作可以根据对 Python 对象执行的操作自动推导出来。
Database Engine
SQLALchemy 使用 engine 对象来管理数据库连接，包含 Core 和 ORM 应用。
create_engine() 函数通过数据库 url 创建一个 engine。
格式为：
{dialet}{&#43;driver}://{username}:{password}@{hostname}:{port}/{database}
其中 SQLite 比较特殊，无需 driver。
对于导入 DATABASE_URL 有两种方式，一种是使用 load_dotenv() 加载 .env 文件的环境变量
import os
from dotenv import load_dotenv
from sqlalchemy import create_engine


load_dotenv()

engine = create_engine(os.environ[&#39;DATABASE_URL&#39;])
另一种是通过 Pydantic BaseSettings
import os
from pathlib import Path
from pydantic_settings import BaseSettings
from pydantic impot SecretStr
from functools import lru_cache
from sqlalchemy import create_engine


class Settings(BaseSettings):
    POSTGRESQL_HOST: str
    POSTGRESQL_PORT: int
    POSTGRESQL_USER: str
    POSTGRESQL_PASSWORD: SecretStr
    POSTGRESQL_DB: str

    @property
    def postgres_db_url(self) -&gt; str:
        # 通常无需显示地写 driver，只有更换 dirver 时才需要写
        return f&#39;postgresql://{self.POSTGRESQL_USER}:{self.POSTGRESQL_PASSWORD.get_secret_value()}@{self.POSTGRESQL_HOST}:{self.POSTGRESQL_PORT}/{self.POSTGRESQL_DB}&#39;

    class Config:
        env_file = str(Path(__file__).parent / &#39;.env&#39;)
        case_sensitive = True
        extra = &#39;ignore&#39;  # 忽略额外字段

@lru_cache
def get_settings() -&gt; Settings:
    return Settings()

# 使用示例
settings = get_settings()
print(&#39;Host:&#39;, settings.POSTGRESQL_HOST)
print(&#39;Password:&#39;, settings.PASSWORD.get_secret_value())
engine = create_engine(settings.postgres_db_url)
create_engine() 函数有以下配置参数：">
<meta name="author" content="Starslayerx">
<link rel="canonical" href="http://localhost:1313/posts/sqlalchemy-database-tables/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.svg">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon.svg">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon.svg">
<link rel="mask-icon" href="http://localhost:1313/favicon.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/sqlalchemy-database-tables/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="http://localhost:1313/posts/sqlalchemy-database-tables/">
  <meta property="og:site_name" content="Starslayerx&#39; Blog">
  <meta property="og:title" content="SQLALchemy - Database Tables">
  <meta property="og:description" content="SQLALchemy Core and SQLALchemy ORM SQLALchemy 分位两个模块：Core 和 ORM (Object-Relational Mapping)。 Core 模块包含对所有受支持数据库方言的集成逻辑，一组用于描述数据库表的类，用于 Python 语言生成 SQL 语句。 ORM 模块在 Python 应用程序中引入了一层抽象，使得许多数据库操作可以根据对 Python 对象执行的操作自动推导出来。
Database Engine SQLALchemy 使用 engine 对象来管理数据库连接，包含 Core 和 ORM 应用。 create_engine() 函数通过数据库 url 创建一个 engine。
格式为：
{dialet}{&#43;driver}://{username}:{password}@{hostname}:{port}/{database} 其中 SQLite 比较特殊，无需 driver。
对于导入 DATABASE_URL 有两种方式，一种是使用 load_dotenv() 加载 .env 文件的环境变量
import os from dotenv import load_dotenv from sqlalchemy import create_engine load_dotenv() engine = create_engine(os.environ[&#39;DATABASE_URL&#39;]) 另一种是通过 Pydantic BaseSettings
import os from pathlib import Path from pydantic_settings import BaseSettings from pydantic impot SecretStr from functools import lru_cache from sqlalchemy import create_engine class Settings(BaseSettings): POSTGRESQL_HOST: str POSTGRESQL_PORT: int POSTGRESQL_USER: str POSTGRESQL_PASSWORD: SecretStr POSTGRESQL_DB: str @property def postgres_db_url(self) -&gt; str: # 通常无需显示地写 driver，只有更换 dirver 时才需要写 return f&#39;postgresql://{self.POSTGRESQL_USER}:{self.POSTGRESQL_PASSWORD.get_secret_value()}@{self.POSTGRESQL_HOST}:{self.POSTGRESQL_PORT}/{self.POSTGRESQL_DB}&#39; class Config: env_file = str(Path(__file__).parent / &#39;.env&#39;) case_sensitive = True extra = &#39;ignore&#39; # 忽略额外字段 @lru_cache def get_settings() -&gt; Settings: return Settings() # 使用示例 settings = get_settings() print(&#39;Host:&#39;, settings.POSTGRESQL_HOST) print(&#39;Password:&#39;, settings.PASSWORD.get_secret_value()) engine = create_engine(settings.postgres_db_url) create_engine() 函数有以下配置参数：">
  <meta property="og:locale" content="en-US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-26T08:00:00+01:00">
    <meta property="article:modified_time" content="2026-01-26T08:00:00+01:00">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="Database">
      <meta property="og:image" content="http://localhost:1313/images/og-default.avif">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/og-default.avif">
<meta name="twitter:title" content="SQLALchemy - Database Tables">
<meta name="twitter:description" content="SQLALchemy Core and SQLALchemy ORM
SQLALchemy 分位两个模块：Core 和 ORM (Object-Relational Mapping)。
Core 模块包含对所有受支持数据库方言的集成逻辑，一组用于描述数据库表的类，用于 Python 语言生成 SQL 语句。
ORM 模块在 Python 应用程序中引入了一层抽象，使得许多数据库操作可以根据对 Python 对象执行的操作自动推导出来。
Database Engine
SQLALchemy 使用 engine 对象来管理数据库连接，包含 Core 和 ORM 应用。
create_engine() 函数通过数据库 url 创建一个 engine。
格式为：
{dialet}{&#43;driver}://{username}:{password}@{hostname}:{port}/{database}
其中 SQLite 比较特殊，无需 driver。
对于导入 DATABASE_URL 有两种方式，一种是使用 load_dotenv() 加载 .env 文件的环境变量
import os
from dotenv import load_dotenv
from sqlalchemy import create_engine


load_dotenv()

engine = create_engine(os.environ[&#39;DATABASE_URL&#39;])
另一种是通过 Pydantic BaseSettings
import os
from pathlib import Path
from pydantic_settings import BaseSettings
from pydantic impot SecretStr
from functools import lru_cache
from sqlalchemy import create_engine


class Settings(BaseSettings):
    POSTGRESQL_HOST: str
    POSTGRESQL_PORT: int
    POSTGRESQL_USER: str
    POSTGRESQL_PASSWORD: SecretStr
    POSTGRESQL_DB: str

    @property
    def postgres_db_url(self) -&gt; str:
        # 通常无需显示地写 driver，只有更换 dirver 时才需要写
        return f&#39;postgresql://{self.POSTGRESQL_USER}:{self.POSTGRESQL_PASSWORD.get_secret_value()}@{self.POSTGRESQL_HOST}:{self.POSTGRESQL_PORT}/{self.POSTGRESQL_DB}&#39;

    class Config:
        env_file = str(Path(__file__).parent / &#39;.env&#39;)
        case_sensitive = True
        extra = &#39;ignore&#39;  # 忽略额外字段

@lru_cache
def get_settings() -&gt; Settings:
    return Settings()

# 使用示例
settings = get_settings()
print(&#39;Host:&#39;, settings.POSTGRESQL_HOST)
print(&#39;Password:&#39;, settings.PASSWORD.get_secret_value())
engine = create_engine(settings.postgres_db_url)
create_engine() 函数有以下配置参数：">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "SQLALchemy - Database Tables",
      "item": "http://localhost:1313/posts/sqlalchemy-database-tables/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SQLALchemy - Database Tables",
  "name": "SQLALchemy - Database Tables",
  "description": "SQLALchemy Core and SQLALchemy ORM SQLALchemy 分位两个模块：Core 和 ORM (Object-Relational Mapping)。 Core 模块包含对所有受支持数据库方言的集成逻辑，一组用于描述数据库表的类，用于 Python 语言生成 SQL 语句。 ORM 模块在 Python 应用程序中引入了一层抽象，使得许多数据库操作可以根据对 Python 对象执行的操作自动推导出来。\nDatabase Engine SQLALchemy 使用 engine 对象来管理数据库连接，包含 Core 和 ORM 应用。 create_engine() 函数通过数据库 url 创建一个 engine。\n格式为：\n{dialet}{+driver}://{username}:{password}@{hostname}:{port}/{database} 其中 SQLite 比较特殊，无需 driver。\n对于导入 DATABASE_URL 有两种方式，一种是使用 load_dotenv() 加载 .env 文件的环境变量\nimport os from dotenv import load_dotenv from sqlalchemy import create_engine load_dotenv() engine = create_engine(os.environ[\u0026#39;DATABASE_URL\u0026#39;]) 另一种是通过 Pydantic BaseSettings\nimport os from pathlib import Path from pydantic_settings import BaseSettings from pydantic impot SecretStr from functools import lru_cache from sqlalchemy import create_engine class Settings(BaseSettings): POSTGRESQL_HOST: str POSTGRESQL_PORT: int POSTGRESQL_USER: str POSTGRESQL_PASSWORD: SecretStr POSTGRESQL_DB: str @property def postgres_db_url(self) -\u0026gt; str: # 通常无需显示地写 driver，只有更换 dirver 时才需要写 return f\u0026#39;postgresql://{self.POSTGRESQL_USER}:{self.POSTGRESQL_PASSWORD.get_secret_value()}@{self.POSTGRESQL_HOST}:{self.POSTGRESQL_PORT}/{self.POSTGRESQL_DB}\u0026#39; class Config: env_file = str(Path(__file__).parent / \u0026#39;.env\u0026#39;) case_sensitive = True extra = \u0026#39;ignore\u0026#39; # 忽略额外字段 @lru_cache def get_settings() -\u0026gt; Settings: return Settings() # 使用示例 settings = get_settings() print(\u0026#39;Host:\u0026#39;, settings.POSTGRESQL_HOST) print(\u0026#39;Password:\u0026#39;, settings.PASSWORD.get_secret_value()) engine = create_engine(settings.postgres_db_url) create_engine() 函数有以下配置参数：\n",
  "keywords": [
    "Python", "Database"
  ],
  "articleBody": "SQLALchemy Core and SQLALchemy ORM SQLALchemy 分位两个模块：Core 和 ORM (Object-Relational Mapping)。 Core 模块包含对所有受支持数据库方言的集成逻辑，一组用于描述数据库表的类，用于 Python 语言生成 SQL 语句。 ORM 模块在 Python 应用程序中引入了一层抽象，使得许多数据库操作可以根据对 Python 对象执行的操作自动推导出来。\nDatabase Engine SQLALchemy 使用 engine 对象来管理数据库连接，包含 Core 和 ORM 应用。 create_engine() 函数通过数据库 url 创建一个 engine。\n格式为：\n{dialet}{+driver}://{username}:{password}@{hostname}:{port}/{database} 其中 SQLite 比较特殊，无需 driver。\n对于导入 DATABASE_URL 有两种方式，一种是使用 load_dotenv() 加载 .env 文件的环境变量\nimport os from dotenv import load_dotenv from sqlalchemy import create_engine load_dotenv() engine = create_engine(os.environ['DATABASE_URL']) 另一种是通过 Pydantic BaseSettings\nimport os from pathlib import Path from pydantic_settings import BaseSettings from pydantic impot SecretStr from functools import lru_cache from sqlalchemy import create_engine class Settings(BaseSettings): POSTGRESQL_HOST: str POSTGRESQL_PORT: int POSTGRESQL_USER: str POSTGRESQL_PASSWORD: SecretStr POSTGRESQL_DB: str @property def postgres_db_url(self) -\u003e str: # 通常无需显示地写 driver，只有更换 dirver 时才需要写 return f'postgresql://{self.POSTGRESQL_USER}:{self.POSTGRESQL_PASSWORD.get_secret_value()}@{self.POSTGRESQL_HOST}:{self.POSTGRESQL_PORT}/{self.POSTGRESQL_DB}' class Config: env_file = str(Path(__file__).parent / '.env') case_sensitive = True extra = 'ignore' # 忽略额外字段 @lru_cache def get_settings() -\u003e Settings: return Settings() # 使用示例 settings = get_settings() print('Host:', settings.POSTGRESQL_HOST) print('Password:', settings.PASSWORD.get_secret_value()) engine = create_engine(settings.postgres_db_url) create_engine() 函数有以下配置参数：\necho=True 日志记录每个 SQL 语句，用于调试非常有用。\npool_size= 指定连接池大小，默认最多 5 个\nmax_overflow= 流量高峰期最多可以创建的超过连接池连接的大小，默认为 10\nfuture=True 告诉 SQLALchemy 1.4 使用 2.0 的新版 APIs\npool_recycle= 设置链接回收时间，单位秒。mysql 默认 8 小时，推荐设置一小时(3600)。\npool_pre_ping=True 在每次从池中取出连接前先 ping 一下，检查是否活着，解决数据库偶尔重启掉线的问题，提高健壮性\nModel 当使用 ORM 模块时，数据库表在 Python 类中定义。 该程序需要为所有的类创建一个父类，以便配置所有表共享的设置。 父类在 SQLALchemy 中被称为 declarative 基类，通常叫做 Model 或 Base。 Model 类的子类集和代表了数据库的结构或模式，通常被称为应用程序的 “模型”。\nModel 类必须从 SQLALchemy 的 DeclartiveBase 类继承。 下面是一个没有额外配置的示例：\n# db.py import os from dotenv import load_dotenv from sqlalchemy import create_engine from sqlalchemy.orm import DeclartiveBase class Model(DeclartiveBase): pass load_dotenv() engine = create_engine(os.env['DATABASE_URL']) 下面使用一个新文件存 Product 表的创建：\nfrom sqlalchemy import String from sqlalchemy.orm import Mapped, mapped_column from db import Model class Product(Model): __tablename__ = 'products' id: Mapped[int] = mapped_column(primary_key=True) name: Mapped[str] = mapped_column(String(64)) manufacturer: Mapped[str] = mapped_column(String(64)) year: Mapped[int] country: Mapped[str] = mapped_column(String(32)) cpu: Mapped[str] = mapped_column(String(32)) def __repr__(self): return f'Product({self.id}, \"{self.name}\")' Model 子类通过类属性定义：\n__tablename__ 属性定义数据库表名称，常见命名规范是表名称使用复数小写形式，这和模型名称形成对比，即使用单数的 camel case 驼峰命名法。\n剩余定义的属性是表中的列，Mapped[t] 类型声明用于定义每个列，其中 t 是 Python 类型，例如 int, str 或 datetime。 对于 year 这样的普通列来说完全足够了，如果列需要额外的功能，就要将其赋值给一个 mapped_column() 构造器。\n在上面的 Product 模型中，可以选择将 id 列作为一个 primary key 主键，其值必须唯一。 SQLALchemy 将主键设置为从 1 开始的自增列。\n剩下的 str 类型通过 String() 添加了最大长度作为补充。 并非所有数据库都要求一定长度，但最好设置一下。\n最后 __repr__() 方法是 Python 的特殊方法，告诉该对象如何打印。 该方法是可选的，但在调试和 shell 环境中使用的时候会很有用。\n要创建模型类的实例，需使用标准构造函数，并以关键字参数形式传入模型属性的值。\nc64 = Product(name='Commodore 64', manufacturer='Commodore') 上面代码会初始化一个新的 Product 实例，这个例子中除了指定的 name 和 manufacturer 之外都会被设置为 None。 尽管这个对象是一个模型实例，但此刻它只是一个普通的 Python 对象，尚未被存储在数据库中。\n模型类的概念只适用于 ORM 模块，当使用 Core 时需要使用 Table 类来表示数据库表。\nDatabase Metadata SQLALchemy 将所有数据库表的定义维护在一个 MetaData 对象中。 出于方便，它会初始化一个声明基类作为 MetaData 的一个属性。 对于 Model 类型，可以通过 Model.metadata 获取该值。 当一个 model class 例如 Product 定义的时候，SQLALchemy 会在对应的属性创建定义。\n默认的 MetaData 配置存在一个总要限制，当项目达到一定规模或复制度时，这个限制必然会导致问题。 这与 naming_convention 相关，该选项用于指示 SQLALchemy 如何命名在数据库中创建的索引和约束。\n默认的命名规范为 MetaData 索引提供了默认命名，但没有为 constraints 约束提供。 因此 SQLALchemy 不会以特定名称初始化它们，导致数据库使用任意名称。 当一个 constraint 约束需要被修改或删除的时候会导致问题，因为 SQLALchemy 无法通过约束名称来定位它。\n为了避免可能出现的复杂情况，Model declarative base 声明基类可以通过更完整的命名约束进行初始化。\nimport os from dotenv import load_dotenv from sqlalchemy import create_engine, MetaData from sqlalchemy.orm import DeclarativeBase class Model(DeclarativeBase): metadata = MetaData(naming_convention={ 'ix': 'ix_%(column_0_label)s', 'uq': 'uq_%(table_name)s_%(column_0_name)s', 'ck': 'ck_%(table_name)s_%(constraint_name)s', 'fk': 'fk_%(table_name)s_%(column_0_name)s_(referred_table_name)s', 'pk': 'pk_%(table_name)s', }) load_dotenv() engine = create_engine(os.environ['DATABASE_URL']) MetaData 对象有一个 create_all() 方法，该方法具有重要作用，因为他会创建与已定义模型关联的所有数据库表。\nModel.metadata.create_all(engine) create_all() 方法向由 engine 表示的数据库发出 SQL 语句，以创建所有模型引用的数据库表。 该方法的局限性是，它只会创建数据库。 这意味着，当一个模型类型被修改了，该方法不能用于将变更传输至相应的数据库表。\n一个修改现存表的变通方法是在调用 create_all() 之前，删除旧版的表，然后创建新版本的表。 对应的 MetaData 有一个 drop_all() 方法，该方法会从数据库删除所有的表。\nModel.metadata.drop_all(engine) Model.metadata.create_all(engine) 不幸的是，这样会导致数据丢失，后面会使用 Alembic 来做数据库迁移。\n如果使用 Core 则必须手动创建数据库 metadata 对象。\nSessions 另一个基于 ORM 的重要概念是 Session。 一个 Session 对象管理一系列示例的新建、读取、修改和删除。\n在会话中累计的更改，会在会话刷新 flush 时，通过数据库事务 transaction 的上下文传递到数据库中。 这一操作在大多数情况下由 SQLALchemy 在需要时自动触发。 一次刷新操作会将修改写入数据库，但保持数据库事务处于打开状态。\n当会话提交后，对应的数据库事务也会提交，造成数据库的永久修改。 数据库事务是关系数据库最重要的优势之一，旨在保护数据的完整性。\n下面示例展示了如何将 c64 对象加入数据库：\nfrom sqlalchemy.orm import Session with Session(engine) as session: try: session.add(c64) session.commit() except: session.rollback() raise print(c64) 管理数据库会话 session 的最佳方式就是通过上下文管理器 context manager。 这能确保会话正确地关闭和清理。\nSession 通过 engine 对象进行初始化。 类似地，也可以使用 future=True 参数将 SQLALchemy 1.4 的 API 设置为 2.0 版本。\nSession 对象被设计成累计修改，直到提交或回滚。 add() 方法用来在会话中插入一个新对象，try/block 块保证 session 总是提交成功或回滚。\n之前说过 SQLALchemy 默认设置主键列为整数自增的。 当会话刷新时，数据库会为新增条目的 id 属性分配下一个可用数字。 若是首次条目，则会分配数字 1。 任何其他没有设定的属性都会在数据库中被记录为 NULL。\nSQLALchemy 提供了一个更加简洁地 session 交互方式。 一个正常的应用中会有许多地方需要创建会话，如果每次都必须传递 engine 和其他选项，就不太方便。 sessionmaker 工厂函数提供了一种创建定制化 Session 类的方法：\nfrom sqlalchemy.orm import sessionmaker Session = sessionmaker(engine) with Session() as session: # ... 将所有的逻辑都放到 try/except 块中仍会显得乏味。 下面的例子在上下文管理器中使用 begin() 替代异常处理：\nwith Session() as session: with session.begin(): session.add(c64) print(c64) 通过 session.begin() 创建的上下文管理器在内部实现了 try/except 逻辑。 如果发生了异常，则会回滚到之前的状态。 下面是一个完整的创建会话的示例：\nimport os from dotenv import load_dotenv from sqlalchemy import create_engine, MetaData from sqlalchemy import DeclarativeBase, sessionmaker class Model(DeclarativeBase): metadata = MetaData(naming_convention={ 'ix': 'ix_%(column_0_label)s', 'uq': 'uq_%(table_name)s_%(column_0_name)s', 'ck': 'ck_%(table_name)s_%(constraint_name)s', 'fk': 'fk_%(table_name)s_%(column_0_name)s_(referred_table_name)s', 'pk': 'pk_%(table_name)s', }) load_dotenv() engine = create_engine(os.environ['DATABASE_URL']) Session = sessionmaker(engine) Queries Query Definition SQLALchemy 提供了 select() 函数来实现 SELECT 关键字一样的查询功能。 假设通过 ORM 定义了一个 Product 表，下面来查询表中所有元素：\nfrom sqlalchemy import select q = select(Product) select() 函数接收需要检索的条目作为参数。 当以模型类作为参数时，SQLALchemy ORM 会自动获取该模型的所有属性，并以透明方式返回 Python 对象。 可以打印查看 SQL 查询语句：\nprint(q) # SELECT products.id, products.name, productsroducts.manufacturer, products.year, products.country, products.cpu # FROM products Query Execution 当查询对象创建后，需要将其传递给 session，这将通过 engine 维护的连接将其发送到数据库驱动程序中执行。 最常见的方法是使用 execute() 命令：\nr = session.execute() list(r) # [(Product(1, Acorn Atom),), # (Product(2, BBC Micro),), # ..., # (Product(149, GEM 1000),)] execute() 方法返回一个可迭代的结果对象，通过 list() 可以将其转换为列表并展示。\nexecute() 执行结果对象可以使用 all() 方法获取和 list() 一样的结果：\nsession.execute(q).all() first() 返回结果的第一行，如果没有结果返回 None\none() 只返回第一个结果，如果有零或多余一个结果，则抛出异常\none_or_none() 只返回第一个结果，如果没有结果返回 None，如果超过一个结果则抛出异常\n获取 iterable 可迭代的结果十分高效，SQLALchemy 只会迭代需要的行。 这意味着，对于很大结果的查询，无需将所有内容存储在列表中，而可以只处理加载的结果。\nr = session.execute(q) for row in r: print(row) 注意处理得到的结果格式：\n(Product(1, \"Acorn Atom\"),) 这不是单纯的一个 Product 对象，而是一个元组，因为查询有时候可能会每行返回多个结果。 如果确定返回结果是单个元素，则可以使用 scalars() 来执行查询：\nsession.scalars(q).all() # [Product(1, Acorn Atom), ..., Product(149, GEM 1000)] 使用该方法时会返回一个不同的结果对象，该对象只包含每行的第一个值。 如果查询结果每行有多个值，则多余的值会被丢弃。 除了 all() 其他的方法例如 first(), one(), one_or_none() 也都能使用 scalars() 方法的结果对象。\n下面还有一些额外的方法(q 为查询)：\nscalar(q) 和 scalars(q).first() 相同 scalar_one(q) 和 scalars(q).one() 相同 scalar_one_or_none(q) 和 scalars(q).one_or_none() 相同 Filters select(Table) 的查询会返回所有项，但实际上并不常用。 很多时候实际上只需要迭代某些项，可以使用 filter 过滤器来只迭代满足要求的项。 在选择后面添加 where() 方法：\n# 筛选特定供应商的产品 q = select(Product).where(Product.manufacturer == 'Commodore') session.scalars(q).all() # [Product(39, PET), # ... # Product(48, Amiga)] # 筛选 1990 年后的产品 q = select(Product).where(Product.year \u003e= 1990) where() 可以多次使用指定多个条件，下一个示例仅检索 Commodore 在 1980 年生产的产品：\nq = (select(Product) .where(Product.manufacturer == 'Commodore') .where(Product.year == 1980) ) 多个条件也可以写在一起\nq = select(Product).where(Product.manufacturer == 'Commodore', Product.year == 1980) 这样会使用 AND 逻辑将多个条件结合起来，有时候查询可能希望使用 OR 逻辑将操作结合。 SQLALchemy 提供了 or_() 函数来实现，下面例子是去过滤在 1970 年之前或 1970 年之后的产品。\nq = select(Product).where( or_(Product.year \u003c 1970, Product.year \u003e 1990) ) 当然也可以显示使用 and_() 函数，此外还有 not_() 函数。\n另一个很有用的过滤是 LIKE 操作，该操作用来实现简易的搜索函数。 下面例子是寻找产品名称中有 Sinclair 产品：\nq = select(Product).where(Product.name.like('%Sinclair%')) 列属性上面的 like() 方法接收一个搜索模式字符串，并返回所有匹配该模式的结果。 该模式定义了要搜索的文本，其中使用 % 字符作为通配符，可匹配零个、一个或多个字符。 并使用 _ 来匹配单个字符。\n下面是一些例子：\nSinclair% 以 Sinclair 开头的项 %Sinclair 以 Sinclair 结尾的项 % Sinclair 以 空格+Sinclair 结尾的项 R__% 以 R 开头并跟随两个字符的项 _ 单字符长的项 like() 函数是大小写敏感的，如果希望忽略大小写形式，应该使用 ilike() 函数。\n可以通过 where() 子句指定下限和上限两个条件来请求一些列条目。 但更清晰的做饭是使用模型类列属性提供的 between() 方法。 例如，下面例子返回 1970 年代生产的产品：\nq = select(Product.year.between(year, 1970, 1979)) 如果要查看生生的 SQL，可以直接打印出来\nprint(q) # SELECT products.id, products.name, products.manufacturer, products.year, products.country, products.cpu # FROM products # WHERE products.year BETWEEN :year_1 AND :year_2 此处可见，查询过滤器中定义的文字并未插入到渲染后的 SQL 语句中。 相反，他们由 :year_1 和 :year_2 这样的占位符替代。 这是防止 SQL 注入的良好实践，SQLAlchemy 会自动实现。\n出于调试目的，可能希望查询包含实际字面值的 SQL 查询。 尽管这种做法可能不安全，但下面展示了如何指示 SQLAlchemy 在渲染查询时，同时显示所有字面量参数：\nprint(q.compile(compile_kwargs={'literal_binds': True})) # SELECT products.id, products.name, products.manufacturer, products.year,products.country, products.cpu # FROM products # WHERE products.year # BETWEEN 1970 AND 1979 Order of Results 上面查询结果是按照数据库选择的顺序返回的，但关系数据库可以直接将结果高效地进行排序。 order_by() 方法可以用来对结果进行排序。\nq = select(Product).order_by(Product.name) session.scalars(q).all() 也可以使用 desc() 让其逆序排序，例如下面例子按年份逆序排序：\nq = select(Product).order_by(Product.name.desc()) session.scalars(q).all() 有时候单一的排序标准是不够的。 例如，在最后结果中会有一些计算机都是同一年制造的，这些计算机之间就是任意排序了。 order_by() 方法接受多个参数，每个参数会添加一层排序。\n例如在之前的例子上，添加一层按产品名称排序：\nq = select(Product).order_by(Product.year.desc(), Product.name.asc()) 注意其中的 asc() 方法，是按照产品名称升序排序，有时候这样写会更加清晰可读。\nAccess to Individual Columns 在之前的所有查询例子中，都是返回一整行的每一项。 select() 方法实际上十分灵活，可以选择指定的项。\nq = select(Product.name) session.scalars(q).all() # [ 'Acorn Atom', ..., 'GEM 1000' ] q = select(Product.name, Product.manufacturer) session.execute(q).all() # [('Acorn Atom', 'Acorn Computers Ltd'), ('BBC Micro', 'Acorn Computers Ltd'), ...] Aggregation Function Aggregation Function: 聚合函数\nselect() 函数也可以配合 SQL 函数使用，这些 SQL 函数会对检索到的数据进行即时求值，从而实现数据转换。 一个很有用的函数是 count()，它会将所有结果行替换为数量。 下一个例子阐明了如何查询数据库中数据的数量：\nfrom sqlalchemy import func q = select(func.count(Product.id)) r = session.scalar(q) # 149 上面使用的 count() 函数将结果降低为单个值，scalar() 方法用于检索它。 在这个例子中，使用 Product.id 作为参数是任意的，任何 Product 类的列都可以，结果一样，因为数据本身不重要。 下面是不需要任何列的结果统计方式：\nq = select(func.count()).select_from(Product) r = session.scalar(q) # 149 在这种形式，count() 函数没有给予任何参数。 使用此格式时，必须添加 select_from() 方法来配置查询中使用的表。 因为 SQLALchemy 无法根据传递给 select() 函数的参数自动确定该表。\n还有一队有用的 SQL 函数 min() 和 max()。 以下示例返回数据库中产品制造的首个和最后年份：\nq = select(func.min(Product.year), func.max(Product.year)) r = session.execute(q) r.first() # (1969, 1995) 该方法要使用 execute() 因为有两个结果。 min() 和 max() 函数会将结果缩减为单行，因此像之前示例那样使用 all() 来获取结果已无必要。 当预先确定查询结果只有单行时，使用 first() 或 one() 方法更为便捷，其中后者会在查询时返回非单行时抛出异常。\nResult Grouping 当前数据库仅将 product 作为首要实体，但有时应用程序要检索相关数据属性，例如制造商。 下面是获取制造商列表的尝试：\nq = select(Product.manufacturer).order_by(Product.manufacturer) session.scalars(q).all() # ['Acorn Computers Ltd', 'Acorn Computers Ltd', ..., 'West Computer AS'] 但显然这里存在一个问题。 尽管查询只检索制造商信息，但查询的表包含产品数据，因此每个结果行对应一个产品。 如果某家制造商在数据库中有多个产品，他就会多次出现。 以字母顺序排列时，排名首位的制造商 Acorn Computers Ltd 就连续出现六次。\n每当数据库查询可能返回重复结果时，添加 distinct() 子句会指示数据库合并相同的结果。\nq = select(Product.manufacturer).order_by(Product.manufacturer).distinct() session.scalars(q).all() # ['Acorn Computers Ltd', 'AGAT', ..., 'West Computer AS'] 你可能会想将 distinct() 子句与 count() 聚合函数结合使用，以查明数据库中存在多少制造商。 不幸的是，distinct() 函数无法与 count() 聚合函数结合使用，因为数据库会在 distinct() 前计算数量。\n如果要计算唯一结果的数量，可以在 count() 函数内部对要计数的对象调用 distinct() 方法。\nq = select(func.count(Product.manufacturer.distinct())) r = session.scalar(q) # 76 使用 distinct() 来合并结果的能力很有限，因为只有当两行结果完全相同时，数据库才会把它们折叠成一行。 举例来说，这种方式无法 “列出每个厂商以及它最早和最晚活跃年份”。 因为一旦把 Product.year 作为第二个字段加入查询，不同年份会让行变得不再相同，从而改变 distinct() 能合并哪些结果。\ngroup_by() 函数提供了更加灵活的结果分组方案。 上述返回制造商列表的查询同样可以通过 group_by() 实现：\nq = (select(Product.manufacturer) .group_by(Product.manufacturer) .order_by(Product.manufacturer)) 这样的结果相同，但使用 group_by() 可以添加额外的查询列，只要通过函数将每个组的数据聚合成单一值。 下一个示例将获取制造商列表，包括其运营的起始与结束年份，以及他们生产的型号数量：\nq = (select( Product.manufacturer, func.min(Product.year), func.max(Product.year), func.count() ) .group_by(Product.manufacturer) .order_by(Product.manufacturer) ) session.execute(q).all() # [('Acorn Computers Ltd', 1980, 1995, 6), ..., ('West Computer AS', 1984, 1984, 1)] 上面执行逻辑是：\n分组 (Group By): 将 Product 根据 manufacturer 把数据扔进不同的“桶” 里 聚合 (Aggregation): 每个桶内计算 func.min/max/count 选择 (Select): 根据选择要求把结果挑出来 排序 (Order By): 根据排序要求，把结果排序 DISTINCT 对“结果整行”去重，GROUP BY 是按某些列建立分组\n在前面已经介绍过，where() 方法可以用于筛选查询返回的结果集，并会在结果分组前进行计算。 因此该子句无法用于筛选分组后的结果。 having() 子句用于筛选分组和聚合后的结果，下面是一个示例，用于获取拥有 5 个或更多型号的制造商列表及其实际数量：\nq = (select( Product.manufacturer, func.count() ) .group_by(Product.manufacturer) .having(func.count() \u003e= 5) .order_by(Product.manufacturer) ) session.execute(q).all() # [('Acorn Computers Ltd', 6), ('Amstrad', 7), ..., ('Timex Sinclair', 6)] 你可能注意到在这个例子中 count() 出现了两次。 首先在 select() 部分出现一次，然后在 having() 方法中又出现一次。 为了确保 count() 只用编写一次，使用 label() 方法计算结果关联一个标签，随后在需要该数据的两个位置直接引用此标签即可。\nnum_products = func.count().label(None) q = (select( Product.manufacturer, num_products ) .group_by(Product.manufacturer) .having(num_products \u003e= 5) .order_by(Product.manufacturer) ) label() 方法的参数是标签的名称，当传入 None 时由 SQLALchemy 自动生成，确保选取唯一名称。 让 SQLALchemy 自动命名是可行的，关键在于将标签实例赋值给 num_products 变量。 当然，如果希望为标签指定名称，也同样允许：\nnum_products = func.count().label('num_products') Pagination 对于很长的查询结果，一个常见的方式是限制最大数量。 limit() 方法用于设置查询的最大返回数量。 在后面的查询中，最多返回了 3 个字母表排序的结果。\nq = select(Product).order_by(Product.name).limit(3) session.execute(q).all() # [Product(131, \"Aamber Pegasus\"), Product(84, \"ABC 80\"), Product(5, \"Acorn Archimedes\")] 限制查询数量防止查询结果太大无法处理。 当执行较长查询时，一种常见的做法是提供分页选项，以便分批次获取结果。 在交互式或网络应用中，用户通常可以选择指定页面大小的增量在结果中前后翻页。\n实现分页查询结果包括为 limit() 方法设置页面大小，并指示从哪个位置开始检索结果。 最简单的方法是选择一个起始位置，并添加 offset() 方法到查询中去。 此方法为要检索的结果设置起始索引，通过添加 offset(0) 可以将上述示例查询进行泛化。 查询第二页的 3 个结果可以这样完成：\nq = select(Product).order_by(Product.name).limit(3).offset(3) # OFFSET 3: 跳过前三条记录 session.scalars(q).all() # [Product(131, \"Aamber Pegasus\"), Product(84, \"ABC 80\"), Product(5, \"Acorn Archimedes\")] 使用 offset() 分页实际上一般被认为是有问题的，首先大多数数据库对其并没有高效的实现。 但更重要的是，对于频繁变化的数据集，它可能会产生令人困惑的结果，即导致 Drifting 飘移。\n例如上面的例子，如果有个叫 “AAA” 的产品添加进去了，用户再查看第三个页面的请求的第一个结果将会是 \"Acorn Archimedes. 类似地，如果一个产品被删除，其他产品的位置也会发生变化。\n一种更可靠地指定，从何处如何开始返回结果的方法是，使用最后返回的项目作为参考。 这样请求第二个页面的方法就是：\nq = select(Product).order_by(Product.name).where(Product.name \u003e 'A700').limit(3) 查询将会返回上面一样的结果，但好处是 item 的插入或删除值不会导致结果重复或省略。 缺点在于，当反向流览结果列表时，情况会变得稍微复杂一些。\n当看到了第二页的查询结果后，回到第一页的查询如下：\nq = (select(Product) .order_by(Product.name.desc()) .where(Product.name \u003c 'Aamber Pegasus') .limit(3) ) session.scalars(q).all() # [Product(6, \"A7000\"), Product(11, \"6128 Plus\"), Product(10, \"464 Plus\")] 但这个代码看上去就不再像是第一页了。 order_by() 子句必须使用 desc() 进行反向排序，以便查询能引用紧邻第二页起始产品 “Aamber Pegasus” 之前的三个项目，而这会导致结果以相反的顺序呈现。 因此应用会需要在呈现给用户前再次反转结果。\n这叫做 Keyset Pegination 键集分页，举个例子说明为什么要 desc()：\nA, B, C, D, E, F, G 如果是正向获取下一页，WHERE Product.name \u003e E 得到 F, G 如果是反向获取上一页，WHERE Product.name \u003c E 得到 A, B, C, D\n因此为了获取紧邻的三项，要使用 DESC 逆向排序，得到 D, C, B，然后再通过应用层反转得到 B, C, D 使用哪种分页方式要看具体的情况。 使用 where() 子句的替代实现方案非常稳健，因为它不会因数据变化而重复或跳过任何项目。 但这会更加复杂，此外，where() 方案不允许随机跳转，用户一次只能移动一页。\nObtain an Element by its Primary Key ",
  "wordCount" : "1490",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/og-default.avif","datePublished": "2026-01-26T08:00:00+01:00",
  "dateModified": "2026-01-26T08:00:00+01:00",
  "author":{
    "@type": "Person",
    "name": "Starslayerx"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/sqlalchemy-database-tables/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Starslayerx' Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.svg"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Starslayerx&#39; Blog (Alt + H)">
                <img src="http://localhost:1313/favicon.svg" alt="" aria-label="logo"
                    height="35">Starslayerx&#39; Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                    <ul class="lang-switch"><li>|</li>
                        <li>
                            <a href="http://localhost:1313/zh-cn/" title="简体中文"
                                aria-label="简体中文">Zh-Cn</a>
                        </li>
                    </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      SQLALchemy - Database Tables
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2026-01-26 08:00:00 +0100 +0100'>January 26, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1490 words</span>&nbsp;·&nbsp;<span>Starslayerx</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#sqlalchemy-core-and-sqlalchemy-orm">SQLALchemy Core and SQLALchemy ORM</a></li>
        <li><a href="#database-engine">Database Engine</a></li>
        <li><a href="#model">Model</a></li>
        <li><a href="#database-metadata">Database Metadata</a></li>
        <li><a href="#sessions">Sessions</a></li>
        <li><a href="#queries">Queries</a>
          <ul>
            <li><a href="#query-definition">Query Definition</a></li>
            <li><a href="#query-execution">Query Execution</a></li>
            <li><a href="#filters">Filters</a></li>
            <li><a href="#order-of-results">Order of Results</a></li>
            <li><a href="#access-to-individual-columns">Access to Individual Columns</a></li>
            <li><a href="#aggregation-function">Aggregation Function</a></li>
            <li><a href="#result-grouping">Result Grouping</a></li>
            <li><a href="#pagination">Pagination</a></li>
            <li><a href="#obtain-an-element-by-its-primary-key">Obtain an Element by its Primary Key</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="sqlalchemy-core-and-sqlalchemy-orm">SQLALchemy Core and SQLALchemy ORM<a hidden class="anchor" aria-hidden="true" href="#sqlalchemy-core-and-sqlalchemy-orm">#</a></h3>
<p>SQLALchemy 分位两个模块：Core 和 ORM (Object-Relational Mapping)。
Core 模块包含对所有受支持数据库方言的集成逻辑，一组用于描述数据库表的类，用于 Python 语言生成 SQL 语句。
ORM 模块在 Python 应用程序中引入了一层抽象，使得许多数据库操作可以根据对 Python 对象执行的操作自动推导出来。</p>
<h3 id="database-engine">Database Engine<a hidden class="anchor" aria-hidden="true" href="#database-engine">#</a></h3>
<p>SQLALchemy 使用 engine 对象来管理数据库连接，包含 Core 和 ORM 应用。
<code>create_engine()</code> 函数通过数据库 url 创建一个 engine。</p>
<p>格式为：</p>
<pre tabindex="0"><code>{dialet}{+driver}://{username}:{password}@{hostname}:{port}/{database}
</code></pre><p>其中 SQLite 比较特殊，无需 driver。</p>
<p>对于导入 DATABASE_URL 有两种方式，一种是使用 <code>load_dotenv()</code> 加载 .env 文件的环境变量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">dotenv</span> <span class="kn">import</span> <span class="n">load_dotenv</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">load_dotenv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;DATABASE_URL&#39;</span><span class="p">])</span>
</span></span></code></pre></div><p>另一种是通过 Pydantic <code>BaseSettings</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pydantic_settings</span> <span class="kn">import</span> <span class="n">BaseSettings</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pydantic</span> <span class="n">impot</span> <span class="n">SecretStr</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Settings</span><span class="p">(</span><span class="n">BaseSettings</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">POSTGRESQL_HOST</span><span class="p">:</span> <span class="nb">str</span>
</span></span><span class="line"><span class="cl">    <span class="n">POSTGRESQL_PORT</span><span class="p">:</span> <span class="nb">int</span>
</span></span><span class="line"><span class="cl">    <span class="n">POSTGRESQL_USER</span><span class="p">:</span> <span class="nb">str</span>
</span></span><span class="line"><span class="cl">    <span class="n">POSTGRESQL_PASSWORD</span><span class="p">:</span> <span class="n">SecretStr</span>
</span></span><span class="line"><span class="cl">    <span class="n">POSTGRESQL_DB</span><span class="p">:</span> <span class="nb">str</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@property</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">postgres_db_url</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 通常无需显示地写 driver，只有更换 dirver 时才需要写</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;postgresql://</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">POSTGRESQL_USER</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">POSTGRESQL_PASSWORD</span><span class="o">.</span><span class="n">get_secret_value</span><span class="p">()</span><span class="si">}</span><span class="s1">@</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">POSTGRESQL_HOST</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">POSTGRESQL_PORT</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">POSTGRESQL_DB</span><span class="si">}</span><span class="s1">&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">class</span> <span class="nc">Config</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">env_file</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="s1">&#39;.env&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">case_sensitive</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">        <span class="n">extra</span> <span class="o">=</span> <span class="s1">&#39;ignore&#39;</span>  <span class="c1"># 忽略额外字段</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@lru_cache</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_settings</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Settings</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">Settings</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用示例</span>
</span></span><span class="line"><span class="cl"><span class="n">settings</span> <span class="o">=</span> <span class="n">get_settings</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Host:&#39;</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">POSTGRESQL_HOST</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Password:&#39;</span><span class="p">,</span> <span class="n">settings</span><span class="o">.</span><span class="n">PASSWORD</span><span class="o">.</span><span class="n">get_secret_value</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">postgres_db_url</span><span class="p">)</span>
</span></span></code></pre></div><p><code>create_engine()</code> 函数有以下配置参数：</p>
<ul>
<li>
<p><code>echo=True</code> 日志记录每个 SQL 语句，用于调试非常有用。</p>
</li>
<li>
<p><code>pool_size=&lt;N&gt;</code> 指定连接池大小，默认最多 5 个</p>
</li>
<li>
<p><code>max_overflow=&lt;N&gt;</code> 流量高峰期最多可以创建的超过连接池连接的大小，默认为 10</p>
</li>
<li>
<p><code>future=True</code> 告诉 SQLALchemy 1.4 使用 2.0 的新版 APIs</p>
</li>
<li>
<p><code>pool_recycle=&lt;N&gt;</code> 设置链接回收时间，单位秒。mysql 默认 8 小时，推荐设置一小时(3600)。</p>
</li>
<li>
<p><code>pool_pre_ping=True</code> 在每次从池中取出连接前先 ping 一下，检查是否活着，解决数据库偶尔重启掉线的问题，提高健壮性</p>
</li>
</ul>
<h3 id="model">Model<a hidden class="anchor" aria-hidden="true" href="#model">#</a></h3>
<p>当使用 ORM 模块时，数据库表在 Python 类中定义。
该程序需要为所有的类创建一个父类，以便配置所有表共享的设置。
父类在 SQLALchemy 中被称为 <code>declarative</code> 基类，通常叫做 <code>Model</code> 或 <code>Base</code>。
Model 类的子类集和代表了数据库的结构或模式，通常被称为应用程序的 “模型”。</p>
<p>Model 类必须从 SQLALchemy 的 <code>DeclartiveBase</code> 类继承。
下面是一个没有额外配置的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="c1"># db.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">dotenv</span> <span class="kn">import</span> <span class="n">load_dotenv</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclartiveBase</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">DeclartiveBase</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">load_dotenv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="s1">&#39;DATABASE_URL&#39;</span><span class="p">])</span>
</span></span></code></pre></div><p>下面使用一个新文件存 Product 表的创建：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">String</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span><span class="p">,</span> <span class="n">mapped_column</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">db</span> <span class="kn">import</span> <span class="n">Model</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Product</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s1">&#39;products&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">manufacturer</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">year</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">country</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">cpu</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Product(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">, &#34;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#34;)&#39;</span>
</span></span></code></pre></div><p>Model 子类通过类属性定义：</p>
<p><code>__tablename__</code> 属性定义数据库表名称，常见命名规范是表名称使用复数小写形式，这和模型名称形成对比，即使用单数的 camel case 驼峰命名法。</p>
<p>剩余定义的属性是表中的列，<code>Mapped[t]</code> 类型声明用于定义每个列，其中 <code>t</code> 是 Python 类型，例如 <code>int</code>, <code>str</code> 或 <code>datetime</code>。
对于 year 这样的普通列来说完全足够了，如果列需要额外的功能，就要将其赋值给一个 <code>mapped_column()</code> 构造器。</p>
<p>在上面的 <code>Product</code> 模型中，可以选择将 id 列作为一个 primary key 主键，其值必须唯一。
SQLALchemy 将主键设置为从 1 开始的自增列。</p>
<p>剩下的 str 类型通过 <code>String()</code> 添加了最大长度作为补充。
并非所有数据库都要求一定长度，但最好设置一下。</p>
<p>最后 <code>__repr__()</code> 方法是 Python 的特殊方法，告诉该对象如何打印。
该方法是可选的，但在调试和 shell 环境中使用的时候会很有用。</p>
<p>要创建模型类的实例，需使用标准构造函数，并以关键字参数形式传入模型属性的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">c64</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Commodore 64&#39;</span><span class="p">,</span> <span class="n">manufacturer</span><span class="o">=</span><span class="s1">&#39;Commodore&#39;</span><span class="p">)</span>
</span></span></code></pre></div><p>上面代码会初始化一个新的 Product 实例，这个例子中除了指定的 name 和 manufacturer 之外都会被设置为 None。
尽管这个对象是一个模型实例，但此刻它只是一个普通的 Python 对象，尚未被存储在数据库中。</p>
<p>模型类的概念只适用于 ORM 模块，当使用 Core 时需要使用 Table 类来表示数据库表。</p>
<h3 id="database-metadata">Database Metadata<a hidden class="anchor" aria-hidden="true" href="#database-metadata">#</a></h3>
<p>SQLALchemy 将所有数据库表的定义维护在一个 <code>MetaData</code> 对象中。
出于方便，它会初始化一个声明基类作为 MetaData 的一个属性。
对于 Model 类型，可以通过 <code>Model.metadata</code> 获取该值。
当一个 model class 例如 Product 定义的时候，SQLALchemy 会在对应的属性创建定义。</p>
<p>默认的 MetaData 配置存在一个总要限制，当项目达到一定规模或复制度时，这个限制必然会导致问题。
这与 <code>naming_convention</code> 相关，该选项用于指示 SQLALchemy 如何命名在数据库中创建的索引和约束。</p>
<p>默认的命名规范为 <code>MetaData</code> 索引提供了默认命名，但没有为 constraints 约束提供。
因此 SQLALchemy 不会以特定名称初始化它们，导致数据库使用任意名称。
当一个 constraint 约束需要被修改或删除的时候会导致问题，因为 SQLALchemy 无法通过约束名称来定位它。</p>
<p>为了避免可能出现的复杂情况，Model declarative base 声明基类可以通过更完整的命名约束进行初始化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">dotenv</span> <span class="kn">import</span> <span class="n">load_dotenv</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">MetaData</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">naming_convention</span><span class="o">=</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;ix&#39;</span><span class="p">:</span> <span class="s1">&#39;ix_</span><span class="si">%(column_0_label)s</span><span class="s1">&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;uq&#39;</span><span class="p">:</span> <span class="s1">&#39;uq_</span><span class="si">%(table_name)s</span><span class="s1">_</span><span class="si">%(column_0_name)s</span><span class="s1">&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;ck&#39;</span><span class="p">:</span> <span class="s1">&#39;ck_</span><span class="si">%(table_name)s</span><span class="s1">_</span><span class="si">%(constraint_name)s</span><span class="s1">&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;fk&#39;</span><span class="p">:</span> <span class="s1">&#39;fk_</span><span class="si">%(table_name)s</span><span class="s1">_</span><span class="si">%(column_0_name)s</span><span class="s1">_(referred_table_name)s&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;pk&#39;</span><span class="p">:</span> <span class="s1">&#39;pk_</span><span class="si">%(table_name)s</span><span class="s1">&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">load_dotenv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;DATABASE_URL&#39;</span><span class="p">])</span>
</span></span></code></pre></div><p>MetaData 对象有一个 <code>create_all()</code> 方法，该方法具有重要作用，因为他会创建与已定义模型关联的所有数据库表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">Model</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
</span></span></code></pre></div><p><code>create_all()</code> 方法向由 <code>engine</code> 表示的数据库发出 SQL 语句，以创建所有模型引用的数据库表。
该方法的局限性是，它只会创建数据库。
这意味着，当一个模型类型被修改了，该方法不能用于将变更传输至相应的数据库表。</p>
<p>一个修改现存表的变通方法是在调用 <code>create_all()</code> 之前，删除旧版的表，然后创建新版本的表。
对应的 MetaData 有一个 <code>drop_all()</code> 方法，该方法会从数据库删除所有的表。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">Model</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">drop_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">Model</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
</span></span></code></pre></div><p>不幸的是，这样会导致数据丢失，后面会使用 Alembic 来做数据库迁移。</p>
<p>如果使用 Core 则必须手动创建数据库 metadata 对象。</p>
<h3 id="sessions">Sessions<a hidden class="anchor" aria-hidden="true" href="#sessions">#</a></h3>
<p>另一个基于 ORM 的重要概念是 Session。
一个 Session 对象管理一系列示例的新建、读取、修改和删除。</p>
<p>在会话中累计的更改，会在会话刷新 flush 时，通过数据库事务 transaction 的上下文传递到数据库中。
这一操作在大多数情况下由 SQLALchemy 在需要时自动触发。
一次刷新操作会将修改写入数据库，但保持数据库事务处于打开状态。</p>
<p>当会话提交后，对应的数据库事务也会提交，造成数据库的永久修改。
数据库事务是关系数据库最重要的优势之一，旨在保护数据的完整性。</p>
<p>下面示例展示了如何将 c64 对象加入数据库：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Session</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">except</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">raise</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">c64</span><span class="p">)</span>
</span></span></code></pre></div><p>管理数据库会话 session 的最佳方式就是通过上下文管理器 context manager。
这能确保会话正确地关闭和清理。</p>
<p>Session 通过 engine 对象进行初始化。
类似地，也可以使用 <code>future=True</code> 参数将 SQLALchemy 1.4 的 API 设置为 2.0 版本。</p>
<p>Session 对象被设计成累计修改，直到提交或回滚。
<code>add()</code> 方法用来在会话中插入一个新对象，<code>try/block</code> 块保证 session 总是提交成功或回滚。</p>
<p>之前说过 SQLALchemy 默认设置主键列为整数自增的。
当会话刷新时，数据库会为新增条目的 <code>id</code> 属性分配下一个可用数字。
若是首次条目，则会分配数字 1。
任何其他没有设定的属性都会在数据库中被记录为 NULL。</p>
<p>SQLALchemy 提供了一个更加简洁地 session 交互方式。
一个正常的应用中会有许多地方需要创建会话，如果每次都必须传递 engine 和其他选项，就不太方便。
<code>sessionmaker</code> 工厂函数提供了一种创建定制化 Session 类的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">sessionmaker</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">with</span> <span class="n">Session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ...</span>
</span></span></code></pre></div><p>将所有的逻辑都放到 <code>try/except</code> 块中仍会显得乏味。
下面的例子在上下文管理器中使用 <code>begin()</code> 替代异常处理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="k">with</span> <span class="n">Session</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c64</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">c64</span><span class="p">)</span>
</span></span></code></pre></div><p>通过 <code>session.begin()</code> 创建的上下文管理器在内部实现了 <code>try/except</code> 逻辑。
如果发生了异常，则会回滚到之前的状态。
下面是一个完整的创建会话的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">dotenv</span> <span class="kn">import</span> <span class="n">load_dotenv</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span><span class="p">,</span> <span class="n">MetaData</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span><span class="p">,</span> <span class="n">sessionmaker</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Model</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">metadata</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">(</span><span class="n">naming_convention</span><span class="o">=</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;ix&#39;</span><span class="p">:</span> <span class="s1">&#39;ix_</span><span class="si">%(column_0_label)s</span><span class="s1">&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;uq&#39;</span><span class="p">:</span> <span class="s1">&#39;uq_</span><span class="si">%(table_name)s</span><span class="s1">_</span><span class="si">%(column_0_name)s</span><span class="s1">&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;ck&#39;</span><span class="p">:</span> <span class="s1">&#39;ck_</span><span class="si">%(table_name)s</span><span class="s1">_</span><span class="si">%(constraint_name)s</span><span class="s1">&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;fk&#39;</span><span class="p">:</span> <span class="s1">&#39;fk_</span><span class="si">%(table_name)s</span><span class="s1">_</span><span class="si">%(column_0_name)s</span><span class="s1">_(referred_table_name)s&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;pk&#39;</span><span class="p">:</span> <span class="s1">&#39;pk_</span><span class="si">%(table_name)s</span><span class="s1">&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">load_dotenv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;DATABASE_URL&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="n">Session</span> <span class="o">=</span> <span class="n">sessionmaker</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="queries">Queries<a hidden class="anchor" aria-hidden="true" href="#queries">#</a></h3>
<h4 id="query-definition">Query Definition<a hidden class="anchor" aria-hidden="true" href="#query-definition">#</a></h4>
<p>SQLALchemy 提供了 <code>select()</code> 函数来实现 SELECT 关键字一样的查询功能。
假设通过 ORM 定义了一个 <code>Product</code> 表，下面来查询表中所有元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">select</span>
</span></span><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span>
</span></span></code></pre></div><p><code>select()</code> 函数接收需要检索的条目作为参数。
当以模型类作为参数时，SQLALchemy ORM 会自动获取该模型的所有属性，并以透明方式返回 Python 对象。
可以打印查看 SQL 查询语句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># SELECT products.id, products.name, productsroducts.manufacturer, products.year, products.country, products.cpu</span>
</span></span><span class="line"><span class="cl"><span class="c1"># FROM products</span>
</span></span></code></pre></div><h4 id="query-execution">Query Execution<a hidden class="anchor" aria-hidden="true" href="#query-execution">#</a></h4>
<p>当查询对象创建后，需要将其传递给 session，这将通过 engine 维护的连接将其发送到数据库驱动程序中执行。
最常见的方法是使用 <code>execute()</code> 命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">r</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [(Product(1, Acorn Atom),),</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  (Product(2, BBC Micro),),</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  ...,</span>
</span></span><span class="line"><span class="cl"><span class="c1"># (Product(149, GEM 1000),)]</span>
</span></span></code></pre></div><p><code>execute()</code> 方法返回一个可迭代的结果对象，通过 list() 可以将其转换为列表并展示。</p>
<ul>
<li>
<p><code>execute()</code> 执行结果对象可以使用 <code>all()</code> 方法获取和 list() 一样的结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span></code></pre></div></li>
<li>
<p><code>first()</code> 返回结果的第一行，如果没有结果返回 <code>None</code></p>
</li>
<li>
<p><code>one()</code> 只返回第一个结果，如果有零或多余一个结果，则抛出异常</p>
</li>
<li>
<p><code>one_or_none()</code> 只返回第一个结果，如果没有结果返回 <code>None</code>，如果超过一个结果则抛出异常</p>
</li>
</ul>
<p>获取 iterable 可迭代的结果十分高效，SQLALchemy 只会迭代需要的行。
这意味着，对于很大结果的查询，无需将所有内容存储在列表中，而可以只处理加载的结果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">r</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span></code></pre></div><p>注意处理得到的结果格式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="p">(</span><span class="n">Product</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;Acorn Atom&#34;</span><span class="p">),)</span>
</span></span></code></pre></div><p>这不是单纯的一个 <code>Product</code> 对象，而是一个元组，因为查询有时候可能会每行返回多个结果。
如果确定返回结果是单个元素，则可以使用 <code>scalars()</code> 来执行查询：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [Product(1, Acorn Atom), ..., Product(149, GEM 1000)]</span>
</span></span></code></pre></div><p>使用该方法时会返回一个不同的结果对象，该对象只包含每行的第一个值。
如果查询结果每行有多个值，则多余的值会被丢弃。
除了 <code>all()</code> 其他的方法例如 <code>first()</code>, <code>one()</code>, <code>one_or_none()</code> 也都能使用 <code>scalars()</code> 方法的结果对象。</p>
<p>下面还有一些额外的方法(q 为查询)：</p>
<ul>
<li><code>scalar(q)</code> 和 <code>scalars(q).first()</code> 相同</li>
<li><code>scalar_one(q)</code> 和 <code>scalars(q).one()</code> 相同</li>
<li><code>scalar_one_or_none(q)</code> 和 <code>scalars(q).one_or_none()</code> 相同</li>
</ul>
<h4 id="filters">Filters<a hidden class="anchor" aria-hidden="true" href="#filters">#</a></h4>
<p><code>select(Table)</code> 的查询会返回所有项，但实际上并不常用。
很多时候实际上只需要迭代某些项，可以使用 filter 过滤器来只迭代满足要求的项。
在选择后面添加 <code>where()</code> 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="c1"># 筛选特定供应商的产品</span>
</span></span><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span> <span class="o">==</span> <span class="s1">&#39;Commodore&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [Product(39, PET),</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  ...</span>
</span></span><span class="line"><span class="cl"><span class="c1">#  Product(48, Amiga)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 筛选 1990 年后的产品</span>
</span></span><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">year</span> <span class="o">&gt;=</span> <span class="mi">1990</span><span class="p">)</span>
</span></span></code></pre></div><p><code>where()</code> 可以多次使用指定多个条件，下一个示例仅检索 Commodore 在 1980 年生产的产品：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span> <span class="o">==</span> <span class="s1">&#39;Commodore&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">year</span> <span class="o">==</span> <span class="mi">1980</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>多个条件也可以写在一起</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span> <span class="o">==</span> <span class="s1">&#39;Commodore&#39;</span><span class="p">,</span> <span class="n">Product</span><span class="o">.</span><span class="n">year</span> <span class="o">==</span> <span class="mi">1980</span><span class="p">)</span>
</span></span></code></pre></div><p>这样会使用 AND 逻辑将多个条件结合起来，有时候查询可能希望使用 OR 逻辑将操作结合。
SQLALchemy 提供了 <code>or_()</code> 函数来实现，下面例子是去过滤在 1970 年之前或 1970 年之后的产品。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">or_</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">year</span> <span class="o">&lt;</span> <span class="mi">1970</span><span class="p">,</span> <span class="n">Product</span><span class="o">.</span><span class="n">year</span> <span class="o">&gt;</span> <span class="mi">1990</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p>当然也可以显示使用 <code>and_()</code> 函数，此外还有 <code>not_()</code> 函数。</p>
<p>另一个很有用的过滤是 LIKE 操作，该操作用来实现简易的搜索函数。
下面例子是寻找产品名称中有 Sinclair 产品：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s1">&#39;%Sinclair%&#39;</span><span class="p">))</span>
</span></span></code></pre></div><p>列属性上面的 <code>like()</code> 方法接收一个搜索模式字符串，并返回所有匹配该模式的结果。
该模式定义了要搜索的文本，其中使用 <code>%</code> 字符作为通配符，可匹配零个、一个或多个字符。
并使用 <code>_</code> 来匹配单个字符。</p>
<p>下面是一些例子：</p>
<ul>
<li><code>Sinclair%</code> 以 Sinclair 开头的项</li>
<li><code>%Sinclair</code> 以 Sinclair 结尾的项</li>
<li><code>% Sinclair</code> 以 空格+Sinclair 结尾的项</li>
<li><code>R__%</code> 以 R 开头并跟随两个字符的项</li>
<li><code>_</code> 单字符长的项</li>
</ul>
<p><code>like()</code> 函数是大小写敏感的，如果希望忽略大小写形式，应该使用 <code>ilike()</code> 函数。</p>
<p>可以通过 <code>where()</code> 子句指定下限和上限两个条件来请求一些列条目。
但更清晰的做饭是使用模型类列属性提供的 <code>between()</code> 方法。
例如，下面例子返回 1970 年代生产的产品：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="mi">1970</span><span class="p">,</span> <span class="mi">1979</span><span class="p">))</span>
</span></span></code></pre></div><p>如果要查看生生的 SQL，可以直接打印出来</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># SELECT products.id, products.name, products.manufacturer, products.year, products.country, products.cpu</span>
</span></span><span class="line"><span class="cl"><span class="c1"># FROM products</span>
</span></span><span class="line"><span class="cl"><span class="c1"># WHERE products.year BETWEEN :year_1 AND :year_2</span>
</span></span></code></pre></div><p>此处可见，查询过滤器中定义的文字并未插入到渲染后的 SQL 语句中。
相反，他们由 <code>:year_1</code> 和 <code>:year_2</code> 这样的占位符替代。
这是防止 SQL 注入的良好实践，SQLAlchemy 会自动实现。</p>
<p>出于调试目的，可能希望查询包含实际字面值的 SQL 查询。
尽管这种做法可能不安全，但下面展示了如何指示 SQLAlchemy 在渲染查询时，同时显示所有字面量参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">compile_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;literal_binds&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}))</span>
</span></span><span class="line"><span class="cl"><span class="c1"># SELECT products.id, products.name, products.manufacturer, products.year,products.country, products.cpu</span>
</span></span><span class="line"><span class="cl"><span class="c1"># FROM products</span>
</span></span><span class="line"><span class="cl"><span class="c1"># WHERE products.year</span>
</span></span><span class="line"><span class="cl"><span class="c1"># BETWEEN 1970 AND 1979</span>
</span></span></code></pre></div><h4 id="order-of-results">Order of Results<a hidden class="anchor" aria-hidden="true" href="#order-of-results">#</a></h4>
<p>上面查询结果是按照数据库选择的顺序返回的，但关系数据库可以直接将结果高效地进行排序。
<code>order_by()</code> 方法可以用来对结果进行排序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span></code></pre></div><p>也可以使用 <code>desc()</code> 让其逆序排序，例如下面例子按年份逆序排序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span></code></pre></div><p>有时候单一的排序标准是不够的。
例如，在最后结果中会有一些计算机都是同一年制造的，这些计算机之间就是任意排序了。
<code>order_by()</code> 方法接受多个参数，每个参数会添加一层排序。</p>
<p>例如在之前的例子上，添加一层按产品名称排序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">desc</span><span class="p">(),</span> <span class="n">Product</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">asc</span><span class="p">())</span>
</span></span></code></pre></div><p>注意其中的 <code>asc()</code> 方法，是按照产品名称升序排序，有时候这样写会更加清晰可读。</p>
<h4 id="access-to-individual-columns">Access to Individual Columns<a hidden class="anchor" aria-hidden="true" href="#access-to-individual-columns">#</a></h4>
<p>在之前的所有查询例子中，都是返回一整行的每一项。
<code>select()</code> 方法实际上十分灵活，可以选择指定的项。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [ &#39;Acorn Atom&#39;, ..., &#39;GEM 1000&#39; ]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [(&#39;Acorn Atom&#39;, &#39;Acorn Computers Ltd&#39;), (&#39;BBC Micro&#39;, &#39;Acorn Computers Ltd&#39;), ...]</span>
</span></span></code></pre></div><h4 id="aggregation-function">Aggregation Function<a hidden class="anchor" aria-hidden="true" href="#aggregation-function">#</a></h4>
<p>Aggregation Function: 聚合函数</p>
<p><code>select()</code> 函数也可以配合 SQL 函数使用，这些 SQL 函数会对检索到的数据进行即时求值，从而实现数据转换。
一个很有用的函数是 <code>count()</code>，它会将所有结果行替换为数量。
下一个例子阐明了如何查询数据库中数据的数量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">func</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 149</span>
</span></span></code></pre></div><p>上面使用的 <code>count()</code> 函数将结果降低为单个值，<code>scalar()</code> 方法用于检索它。
在这个例子中，使用 <code>Product.id</code> 作为参数是任意的，任何 Product 类的列都可以，结果一样，因为数据本身不重要。
下面是不需要任何列的结果统计方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">())</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 149</span>
</span></span></code></pre></div><p>在这种形式，<code>count()</code> 函数没有给予任何参数。
使用此格式时，必须添加 <code>select_from()</code> 方法来配置查询中使用的表。
因为 SQLALchemy 无法根据传递给 <code>select()</code> 函数的参数自动确定该表。</p>
<p>还有一队有用的 SQL 函数 <code>min()</code> 和 <code>max()</code>。
以下示例返回数据库中产品制造的首个和最后年份：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">year</span><span class="p">),</span> <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">year</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># (1969, 1995)</span>
</span></span></code></pre></div><p>该方法要使用 <code>execute()</code> 因为有两个结果。
<code>min()</code> 和 <code>max()</code> 函数会将结果缩减为单行，因此像之前示例那样使用 <code>all()</code> 来获取结果已无必要。
当预先确定查询结果只有单行时，使用 <code>first()</code> 或 <code>one()</code> 方法更为便捷，其中后者会在查询时返回非单行时抛出异常。</p>
<h4 id="result-grouping">Result Grouping<a hidden class="anchor" aria-hidden="true" href="#result-grouping">#</a></h4>
<p>当前数据库仅将 product 作为首要实体，但有时应用程序要检索相关数据属性，例如制造商。
下面是获取制造商列表的尝试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [&#39;Acorn Computers Ltd&#39;, &#39;Acorn Computers Ltd&#39;, ..., &#39;West Computer AS&#39;]</span>
</span></span></code></pre></div><p>但显然这里存在一个问题。
尽管查询只检索制造商信息，但查询的表包含产品数据，因此每个结果行对应一个产品。
如果某家制造商在数据库中有多个产品，他就会多次出现。
以字母顺序排列时，排名首位的制造商 Acorn Computers Ltd 就连续出现六次。</p>
<p>每当数据库查询可能返回重复结果时，添加 <code>distinct()</code> 子句会指示数据库合并相同的结果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [&#39;Acorn Computers Ltd&#39;, &#39;AGAT&#39;, ..., &#39;West Computer AS&#39;]</span>
</span></span></code></pre></div><p>你可能会想将 <code>distinct()</code> 子句与 <code>count()</code> 聚合函数结合使用，以查明数据库中存在多少制造商。
不幸的是，<code>distinct()</code> 函数无法与 <code>count()</code> 聚合函数结合使用，因为数据库会在 <code>distinct()</code> 前计算数量。</p>
<p>如果要计算唯一结果的数量，可以在 <code>count()</code> 函数内部对要计数的对象调用 <code>distinct()</code> 方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="o">.</span><span class="n">distinct</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 76</span>
</span></span></code></pre></div><p>使用 <code>distinct()</code> 来合并结果的能力很有限，因为只有当两行结果完全相同时，数据库才会把它们折叠成一行。
举例来说，这种方式无法 “列出每个厂商以及它最早和最晚活跃年份”。
因为一旦把 <code>Product.year</code> 作为第二个字段加入查询，不同年份会让行变得不再相同，从而改变 <code>distinct()</code> 能合并哪些结果。</p>
<p><code>group_by()</code> 函数提供了更加灵活的结果分组方案。
上述返回制造商列表的查询同样可以通过 <code>group_by()</code> 实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">))</span>
</span></span></code></pre></div><p>这样的结果相同，但使用 <code>group_by()</code> 可以添加额外的查询列，只要通过函数将每个组的数据聚合成单一值。
下一个示例将获取制造商列表，包括其运营的起始与结束年份，以及他们生产的型号数量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">select</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">func</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">year</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">year</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [(&#39;Acorn Computers Ltd&#39;, 1980, 1995, 6), ..., (&#39;West Computer AS&#39;, 1984, 1984, 1)]</span>
</span></span></code></pre></div><p>上面执行逻辑是：</p>
<ul>
<li>分组 (Group By): 将 Product 根据 manufacturer 把数据扔进不同的“桶” 里</li>
<li>聚合 (Aggregation): 每个桶内计算 <code>func.min/max/count</code></li>
<li>选择 (Select): 根据选择要求把结果挑出来</li>
<li>排序 (Order By): 根据排序要求，把结果排序</li>
</ul>
<blockquote>
<p>DISTINCT 对“结果整行”去重，GROUP BY 是按某些列建立分组</p>
</blockquote>
<p>在前面已经介绍过，<code>where()</code> 方法可以用于筛选查询返回的结果集，并会在结果分组前进行计算。
因此该子句无法用于筛选分组后的结果。
<code>having()</code> 子句用于筛选分组和聚合后的结果，下面是一个示例，用于获取拥有 5 个或更多型号的制造商列表及其实际数量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">select</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">having</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [(&#39;Acorn Computers Ltd&#39;, 6), (&#39;Amstrad&#39;, 7), ..., (&#39;Timex Sinclair&#39;, 6)]</span>
</span></span></code></pre></div><p>你可能注意到在这个例子中 <code>count()</code> 出现了两次。
首先在 <code>select()</code> 部分出现一次，然后在 <code>having()</code> 方法中又出现一次。
为了确保 <code>count()</code> 只用编写一次，使用 <code>label()</code> 方法计算结果关联一个标签，随后在需要该数据的两个位置直接引用此标签即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">num_products</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">select</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">num_products</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">having</span><span class="p">(</span><span class="n">num_products</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">manufacturer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></div><p><code>label()</code> 方法的参数是标签的名称，当传入 <code>None</code> 时由 SQLALchemy 自动生成，确保选取唯一名称。
让 SQLALchemy 自动命名是可行的，关键在于将标签实例赋值给 <code>num_products</code> 变量。
当然，如果希望为标签指定名称，也同样允许：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">num_products</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;num_products&#39;</span><span class="p">)</span>
</span></span></code></pre></div><h4 id="pagination">Pagination<a hidden class="anchor" aria-hidden="true" href="#pagination">#</a></h4>
<p>对于很长的查询结果，一个常见的方式是限制最大数量。
<code>limit()</code> 方法用于设置查询的最大返回数量。
在后面的查询中，最多返回了 3 个字母表排序的结果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [Product(131, &#34;Aamber Pegasus&#34;), Product(84, &#34;ABC 80&#34;), Product(5, &#34;Acorn Archimedes&#34;)]</span>
</span></span></code></pre></div><p>限制查询数量防止查询结果太大无法处理。
当执行较长查询时，一种常见的做法是提供分页选项，以便分批次获取结果。
在交互式或网络应用中，用户通常可以选择指定页面大小的增量在结果中前后翻页。</p>
<p>实现分页查询结果包括为 <code>limit()</code> 方法设置页面大小，并指示从哪个位置开始检索结果。
最简单的方法是选择一个起始位置，并添加 <code>offset()</code> 方法到查询中去。
此方法为要检索的结果设置起始索引，通过添加 <code>offset(0)</code> 可以将上述示例查询进行泛化。
查询第二页的 3 个结果可以这样完成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># OFFSET 3: 跳过前三条记录</span>
</span></span><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [Product(131, &#34;Aamber Pegasus&#34;), Product(84, &#34;ABC 80&#34;), Product(5, &#34;Acorn Archimedes&#34;)]</span>
</span></span></code></pre></div><p>使用 <code>offset()</code> 分页实际上一般被认为是有问题的，首先大多数数据库对其并没有高效的实现。
但更重要的是，对于频繁变化的数据集，它可能会产生令人困惑的结果，即导致 Drifting 飘移。</p>
<p>例如上面的例子，如果有个叫 &ldquo;AAA&rdquo; 的产品添加进去了，用户再查看第三个页面的请求的第一个结果将会是 <code>&quot;Acorn Archimedes</code>.
类似地，如果一个产品被删除，其他产品的位置也会发生变化。</p>
<p>一种更可靠地指定，从何处如何开始返回结果的方法是，使用最后返回的项目作为参考。
这样请求第二个页面的方法就是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">name</span> <span class="o">&gt;</span> <span class="s1">&#39;A700&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span></code></pre></div><p>查询将会返回上面一样的结果，但好处是 item 的插入或删除值不会导致结果重复或省略。
缺点在于，当反向流览结果列表时，情况会变得稍微复杂一些。</p>
<p>当看到了第二页的查询结果后，回到第一页的查询如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Python" data-lang="Python"><span class="line"><span class="cl"><span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Product</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Product</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="s1">&#39;Aamber Pegasus&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [Product(6, &#34;A7000&#34;), Product(11, &#34;6128 Plus&#34;), Product(10, &#34;464 Plus&#34;)]</span>
</span></span></code></pre></div><p>但这个代码看上去就不再像是第一页了。
<code>order_by()</code> 子句必须使用 <code>desc()</code> 进行反向排序，以便查询能引用紧邻第二页起始产品 &ldquo;Aamber Pegasus&rdquo; 之前的三个项目，而这会导致结果以相反的顺序呈现。
因此应用会需要在呈现给用户前再次反转结果。</p>
<hr>
<p>这叫做 Keyset Pegination 键集分页，举个例子说明为什么要 <code>desc()</code>：</p>
<pre tabindex="0"><code>A, B, C, D, E, F, G
</code></pre><ul>
<li>如果是正向获取下一页，<code>WHERE Product.name &gt; E</code> 得到 <code>F, G</code></li>
<li>如果是反向获取上一页，<code>WHERE Product.name &lt; E</code> 得到 <code>A, B, C, D</code><br>
因此为了获取紧邻的三项，要使用 <code>DESC</code> 逆向排序，得到 <code>D, C, B</code>，然后再通过应用层反转得到 <code>B, C, D</code></li>
</ul>
<hr>
<p>使用哪种分页方式要看具体的情况。
使用 <code>where()</code> 子句的替代实现方案非常稳健，因为它不会因数据变化而重复或跳过任何项目。
但这会更加复杂，此外，<code>where()</code> 方案不允许随机跳转，用户一次只能移动一页。</p>
<h4 id="obtain-an-element-by-its-primary-key">Obtain an Element by its Primary Key<a hidden class="anchor" aria-hidden="true" href="#obtain-an-element-by-its-primary-key">#</a></h4>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/python/">Python</a></li>
      <li><a href="http://localhost:1313/tags/database/">Database</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/python-asyncio-04-concurrent-web-requests/">
    <span class="title">« Prev</span>
    <br>
    <span>Python Asyncio 04: Concurrent web requests</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/python-tricks-part-7-classes-and-object-oriented-programming/">
    <span class="title">Next »</span>
    <br>
    <span>Python Tricks Part 7: Classes and Object-Oriented Programming</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share SQLALchemy - Database Tables on x"
            href="https://x.com/intent/tweet/?text=SQLALchemy%20-%20Database%20Tables&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fsqlalchemy-database-tables%2f&amp;hashtags=Python%2cDatabase">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share SQLALchemy - Database Tables on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fsqlalchemy-database-tables%2f&amp;title=SQLALchemy%20-%20Database%20Tables&amp;summary=SQLALchemy%20-%20Database%20Tables&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fsqlalchemy-database-tables%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share SQLALchemy - Database Tables on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fsqlalchemy-database-tables%2f&title=SQLALchemy%20-%20Database%20Tables">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share SQLALchemy - Database Tables on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fsqlalchemy-database-tables%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share SQLALchemy - Database Tables on whatsapp"
            href="https://api.whatsapp.com/send?text=SQLALchemy%20-%20Database%20Tables%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fsqlalchemy-database-tables%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share SQLALchemy - Database Tables on telegram"
            href="https://telegram.me/share/url?text=SQLALchemy%20-%20Database%20Tables&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fsqlalchemy-database-tables%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share SQLALchemy - Database Tables on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=SQLALchemy%20-%20Database%20Tables&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fsqlalchemy-database-tables%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">Starslayerx&#39; Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
