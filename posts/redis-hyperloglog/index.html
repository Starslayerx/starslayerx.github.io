<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis HyperLogLog | Starslayerx' Blog</title><meta name=keywords content="Redis"><meta name=description content="之前曾介绍过使用 Redis 集和构建唯一计数器, 并将这个计数器用于计算网站的唯一房客 IP.
虽然使用集和实现唯一计数器可以实现该功能, 但这个方法有一个明显的缺陷:
随着被计数元素的不断增多, 唯一计数器占用的内存也会越来越大; 计数器越多, 他们的体积越大, 这一情况就会越严峻.
以计算唯一访客 IP 为例:

存储一个 IPv4 格式的 IP 地址最多需要 15 个字节
根据网站的规模不同, 每天出现的唯一 IP 可能会有数十万、数百万个
为了记录网站在不同时期的访客, 并进行相关的数据分析, 网站可能需要次序地记录每天的唯一访客 IP 数量

综上, 如果一个网站想要长时间记录访客 IP, 就必须创建多个唯一计数器. 如果访客比较多, 那么它创建的每个唯一计数器都将包含大量元素, 并因此占用相当一部分内存.
为了高效解决计算机唯一访客 IP 数量这类问题, 其中一种方法就是 HyperLogLog.
HyperLogLog 简介
HyperLogLog 是一个专门为了计算集和的基数而创建的概率算法, 对于一个给定的集和, HyperLogLog 可以计算出这个集合的近似基数:
近似基数并非集和的实际基数, 它可能会比实际的基数大一点或者小一点, 但误差会在一个合理范围内.
因此, 那些不需要知道实际基数的程序就可以把这个近似基数当作集合的基数来使用.
HyperLogLog 的优点在于计算近似基础所需的内存并不会因为集和的大小而改变, 无论集和包含元素有多少个, HyperLogLog 进行计算所需的内存总是固定的, 无论集和包含元素多少个, HyperLogLog 进行计算所需的内存总是固定的, 并且是非常少的.
PFADD: 对集和元素进行计数
PFADD hyperloglog element [element ...]
根据给定元素是否已经进行过计数, PFADD 命令可能返回0, 也可能返回1:"><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/posts/redis-hyperloglog/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://starslayerx.github.io/posts/redis-hyperloglog/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/posts/redis-hyperloglog/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Redis HyperLogLog"><meta property="og:description" content="之前曾介绍过使用 Redis 集和构建唯一计数器, 并将这个计数器用于计算网站的唯一房客 IP. 虽然使用集和实现唯一计数器可以实现该功能, 但这个方法有一个明显的缺陷: 随着被计数元素的不断增多, 唯一计数器占用的内存也会越来越大; 计数器越多, 他们的体积越大, 这一情况就会越严峻.
以计算唯一访客 IP 为例:
存储一个 IPv4 格式的 IP 地址最多需要 15 个字节 根据网站的规模不同, 每天出现的唯一 IP 可能会有数十万、数百万个 为了记录网站在不同时期的访客, 并进行相关的数据分析, 网站可能需要次序地记录每天的唯一访客 IP 数量 综上, 如果一个网站想要长时间记录访客 IP, 就必须创建多个唯一计数器. 如果访客比较多, 那么它创建的每个唯一计数器都将包含大量元素, 并因此占用相当一部分内存.
为了高效解决计算机唯一访客 IP 数量这类问题, 其中一种方法就是 HyperLogLog.
HyperLogLog 简介 HyperLogLog 是一个专门为了计算集和的基数而创建的概率算法, 对于一个给定的集和, HyperLogLog 可以计算出这个集合的近似基数: 近似基数并非集和的实际基数, 它可能会比实际的基数大一点或者小一点, 但误差会在一个合理范围内. 因此, 那些不需要知道实际基数的程序就可以把这个近似基数当作集合的基数来使用.
HyperLogLog 的优点在于计算近似基础所需的内存并不会因为集和的大小而改变, 无论集和包含元素有多少个, HyperLogLog 进行计算所需的内存总是固定的, 无论集和包含元素多少个, HyperLogLog 进行计算所需的内存总是固定的, 并且是非常少的.
PFADD: 对集和元素进行计数 PFADD hyperloglog element [element ...] 根据给定元素是否已经进行过计数, PFADD 命令可能返回0, 也可能返回1:"><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-18T08:00:00+08:00"><meta property="article:modified_time" content="2025-09-18T08:00:00+08:00"><meta property="article:tag" content="Redis"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Redis HyperLogLog"><meta name=twitter:description content="之前曾介绍过使用 Redis 集和构建唯一计数器, 并将这个计数器用于计算网站的唯一房客 IP.
虽然使用集和实现唯一计数器可以实现该功能, 但这个方法有一个明显的缺陷:
随着被计数元素的不断增多, 唯一计数器占用的内存也会越来越大; 计数器越多, 他们的体积越大, 这一情况就会越严峻.
以计算唯一访客 IP 为例:

存储一个 IPv4 格式的 IP 地址最多需要 15 个字节
根据网站的规模不同, 每天出现的唯一 IP 可能会有数十万、数百万个
为了记录网站在不同时期的访客, 并进行相关的数据分析, 网站可能需要次序地记录每天的唯一访客 IP 数量

综上, 如果一个网站想要长时间记录访客 IP, 就必须创建多个唯一计数器. 如果访客比较多, 那么它创建的每个唯一计数器都将包含大量元素, 并因此占用相当一部分内存.
为了高效解决计算机唯一访客 IP 数量这类问题, 其中一种方法就是 HyperLogLog.
HyperLogLog 简介
HyperLogLog 是一个专门为了计算集和的基数而创建的概率算法, 对于一个给定的集和, HyperLogLog 可以计算出这个集合的近似基数:
近似基数并非集和的实际基数, 它可能会比实际的基数大一点或者小一点, 但误差会在一个合理范围内.
因此, 那些不需要知道实际基数的程序就可以把这个近似基数当作集合的基数来使用.
HyperLogLog 的优点在于计算近似基础所需的内存并不会因为集和的大小而改变, 无论集和包含元素有多少个, HyperLogLog 进行计算所需的内存总是固定的, 无论集和包含元素多少个, HyperLogLog 进行计算所需的内存总是固定的, 并且是非常少的.
PFADD: 对集和元素进行计数
PFADD hyperloglog element [element ...]
根据给定元素是否已经进行过计数, PFADD 命令可能返回0, 也可能返回1:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://starslayerx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Redis HyperLogLog","item":"https://starslayerx.github.io/posts/redis-hyperloglog/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis HyperLogLog","name":"Redis HyperLogLog","description":"之前曾介绍过使用 Redis 集和构建唯一计数器, 并将这个计数器用于计算网站的唯一房客 IP. 虽然使用集和实现唯一计数器可以实现该功能, 但这个方法有一个明显的缺陷: 随着被计数元素的不断增多, 唯一计数器占用的内存也会越来越大; 计数器越多, 他们的体积越大, 这一情况就会越严峻.\n以计算唯一访客 IP 为例:\n存储一个 IPv4 格式的 IP 地址最多需要 15 个字节 根据网站的规模不同, 每天出现的唯一 IP 可能会有数十万、数百万个 为了记录网站在不同时期的访客, 并进行相关的数据分析, 网站可能需要次序地记录每天的唯一访客 IP 数量 综上, 如果一个网站想要长时间记录访客 IP, 就必须创建多个唯一计数器. 如果访客比较多, 那么它创建的每个唯一计数器都将包含大量元素, 并因此占用相当一部分内存.\n为了高效解决计算机唯一访客 IP 数量这类问题, 其中一种方法就是 HyperLogLog.\nHyperLogLog 简介 HyperLogLog 是一个专门为了计算集和的基数而创建的概率算法, 对于一个给定的集和, HyperLogLog 可以计算出这个集合的近似基数: 近似基数并非集和的实际基数, 它可能会比实际的基数大一点或者小一点, 但误差会在一个合理范围内. 因此, 那些不需要知道实际基数的程序就可以把这个近似基数当作集合的基数来使用.\nHyperLogLog 的优点在于计算近似基础所需的内存并不会因为集和的大小而改变, 无论集和包含元素有多少个, HyperLogLog 进行计算所需的内存总是固定的, 无论集和包含元素多少个, HyperLogLog 进行计算所需的内存总是固定的, 并且是非常少的.\nPFADD: 对集和元素进行计数 PFADD hyperloglog element [element ...] 根据给定元素是否已经进行过计数, PFADD 命令可能返回0, 也可能返回1:\n","keywords":["Redis"],"articleBody":"之前曾介绍过使用 Redis 集和构建唯一计数器, 并将这个计数器用于计算网站的唯一房客 IP. 虽然使用集和实现唯一计数器可以实现该功能, 但这个方法有一个明显的缺陷: 随着被计数元素的不断增多, 唯一计数器占用的内存也会越来越大; 计数器越多, 他们的体积越大, 这一情况就会越严峻.\n以计算唯一访客 IP 为例:\n存储一个 IPv4 格式的 IP 地址最多需要 15 个字节 根据网站的规模不同, 每天出现的唯一 IP 可能会有数十万、数百万个 为了记录网站在不同时期的访客, 并进行相关的数据分析, 网站可能需要次序地记录每天的唯一访客 IP 数量 综上, 如果一个网站想要长时间记录访客 IP, 就必须创建多个唯一计数器. 如果访客比较多, 那么它创建的每个唯一计数器都将包含大量元素, 并因此占用相当一部分内存.\n为了高效解决计算机唯一访客 IP 数量这类问题, 其中一种方法就是 HyperLogLog.\nHyperLogLog 简介 HyperLogLog 是一个专门为了计算集和的基数而创建的概率算法, 对于一个给定的集和, HyperLogLog 可以计算出这个集合的近似基数: 近似基数并非集和的实际基数, 它可能会比实际的基数大一点或者小一点, 但误差会在一个合理范围内. 因此, 那些不需要知道实际基数的程序就可以把这个近似基数当作集合的基数来使用.\nHyperLogLog 的优点在于计算近似基础所需的内存并不会因为集和的大小而改变, 无论集和包含元素有多少个, HyperLogLog 进行计算所需的内存总是固定的, 无论集和包含元素多少个, HyperLogLog 进行计算所需的内存总是固定的, 并且是非常少的.\nPFADD: 对集和元素进行计数 PFADD hyperloglog element [element ...] 根据给定元素是否已经进行过计数, PFADD 命令可能返回0, 也可能返回1:\n如果给定的所有元素都已经计数, 那么 PFADD 命令返回 0, 表示 HyperLogLog 计算出是近似基数没有发生变化 如果给定的的元素中出现了至少一个没有过进行计数的元素, 导致 HyperLogLog 计算出的近似基数发生了变化, 那么 PFADD 命令返回 1 复杂度: O(N), N 为给定元素数量\nPFCOUNT: 返回集和的近似基数 PFCOUNT hyperloglog [hyperloglog ...] 使用 PFADD 命令对元素进行计数后, 用户可以通过执行 PFCOUNT 命令来获取 HyperLogLog 为集和计算出的近似基数.\n当用户给定的 HyperLogLog 不存在时, PFCOUNT 命令将返回 0 作为结果.\n当用户向 PFCOUNT 传入多个 HyperLogLog 时, PFCOUNT 命令将对所有给定的 HyperLogLog 执行并行计算, 然后返回并集计算出的近似基数.\nPFADD alphabets1 \"a\" \"b\" \"c\" PFADD alphabets2 \"c\" \"d\" \"e\" PFCOUNT alphabets1 alphabets2 \u003e (integer) 5 上面计算类似于\nPFADD temp-hyperloglog \"a\" \"b\" \"c\" \"c\" \"d\" \"e\" PFCOUNT temphyperloglog temp-hyperloglog \u003e (integer) 5 示例: 优化唯一计数器 from redis import Redis class UniqueCounter: def __init__(self, client, key): self.client = client self.key = key def count_in(self, item): \"\"\"对给定的元素进行计数\"\"\" self.client.pfadd(self.key, item) def get_result(self): \"\"\"返回计数器的值\"\"\" return self.client.pfcount(self.key) client = Redis(decode_responses=True) counter = UniqueCounter(client, 'unique-ip-counter') # 创建一个唯一 IP 计数器 counter.count_in('1.1.1.1') counter.count_in('2.2.2.2') counter.count_in('3.3.3.3') print(counter.get_result()) counter.count_in('3.3.3.3') print(counter.get_result()) 通过使用 HyperLogLog 实现的唯一计数器去取代集和实现的唯一计数器, 可以大副降低存储所需的内存.\n示例: 检测重复信息 在构建应用程序的过程中, 经常要处理广告等垃圾信息. 而发送者经常会使用不同的帐号, 发送相同的垃圾信息, 所有一种简单的方法就是找出重复 的信息: 如果两个用户发送了完全相同的信息, 那么这些信息很可能就是垃圾短信.\n判断两段信息是否相同并不是意见容易的事情, 如果使用一般的比较函数, 那复杂度就会很高: O(N*M), 其中 N 为信息的长度, M 为系统目前已有的信息数量.\n为了降低复杂度, 可以使用 HyperLogLog 来记录所有以发送的信息: 每当用户发送一条信息时, 程序就使用 PFADD 命令将这条信息添加到 HyperLogLog 中:\n如果命令返回 1, 说明这条信息未出现过 如果命令返回 0, 说明这条信息已出现过 由于 HyperLogLog 是概率算法, 所以即使信息长度非常长, HyperLogLog判断信息是否重复所需的时间也非常短.\nfrom redis import Redis class DuplicateChecker: def __init__(self, client, key): self.client = client self.key = key def is_duplicated(self, content): \"\"\"在信息重复时返回 True, 未重复时返回 False\"\"\" return self.client.pfadd(self.key, content) == 0 def unique_count(self): \"\"\"返回检测器已经检查过的非重复信息数量\"\"\" return self.client.pfcount(self.key) client = Redis(decode_responses=True) checker = DuplicateChecker(client, 'duplicate-message-checker') # 输入非重复信息 checker.is_duplicated(\"hello world!\") checker.is_duplicated(\"good morning!\") checker.is_duplicated(\"bye bye\") print(checker.unique_count()) checker.is_duplicated(\"hello world!\") PFMERGE: 计算多个 HyperLogLog 的并集 PFMERGE destination hyperloglog [hyperloglog ...] 该命令可以对多个给定的 HyperLogLog 执行并行计算, 然后把计算得出的并集 HyperLogLog 保存到指定的键中.\n如果指定的键已存在, 则会覆盖原有的键, 执行成功后返回 OK.\nHyperLogLog 并集计算的近似基数接近于所有给定 HyperLogLog 的被计数集合的并集基数.\nPFADD numbers1 128 256 512 PFADD numbers2 128 256 512 PFADD numbers3 128 512 1024 PFMERGE union-numbers numbers1 numbers2 numbers3 \u003e OK PFCOUNT union-numbers \u003e (integer) 4 PFCOUNT 与 PFMERGE PFCOUNT 命令在计算多个 HyperLogLog 的近似基数时会执行以下操作:\n在内部调用 PFMERGE 命令, 计算所有给定 HyperLogLog 的并集, 并将这个并集存储到一个临时的 HyperLogLog 中 对临时的 HyperLogLog 执行 PFCOUNT 命令, 得到它的近似基数 删除临时 HyperLogLog 向用户返回之前得到的近似基数 示例: 实现每周/月度/年度计数器 通过 PFMERGE 命令可以对多个 HyperLogLog 实现的唯一计数器执行并集计算, 从而实现每周/月度/年度计数器:\n通过对一周内每天的唯一访客 IP 计数器执行 PFMERGE 命令, 可以计算出那一周的唯一访客 IP 数量 通过对一个月每天的唯一访客 IP 计数器执行 PFMERGE 命令, 可以计数器那一个月的唯一访客 IP 数量 年度甚至更长时间的唯一访客 IP 数量也可以按照类似的方法计算 from redis import Redis class UniqueCounterMerger: def __init__(self, client): self.client = client def merge(self, destination, *hyperloglogs): self.client.pfmerge(destination, *hyperloglogs) client = Redis(decode_response=True) merger = UniqueCounterMerger(client) # 本周 7 天的计数器排名 counters = [ 'unique_ip_counter:8-10', 'unique_ip_counter:8-11', 'unique_ip_counter:8-12', 'unique_ip_counter:8-13', 'unique_ip_counter:8-14', 'unique_ip_counter:8-15', 'unique_ip_counter:8-16', ] # 计算并存储本周的唯一访客 IP 数量 merger.merger('unique_ip_counter::No_33_week', *counters) # 去本周的唯一访客 IP 数量 weekly_unique_visitors = client.pfcount('unique_ip_counter::No_33_week') print(f\"本周唯一访客 IP 数量: {weekly_unique_visitors}\") ","wordCount":"456","inLanguage":"en","image":"https://starslayerx.github.io/images/og-default.avif","datePublished":"2025-09-18T08:00:00+08:00","dateModified":"2025-09-18T08:00:00+08:00","author":{"@type":"Person","name":"Starslayerx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://starslayerx.github.io/posts/redis-hyperloglog/"},"publisher":{"@type":"Organization","name":"Starslayerx' Blog","logo":{"@type":"ImageObject","url":"https://starslayerx.github.io/favicon.svg"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Redis HyperLogLog</h1><div class=post-meta><span title='2025-09-18 08:00:00 +0800 +0800'>September 18, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>456 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#hyperloglog-简介>HyperLogLog 简介</a><ul><li><a href=#pfadd-对集和元素进行计数>PFADD: 对集和元素进行计数</a></li><li><a href=#pfcount-返回集和的近似基数>PFCOUNT: 返回集和的近似基数</a></li><li><a href=#示例-优化唯一计数器>示例: 优化唯一计数器</a></li><li><a href=#示例-检测重复信息>示例: 检测重复信息</a></li><li><a href=#pfmerge-计算多个-hyperloglog-的并集>PFMERGE: 计算多个 HyperLogLog 的并集</a><ul><li><a href=#pfcount-与-pfmerge>PFCOUNT 与 PFMERGE</a></li></ul></li><li><a href=#示例-实现每周月度年度计数器>示例: 实现每周/月度/年度计数器</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>之前曾介绍过使用 Redis 集和构建唯一计数器, 并将这个计数器用于计算网站的唯一房客 IP.
虽然使用集和实现唯一计数器可以实现该功能, 但这个方法有一个明显的缺陷:
随着被计数元素的不断增多, 唯一计数器占用的内存也会越来越大; 计数器越多, 他们的体积越大, 这一情况就会越严峻.</p><p>以计算唯一访客 IP 为例:</p><ul><li>存储一个 IPv4 格式的 IP 地址最多需要 15 个字节</li><li>根据网站的规模不同, 每天出现的唯一 IP 可能会有数十万、数百万个</li><li>为了记录网站在不同时期的访客, 并进行相关的数据分析, 网站可能需要次序地记录每天的唯一访客 IP 数量</li></ul><p>综上, 如果一个网站想要长时间记录访客 IP, 就必须创建多个唯一计数器. 如果访客比较多, 那么它创建的每个唯一计数器都将包含大量元素, 并因此占用相当一部分内存.</p><p>为了高效解决计算机唯一访客 IP 数量这类问题, 其中一种方法就是 HyperLogLog.</p><h2 id=hyperloglog-简介>HyperLogLog 简介<a hidden class=anchor aria-hidden=true href=#hyperloglog-简介>#</a></h2><p>HyperLogLog 是一个专门为了计算集和的基数而创建的概率算法, 对于一个给定的集和, HyperLogLog 可以计算出这个集合的近似基数:
近似基数并非集和的实际基数, 它可能会比实际的基数大一点或者小一点, 但误差会在一个合理范围内.
因此, 那些不需要知道实际基数的程序就可以把这个近似基数当作集合的基数来使用.</p><p>HyperLogLog 的优点在于计算近似基础所需的内存并不会因为集和的大小而改变, 无论集和包含元素有多少个, HyperLogLog 进行计算所需的内存总是固定的, 无论集和包含元素多少个, HyperLogLog 进行计算所需的内存总是固定的, 并且是非常少的.</p><h3 id=pfadd-对集和元素进行计数>PFADD: 对集和元素进行计数<a hidden class=anchor aria-hidden=true href=#pfadd-对集和元素进行计数>#</a></h3><pre tabindex=0><code class=language-Redis data-lang=Redis>PFADD hyperloglog element [element ...]
</code></pre><p>根据给定元素是否已经进行过计数, PFADD 命令可能返回0, 也可能返回1:</p><ul><li>如果给定的所有元素都已经计数, 那么 PFADD 命令返回 0, 表示 HyperLogLog 计算出是近似基数没有发生变化</li><li>如果给定的的元素中出现了至少一个没有过进行计数的元素, 导致 HyperLogLog 计算出的近似基数发生了变化, 那么 PFADD 命令返回 1</li></ul><p>复杂度: O(N), N 为给定元素数量</p><h3 id=pfcount-返回集和的近似基数>PFCOUNT: 返回集和的近似基数<a hidden class=anchor aria-hidden=true href=#pfcount-返回集和的近似基数>#</a></h3><pre tabindex=0><code class=language-Redis data-lang=Redis>PFCOUNT hyperloglog [hyperloglog ...]
</code></pre><p>使用 PFADD 命令对元素进行计数后, 用户可以通过执行 PFCOUNT 命令来获取 HyperLogLog 为集和计算出的近似基数.<br>当用户给定的 HyperLogLog 不存在时, PFCOUNT 命令将返回 0 作为结果.<br>当用户向 PFCOUNT 传入多个 HyperLogLog 时, PFCOUNT 命令将对所有给定的 HyperLogLog 执行并行计算, 然后返回并集计算出的近似基数.</p><pre tabindex=0><code class=language-Redis data-lang=Redis>PFADD alphabets1 &#34;a&#34; &#34;b&#34; &#34;c&#34;
PFADD alphabets2 &#34;c&#34; &#34;d&#34; &#34;e&#34;
PFCOUNT alphabets1 alphabets2

&gt; (integer) 5
</code></pre><p>上面计算类似于</p><pre tabindex=0><code class=language-Redis data-lang=Redis>PFADD temp-hyperloglog &#34;a&#34; &#34;b&#34; &#34;c&#34; &#34;c&#34; &#34;d&#34; &#34;e&#34;
PFCOUNT temphyperloglog temp-hyperloglog

&gt; (integer) 5
</code></pre><h3 id=示例-优化唯一计数器>示例: 优化唯一计数器<a hidden class=anchor aria-hidden=true href=#示例-优化唯一计数器>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>redis</span> <span class=kn>import</span> <span class=n>Redis</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UniqueCounter</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>client</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>client</span> <span class=o>=</span> <span class=n>client</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>key</span> <span class=o>=</span> <span class=n>key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>count_in</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;对给定的元素进行计数&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>pfadd</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>key</span><span class=p>,</span> <span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_result</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;返回计数器的值&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>pfcount</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>client</span> <span class=o>=</span> <span class=n>Redis</span><span class=p>(</span><span class=n>decode_responses</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>counter</span> <span class=o>=</span> <span class=n>UniqueCounter</span><span class=p>(</span><span class=n>client</span><span class=p>,</span> <span class=s1>&#39;unique-ip-counter&#39;</span><span class=p>)</span> <span class=c1># 创建一个唯一 IP 计数器</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>counter</span><span class=o>.</span><span class=n>count_in</span><span class=p>(</span><span class=s1>&#39;1.1.1.1&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>counter</span><span class=o>.</span><span class=n>count_in</span><span class=p>(</span><span class=s1>&#39;2.2.2.2&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>counter</span><span class=o>.</span><span class=n>count_in</span><span class=p>(</span><span class=s1>&#39;3.3.3.3&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>counter</span><span class=o>.</span><span class=n>get_result</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>counter</span><span class=o>.</span><span class=n>count_in</span><span class=p>(</span><span class=s1>&#39;3.3.3.3&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>counter</span><span class=o>.</span><span class=n>get_result</span><span class=p>())</span>
</span></span></code></pre></div><p>通过使用 HyperLogLog 实现的唯一计数器去取代集和实现的唯一计数器, 可以大副降低存储所需的内存.</p><h3 id=示例-检测重复信息>示例: 检测重复信息<a hidden class=anchor aria-hidden=true href=#示例-检测重复信息>#</a></h3><p>在构建应用程序的过程中, 经常要处理广告等垃圾信息. 而发送者经常会使用不同的帐号, 发送相同的垃圾信息, 所有一种简单的方法就是找出重复 的信息: 如果两个用户发送了完全相同的信息, 那么这些信息很可能就是垃圾短信.</p><p>判断两段信息是否相同并不是意见容易的事情, 如果使用一般的比较函数, 那复杂度就会很高: O(N*M), 其中 N 为信息的长度, M 为系统目前已有的信息数量.</p><p>为了降低复杂度, 可以使用 HyperLogLog 来记录所有以发送的信息: 每当用户发送一条信息时, 程序就使用 PFADD 命令将这条信息添加到 HyperLogLog 中:</p><ul><li>如果命令返回 1, 说明这条信息未出现过</li><li>如果命令返回 0, 说明这条信息已出现过</li></ul><p>由于 HyperLogLog 是概率算法, 所以即使信息长度非常长, HyperLogLog判断信息是否重复所需的时间也非常短.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>redis</span> <span class=kn>import</span> <span class=n>Redis</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DuplicateChecker</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>client</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>client</span> <span class=o>=</span> <span class=n>client</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>key</span> <span class=o>=</span> <span class=n>key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>is_duplicated</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>content</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;在信息重复时返回 True, 未重复时返回 False&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>pfadd</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>key</span><span class=p>,</span> <span class=n>content</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>unique_count</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;返回检测器已经检查过的非重复信息数量&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>pfcount</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>client</span> <span class=o>=</span> <span class=n>Redis</span><span class=p>(</span><span class=n>decode_responses</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>checker</span> <span class=o>=</span> <span class=n>DuplicateChecker</span><span class=p>(</span><span class=n>client</span><span class=p>,</span> <span class=s1>&#39;duplicate-message-checker&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 输入非重复信息</span>
</span></span><span class=line><span class=cl><span class=n>checker</span><span class=o>.</span><span class=n>is_duplicated</span><span class=p>(</span><span class=s2>&#34;hello world!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>checker</span><span class=o>.</span><span class=n>is_duplicated</span><span class=p>(</span><span class=s2>&#34;good morning!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>checker</span><span class=o>.</span><span class=n>is_duplicated</span><span class=p>(</span><span class=s2>&#34;bye bye&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>checker</span><span class=o>.</span><span class=n>unique_count</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>checker</span><span class=o>.</span><span class=n>is_duplicated</span><span class=p>(</span><span class=s2>&#34;hello world!&#34;</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=pfmerge-计算多个-hyperloglog-的并集>PFMERGE: 计算多个 HyperLogLog 的并集<a hidden class=anchor aria-hidden=true href=#pfmerge-计算多个-hyperloglog-的并集>#</a></h3><pre tabindex=0><code class=language-Redis data-lang=Redis>PFMERGE destination hyperloglog [hyperloglog ...]
</code></pre><p>该命令可以对多个给定的 HyperLogLog 执行并行计算, 然后把计算得出的并集 HyperLogLog 保存到指定的键中.<br>如果指定的键已存在, 则会覆盖原有的键, 执行成功后返回 OK.<br>HyperLogLog 并集计算的近似基数接近于所有给定 HyperLogLog 的被计数集合的并集基数.</p><pre tabindex=0><code class=language-Redis data-lang=Redis>PFADD numbers1 128 256 512
PFADD numbers2 128 256 512
PFADD numbers3 128 512 1024
PFMERGE union-numbers numbers1 numbers2 numbers3

&gt; OK

PFCOUNT union-numbers
&gt; (integer) 4
</code></pre><h4 id=pfcount-与-pfmerge>PFCOUNT 与 PFMERGE<a hidden class=anchor aria-hidden=true href=#pfcount-与-pfmerge>#</a></h4><p><strong>PFCOUNT</strong> 命令在计算多个 HyperLogLog 的近似基数时会执行以下操作:</p><ol><li>在内部调用 PFMERGE 命令, 计算所有给定 HyperLogLog 的并集, 并将这个并集存储到一个临时的 HyperLogLog 中</li><li>对临时的 HyperLogLog 执行 PFCOUNT 命令, 得到它的近似基数</li><li>删除临时 HyperLogLog</li><li>向用户返回之前得到的近似基数</li></ol><h3 id=示例-实现每周月度年度计数器>示例: 实现每周/月度/年度计数器<a hidden class=anchor aria-hidden=true href=#示例-实现每周月度年度计数器>#</a></h3><p>通过 PFMERGE 命令可以对多个 HyperLogLog 实现的唯一计数器执行并集计算, 从而实现每周/月度/年度计数器:</p><ul><li>通过对一周内每天的唯一访客 IP 计数器执行 PFMERGE 命令, 可以计算出那一周的唯一访客 IP 数量</li><li>通过对一个月每天的唯一访客 IP 计数器执行 PFMERGE 命令, 可以计数器那一个月的唯一访客 IP 数量</li><li>年度甚至更长时间的唯一访客 IP 数量也可以按照类似的方法计算</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>redis</span> <span class=kn>import</span> <span class=n>Redis</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UniqueCounterMerger</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>client</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>client</span> <span class=o>=</span> <span class=n>client</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>destination</span><span class=p>,</span> <span class=o>*</span><span class=n>hyperloglogs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>client</span><span class=o>.</span><span class=n>pfmerge</span><span class=p>(</span><span class=n>destination</span><span class=p>,</span> <span class=o>*</span><span class=n>hyperloglogs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>client</span> <span class=o>=</span> <span class=n>Redis</span><span class=p>(</span><span class=n>decode_response</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>merger</span> <span class=o>=</span> <span class=n>UniqueCounterMerger</span><span class=p>(</span><span class=n>client</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 本周 7 天的计数器排名</span>
</span></span><span class=line><span class=cl><span class=n>counters</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;unique_ip_counter:8-10&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;unique_ip_counter:8-11&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;unique_ip_counter:8-12&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;unique_ip_counter:8-13&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;unique_ip_counter:8-14&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;unique_ip_counter:8-15&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;unique_ip_counter:8-16&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 计算并存储本周的唯一访客 IP 数量</span>
</span></span><span class=line><span class=cl><span class=n>merger</span><span class=o>.</span><span class=n>merger</span><span class=p>(</span><span class=s1>&#39;unique_ip_counter::No_33_week&#39;</span><span class=p>,</span> <span class=o>*</span><span class=n>counters</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 去本周的唯一访客 IP 数量</span>
</span></span><span class=line><span class=cl><span class=n>weekly_unique_visitors</span> <span class=o>=</span> <span class=n>client</span><span class=o>.</span><span class=n>pfcount</span><span class=p>(</span><span class=s1>&#39;unique_ip_counter::No_33_week&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;本周唯一访客 IP 数量: </span><span class=si>{</span><span class=n>weekly_unique_visitors</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://starslayerx.github.io/tags/redis/>Redis</a></li></ul><nav class=paginav><a class=prev href=https://starslayerx.github.io/posts/redis-bitmap/><span class=title>« Prev</span><br><span>Redis Bitmap</span>
</a><a class=next href=https://starslayerx.github.io/posts/morden-javascript-tutorial-chapter-2-fundamentals-06~10/><span class=title>Next »</span><br><span>Morden Javascript Tutorial Chapter 2 - Fundamentals: 06~10</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Redis HyperLogLog on x" href="https://x.com/intent/tweet/?text=Redis%20HyperLogLog&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fredis-hyperloglog%2f&amp;hashtags=Redis"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Redis HyperLogLog on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fredis-hyperloglog%2f&amp;title=Redis%20HyperLogLog&amp;summary=Redis%20HyperLogLog&amp;source=https%3a%2f%2fstarslayerx.github.io%2fposts%2fredis-hyperloglog%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Redis HyperLogLog on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fredis-hyperloglog%2f&title=Redis%20HyperLogLog"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Redis HyperLogLog on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fredis-hyperloglog%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Redis HyperLogLog on whatsapp" href="https://api.whatsapp.com/send?text=Redis%20HyperLogLog%20-%20https%3a%2f%2fstarslayerx.github.io%2fposts%2fredis-hyperloglog%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Redis HyperLogLog on telegram" href="https://telegram.me/share/url?text=Redis%20HyperLogLog&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fredis-hyperloglog%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Redis HyperLogLog on ycombinator" href="https://news.ycombinator.com/submitlink?t=Redis%20HyperLogLog&u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fredis-hyperloglog%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>