<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python Asyncio 01: Getting to know asyncio | Starslayerx' Blog</title><meta name=keywords content="Python,Asyncio"><meta name=description content="Python asyncio 基础篇
本篇包含

asyncio 是什么以及如何使用它
concurrency 并发、parallelism 并行、threads 线程和 processes 进程
GIL (global interpreter lock) 全局解释器锁和其带来的并发跳转
非阻塞 sockets 如何只通过一个线程实现并发
基于事件循环 (event-loop-based) 并发的基本原理

异步编程 (asynchronous programming) 意思是可以在主程序之外，额外运行一个特定的长时运行的任务。
一个 coroutine 协程是一种方法，协程是一种方法，当遇到可能长时间运行的任务时，它可以暂停执行，并在任务完成后恢复执行。
asyncio 这个库的名称可能让人人为其只适合编写 I/O 操作，但实际上该库可以和 threading 和 multiprocessing 库结合使用。
基于这种 interoperability 互操作性，可以使用 async/await 关键字让工作流更加容易理解。
这意味着，asyncio 不仅适合 I/O 的并发，也可以在 CPU 密集操作中使用。
所谓的 I/O-bound 和 CPU-bound 是指限制程序运行更快的主要因素，这意味着如果增加该方面的性能，程序就能够在更短的时间内完成。
下面是一些例子

I/O 密集操作：网络请求、文件读取
CPU 密集操作：循环遍历文件夹、计算 pi

import requests

response = requests.get('https://www.example.com')  # 1
items = response.headers.items()
headers = [f'{key}: {headers}' for key, header in items]  # 2
formatted_headers = '\n'.join(headers)  # 3
with open('headers.txt', 'w') as file:  # 4
    file.write(formatted_headers)

I/O-bound 网络请求
CPU-bound 响应处理
CPU-bound 字符串拼接
I/O-bound 写入磁盘

Concurrency 并发 和 Parallelism 并行的区别这里就不多说了。"><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/posts/python-asyncio-01-getting-to-know-asyncio/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://starslayerx.github.io/posts/python-asyncio-01-getting-to-know-asyncio/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/posts/python-asyncio-01-getting-to-know-asyncio/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Python Asyncio 01: Getting to know asyncio"><meta property="og:description" content="Python asyncio 基础篇 本篇包含
asyncio 是什么以及如何使用它 concurrency 并发、parallelism 并行、threads 线程和 processes 进程 GIL (global interpreter lock) 全局解释器锁和其带来的并发跳转 非阻塞 sockets 如何只通过一个线程实现并发 基于事件循环 (event-loop-based) 并发的基本原理 异步编程 (asynchronous programming) 意思是可以在主程序之外，额外运行一个特定的长时运行的任务。
一个 coroutine 协程是一种方法，协程是一种方法，当遇到可能长时间运行的任务时，它可以暂停执行，并在任务完成后恢复执行。
asyncio 这个库的名称可能让人人为其只适合编写 I/O 操作，但实际上该库可以和 threading 和 multiprocessing 库结合使用。 基于这种 interoperability 互操作性，可以使用 async/await 关键字让工作流更加容易理解。 这意味着，asyncio 不仅适合 I/O 的并发，也可以在 CPU 密集操作中使用。
所谓的 I/O-bound 和 CPU-bound 是指限制程序运行更快的主要因素，这意味着如果增加该方面的性能，程序就能够在更短的时间内完成。
下面是一些例子
I/O 密集操作：网络请求、文件读取 CPU 密集操作：循环遍历文件夹、计算 pi import requests response = requests.get('https://www.example.com') # 1 items = response.headers.items() headers = [f'{key}: {headers}' for key, header in items] # 2 formatted_headers = '\n'.join(headers) # 3 with open('headers.txt', 'w') as file: # 4 file.write(formatted_headers) I/O-bound 网络请求 CPU-bound 响应处理 CPU-bound 字符串拼接 I/O-bound 写入磁盘 Concurrency 并发 和 Parallelism 并行的区别这里就不多说了。"><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-19T08:00:00+08:00"><meta property="article:modified_time" content="2025-11-19T08:00:00+08:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Asyncio"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Python Asyncio 01: Getting to know asyncio"><meta name=twitter:description content="Python asyncio 基础篇
本篇包含

asyncio 是什么以及如何使用它
concurrency 并发、parallelism 并行、threads 线程和 processes 进程
GIL (global interpreter lock) 全局解释器锁和其带来的并发跳转
非阻塞 sockets 如何只通过一个线程实现并发
基于事件循环 (event-loop-based) 并发的基本原理

异步编程 (asynchronous programming) 意思是可以在主程序之外，额外运行一个特定的长时运行的任务。
一个 coroutine 协程是一种方法，协程是一种方法，当遇到可能长时间运行的任务时，它可以暂停执行，并在任务完成后恢复执行。
asyncio 这个库的名称可能让人人为其只适合编写 I/O 操作，但实际上该库可以和 threading 和 multiprocessing 库结合使用。
基于这种 interoperability 互操作性，可以使用 async/await 关键字让工作流更加容易理解。
这意味着，asyncio 不仅适合 I/O 的并发，也可以在 CPU 密集操作中使用。
所谓的 I/O-bound 和 CPU-bound 是指限制程序运行更快的主要因素，这意味着如果增加该方面的性能，程序就能够在更短的时间内完成。
下面是一些例子

I/O 密集操作：网络请求、文件读取
CPU 密集操作：循环遍历文件夹、计算 pi

import requests

response = requests.get('https://www.example.com')  # 1
items = response.headers.items()
headers = [f'{key}: {headers}' for key, header in items]  # 2
formatted_headers = '\n'.join(headers)  # 3
with open('headers.txt', 'w') as file:  # 4
    file.write(formatted_headers)

I/O-bound 网络请求
CPU-bound 响应处理
CPU-bound 字符串拼接
I/O-bound 写入磁盘

Concurrency 并发 和 Parallelism 并行的区别这里就不多说了。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://starslayerx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python Asyncio 01: Getting to know asyncio","item":"https://starslayerx.github.io/posts/python-asyncio-01-getting-to-know-asyncio/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python Asyncio 01: Getting to know asyncio","name":"Python Asyncio 01: Getting to know asyncio","description":"Python asyncio 基础篇 本篇包含\nasyncio 是什么以及如何使用它 concurrency 并发、parallelism 并行、threads 线程和 processes 进程 GIL (global interpreter lock) 全局解释器锁和其带来的并发跳转 非阻塞 sockets 如何只通过一个线程实现并发 基于事件循环 (event-loop-based) 并发的基本原理 异步编程 (asynchronous programming) 意思是可以在主程序之外，额外运行一个特定的长时运行的任务。\n一个 coroutine 协程是一种方法，协程是一种方法，当遇到可能长时间运行的任务时，它可以暂停执行，并在任务完成后恢复执行。\nasyncio 这个库的名称可能让人人为其只适合编写 I/O 操作，但实际上该库可以和 threading 和 multiprocessing 库结合使用。 基于这种 interoperability 互操作性，可以使用 async/await 关键字让工作流更加容易理解。 这意味着，asyncio 不仅适合 I/O 的并发，也可以在 CPU 密集操作中使用。\n所谓的 I/O-bound 和 CPU-bound 是指限制程序运行更快的主要因素，这意味着如果增加该方面的性能，程序就能够在更短的时间内完成。\n下面是一些例子\nI/O 密集操作：网络请求、文件读取 CPU 密集操作：循环遍历文件夹、计算 pi import requests response = requests.get(\u0026#39;https://www.example.com\u0026#39;) # 1 items = response.headers.items() headers = [f\u0026#39;{key}: {headers}\u0026#39; for key, header in items] # 2 formatted_headers = \u0026#39;\\n\u0026#39;.join(headers) # 3 with open(\u0026#39;headers.txt\u0026#39;, \u0026#39;w\u0026#39;) as file: # 4 file.write(formatted_headers) I/O-bound 网络请求 CPU-bound 响应处理 CPU-bound 字符串拼接 I/O-bound 写入磁盘 Concurrency 并发 和 Parallelism 并行的区别这里就不多说了。\n","keywords":["Python","Asyncio"],"articleBody":"Python asyncio 基础篇 本篇包含\nasyncio 是什么以及如何使用它 concurrency 并发、parallelism 并行、threads 线程和 processes 进程 GIL (global interpreter lock) 全局解释器锁和其带来的并发跳转 非阻塞 sockets 如何只通过一个线程实现并发 基于事件循环 (event-loop-based) 并发的基本原理 异步编程 (asynchronous programming) 意思是可以在主程序之外，额外运行一个特定的长时运行的任务。\n一个 coroutine 协程是一种方法，协程是一种方法，当遇到可能长时间运行的任务时，它可以暂停执行，并在任务完成后恢复执行。\nasyncio 这个库的名称可能让人人为其只适合编写 I/O 操作，但实际上该库可以和 threading 和 multiprocessing 库结合使用。 基于这种 interoperability 互操作性，可以使用 async/await 关键字让工作流更加容易理解。 这意味着，asyncio 不仅适合 I/O 的并发，也可以在 CPU 密集操作中使用。\n所谓的 I/O-bound 和 CPU-bound 是指限制程序运行更快的主要因素，这意味着如果增加该方面的性能，程序就能够在更短的时间内完成。\n下面是一些例子\nI/O 密集操作：网络请求、文件读取 CPU 密集操作：循环遍历文件夹、计算 pi import requests response = requests.get('https://www.example.com') # 1 items = response.headers.items() headers = [f'{key}: {headers}' for key, header in items] # 2 formatted_headers = '\\n'.join(headers) # 3 with open('headers.txt', 'w') as file: # 4 file.write(formatted_headers) I/O-bound 网络请求 CPU-bound 响应处理 CPU-bound 字符串拼接 I/O-bound 写入磁盘 Concurrency 并发 和 Parallelism 并行的区别这里就不多说了。\nMultitasking 分为 preemptive multitasking 抢占式多任务处理 和 cooperative multitasking 协作式多任务处理。\nPreemptive Multitasking\n在抢占式多任务处理中，通过时间片轮转 (time slicing) 进程，让操作系统来决定执行哪些任务切换。 当操作系统在不同任务之间切换的时候，我们称其为抢占 (preempting)。 该机制底层如何工作取决于操作系统，这主要通过多进程或多线程实现\nCoorperative Multitasking\n在协作式多任务处理中，不让操作系统决定何时切换任务，而是通过明确的编码来指明何时可以切换到其他任务上。 应用任务运行一个协作模型，显示地说“我要暂停这个任务一会儿，执行别的任务去吧”。\n协作式的优势：首先协作式资源消耗更低，当操作系统需要在进程或线程间切换的时候，会有一个上下文切换的过程。 第二个是粒度，操作系统切换任务的时间点可能并非最优的，当并发处理的时候就有了更多控制权，可以在正确的时间切换任务。\nProcess 进程 一个进程有独立的内存空间，且其他应用不能访问。 一台机器可以运行多个进程，如果 CPU 是多核的，那么可以同时运行多个进程。\nThread 线程 线程是操作系统的最小管理单元，可以看作是一个轻量的进程。 它们没有进程那样的独立内存空间，相反，线程共享进程创建的内存空间。\n线程是和创建他们的进程相关联的，进程至少会有一个线程，一般称为主线程 main thread。 进程还可以创建其他线程，一般称为 worker 或 background threads。 这些线程可以和主线程并发运行，操作系统也可以在时间片(time slicing)轮转时切换他们。\n当启动一个 Python 应用的时候，我们会创建一个进程和一个主线程来负责运行 Python 应用。\nimport os import threading print(f\"Python process running with process id: {os.getpid()}\") total_threads = threading.active_count() thread_name = threading.current_thread().name print(f\"Python is currently running: {total_threads} thread(s).\") print(f\"The current thread is {thread_name}\") 输出为\nPython process running with process id: 62973 Python is currently running: 1 thread(s). The current thread is MainThread 多线程 Python 应用示例 import threading def hello_from_thread(): \"\"\"Print current thread name.\"\"\" print(f\"Hello from thread {threading.current_thread()}!\") # 显示创建的 thread (not main thread) hello_thread = threading.Thread(target=hello_from_thread) hello_thread.start() # start thread total_threads = threading.active_count() thread_name = threading.current_thread().name print(f\"Python is currently running {total_threads} thread(s)\") print(f\"The current thread is {thread_name}\") hello_thread.join() # pause untill started and completed 输出为\nHello from thread ! Python is currently running 2 thread(s) The current thread is MainThread 要注意，运行上面代码可能会看到线程中输出 hello 的内容，并且看到 “Python is currently runnig 2 thread(s)” 在统一行输出两次。 这里一种 race condition 竟态条件，多线程是许多编程语言的实现并发的一种方式，但由于 GIL 的限制，python 的多线程只对 I/O-bound 类型有效。\n此外，还可以使用多进程，即 multiprocessing，一个父进程会创建子进程并管理这些进程，然后将工作内存分发给这些子进程。 multiprocessing 的 API 类似 threading，首先创建一个 target function，然后调用 start 方法执行，最后 join 等待运行完成。\nimport os import multiprocessing def hello_from_process(): print(f\"Hello from child process {os.getpid()}!\") if __name__ == \"__main__\": hello_process = multiprocessing.Process(target=hello_from_process) hello_process.start() print(f\"Hello from parent process {os.getpid()}\") hello_process.join() 输出为\nHello from parent process 35718 Hello from child process 35720! 多进程尤其适合 CPU 密集任务。\nGlobal interpreter lock 全局解释器锁会使得 python 进程只能同时有一个线程运行 python 代码。\n全局解释器存在的原因是由于 CPython 的内存管理方式，在 CPython 中内存主要通过引用计数 (reference counting) 的方式管理。 引用计数的工作原理是跟踪当前哪些程序需要访问特定的 Python 对象，如整数、字典或列表。\n这里的冲突是 CPython 多线程不是线程安全的，如果有多余两个线程同时修改同一个变量，则该变量的状态将变得未知。 当两个线程访问同一个 Python 对象的时候会产生竟态条件，最终可能导致应用崩溃。\n这是否意味着在 Python 中无法利用多线程的性能优势了呢？ 实际上，对于 I/O 任务仍然可以通过多线程加速（在一些特殊情况下有一些 cpu 密集的例外可以多线程并发），来看下面的示例\nimport time import requests def read_example() -\u003e None: response = resuests.get(\"https://www.example.com\") print(response.status_code) sync_start = time.time() read_example() read_example() sync_end = time.time() print(f\"Running synchronously took {sync_end - sync_start:.4f} seconds.\") 应该会看到下面这样输出\n200 200 Running synchronously took 0.2066 seconds. 下面再编写一个多线程版本对比一下\nimport time import requests import threading def read_example() -\u003e None: response = requests.get(\"https://www.example.com\") print(response.status_code) thread_1 = threading.Thread(target=read_example) thread_2 = threading.Thread(target=read_example) thread_start = time.time() thread_1.start() thread_2.start() print(\"All threads running!\") thread_end = time.time() thread_1.join() thread_2.join() thread_end = time.time() print(f\"Running with threads took {thread_end - thread_start:.4f} seconds.\") 输出为\nAll threads running! 200 200 Running with threads took 0.0917 seconds. 这几乎有两倍的差距！ 答案藏在系统后台调用中，在这种情况下 I/O 会释放锁，因为网络请求是在操作系统层处理的。 这时，只有当收到数据返回为 Python 对象的时候才会重新获取锁。 换句话说，在 Java 或 C++ 这样语言中，这种情况下会并行执行，然而 Python 由于 GIL 的限制只能进行 I/O 类型的并发，同一时刻只能有一份 Python 代码在执行。\nasyncio and the GIL asyncio 利用 I/O 操作会释放 GIL 的特性，使得即使只有单个线程也能够实现并发。 当使用 asyncio 的时候会创建叫 coroutines 协程的对象，一个协程可以被看成是一个轻量级线程。\n这意味着 asyncio 并非绕过了 GIl，而是仍然受其限制。 如果我们有一个 cpu-bound 任务，我们仍然需要多进程来并发执行。\nHow single-threaded concurrency works 之所以可以实现单线程并发是因为在系统层面，I/O 操作可以被并发完成。 为了更好理解，先需要弄懂 sockets 如何工作，有其实非阻塞套接字 non-blocking sockets。\nsocket 本质上网络发送和接收数据的是底层抽象，这是数据在服务器之前传输的基础。 sockets 支持两个简本的操作：发送字节和接收字节。 可以将 sockets 类比为邮箱，你可以向邮箱中放入信封，收件人打开邮箱和你的邮件，根据右键里面内容，收件人可能会给你回信。\nsockets 默认是阻塞的，简单来说，这意味着当我们在等待服务器回复数据的时候，会暂停当前应用或阻塞直到收到数据。 但在操作系统层面，sockets 可以在非阻塞模式下运行，并可以执行即发即弃的读写操作，程序能够继续执行其他任务。 然后，会在操作系统层收到并处理字节。不是阻塞和等待数据返回，而是通过更加响应式的方式，让操作系统数据准备好后通知我们。\n在后台，这时通过不同的通知系统实现的，根据操作系统会有不同：\nkqueue - FreeBSD and MacOS epool - Linux IOCP (I/O complection port) - Windows 这些通知系统是 asyncio 实现的基础，Python 中一个最基础的事件循环 event loop 类似下面这样：\nfrom collections import deque messages = deque() while True: if messages: message = message.pop() process_message(message) 在 asyncio 中，事件循环里面保存的是 tasks 任务，而非消息。 当创建事件循环的时候，会创建一个空的任务队列。 事件循环的每一次迭代都会检查需要执行的任务，并逐个运行它们，直到某个任务遇到 I/O 操作。 这时候任务会被暂停，并且我们指示操作系统监控套接字，等待 I/O 完成，然后去运行下一个任务。 在每一次事件循环中，检查是否有任何 I/O 完成了。\n","wordCount":"587","inLanguage":"en","image":"https://starslayerx.github.io/images/og-default.avif","datePublished":"2025-11-19T08:00:00+08:00","dateModified":"2025-11-19T08:00:00+08:00","author":{"@type":"Person","name":"Starslayerx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://starslayerx.github.io/posts/python-asyncio-01-getting-to-know-asyncio/"},"publisher":{"@type":"Organization","name":"Starslayerx' Blog","logo":{"@type":"ImageObject","url":"https://starslayerx.github.io/favicon.svg"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Python Asyncio 01: Getting to know asyncio</h1><div class=post-meta><span title='2025-11-19 08:00:00 +0800 +0800'>November 19, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>587 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#python-asyncio-基础篇>Python asyncio 基础篇</a><ul><li><a href=#process-进程>Process 进程</a></li><li><a href=#thread-线程>Thread 线程</a></li><li><a href=#global-interpreter-lock>Global interpreter lock</a></li><li><a href=#asyncio-and-the-gil>asyncio and the GIL</a></li><li><a href=#how-single-threaded-concurrency-works>How single-threaded concurrency works</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=python-asyncio-基础篇>Python asyncio 基础篇<a hidden class=anchor aria-hidden=true href=#python-asyncio-基础篇>#</a></h2><p>本篇包含</p><ul><li>asyncio 是什么以及如何使用它</li><li>concurrency 并发、parallelism 并行、threads 线程和 processes 进程</li><li>GIL (global interpreter lock) 全局解释器锁和其带来的并发跳转</li><li>非阻塞 sockets 如何只通过一个线程实现并发</li><li>基于事件循环 (event-loop-based) 并发的基本原理</li></ul><p>异步编程 (asynchronous programming) 意思是可以在主程序之外，额外运行一个特定的长时运行的任务。</p><p>一个 coroutine 协程是一种方法，协程是一种方法，当遇到可能长时间运行的任务时，它可以暂停执行，并在任务完成后恢复执行。</p><p>asyncio 这个库的名称可能让人人为其只适合编写 I/O 操作，但实际上该库可以和 threading 和 multiprocessing 库结合使用。
基于这种 interoperability 互操作性，可以使用 async/await 关键字让工作流更加容易理解。
这意味着，asyncio 不仅适合 I/O 的并发，也可以在 CPU 密集操作中使用。</p><p>所谓的 I/O-bound 和 CPU-bound 是指限制程序运行更快的主要因素，这意味着如果增加该方面的性能，程序就能够在更短的时间内完成。</p><p>下面是一些例子</p><ul><li>I/O 密集操作：网络请求、文件读取</li><li>CPU 密集操作：循环遍历文件夹、计算 pi</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>requests</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>response</span> <span class=o>=</span> <span class=n>requests</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;https://www.example.com&#39;</span><span class=p>)</span>  <span class=c1># 1</span>
</span></span><span class=line><span class=cl><span class=n>items</span> <span class=o>=</span> <span class=n>response</span><span class=o>.</span><span class=n>headers</span><span class=o>.</span><span class=n>items</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>headers</span> <span class=o>=</span> <span class=p>[</span><span class=sa>f</span><span class=s1>&#39;</span><span class=si>{</span><span class=n>key</span><span class=si>}</span><span class=s1>: </span><span class=si>{</span><span class=n>headers</span><span class=si>}</span><span class=s1>&#39;</span> <span class=k>for</span> <span class=n>key</span><span class=p>,</span> <span class=n>header</span> <span class=ow>in</span> <span class=n>items</span><span class=p>]</span>  <span class=c1># 2</span>
</span></span><span class=line><span class=cl><span class=n>formatted_headers</span> <span class=o>=</span> <span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>headers</span><span class=p>)</span>  <span class=c1># 3</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s1>&#39;headers.txt&#39;</span><span class=p>,</span> <span class=s1>&#39;w&#39;</span><span class=p>)</span> <span class=k>as</span> <span class=n>file</span><span class=p>:</span>  <span class=c1># 4</span>
</span></span><span class=line><span class=cl>    <span class=n>file</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>formatted_headers</span><span class=p>)</span>
</span></span></code></pre></div><ol><li>I/O-bound 网络请求</li><li>CPU-bound 响应处理</li><li>CPU-bound 字符串拼接</li><li>I/O-bound 写入磁盘</li></ol><p>Concurrency 并发 和 Parallelism 并行的区别这里就不多说了。</p><p>Multitasking 分为 preemptive multitasking 抢占式多任务处理 和 cooperative multitasking 协作式多任务处理。</p><ul><li><p>Preemptive Multitasking</p><p>在抢占式多任务处理中，通过时间片轮转 (time slicing) 进程，让操作系统来决定执行哪些任务切换。
当操作系统在不同任务之间切换的时候，我们称其为抢占 (preempting)。
该机制底层如何工作取决于操作系统，这主要通过多进程或多线程实现</p></li><li><p>Coorperative Multitasking</p><p>在协作式多任务处理中，不让操作系统决定何时切换任务，而是通过明确的编码来指明何时可以切换到其他任务上。
应用任务运行一个协作模型，显示地说“我要暂停这个任务一会儿，执行别的任务去吧”。</p><p>协作式的优势：首先协作式资源消耗更低，当操作系统需要在进程或线程间切换的时候，会有一个上下文切换的过程。
第二个是粒度，操作系统切换任务的时间点可能并非最优的，当并发处理的时候就有了更多控制权，可以在正确的时间切换任务。</p></li></ul><h3 id=process-进程>Process 进程<a hidden class=anchor aria-hidden=true href=#process-进程>#</a></h3><p>一个进程有独立的内存空间，且其他应用不能访问。
一台机器可以运行多个进程，如果 CPU 是多核的，那么可以同时运行多个进程。</p><h3 id=thread-线程>Thread 线程<a hidden class=anchor aria-hidden=true href=#thread-线程>#</a></h3><p>线程是操作系统的最小管理单元，可以看作是一个轻量的进程。
它们没有进程那样的独立内存空间，相反，线程共享进程创建的内存空间。</p><p>线程是和创建他们的进程相关联的，进程至少会有一个线程，一般称为主线程 main thread。
进程还可以创建其他线程，一般称为 worker 或 background threads。
这些线程可以和主线程并发运行，操作系统也可以在时间片(time slicing)轮转时切换他们。</p><p>当启动一个 Python 应用的时候，我们会创建一个进程和一个主线程来负责运行 Python 应用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Python process running with process id: </span><span class=si>{</span><span class=n>os</span><span class=o>.</span><span class=n>getpid</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>total_threads</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>active_count</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>thread_name</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>current_thread</span><span class=p>()</span><span class=o>.</span><span class=n>name</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Python is currently running: </span><span class=si>{</span><span class=n>total_threads</span><span class=si>}</span><span class=s2> thread(s).&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;The current thread is </span><span class=si>{</span><span class=n>thread_name</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>输出为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Python process running with process id: 62973
</span></span><span class=line><span class=cl>Python is currently running: 1 thread(s).
</span></span><span class=line><span class=cl>The current thread is MainThread
</span></span></code></pre></div><ul><li>多线程 Python 应用示例</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>hello_from_thread</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Print current thread name.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Hello from thread </span><span class=si>{</span><span class=n>threading</span><span class=o>.</span><span class=n>current_thread</span><span class=p>()</span><span class=si>}</span><span class=s2>!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示创建的 thread (not main thread)</span>
</span></span><span class=line><span class=cl><span class=n>hello_thread</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>hello_from_thread</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>hello_thread</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>  <span class=c1># start thread</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>total_threads</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>active_count</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>thread_name</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>current_thread</span><span class=p>()</span><span class=o>.</span><span class=n>name</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Python is currently running </span><span class=si>{</span><span class=n>total_threads</span><span class=si>}</span><span class=s2> thread(s)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;The current thread is </span><span class=si>{</span><span class=n>thread_name</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>hello_thread</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>  <span class=c1># pause untill started and completed</span>
</span></span></code></pre></div><p>输出为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Hello from thread &lt;Thread(Thread-1 (hello_from_thread), started 6111047680)&gt;!
</span></span><span class=line><span class=cl>Python is currently running 2 thread(s)
</span></span><span class=line><span class=cl>The current thread is MainThread
</span></span></code></pre></div><p>要注意，运行上面代码可能会看到线程中输出 hello 的内容，并且看到 &ldquo;Python is currently runnig 2 thread(s)&rdquo; 在统一行输出两次。
这里一种 race condition 竟态条件，多线程是许多编程语言的实现并发的一种方式，但由于 GIL 的限制，python 的多线程只对 I/O-bound 类型有效。</p><p>此外，还可以使用多进程，即 multiprocessing，一个父进程会创建子进程并管理这些进程，然后将工作内存分发给这些子进程。
multiprocessing 的 API 类似 threading，首先创建一个 target function，然后调用 start 方法执行，最后 join 等待运行完成。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>multiprocessing</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>hello_from_process</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Hello from child process </span><span class=si>{</span><span class=n>os</span><span class=o>.</span><span class=n>getpid</span><span class=p>()</span><span class=si>}</span><span class=s2>!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>hello_process</span> <span class=o>=</span> <span class=n>multiprocessing</span><span class=o>.</span><span class=n>Process</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>hello_from_process</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>hello_process</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Hello from parent process </span><span class=si>{</span><span class=n>os</span><span class=o>.</span><span class=n>getpid</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>hello_process</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></div><p>输出为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Hello from parent process 35718
</span></span><span class=line><span class=cl>Hello from child process 35720!
</span></span></code></pre></div><p>多进程尤其适合 CPU 密集任务。</p><h3 id=global-interpreter-lock>Global interpreter lock<a hidden class=anchor aria-hidden=true href=#global-interpreter-lock>#</a></h3><p>全局解释器锁会使得 python 进程只能同时有一个线程运行 python 代码。</p><p>全局解释器存在的原因是由于 CPython 的内存管理方式，在 CPython 中内存主要通过引用计数 (reference counting) 的方式管理。
引用计数的工作原理是跟踪当前哪些程序需要访问特定的 Python 对象，如整数、字典或列表。</p><p>这里的冲突是 CPython 多线程不是线程安全的，如果有多余两个线程同时修改同一个变量，则该变量的状态将变得未知。
当两个线程访问同一个 Python 对象的时候会产生竟态条件，最终可能导致应用崩溃。</p><p>这是否意味着在 Python 中无法利用多线程的性能优势了呢？
实际上，对于 I/O 任务仍然可以通过多线程加速（在一些特殊情况下有一些 cpu 密集的例外可以多线程并发），来看下面的示例</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>requests</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>read_example</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>response</span> <span class=o>=</span> <span class=n>resuests</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&#34;https://www.example.com&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>response</span><span class=o>.</span><span class=n>status_code</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sync_start</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>read_example</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>read_example</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>sync_end</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Running synchronously took </span><span class=si>{</span><span class=n>sync_end</span> <span class=o>-</span> <span class=n>sync_start</span><span class=si>:</span><span class=s2>.4f</span><span class=si>}</span><span class=s2> seconds.&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>应该会看到下面这样输出</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>200
</span></span><span class=line><span class=cl>200
</span></span><span class=line><span class=cl>Running synchronously took 0.2066 seconds.
</span></span></code></pre></div><p>下面再编写一个多线程版本对比一下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>requests</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>read_example</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>response</span> <span class=o>=</span> <span class=n>requests</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&#34;https://www.example.com&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>response</span><span class=o>.</span><span class=n>status_code</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>thread_1</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>read_example</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>thread_2</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>read_example</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>thread_start</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>thread_1</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>thread_2</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;All threads running!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>thread_end</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>thread_1</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>thread_2</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>thread_end</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Running with threads took </span><span class=si>{</span><span class=n>thread_end</span> <span class=o>-</span> <span class=n>thread_start</span><span class=si>:</span><span class=s2>.4f</span><span class=si>}</span><span class=s2> seconds.&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>输出为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>All threads running!
</span></span><span class=line><span class=cl>200
</span></span><span class=line><span class=cl>200
</span></span><span class=line><span class=cl>Running with threads took 0.0917 seconds.
</span></span></code></pre></div><p>这几乎有两倍的差距！
答案藏在系统后台调用中，在这种情况下 I/O 会释放锁，因为网络请求是在操作系统层处理的。
这时，只有当收到数据返回为 Python 对象的时候才会重新获取锁。
换句话说，在 Java 或 C++ 这样语言中，这种情况下会并行执行，然而 Python 由于 GIL 的限制只能进行 I/O 类型的并发，同一时刻只能有一份 Python 代码在执行。</p><h3 id=asyncio-and-the-gil>asyncio and the GIL<a hidden class=anchor aria-hidden=true href=#asyncio-and-the-gil>#</a></h3><p>asyncio 利用 I/O 操作会释放 GIL 的特性，使得即使只有单个线程也能够实现并发。
当使用 asyncio 的时候会创建叫 coroutines 协程的对象，一个协程可以被看成是一个轻量级线程。</p><p>这意味着 asyncio 并非绕过了 GIl，而是仍然受其限制。
如果我们有一个 cpu-bound 任务，我们仍然需要多进程来并发执行。</p><h3 id=how-single-threaded-concurrency-works>How single-threaded concurrency works<a hidden class=anchor aria-hidden=true href=#how-single-threaded-concurrency-works>#</a></h3><p>之所以可以实现单线程并发是因为在系统层面，I/O 操作可以被并发完成。
为了更好理解，先需要弄懂 sockets 如何工作，有其实非阻塞套接字 non-blocking sockets。</p><p>socket 本质上网络发送和接收数据的是底层抽象，这是数据在服务器之前传输的基础。
sockets 支持两个简本的操作：发送字节和接收字节。
可以将 sockets 类比为邮箱，你可以向邮箱中放入信封，收件人打开邮箱和你的邮件，根据右键里面内容，收件人可能会给你回信。</p><p>sockets 默认是阻塞的，简单来说，这意味着当我们在等待服务器回复数据的时候，会暂停当前应用或阻塞直到收到数据。
但在操作系统层面，sockets 可以在非阻塞模式下运行，并可以执行即发即弃的读写操作，程序能够继续执行其他任务。
然后，会在操作系统层收到并处理字节。不是阻塞和等待数据返回，而是通过更加响应式的方式，让操作系统数据准备好后通知我们。</p><p>在后台，这时通过不同的通知系统实现的，根据操作系统会有不同：</p><ul><li>kqueue - FreeBSD and MacOS</li><li>epool - Linux</li><li>IOCP (I/O complection port) - Windows</li></ul><p>这些通知系统是 asyncio 实现的基础，Python 中一个最基础的事件循环 event loop 类似下面这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>messages</span> <span class=o>=</span> <span class=n>deque</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>messages</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>message</span> <span class=o>=</span> <span class=n>message</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>process_message</span><span class=p>(</span><span class=n>message</span><span class=p>)</span>
</span></span></code></pre></div><p>在 asyncio 中，事件循环里面保存的是 tasks 任务，而非消息。
当创建事件循环的时候，会创建一个空的任务队列。
事件循环的每一次迭代都会检查需要执行的任务，并逐个运行它们，直到某个任务遇到 I/O 操作。
这时候任务会被暂停，并且我们指示操作系统监控套接字，等待 I/O 完成，然后去运行下一个任务。
在每一次事件循环中，检查是否有任何 I/O 完成了。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://starslayerx.github.io/tags/python/>Python</a></li><li><a href=https://starslayerx.github.io/tags/asyncio/>Asyncio</a></li></ul><nav class=paginav><a class=prev href=https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-1/><span class=title>« Prev</span><br><span>Python Asyncio 02: Asyncio Basics Part 1</span>
</a><a class=next href=https://starslayerx.github.io/posts/postgresql-03-psql-tool-introduction/><span class=title>Next »</span><br><span>Postgresql 03: psql Tool Introduction</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 01: Getting to know asyncio on x" href="https://x.com/intent/tweet/?text=Python%20Asyncio%2001%3a%20Getting%20to%20know%20asyncio&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-01-getting-to-know-asyncio%2f&amp;hashtags=Python%2cAsyncio"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 01: Getting to know asyncio on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-01-getting-to-know-asyncio%2f&amp;title=Python%20Asyncio%2001%3a%20Getting%20to%20know%20asyncio&amp;summary=Python%20Asyncio%2001%3a%20Getting%20to%20know%20asyncio&amp;source=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-01-getting-to-know-asyncio%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 01: Getting to know asyncio on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-01-getting-to-know-asyncio%2f&title=Python%20Asyncio%2001%3a%20Getting%20to%20know%20asyncio"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 01: Getting to know asyncio on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-01-getting-to-know-asyncio%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 01: Getting to know asyncio on whatsapp" href="https://api.whatsapp.com/send?text=Python%20Asyncio%2001%3a%20Getting%20to%20know%20asyncio%20-%20https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-01-getting-to-know-asyncio%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 01: Getting to know asyncio on telegram" href="https://telegram.me/share/url?text=Python%20Asyncio%2001%3a%20Getting%20to%20know%20asyncio&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-01-getting-to-know-asyncio%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 01: Getting to know asyncio on ycombinator" href="https://news.ycombinator.com/submitlink?t=Python%20Asyncio%2001%3a%20Getting%20to%20know%20asyncio&u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-01-getting-to-know-asyncio%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>