<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python Tricks Part 5: Functions | Starslayerx' Blog</title><meta name=keywords content="Python"><meta name=description content='函数是 Python 的基础模块，本篇会介绍 function application 函数定义、function application 函数应用、scoping rules 作用域规则、closures 闭包、decorators 装饰器和其他函数式编程特性。
特别关注不同的编程习惯 idioms、求值模型以及与函数相关的模式。
Default Arguments
你可以通过在函数定义处赋值的方式，给函数的参数添加默认值，例如：
def split(line, delimiter=","):
    statements
当一个函数定义了默认参数的时候，其右侧都必须是含有默认值的可选参数。
默认函数参数会在函数首次定义的时候调用一次，这有时会导致出乎意料的行为：
def func(x, items=[]):
    items.append(x)
    return items

func(1)  # returns [1]
func(2)  # returns [1, 2]
func(3)  # returns [1, 2, 3]
注意到每次掉都将函数默认值给修改了，要避免这种行为，使用 None 并进行检查：
def func(x, items=None):
    if not items:
        items = []
    items.append(x)
    return items
通常来说，建议只使用不可变对象作为默认参数值。
Variadic Arguments
可变参数
如果在最后一个参数前使用 asterisk 星号作为前缀，函数就可以接受可变数量的参数。
def product(first, *args):
    result = first
    for x in args:
        result = result *x
    return result

product(10, 20)      # 200
product(2, 3, 4, 5)  # 120
在这个例子中，所有的额外参数都作为一个元组放在 args 变量中。
对于元组，你可以使用序列的标准操作处理，如迭代、切片，解包等。
Keyword Arguments
函数参考可以通过显示命名每个参数并指定值来提供函数参数。
这被称为 keyword arguments 关键字参数，例如：'><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/posts/python-tricks-part-5-functions/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://starslayerx.github.io/posts/python-tricks-part-5-functions/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/posts/python-tricks-part-5-functions/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Python Tricks Part 5: Functions"><meta property="og:description" content='函数是 Python 的基础模块，本篇会介绍 function application 函数定义、function application 函数应用、scoping rules 作用域规则、closures 闭包、decorators 装饰器和其他函数式编程特性。 特别关注不同的编程习惯 idioms、求值模型以及与函数相关的模式。
Default Arguments 你可以通过在函数定义处赋值的方式，给函数的参数添加默认值，例如：
def split(line, delimiter=","): statements 当一个函数定义了默认参数的时候，其右侧都必须是含有默认值的可选参数。
默认函数参数会在函数首次定义的时候调用一次，这有时会导致出乎意料的行为：
def func(x, items=[]): items.append(x) return items func(1) # returns [1] func(2) # returns [1, 2] func(3) # returns [1, 2, 3] 注意到每次掉都将函数默认值给修改了，要避免这种行为，使用 None 并进行检查：
def func(x, items=None): if not items: items = [] items.append(x) return items 通常来说，建议只使用不可变对象作为默认参数值。
Variadic Arguments 可变参数
如果在最后一个参数前使用 asterisk 星号作为前缀，函数就可以接受可变数量的参数。
def product(first, *args): result = first for x in args: result = result *x return result product(10, 20) # 200 product(2, 3, 4, 5) # 120 在这个例子中，所有的额外参数都作为一个元组放在 args 变量中。 对于元组，你可以使用序列的标准操作处理，如迭代、切片，解包等。
Keyword Arguments 函数参考可以通过显示命名每个参数并指定值来提供函数参数。 这被称为 keyword arguments 关键字参数，例如：'><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-19T08:00:00+08:00"><meta property="article:modified_time" content="2025-12-19T08:00:00+08:00"><meta property="article:tag" content="Python"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Python Tricks Part 5: Functions"><meta name=twitter:description content='函数是 Python 的基础模块，本篇会介绍 function application 函数定义、function application 函数应用、scoping rules 作用域规则、closures 闭包、decorators 装饰器和其他函数式编程特性。
特别关注不同的编程习惯 idioms、求值模型以及与函数相关的模式。
Default Arguments
你可以通过在函数定义处赋值的方式，给函数的参数添加默认值，例如：
def split(line, delimiter=","):
    statements
当一个函数定义了默认参数的时候，其右侧都必须是含有默认值的可选参数。
默认函数参数会在函数首次定义的时候调用一次，这有时会导致出乎意料的行为：
def func(x, items=[]):
    items.append(x)
    return items

func(1)  # returns [1]
func(2)  # returns [1, 2]
func(3)  # returns [1, 2, 3]
注意到每次掉都将函数默认值给修改了，要避免这种行为，使用 None 并进行检查：
def func(x, items=None):
    if not items:
        items = []
    items.append(x)
    return items
通常来说，建议只使用不可变对象作为默认参数值。
Variadic Arguments
可变参数
如果在最后一个参数前使用 asterisk 星号作为前缀，函数就可以接受可变数量的参数。
def product(first, *args):
    result = first
    for x in args:
        result = result *x
    return result

product(10, 20)      # 200
product(2, 3, 4, 5)  # 120
在这个例子中，所有的额外参数都作为一个元组放在 args 变量中。
对于元组，你可以使用序列的标准操作处理，如迭代、切片，解包等。
Keyword Arguments
函数参考可以通过显示命名每个参数并指定值来提供函数参数。
这被称为 keyword arguments 关键字参数，例如：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://starslayerx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python Tricks Part 5: Functions","item":"https://starslayerx.github.io/posts/python-tricks-part-5-functions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python Tricks Part 5: Functions","name":"Python Tricks Part 5: Functions","description":"函数是 Python 的基础模块，本篇会介绍 function application 函数定义、function application 函数应用、scoping rules 作用域规则、closures 闭包、decorators 装饰器和其他函数式编程特性。 特别关注不同的编程习惯 idioms、求值模型以及与函数相关的模式。\nDefault Arguments 你可以通过在函数定义处赋值的方式，给函数的参数添加默认值，例如：\ndef split(line, delimiter=\u0026#34;,\u0026#34;): statements 当一个函数定义了默认参数的时候，其右侧都必须是含有默认值的可选参数。\n默认函数参数会在函数首次定义的时候调用一次，这有时会导致出乎意料的行为：\ndef func(x, items=[]): items.append(x) return items func(1) # returns [1] func(2) # returns [1, 2] func(3) # returns [1, 2, 3] 注意到每次掉都将函数默认值给修改了，要避免这种行为，使用 None 并进行检查：\ndef func(x, items=None): if not items: items = [] items.append(x) return items 通常来说，建议只使用不可变对象作为默认参数值。\nVariadic Arguments 可变参数\n如果在最后一个参数前使用 asterisk 星号作为前缀，函数就可以接受可变数量的参数。\ndef product(first, *args): result = first for x in args: result = result *x return result product(10, 20) # 200 product(2, 3, 4, 5) # 120 在这个例子中，所有的额外参数都作为一个元组放在 args 变量中。 对于元组，你可以使用序列的标准操作处理，如迭代、切片，解包等。\nKeyword Arguments 函数参考可以通过显示命名每个参数并指定值来提供函数参数。 这被称为 keyword arguments 关键字参数，例如：\n","keywords":["Python"],"articleBody":"函数是 Python 的基础模块，本篇会介绍 function application 函数定义、function application 函数应用、scoping rules 作用域规则、closures 闭包、decorators 装饰器和其他函数式编程特性。 特别关注不同的编程习惯 idioms、求值模型以及与函数相关的模式。\nDefault Arguments 你可以通过在函数定义处赋值的方式，给函数的参数添加默认值，例如：\ndef split(line, delimiter=\",\"): statements 当一个函数定义了默认参数的时候，其右侧都必须是含有默认值的可选参数。\n默认函数参数会在函数首次定义的时候调用一次，这有时会导致出乎意料的行为：\ndef func(x, items=[]): items.append(x) return items func(1) # returns [1] func(2) # returns [1, 2] func(3) # returns [1, 2, 3] 注意到每次掉都将函数默认值给修改了，要避免这种行为，使用 None 并进行检查：\ndef func(x, items=None): if not items: items = [] items.append(x) return items 通常来说，建议只使用不可变对象作为默认参数值。\nVariadic Arguments 可变参数\n如果在最后一个参数前使用 asterisk 星号作为前缀，函数就可以接受可变数量的参数。\ndef product(first, *args): result = first for x in args: result = result *x return result product(10, 20) # 200 product(2, 3, 4, 5) # 120 在这个例子中，所有的额外参数都作为一个元组放在 args 变量中。 对于元组，你可以使用序列的标准操作处理，如迭代、切片，解包等。\nKeyword Arguments 函数参考可以通过显示命名每个参数并指定值来提供函数参数。 这被称为 keyword arguments 关键字参数，例如：\ndef func(w, x, y, z): statements # Keyword argument invocation func(x=3, y=22, w=\"hello\", z=[1, 2]) 使用关键字参数，参数的顺序就不重要了，只要每个参数获取到了对应的值即可。 如果有任何不符合的关键字参数，则会抛出一个 TypeError 异常。 关键字参数按照它们在函数调用中指定的顺序进行求值。\nPositional arguments 位置参数和 keyword arguments 关键字参数可以在同一个函数调用中出现， 前提是所有的位置参数出现在前面，所有非可选参数都有值，且没有参数被赋予多个值。\n下面是一个例子：\nfunc(\"hello\", 3, z=[1, 2], y=22) func(3, 22, w=\"hello\", z=[1, 2]) # TypeError. Multiple values for w 如果想，可以强制使用关键字参数，通过将参数放到星号后面来实现：\ndef read_data(filename, *, debug=False): ... def product(first, *values, scale=1): result = first * scale for val in values: result = resul * val return result 在上面例子中，read_data 函数的 debug 参数只能通过关键字参数来确定。 这个限制通常能提高代码可读性：\ndata = read_data(\"Data.csv\", True) # No. TypeError data = read_data(\"Data.csv\", debug=True) # Yes. product() 函数接受任意数量的位置参数，和一个可选的关键字参数，例如：\nresult = product(2, 3, 4) # 24 result = product(2, 3, 4, scale=10) # 240 Variadic Keyword Arguments 如果函数最后一个参数有前缀 **，那所有的额外关键字参数（没有匹配任何参数名的），都会被放在一个字典中传入函数。 此字典中条目的顺序保证与关键字参数的提供顺序一致。\n接受任意关键字参数可能是定义函数的一种有效方式，这些函数需要处理大量的配置选项，若全列为参数会显得过于繁琐。\ndef make_table(data, **parms): fgcolor = parms.pop(\"fgcolor\", \"black\") bgcolor = parms.pop(\"bgcolor\", \"white\") width = parms.pop(\"width\", None) # No more options if parms: raise TypeError(f\"Unsupported configuration options {list(parms)}\") make_table(items, fgcolor=\"black\", bgcolor=\"white\", border=1, borderstyle=\"grooved\", cellpadding=10, width=400) 字典的 pop() 方法去除字典中的一个元素并返回，如果没有定义返回一个可能的默认值。\nFunctions Accepting All Inputs 如果一起使用 * 和 **，可以编写一个接受任意参数组合的函数。 位置参数通过元组传递，关键字参数通过字典传递。\n# Accept variable number of positional or keyword arguments def func(*args, **kwargs): # args is a tuple of positional args # kwargs is a dictionary of keyword args ... *args 和 **kwargs 这样的组合通常用于编写包装器、装饰器、代理以及类似类型的函数。\n例如，假设你有一个从可迭代对象处理行的函数：\ndef parse_lines(lines, separator=\",\", tyeps=(), debug=False): for line in lines: ... statements ... 现在，假设你想要创建一个特殊用途的函数，用于解析指定文件名对应的文件中的数据：\ndef prase_lines(filename, *args, **kwargs): with open(filename, 'rt') as file: return parse_lines(file, *args, **kwargs) 这样的好处之一是，函数 prase_lines 无序知道任何关于 prase_lines 函数的参数信息。 它接受调用者提供的任何额外参数并将其传递下去。 这也让函数 prase_lines 的维护更加简单了，如果要添加一个新字段，该函数无序修改也能工作。\nPositional Only Arguments 许多 Python 的内置函数值接受位置参数，可以使用 slash 斜杠 / 来指明。 例如 func(x, y, /)，这意味着在斜杠前面的参数只能通过位置参数指定。\n这种定义并不常见，因为在 Python 3.8 才开始支持。 但这是一种有效的避免命名冲突的方法。 例如：\nimport time def after(seconds, func, /, *args, **kwargs): time.sleep(seconds) return func(*args, **kwargs) def duration(*, seconds, minutes, hours): return seconds 60 * minutes + 3600 * hours after(5, duration, seconds=20, minutes=3, hours=2) 在上面例子总，after 有个参数 seconds，同样 duration 也有一样的参数名称，通过强制要求位置参数，避免了变量命名的冲突。 这里的 seconds=20 被解析成关键字参数，通过 **kwargs 传递给 duration 函数。\nNames, Documentation Strings, and Type Hints 标准的函数命名惯例使用小写字母和 undersocre 下划线作为分隔符。 如果一个函数不想被直接调用，比如内部的方法，使用单个下划线作为前置，例如 _helper()。\n函数名称可以通过 __name__ 属性获取，有时候调试非常有用\ndef square(x): return x * x square.__name__ # 'square' 在函数的第一次声明的时候，使用文档字符串描述使用方式很常见，例如：\ndef factorial(n): \"\"\" Computes n factorial. For example: \u003e\u003e\u003e factorial(6) 120 \u003e\u003e\u003e \"\"\" if n \u003c= 1: return 1 else: return n * factorial(n - 1) 文档字符串存储在函数属性 __doc__ 里，IDE 经常会访问作为交互使用。\n函数也可以添加类型提示：\ndef factorial(n: int) -\u003e int: if n \u003c= 1: return 1 else: return n * factorial(n - 1) 类型提示对函数的计算结果不会有任何影响，即没有任何额外的性能提示或运行时错误检查。 提示会存储在函数的 __annotations__ 属性中，该属性是一个参数名称映射提示的字典，许多 IDE 和第三方工具会使用提示内容。\n有时候提示会写在一个本地变量旁边，例如：\ndef factorial(int: n) -\u003e int: result: int = 1 # Type hinted local variable while n \u003e 1: result *= n n -= 1 return result 这种提示也会被解释器忽略，同样该提示是提供给第三方代码检查工具使用的。\nFunction Application and Parameter Passing 当函数被调用时，函数参数会成为局部名称，绑定到传入的输入对象。 Python 将传递的对象原样传递给函数，不进行任何额外的拷贝。 要小心如果可变类型作为参数传递，如果对象进行了任何修改，会影响到原来的对象。\n例如这个例子：\ndef square(items): for i, x in enumerate(items): items[i] = x * x # modify items in-place s = [1, 2, 3, 4, 5] suqare(s) # Change a to [1, 4, 9, 16, 25] 会修改输入值的函数会产生“副作用”，一般的规则是避免这种情况。 这种函数也难以和多线程和并发程序交互，因为副作用通常会被锁保护。\n当然，还要重点区分修改对象和重新分配 reassign 对象的区别，例如：\ndef sum_squares(items): items = [x*x for x in items] # Reassign \"items\" name return sum(items) a = [1, 2, 3, 4, 5] result = sum_squares(a) print(a) # [1, 2, 3, 4, 5] (Unchanged) 在这个例子中，sum_squares 函数看上去重写了 items 变量。 没错，标签 items 被重新分配了新的值。 然而，items 原始的值并没有被操作修改，而是将标签 items 绑定到了不同变量上面，即内部的列表推导式的值。 赋值给一个变量和修改一个对象是有区别的，当给一个变量赋值的时候，并不会重写已经存在的对象。 而是在给不同的对象重命名。\n从风格上来讲，会产生“副作用”的函数通常会返回 None 作为结果。 例如列表的 sort() 函数：\nitems = [10, 3, 2, 9, 5] items.sort() # Observe: no return value items # [2, 3, 5, 9, 10] 该 sort() 方法会将列表原地排序，并不返回值。 缺少返回值是一个强有力的“副作用”指标，在这个例子中列表被重新排序了。\n有时候，你已经有值存储在序列 sqeuence 或字典 mapping 中了，要将他们传递给一个函数，在函数调用中使用 * 和 **：\ndef func(x, y, z): ... # Pass a sequence as arguments s = (1, 2, 3) result = func(*s) # Pass a mapping as keyword arguments d = {\"x\": 1, \"y\": 2, \"z\": 3} result = func(**d) 如果从多个源获取数据，甚至显示提供部分参数，只要函数获得所有必须的参数、不含重复项，且调用前面中的所有内容都正确对齐，一切都会正常运行。 甚至可以在函数调用中多次使用 * 和 **，但如果确实值，或参数重复，将会遇到一个报错。\nReturn Values return 语句返回一个函数值，如果省略了返回或没有值，则返回 None。 如果要返回多个值，将他们放到一个元组中：\ndef parse_value(text): \"\"\" Split text of the form name=val into (name, val) \"\"\" parts = text.split(\"=\", 1) return (parts[0].strip(), parts[1].strip()) 返回的元组可以这样拆开成单个值：\nname, value = parse_value(\"url=https//www.python.org\") 有时候可以使用 named tuples 具名元组替代：\nfrom typing import NamedTuple class ParseResult(NamedTuple): name: str value: str def parse_value(text): \"\"\" Split text of the form name=val into (name, val) \"\"\" parts = text.split(\"=\", 1) return ParseResult(parts[0].strip(), parts[1].strip()) 具名元组和普通的元组一样，你可以进行同样的操作例如解包，但还可以通过名称属性来访问元素：\nr: ParseResult = parse_value(\"url=http://www.python.org\") print(r.name, r.vlaue) Error Handling 上面的 parse_value() 函数没有错误处理，如果字符串不是预期的格式应该怎么办？ 一种方式是将结果视为可选的，即函数要么返回结果，要么返回 None，这个常用于表示缺失值。 例如，该函数可以这样修改：\ndef parse_value(text): parts = text.split(\"=\", 1) if len(parts) == 2: return ParseResult(parts[0].strip(), parts[1].strip()) else: return None 使用这种设计，结果检测的重担就传递给了调用者：\nresult = parse_value(text) if result: name, value = result 或者使用更紧凑的 Python 3.8 新语法：\nif result := parse_value(text) name, value = result 除了返回 None，也可以遇到错误文本时抛出异常：\ndef parse_value(text): parts = tex.split(\"=\", 1) if len(parts) == 2: return PraseResult(parts[0].strip(), parts[1].strip()) else: raise ValueError(\"Bad value\") 在这个情况下，调用者使用 try-except 语句来处理错误：\ntry: name, value = prase_value(text) except ValueError: ... 是否要使用异常处理并不总是明确的。 一般而言，异常是更常见的异常处理方式。 但异常处理会更加昂贵，如果在编写一些性能要求高的代码，应该返回 None, False, -1 或者其他的特殊值来表示错误。\nScoping Rules 每次执行一个函数，都会创建一个命名空间。 这个命名空间代表一个环境，包含了函数参数的名称和值，以及函数体内赋值的所有变量。 函数内部赋值的变量是局部变量，直接引用但未赋值的变量会到函数定义所在的模块的全局作用域中查找。\n有两类和命名相关的错误，在全局环境查找一个未定义的自由变量会产生 NameError 异常。 查询一个未赋值的本地变量会产生一个 UnboundLocalError 异常，这种错误通常源于控制流缺陷。\n比如这样：\ndef func(x): if x \u003e 0: y = 42 # y not assigned if conditional is false return x + y func(10) func(-10) # UnboundLocalError: y referenced before assigment 或者是原地计算产生的错误：\ndef func(): n += 1 # Error: UnboundLocalError 需要强调的是，变量名的作用域永远不会改变，要么是全局变量，要么是局部变量，这取决于函数定义时的设定。\nx = 42 def func(): print(x) # UnboundLocalError x = 12 上面例子看上去好像能正常运行，但实际上由于下面 x = 12 的赋值，x 实际上是局部变量，且还未定义，因此会报错。\n如果要在函数内修改外部变量，使用 global 关键字：\nx = 42 y = 37 def func(): global x x = 13 y = 0 func() # x is 13, y is sitll 37 但使用 global 并不是特别符合 Python 风格。 如果要通过函数修改状态，考虑使用类定义，并通过修改实例变量或类变量来实现状态变化。\nclass Config: x = 42 def func(): Config.x = 13 Python 允许嵌套函数定义，例如：\ndef countdown(start): n = start def display(): # Nested function definition print(\"T-minus\", n) while n \u003e 0: display() n -= 1 嵌套函数中的变量通过词法作用域绑定。 也就是说，名称首先在局部作用域解析，然后从最内层作用域到最外层作用域，依次在连续的封闭作用域中解析。 同样，这个过程不是动态的，名称的绑定是在函数定义时根据语法一次性确定的。\n例如，下面这段代码不会工作：\ndef countdown(start): n = start def display(): print(\"T-minus\", n) def decrement(): n -= 1 # UnboundLocalError: 局部变量在赋值前被引用 while n \u003e 0: display() decrement() 要修复这段代码，使用 nonlocal 关键字，声明该变量来自外层函数。\ndef countdown(start): n = start def display(): print(\"T-minus\", n) def decrement(): nonlocal n n -= 1 while n \u003e 0: display() decrement() nonlocal 不能用于引用全局变量，它必须指向外层作用域中的局部变量。 因此，如果一个变量是全局的，还是应该使用 global 关键字。\nRecursion Python 支持递归函数，例如：\ndef sumn(n): if n == 0: return 0 else: return n + sumn(n- 1) 但递归深度是有限制的，函数 sys.getrecursionlimit() 返回当前最大的递归深度，使用函数 sys.setrecursionlimit() 可以修改该值。 尽管可以改变递归深度，但栈的大小仍然受操作系统的限制。 当超出最大递归深度后，会抛出一个 RuntimeError。 如果限制递归深度太高，Python 可能会因 segmentation error 段错误或其他操作系统错误而崩溃。\n在实践中，一般递归限制只会在使用树或图这类深度嵌套数据结构的时候，才会导致递归深度的问题。\nThe lambda Expression 一个匿名函数可以使用 lambda 关键字定义：\nlambda args: expression args 是一个由逗号分隔的参数列表，而 expression 则是这些参数的表达式，例如：\na = lambda x, y: x + y r = a(2, 3) # r gets 5 使用 lambda 定义的代码必须是一个合理的表达式，多个语句以及其他非表达式语句，例如 try 和 while，不能出现在 lambda 表达式中。 lambda 表达式也遵循和函数一样的作用域。\n一个使用 lambda 的例子是定义小的回调函数，例如你可能在 sorted() 函数中这样使用：\nresult = sorted(words, key=lambda word: len(set(word))) # len(set(str)) 是不重复字符数量 如果 lambda 中含有自由变量则需要注意：\nx = 2 f = lambda y: x * y x = 3 g = lambda y: x * y print(f(10)) # 30 print(g(10)) # 30 函数 f(10) 使用调用时 x 的值，而不是函数定义时 x 的值，这种行为被称为 late-binding 延迟绑定。\n在定义时绑定值使用 default arguemnt 默认参数：\nx = 2 f = lambda y, x=x: x * y x = 3 g = lambda y, x=x: x * y print(f(10)) # 20 print(g(10)) # 30 这是因为 default argument 默认参数值仅在函数定义时被求值，因此会捕获变量x的当前值。\nHigher Order Functions Python 支持 “higher-order functions” 高阶函数的概念，这意味着函数可以作为参数传递给其他函数，存储数据结构中，并作为结果返回。 有时候会说函数是 “first-class” 一等公民，意味着函数和其他数据类型没有区别。\nimport time def after(seconds, func): time.sleep(seconds) func() def greeting(): print(\"Hello World\") after(10, greeting) 在这个例子中，after() 函数的 func 参数就是所谓的 “callback function” 回调函数，这是指 after 会回调作为参数的函数。\n当函数作为数据传递的时候，它会显示地携带函数定时时，关于环境的信息。 例如下面这个例子，greeting() 函数是这样使用变量：\ndef main(): name = \"Guido\" def greeting(): print(\"Hello\", name) after(10, greeting) # Hello Guido main() 在这个例子中，变量 name 被 greeting() 调用，但 name 是 main 函数的本地变量。 当 greeting 传递给 after()，该函数会记得其环境，并使用环境中的 name 变量。 该特性被称为 “closure” 闭包。\nClosure 闭包是一个函数及其执行函数体所需的变量所构成的环境。 闭包与嵌套函数在编写基于惰性或延迟求值的概念的代码时尤其有用。 如上面的 after() 函数，它不会接收一个立刻执行的函数，该函数会在之后的某个时间点才被调用，该编程模式在其他场景中也很常见。\n例如，程序可能仅在响应事件时才执行的函数（如按键、鼠标移动、网络数据包到达等）。 在所有这些情况下，函数求值会延迟到发生某些有意义的事件时再进行。 当函数最后执行的时候，闭包确保函数能获取到它所需要的一切。\n你也可以这样编写和创建函数，例如：\ndef make_greeting(name): def greeting(): print(\"Hello\", name) return greeting f = make_greeting(\"Guido\") g = make_greeting(\"Ada\") f() # Hello Guido g() # Hello Ada 在这个例子中，make_greeting() 函数并不会携带有任何有意义的计算。 相反，它创建并返回了一个真正执行任务的 greeting() 函数。 这种情况只会在函数被求值后发生。\n在上面例子中，f 和 g 函数是两个版本的 greeting() 函数。 尽管创建这些函数的 make_greeting() 函数已不再执行，但 greeting() 函数仍能记住已定义的 name 变量，这是函数闭包的一部分。\n关于闭包需要注意的一点是，对变量名的绑定并非“快照”，而是一个动态过程。 这意味着，闭包指向的是变量名及其最近被赋予的值。 下面示例说明了可能引发的情况：\ndef make_greetings(names): funcs = [] for name in names: funcs.append(lambda: print(\"Hello\", name)) return funcs a, b, c = make_greetings([\"Guido\", \"Ada\", \"Margaret\"]) a() # Hello Margaret b() # Hello Margaret c() # Hello Margaret 在这个例子中，列表中不同的函数使用 lambda 构造，他们看起来似乎都使用了唯一的 name 值。 但实际上是，所有函数都会使用同一个 name 值，无论该值是在外部 make_greetings() 函数返回时如何设置的。 因为 lambda 函数中的 name 变量是一个自由变量，它会在函数执行时才查找值，而不是在定义时（for 不会创建新的作用域）。\n正确的方式可以使用默认参数进行捕获：\ndef make_greetings(names): funcs = [] for name in names: func.append(lambda name=name: print(\"Hello\", name)) return funcs a, b, c = make_greetings([\"Guido\", \"Ada\", \"Margaret\"]) a() # Hello Guido b() # Hello Ada c() # Hello Margaret 或者这样\ndef make_greetings(names): funcs = [] for names in names: def greeting(name=name): print(\"Hello\", name) funcs.append(greeting) return funcs Argument Passing in Callback Functions 使用 callback function 回调函数时，一个具有挑战性的编码问题是如何向提供的函数传递参数。 考虑之前的 after() 函数：\nimport time def after(seconds, func): time.sleep(seconds) func() 在这个例子中，func 是硬编码且没有参数的。 如果你想要解析额外的参数，那就不好用了，例如：\ndef add(x, y): print(f\"{x} + {y} -\u003e {x + y}\") return x + y after(10, add(2, 3)) # Fails: add() called immediately 在这个例子中，在这个例子中，add(2, 3) 函数立即执行并返回结果 5。 随后，after() 函数在 10 秒后尝试执行 5() 时崩溃。\n这显然不是这段代码的本意，这个问题暗示了一个更广泛的设计议题。 即关于函数及函数式编程的整体运用，特别是与函数组合相关的方面。 当函数通过各种方式混合在一起的时候，你通常需要思考函数的输入与输出如何相互连接。\n这个例子的一种解决方案是，使用无参数 lambda 函数打包，例如：\nafter(10, lambda: add(2, 3)) 这样的小型 zero-argument 零参数函数有时被称为 “thunk” (延迟计算或惰性求值)。 基本上，它代表一个表达式，该表达式将在最终被作为无参数函数调用时进行求值。 这可以作为一种通用方法，将任何表达式的求值延迟到稍后的时间点，将表达式放入 lambda 函数中，并在实际需要该值时调用该函数。\n作为 lambda 的一种替代方案，可以使用 functools.partial() 来创建一个部分求值的函数：\nfrom functools import partial after(10, partial(add, 2, 3)) partial() 这里扮演一个函数工厂的角色，它不立刻计算结果，而是生成一个新的函数。 在未来需要被调用的时候，才去真实调用该函数。 这是一种有效的方法，可以使非标准函数在回调和其他应用中，匹配预期的调用签名。\n下面是更多例子：\ndef func(a, b, c, d): print(a, b, c, d) f = partial(func, 1, 2) f(3, 4) # func(1, 2, 3, 4) f(10, 20) # func(1, 2, 10, 20) g = partial(func, 1, 2, d=4) g(3) # func(1, 2, 3, 4) g(10) # func(1, 2, 10, 4) partial() 和 lambda 都有类似的目的，但两种方法在语义上有重大区别。 使用 partial() 时，参数会在偏函数首次定义时被求值并绑定； 而使用无参 lambda 时，参数的实际求值和绑定会延迟至该 lambda 函数后续真正执行时才发生（求值都被延迟了）。\ndef func(x, y): return x + y a = 2 b = 3 f = lambda: func(a, b) g = partial(func, a, b) a = 10 b = 20 f() # 使用当前的 a=10, b=20 的值 g() # 使用初始的 a=2, b=3 的值 由于 partials 偏函数会计算出函数结果，由 partial() 创建的可调用对象是可以序列化为字节、保存到文件中，甚至通过网络传输的对象。 但使用 lambda 函数就不可能实现，因此在需要传递函数，尤其是可能传递给不同进程或不同机器上的 Python 解释器的应用场景中，partial() 根据适应性。\n部分函数应用和一种 “currying” 柯里化的应用密切相关。 柯里化是一种函数式编程的技术，将多参数函数表示为单参数函数的嵌套函数。\n# 3 参数函数 def f(x, y, z): return x + y + z # Curried version def fc(x): return lambda y: (lambda z: x + y + z) a = f(2, 3, 4) b = fc(2)(3)(4) 回到之前的参数传递问题，另一种传递参数的方法是将其视作外部调用函数的独立参数来接收。\ndef after(seconds, func, *args): time.sleep(seconds) func(*args) after(10, add, 2, 3) # 10 秒后调用 add(2, 3) 你会发现，在 func() 中传递关键字参数是不被允许的。 这就是这样设计的，因为如果允许使用关键字参数，则可能会和 after 的参数 seconds 产生冲突。 关键字参数可能被保留用于指定 after() 函数本身的选项，例如：\ndef after(seconds, func, *args, debug=False): time.sleep(seconds) if debug: print(\"About to call\", func, args) func(*args) 然而并非全无希望，如果需要为 func() 指定关键字参数，仍然可以通过 partial() 实现，例如：\nafter(10, partial(add, y=3), 2) 如果想要让 after() 接受关键字参数，一个安全的方式是只允许使用位置参数传递值，例如：\ndef after(seconds, func, debug=False, /, *args, **kwargs): time.sleep(seconds) if debug: print(\"About to call\", func, args, kwargs) func(*args, **kwargs) after(10, add, 2, y=3) 另一个让人不安的洞见是，after() 的参数实际上是两个不同函数的参数合并。 或许传递参数的问题可以分解为两个函数，例如这样：\ndef after(seconds, func, debug=False): def call(*args, **kwargs): time.sleep(seconds) if debug: print(\"About to call\", func, args, kwargs) func(*args, **kwargs) return call after(10, add)(2, y=3) 现在，after() 函数的参数与 func 函数的参数之间没有任何冲突。 然而，这样做可能会和同事之间发生冲突 XD …\nReturning Results from Callbacks 另一个没有说的问题是关于返回计算结果，例如 aftre() 函数：\ndef after(seconds, func, *args): time.sleep(seconds) return func(*args) 在异常处理的时候有两种情况：\nafter(\"1\", add, 2, 3) # Fails: TypeError (integer is excepted) after(1, add, \"2\", 3) # Fails: TypeError (can't concatenate int to str) 上例中，两个都抛出 TypeError，但原因却不同。 第一个是 after() 函数导致的错误，第二个是 func() 函数导致的错误。 一个解决思路是将 call function 回调函数中的错误以不同方式封装，使其能够与其他类型的错误分开处理。\n例如：\nclass CallbackError(Exception): pass def after(seconds, func, *args): time.sleep(seconds) try: return func(*args) except Exception as err: raise CallbackError(\"Callback function failed\") from err 这段修改后的代码将来自所提供回调函数的错误隔离到其自身的异常类型中：\ntry: r = after(delay, add, x, y) except CallbackError as err: print(\"It failed, Reason\", err.__cause__) 如果 after() 本身的执行出现问题，该异常将未经捕获地向外传播。 另一方面，与所提供回调函数实际执行相关的问题会被捕获并报告为 CallbackError。 这一切都相当微妙，在实践中，异常处理很难。 这种方式让责任归属更加明确，同时 after() 的行为也更容易记录。 如果回调函数出现问题，则总是报告为 CallbackError。\n另一种方法是将结果包装到实例中去，包含了结果和错误信息：\nclass Result: def __init__(self, value=None, exc=None): self._value = value self._exc = exc def result(self): if self._exc: raise self._exc else: return self._value 然后使用这个类作为 after() 函数的返回值\ndef after(seconds, func, *args): time.sleep(seconds) try: return Result(value=func(*args)) except Exception as err: return Result(exc=err) r = after(1, add, 2, 3) print(r.result()) # 5 s = after(\"1\", add, 2, 3) # TypeError t = after(1, add, \"2\", 3) # Return a \"Result\" print(t.result()) 第二种方法的工作原理是将回调函数的结果推迟到一个独立的步骤中。 如果 after() 出现问题，会立刻报告； 而如果回调函数 func() 出现问题，则会在用户尝试通过调用 result() 方法获取结果时报告。\n这种将结果封装在特定实例中，以便后续解包的编程风格在现代编程语言中正变得越来越普遍。 一个这样做的动机是因为能够促进类型提示，例如：\ndef after(seconds, func, *args) -\u003e Result: ... 尽管在大多数 Python 代码中，这类模式并不常见，但在处理线程和进程等并发原语时，会频繁出现。 例如，在使用线程池时，所谓的 Fruture 实例就表现出这种行为：\nfrom concurrent.futures import ThreadPoolExecutor pool = ThreadPoolExecutor(16) r = pool.submit(add, 2, 3) # Returns a Future print(r.result()) # Unwarp the Future result Decorators 装饰器是一个函数，它能够为另一个函数创建包装器。 包装的主要目的是为了修改或增强被包装对象的行为。 语法上，装饰器使用 @ 符号来表示：\n@decorate def func(x): ... 前面代码是下面的简写形式：\ndef func(x): ... func = decorate(func) 在这个例子中，定义了函数 func()，但马上将该函数作为参数传递给 docorate()，并返回一个新的对象替代掉原始的 func 函数。\n下面看一个具体的例子，使用 @trace 装饰器为函数添加调试信息：\ndef trace(func): def call(*args, **kwargs): print(\"Calling\", func.__name__) return func(*args, **kwargs) return call # Example @trace def square(x): return x * x 这段代码中，trace 创建了一个装饰器，输出函数的调试信息，然后再调用函数。 看上去十分简单，但在实际中，函数还会含有一些元信息，例如函数名称、doc string 和 type hints 类型提示等。 如果直接使用上面的函数来包装，会将这些信息隐藏。 因此，编写装饰器时常用 @wraps() 装饰器，例如：\nfrom functools import wraps def trace(func): @wraps(func) def call(*args, **kwargs): print(\"Calling\", func.__name__) return func(*args, **kwargs) return call @wraps() 装饰器会将函数的元数据复制到要替换的函数上，在这个例子中 func() 函数的元数据被复制到了 call() 包装器函数上。\n使用装饰器时，其必须放在函数的上面一行，一个函数可以应用更多的装饰器：\n@docorator1 @docorator2 def func(x): pass 在这个例子中，装饰器等同于这样：\ndef func(x): pass func = docorator1(decorator2(func)) 装饰器的顺序可能会很重要。 例如在类定义中，@classmethod 和 @staticmethod 总是需要放到最外层。\n例如：\nclass SomeClass(object): # Yes @calssmethod @trace def a(cls): pass @trace @classmethod def a(cls): # No. Fails pass 这种放置限制的原因与 @classmethod 返回的值有关。 有时装饰器会返回一个不同于普通函数的对象。 如果最外层装饰器未预料到这种情况，则会崩溃。 在这种情况下，@classmethod 会创建一个类方法描述符对象。 除非 @trace 装饰器在设计时已考虑到这一点，否则装饰器顺序不当会使装饰器失效。\n装饰器也能够接受参数，例如，修改 @trace 装饰器来支持自定义信息：\n@trace(\"You called {func.__name}\") # f-string 是立刻求值的，不能在这里使用 def func(): pass 提供参数的装饰器语义如下：\ndef func(): pass # Create the decorator function temp = trace(\"You called {func.__name__}\") # Apply it to func func = temp(func) 在这种情况下，接受参数的最外层函数负责创建装饰器函数。 随后，该函数会与待装饰的函数一同调用，以获取最终结果。\n以下是装饰器可能实现的样子：\nfrom functools import wraps def trace(message): # message: 装饰参数 def decorate(func): # func: 装饰函数 @wraps(func) def wrapper(*args, **kwargs): print(message.format(func=func)) # str.format() 延迟求值 return func(*args, **kwargs) return wrapper return decorate 这种实现的一个有趣特性是，外层函数实际上是一种 “decorator factory” 装饰器工厂。\n假如这样写代码：\n@trace(\"You called {func.__name__}\") def func1(): pass @trace(\"You called {func.__name__}\") def func2(): pass 但这样会显得很繁琐，你可以通过调用外部装饰器函数一次，并重复使用其结果来简化：\nlogged = trace(\"You called {func.__name__}\") @logged def func1(): pass @logged def func2(): pass 装饰器不一定要替换原始函数。 有时，装饰器仅执行诸如注册之类的操作。 例如，如果你正在构建一个事件处理器的注册列表，你可能希望定义一个这样工作的装饰器：\n@eventhandler(\"BUTTON\") def handle_button(msg): ... @eventhandler(\"RESET\") def handle_reset(msg): ... 下面是管理装饰器定义:\n# Event handler decorator _event_handlers = { } def eventhandler(event): def register_function(func): _event_handlers[event] = func return func return register_function Map, Filter, and Reduce 熟悉函数式编程的程序员可能想知道常见的列表操作，如 map 映射, filter 过滤和 reduce 归约。 多部分这些功能都可以对列表推导式和生成器表达式有效：\ndef square(x): return x * x nums = [1, 2, 3, 4, 5] squares = [square(x) for x in nums] # [1, 4, 9, 16, 25] 你甚至不需要这个单行函数：\nsquares = [x * x for x in nums] 其中也可以进行过滤 filtering\na = [x for x in nums if x \u003e 2] # [3, 4 ,5] 内置函数 map()，其功能与使用生成器表达式映射函数相同。\nsquares = map(lambda x: x*x, nums) for n in squares: print(n) 该内置函数会创建一个过滤值的生成器：\nfor n in filter(lambda x: x \u003e 2, nums): print(n) 如果要累加或减去值，使用 functools.reduce()，例如：\nfrom functools import reduce nums = [1, 2, 3, 4, 5] total = reduce(lambda x, y: x + y, nums) # 15 product = reduce(lambda x, y: x * y, nums, 1) # 120 pairs = reduce(lambda x, y: (x, y), nums, None) # (((((None, 1), 2), 3), 4), 5) reduce() 接受一个两个参数的函数，一个可迭代对象和一个初始值。 从左到右对提供的可迭代对象jinx值累积，这有时被称为 “left-fold” 左折叠操作。\n下面是伪代码：\ndef reduce(func, items, initial): result = initial for item in items: result = func(result, item) return result 经验表明，使用 reduce() 有时会令人赶到困惑。 此外，常见的归约操作，如 sum()、min() 和 max() 已内置在语言中。 使用这些内置操作比 reduce() 更加容易理解。\nFunction Introspection, Attributes, and Signatures 如前所述，函数也是对象，这意味着他们可以被复制给变量、存储在数据结构中，并可以像程序中其他类型数据一样使用。 他们也可以通过多种方式进行查看。 下表展示了函数的一些常见属性，其中许多属性在调试、日志记录以及其他涉及函数的操作中非常有用。\nAttribute Description f.__name__ Function name f.__qualname__ Fully qualified name f.__module__ Name of module in which defined f.__doc__ Documentation string f.__annotations__ Type hints f.__globals__ Dictionary that is the global namespace f.__closure__ Closure variables f.__code__ Underlying code object f.__qualname__ 是包含嵌套格式的完整路径名 外层类名.内层类名.方法名 或 外层函数.内层函数名\nf.__module__ 是一个包含模块名称的字符串\nf.__globals__ 是一个字典，包含函数定义时的全局命名空间，类似这样\n{ '__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': \u003c...\u003e, '__spec__': None, '__annotations__': {}, '__builtins__': \u003cmodule 'builtins'\u003e, '__file__': 'test.py', 'x': 10, 'f': \u003cfunction f at 0x...\u003e # ... 还有很多内置属性 } f.__closure__ 保存了嵌套函数中闭包变量的引用值\n这可能不太显眼，例如：\ndef add(x, y): def do_add(): return x + y return do_add() a = add(1, 2) a.__closure__ # ( # , # # ) a.__closure__[0].cell_contents # 2 f.__code__ 对象代表编译过的函数体字节码\na.__code__ # ","wordCount":"3236","inLanguage":"en","image":"https://starslayerx.github.io/images/og-default.avif","datePublished":"2025-12-19T08:00:00+08:00","dateModified":"2025-12-19T08:00:00+08:00","author":{"@type":"Person","name":"Starslayerx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://starslayerx.github.io/posts/python-tricks-part-5-functions/"},"publisher":{"@type":"Organization","name":"Starslayerx' Blog","logo":{"@type":"ImageObject","url":"https://starslayerx.github.io/favicon.svg"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Python Tricks Part 5: Functions</h1><div class=post-meta><span title='2025-12-19 08:00:00 +0800 +0800'>December 19, 2025</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>3236 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#default-arguments>Default Arguments</a></li><li><a href=#variadic-arguments>Variadic Arguments</a></li><li><a href=#keyword-arguments>Keyword Arguments</a></li><li><a href=#variadic-keyword-arguments>Variadic Keyword Arguments</a></li><li><a href=#functions-accepting-all-inputs>Functions Accepting All Inputs</a></li><li><a href=#positional-only-arguments>Positional Only Arguments</a></li><li><a href=#names-documentation-strings-and-type-hints>Names, Documentation Strings, and Type Hints</a></li><li><a href=#function-application-and-parameter-passing>Function Application and Parameter Passing</a></li><li><a href=#return-values>Return Values</a></li><li><a href=#error-handling>Error Handling</a></li><li><a href=#scoping-rules>Scoping Rules</a></li><li><a href=#recursion>Recursion</a></li><li><a href=#the-lambda-expression>The lambda Expression</a></li><li><a href=#higher-order-functions>Higher Order Functions</a></li><li><a href=#argument-passing-in-callback-functions>Argument Passing in Callback Functions</a></li><li><a href=#returning-results-from-callbacks>Returning Results from Callbacks</a></li><li><a href=#decorators>Decorators</a></li><li><a href=#map-filter-and-reduce>Map, Filter, and Reduce</a></li><li><a href=#function-introspection-attributes-and-signatures>Function Introspection, Attributes, and Signatures</a></li><li><a href=#environment-inspection>Environment Inspection</a></li><li><a href=#dynamic-code-execution-and-creation>Dynamic Code Execution and Creation</a></li><li><a href=#asynchronous-functions-and-await>Asynchronous Functions and Await</a></li><li><a href=#final-words-thoughts-on-functions-and-compoistion>Final Words: Thoughts on Functions and Compoistion</a></li></ul></nav></div></details></div><div class=post-content><p>函数是 Python 的基础模块，本篇会介绍 function application 函数定义、function application 函数应用、scoping rules 作用域规则、closures 闭包、decorators 装饰器和其他函数式编程特性。
特别关注不同的编程习惯 idioms、求值模型以及与函数相关的模式。</p><h2 id=default-arguments>Default Arguments<a hidden class=anchor aria-hidden=true href=#default-arguments>#</a></h2><p>你可以通过在函数定义处赋值的方式，给函数的参数添加默认值，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>split</span><span class=p>(</span><span class=n>line</span><span class=p>,</span> <span class=n>delimiter</span><span class=o>=</span><span class=s2>&#34;,&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>statements</span>
</span></span></code></pre></div><p>当一个函数定义了默认参数的时候，其右侧都必须是含有默认值的可选参数。</p><p>默认函数参数会在函数首次定义的时候调用一次，这有时会导致出乎意料的行为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>items</span><span class=o>=</span><span class=p>[]):</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>items</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># returns [1]</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>  <span class=c1># returns [1, 2]</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>  <span class=c1># returns [1, 2, 3]</span>
</span></span></code></pre></div><p>注意到每次掉都将函数默认值给修改了，要避免这种行为，使用 <code>None</code> 并进行检查：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>items</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>items</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>items</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>items</span>
</span></span></code></pre></div><p>通常来说，建议只使用不可变对象作为默认参数值。</p><h2 id=variadic-arguments>Variadic Arguments<a hidden class=anchor aria-hidden=true href=#variadic-arguments>#</a></h2><p>可变参数</p><p>如果在最后一个参数前使用 asterisk 星号作为前缀，函数就可以接受可变数量的参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>product</span><span class=p>(</span><span class=n>first</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>first</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>args</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>result</span> <span class=o>*</span><span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>product</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>)</span>      <span class=c1># 200</span>
</span></span><span class=line><span class=cl><span class=n>product</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>  <span class=c1># 120</span>
</span></span></code></pre></div><p>在这个例子中，所有的额外参数都作为一个元组放在 <code>args</code> 变量中。
对于元组，你可以使用序列的标准操作处理，如迭代、切片，解包等。</p><h2 id=keyword-arguments>Keyword Arguments<a hidden class=anchor aria-hidden=true href=#keyword-arguments>#</a></h2><p>函数参考可以通过显示命名每个参数并指定值来提供函数参数。
这被称为 keyword arguments 关键字参数，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>statements</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Keyword argument invocation</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=n>x</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=mi>22</span><span class=p>,</span> <span class=n>w</span><span class=o>=</span><span class=s2>&#34;hello&#34;</span><span class=p>,</span> <span class=n>z</span><span class=o>=</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>])</span>
</span></span></code></pre></div><p>使用关键字参数，参数的顺序就不重要了，只要每个参数获取到了对应的值即可。
如果有任何不符合的关键字参数，则会抛出一个 <code>TypeError</code> 异常。
关键字参数按照它们在函数调用中指定的顺序进行求值。</p><p>Positional arguments 位置参数和 keyword arguments 关键字参数可以在同一个函数调用中出现，
前提是所有的位置参数出现在前面，所有非可选参数都有值，且没有参数被赋予多个值。</p><p>下面是一个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=s2>&#34;hello&#34;</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=n>z</span><span class=o>=</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>],</span> <span class=n>y</span><span class=o>=</span><span class=mi>22</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>22</span><span class=p>,</span> <span class=n>w</span><span class=o>=</span><span class=s2>&#34;hello&#34;</span><span class=p>,</span> <span class=n>z</span><span class=o>=</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>])</span>  <span class=c1># TypeError. Multiple values for w</span>
</span></span></code></pre></div><p>如果想，可以强制使用关键字参数，通过将参数放到星号后面来实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>read_data</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>debug</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>product</span><span class=p>(</span><span class=n>first</span><span class=p>,</span> <span class=o>*</span><span class=n>values</span><span class=p>,</span> <span class=n>scale</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>first</span> <span class=o>*</span> <span class=n>scale</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>val</span> <span class=ow>in</span> <span class=n>values</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>resul</span> <span class=o>*</span> <span class=n>val</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><p>在上面例子中，<code>read_data</code> 函数的 <code>debug</code> 参数只能通过关键字参数来确定。
这个限制通常能提高代码可读性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=n>read_data</span><span class=p>(</span><span class=s2>&#34;Data.csv&#34;</span><span class=p>,</span> <span class=kc>True</span><span class=p>)</span>  <span class=c1># No. TypeError</span>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=n>read_data</span><span class=p>(</span><span class=s2>&#34;Data.csv&#34;</span><span class=p>,</span> <span class=n>debug</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>  <span class=c1># Yes.</span>
</span></span></code></pre></div><p><code>product()</code> 函数接受任意数量的位置参数，和一个可选的关键字参数，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>product</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>            <span class=c1># 24</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>product</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=n>scale</span><span class=o>=</span><span class=mi>10</span><span class=p>)</span>  <span class=c1># 240</span>
</span></span></code></pre></div><h2 id=variadic-keyword-arguments>Variadic Keyword Arguments<a hidden class=anchor aria-hidden=true href=#variadic-keyword-arguments>#</a></h2><p>如果函数最后一个参数有前缀 <code>**</code>，那所有的额外关键字参数（没有匹配任何参数名的），都会被放在一个字典中传入函数。
此字典中条目的顺序保证与关键字参数的提供顺序一致。</p><p>接受任意关键字参数可能是定义函数的一种有效方式，这些函数需要处理大量的配置选项，若全列为参数会显得过于繁琐。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>make_table</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=o>**</span><span class=n>parms</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>fgcolor</span> <span class=o>=</span> <span class=n>parms</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s2>&#34;fgcolor&#34;</span><span class=p>,</span> <span class=s2>&#34;black&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>bgcolor</span> <span class=o>=</span> <span class=n>parms</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s2>&#34;bgcolor&#34;</span><span class=p>,</span> <span class=s2>&#34;white&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>width</span> <span class=o>=</span> <span class=n>parms</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s2>&#34;width&#34;</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># No more options</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>parms</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Unsupported configuration options </span><span class=si>{</span><span class=nb>list</span><span class=p>(</span><span class=n>parms</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>make_table</span><span class=p>(</span><span class=n>items</span><span class=p>,</span> <span class=n>fgcolor</span><span class=o>=</span><span class=s2>&#34;black&#34;</span><span class=p>,</span> <span class=n>bgcolor</span><span class=o>=</span><span class=s2>&#34;white&#34;</span><span class=p>,</span> <span class=n>border</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>borderstyle</span><span class=o>=</span><span class=s2>&#34;grooved&#34;</span><span class=p>,</span> <span class=n>cellpadding</span><span class=o>=</span><span class=mi>10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>width</span><span class=o>=</span><span class=mi>400</span><span class=p>)</span>
</span></span></code></pre></div><p>字典的 <code>pop()</code> 方法去除字典中的一个元素并返回，如果没有定义返回一个可能的默认值。</p><h2 id=functions-accepting-all-inputs>Functions Accepting All Inputs<a hidden class=anchor aria-hidden=true href=#functions-accepting-all-inputs>#</a></h2><p>如果一起使用 <code>*</code> 和 <code>**</code>，可以编写一个接受任意参数组合的函数。
位置参数通过元组传递，关键字参数通过字典传递。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># Accept variable number of positional or keyword arguments</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># args is a tuple of positional args</span>
</span></span><span class=line><span class=cl>    <span class=c1># kwargs is a dictionary of keyword args</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></div><p><code>*args</code> 和 <code>**kwargs</code> 这样的组合通常用于编写包装器、装饰器、代理以及类似类型的函数。</p><p>例如，假设你有一个从可迭代对象处理行的函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_lines</span><span class=p>(</span><span class=n>lines</span><span class=p>,</span> <span class=n>separator</span><span class=o>=</span><span class=s2>&#34;,&#34;</span><span class=p>,</span> <span class=n>tyeps</span><span class=o>=</span><span class=p>(),</span> <span class=n>debug</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>lines</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>        <span class=n>statements</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span></code></pre></div><p>现在，假设你想要创建一个特殊用途的函数，用于解析指定文件名对应的文件中的数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>prase_lines</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=s1>&#39;rt&#39;</span><span class=p>)</span> <span class=k>as</span> <span class=n>file</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>parse_lines</span><span class=p>(</span><span class=n>file</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span></code></pre></div><p>这样的好处之一是，函数 <code>prase_lines</code> 无序知道任何关于 <code>prase_lines</code> 函数的参数信息。
它接受调用者提供的任何额外参数并将其传递下去。
这也让函数 <code>prase_lines</code> 的维护更加简单了，如果要添加一个新字段，该函数无序修改也能工作。</p><h2 id=positional-only-arguments>Positional Only Arguments<a hidden class=anchor aria-hidden=true href=#positional-only-arguments>#</a></h2><p>许多 Python 的内置函数值接受位置参数，可以使用 slash 斜杠 <code>/</code> 来指明。
例如 <code>func(x, y, /)</code>，这意味着在斜杠前面的参数只能通过位置参数指定。</p><p>这种定义并不常见，因为在 Python 3.8 才开始支持。
但这是一种有效的避免命名冲突的方法。
例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>after</span><span class=p>(</span><span class=n>seconds</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=o>/</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>duration</span><span class=p>(</span><span class=o>*</span><span class=p>,</span> <span class=n>seconds</span><span class=p>,</span> <span class=n>minutes</span><span class=p>,</span> <span class=n>hours</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>seconds</span> <span class=mi>60</span> <span class=o>*</span> <span class=n>minutes</span> <span class=o>+</span> <span class=mi>3600</span> <span class=o>*</span> <span class=n>hours</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>after</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=n>duration</span><span class=p>,</span> <span class=n>seconds</span><span class=o>=</span><span class=mi>20</span><span class=p>,</span> <span class=n>minutes</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=n>hours</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></div><p>在上面例子总，<code>after</code> 有个参数 <code>seconds</code>，同样 <code>duration</code> 也有一样的参数名称，通过强制要求位置参数，避免了变量命名的冲突。
这里的 <code>seconds=20</code> 被解析成关键字参数，通过 <code>**kwargs</code> 传递给 <code>duration</code> 函数。</p><h2 id=names-documentation-strings-and-type-hints>Names, Documentation Strings, and Type Hints<a hidden class=anchor aria-hidden=true href=#names-documentation-strings-and-type-hints>#</a></h2><p>标准的函数命名惯例使用小写字母和 undersocre 下划线作为分隔符。
如果一个函数不想被直接调用，比如内部的方法，使用单个下划线作为前置，例如 <code>_helper()</code>。</p><p>函数名称可以通过 <code>__name__</code> 属性获取，有时候调试非常有用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>square</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span>
</span></span><span class=line><span class=cl><span class=n>square</span><span class=o>.</span><span class=vm>__name__</span>  <span class=c1># &#39;square&#39;</span>
</span></span></code></pre></div><p>在函数的第一次声明的时候，使用文档字符串描述使用方式很常见，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>factorial</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Computes n factorial. For example:
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt; factorial(6)
</span></span></span><span class=line><span class=cl><span class=s2>    120
</span></span></span><span class=line><span class=cl><span class=s2>    &gt;&gt;&gt;
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span> <span class=o>*</span> <span class=n>factorial</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>文档字符串存储在函数属性 <code>__doc__</code> 里，IDE 经常会访问作为交互使用。</p><p>函数也可以添加类型提示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>factorial</span><span class=p>(</span><span class=n>n</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span> <span class=o>*</span> <span class=n>factorial</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>类型提示对函数的计算结果不会有任何影响，即没有任何额外的性能提示或运行时错误检查。
提示会存储在函数的 <code>__annotations__</code> 属性中，该属性是一个参数名称映射提示的字典，许多 IDE 和第三方工具会使用提示内容。</p><p>有时候提示会写在一个本地变量旁边，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>factorial</span><span class=p>(</span><span class=nb>int</span><span class=p>:</span> <span class=n>n</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>1</span>  <span class=c1># Type hinted local variable</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>n</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>*=</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><p>这种提示也会被解释器忽略，同样该提示是提供给第三方代码检查工具使用的。</p><h2 id=function-application-and-parameter-passing>Function Application and Parameter Passing<a hidden class=anchor aria-hidden=true href=#function-application-and-parameter-passing>#</a></h2><p>当函数被调用时，函数参数会成为局部名称，绑定到传入的输入对象。
Python 将传递的对象原样传递给函数，不进行任何额外的拷贝。
要小心如果可变类型作为参数传递，如果对象进行了任何修改，会影响到原来的对象。</p><p>例如这个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>square</span><span class=p>(</span><span class=n>items</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>items</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>items</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span>  <span class=c1># modify items in-place</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>suqare</span><span class=p>(</span><span class=n>s</span><span class=p>)</span>  <span class=c1># Change a to [1, 4, 9, 16, 25]</span>
</span></span></code></pre></div><p>会修改输入值的函数会产生“副作用”，一般的规则是避免这种情况。
这种函数也难以和多线程和并发程序交互，因为副作用通常会被锁保护。</p><p>当然，还要重点区分修改对象和重新分配 reassign 对象的区别，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>sum_squares</span><span class=p>(</span><span class=n>items</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span><span class=o>*</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>items</span><span class=p>]</span>  <span class=c1># Reassign &#34;items&#34; name</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>items</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>sum_squares</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>  <span class=c1># [1, 2, 3, 4, 5] (Unchanged)</span>
</span></span></code></pre></div><p>在这个例子中，<code>sum_squares</code> 函数看上去重写了 <code>items</code> 变量。
没错，标签 <code>items</code> 被重新分配了新的值。
然而，<code>items</code> 原始的值并没有被操作修改，而是将标签 <code>items</code> 绑定到了不同变量上面，即内部的列表推导式的值。
赋值给一个变量和修改一个对象是有区别的，当给一个变量赋值的时候，并不会重写已经存在的对象。
而是在给不同的对象重命名。</p><p>从风格上来讲，会产生“副作用”的函数通常会返回 <code>None</code> 作为结果。
例如列表的 <code>sort()</code> 函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>items</span> <span class=o>=</span> <span class=p>[</span><span class=mi>10</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>items</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span>  <span class=c1># Observe: no return value</span>
</span></span><span class=line><span class=cl><span class=n>items</span>  <span class=c1># [2, 3, 5, 9, 10]</span>
</span></span></code></pre></div><p>该 <code>sort()</code> 方法会将列表原地排序，并不返回值。
缺少返回值是一个强有力的“副作用”指标，在这个例子中列表被重新排序了。</p><p>有时候，你已经有值存储在序列 sqeuence 或字典 mapping 中了，要将他们传递给一个函数，在函数调用中使用 <code>*</code> 和 <code>**</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Pass a sequence as arguments</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Pass a mapping as keyword arguments</span>
</span></span><span class=line><span class=cl><span class=n>d</span> <span class=o>=</span> <span class=p>{</span><span class=s2>&#34;x&#34;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&#34;y&#34;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s2>&#34;z&#34;</span><span class=p>:</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=o>**</span><span class=n>d</span><span class=p>)</span>
</span></span></code></pre></div><p>如果从多个源获取数据，甚至显示提供部分参数，只要函数获得所有必须的参数、不含重复项，且调用前面中的所有内容都正确对齐，一切都会正常运行。
甚至可以在函数调用中多次使用 <code>*</code> 和 <code>**</code>，但如果确实值，或参数重复，将会遇到一个报错。</p><h2 id=return-values>Return Values<a hidden class=anchor aria-hidden=true href=#return-values>#</a></h2><p><code>return</code> 语句返回一个函数值，如果省略了返回或没有值，则返回 <code>None</code>。
如果要返回多个值，将他们放到一个元组中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_value</span><span class=p>(</span><span class=n>text</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Split text of the form name=val into (name, val)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>parts</span> <span class=o>=</span> <span class=n>text</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;=&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>parts</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>strip</span><span class=p>(),</span> <span class=n>parts</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>strip</span><span class=p>())</span>
</span></span></code></pre></div><p>返回的元组可以这样拆开成单个值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>name</span><span class=p>,</span> <span class=n>value</span> <span class=o>=</span> <span class=n>parse_value</span><span class=p>(</span><span class=s2>&#34;url=https//www.python.org&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>有时候可以使用 named tuples 具名元组替代：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>typing</span> <span class=kn>import</span> <span class=n>NamedTuple</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ParseResult</span><span class=p>(</span><span class=n>NamedTuple</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>    <span class=n>value</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_value</span><span class=p>(</span><span class=n>text</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    Split text of the form name=val into (name, val)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>parts</span> <span class=o>=</span> <span class=n>text</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;=&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ParseResult</span><span class=p>(</span><span class=n>parts</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>strip</span><span class=p>(),</span> <span class=n>parts</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>strip</span><span class=p>())</span>
</span></span></code></pre></div><p>具名元组和普通的元组一样，你可以进行同样的操作例如解包，但还可以通过名称属性来访问元素：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>r</span><span class=p>:</span> <span class=n>ParseResult</span> <span class=o>=</span> <span class=n>parse_value</span><span class=p>(</span><span class=s2>&#34;url=http://www.python.org&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>r</span><span class=o>.</span><span class=n>name</span><span class=p>,</span> <span class=n>r</span><span class=o>.</span><span class=n>vlaue</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=error-handling>Error Handling<a hidden class=anchor aria-hidden=true href=#error-handling>#</a></h2><p>上面的 <code>parse_value()</code> 函数没有错误处理，如果字符串不是预期的格式应该怎么办？
一种方式是将结果视为可选的，即函数要么返回结果，要么返回 <code>None</code>，这个常用于表示缺失值。
例如，该函数可以这样修改：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_value</span><span class=p>(</span><span class=n>text</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>parts</span> <span class=o>=</span> <span class=n>text</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;=&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>parts</span><span class=p>)</span> <span class=o>==</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ParseResult</span><span class=p>(</span><span class=n>parts</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>strip</span><span class=p>(),</span> <span class=n>parts</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>strip</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span></code></pre></div><p>使用这种设计，结果检测的重担就传递给了调用者：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>parse_value</span><span class=p>(</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>result</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=p>,</span> <span class=n>value</span> <span class=o>=</span> <span class=n>result</span>
</span></span></code></pre></div><p>或者使用更紧凑的 Python 3.8 新语法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>if</span> <span class=n>result</span> <span class=o>:=</span> <span class=n>parse_value</span><span class=p>(</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=p>,</span> <span class=n>value</span> <span class=o>=</span> <span class=n>result</span>
</span></span></code></pre></div><p>除了返回 <code>None</code>，也可以遇到错误文本时抛出异常：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_value</span><span class=p>(</span><span class=n>text</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>parts</span> <span class=o>=</span> <span class=n>tex</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;=&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>parts</span><span class=p>)</span> <span class=o>==</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>PraseResult</span><span class=p>(</span><span class=n>parts</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>strip</span><span class=p>(),</span> <span class=n>parts</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>strip</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;Bad value&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>在这个情况下，调用者使用 <code>try-except</code> 语句来处理错误：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=p>,</span> <span class=n>value</span> <span class=o>=</span> <span class=n>prase_value</span><span class=p>(</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>except</span> <span class=ne>ValueError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></div><p>是否要使用异常处理并不总是明确的。
一般而言，异常是更常见的异常处理方式。
但异常处理会更加昂贵，如果在编写一些性能要求高的代码，应该返回 <code>None</code>, <code>False</code>, <code>-1</code> 或者其他的特殊值来表示错误。</p><h2 id=scoping-rules>Scoping Rules<a hidden class=anchor aria-hidden=true href=#scoping-rules>#</a></h2><p>每次执行一个函数，都会创建一个命名空间。
这个命名空间代表一个环境，包含了函数参数的名称和值，以及函数体内赋值的所有变量。
函数内部赋值的变量是局部变量，直接引用但未赋值的变量会到函数定义所在的模块的全局作用域中查找。</p><p>有两类和命名相关的错误，在全局环境查找一个未定义的自由变量会产生 <code>NameError</code> 异常。
查询一个未赋值的本地变量会产生一个 <code>UnboundLocalError</code> 异常，这种错误通常源于控制流缺陷。</p><p>比如这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>y</span> <span class=o>=</span> <span class=mi>42</span>  <span class=c1># y not assigned if conditional is false</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>(</span><span class=o>-</span><span class=mi>10</span><span class=p>)</span>  <span class=c1># UnboundLocalError: y referenced before assigment</span>
</span></span></code></pre></div><p>或者是原地计算产生的错误：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>+=</span> <span class=mi>1</span>  <span class=c1># Error: UnboundLocalError</span>
</span></span></code></pre></div><p>需要强调的是，变量名的作用域永远不会改变，要么是全局变量，要么是局部变量，这取决于函数定义时的设定。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>  <span class=c1># UnboundLocalError</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=mi>12</span>
</span></span></code></pre></div><p>上面例子看上去好像能正常运行，但实际上由于下面 <code>x = 12</code> 的赋值，x 实际上是局部变量，且还未定义，因此会报错。</p><p>如果要在函数内修改外部变量，使用 <code>global</code> 关键字：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=mi>37</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=mi>13</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>()</span>  <span class=c1># x is 13, y is sitll 37</span>
</span></span></code></pre></div><p>但使用 <code>global</code> 并不是特别符合 Python 风格。
如果要通过函数修改状态，考虑使用类定义，并通过修改实例变量或类变量来实现状态变化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Config</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>Config</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=mi>13</span>
</span></span></code></pre></div><p>Python 允许嵌套函数定义，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>countdown</span><span class=p>(</span><span class=n>start</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=n>start</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>display</span><span class=p>():</span>  <span class=c1># Nested function definition</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T-minus&#34;</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>n</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>display</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span></code></pre></div><p>嵌套函数中的变量通过词法作用域绑定。
也就是说，名称首先在局部作用域解析，然后从最内层作用域到最外层作用域，依次在连续的封闭作用域中解析。
同样，这个过程不是动态的，名称的绑定是在函数定义时根据语法一次性确定的。</p><p>例如，下面这段代码不会工作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>countdown</span><span class=p>(</span><span class=n>start</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=n>start</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>display</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T-minus&#34;</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>decrement</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>-=</span> <span class=mi>1</span>  <span class=c1># UnboundLocalError: 局部变量在赋值前被引用</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>n</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>display</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>decrement</span><span class=p>()</span>
</span></span></code></pre></div><p>要修复这段代码，使用 <code>nonlocal</code> 关键字，声明该变量来自外层函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>countdown</span><span class=p>(</span><span class=n>start</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=n>start</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>display</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T-minus&#34;</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>decrement</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>nonlocal</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>n</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>display</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>decrement</span><span class=p>()</span>
</span></span></code></pre></div><p><code>nonlocal</code> 不能用于引用全局变量，它必须指向外层作用域中的局部变量。
因此，如果一个变量是全局的，还是应该使用 <code>global</code> 关键字。</p><h2 id=recursion>Recursion<a hidden class=anchor aria-hidden=true href=#recursion>#</a></h2><p>Python 支持递归函数，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>sumn</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span> <span class=o>+</span> <span class=n>sumn</span><span class=p>(</span><span class=n>n</span><span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>但递归深度是有限制的，函数 <code>sys.getrecursionlimit()</code> 返回当前最大的递归深度，使用函数 <code>sys.setrecursionlimit()</code> 可以修改该值。
尽管可以改变递归深度，但栈的大小仍然受操作系统的限制。
当超出最大递归深度后，会抛出一个 <code>RuntimeError</code>。
如果限制递归深度太高，Python 可能会因 segmentation error 段错误或其他操作系统错误而崩溃。</p><p>在实践中，一般递归限制只会在使用树或图这类深度嵌套数据结构的时候，才会导致递归深度的问题。</p><h2 id=the-lambda-expression>The lambda Expression<a hidden class=anchor aria-hidden=true href=#the-lambda-expression>#</a></h2><p>一个匿名函数可以使用 <code>lambda</code> 关键字定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>lambda</span> <span class=n>args</span><span class=p>:</span> <span class=n>expression</span>
</span></span></code></pre></div><p>args 是一个由逗号分隔的参数列表，而 expression 则是这些参数的表达式，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl><span class=n>r</span> <span class=o>=</span> <span class=n>a</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># r gets 5</span>
</span></span></code></pre></div><p>使用 lambda 定义的代码必须是一个合理的表达式，多个语句以及其他非表达式语句，例如 try 和 while，不能出现在 lambda 表达式中。
lambda 表达式也遵循和函数一样的作用域。</p><p>一个使用 lambda 的例子是定义小的回调函数，例如你可能在 <code>sorted()</code> 函数中这样使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>words</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>word</span><span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=nb>set</span><span class=p>(</span><span class=n>word</span><span class=p>)))</span>  <span class=c1># len(set(str)) 是不重复字符数量</span>
</span></span></code></pre></div><p>如果 lambda 中含有自由变量则需要注意：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=n>f</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>y</span><span class=p>:</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>g</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>y</span><span class=p>:</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>  <span class=c1># 30</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>g</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>  <span class=c1># 30</span>
</span></span></code></pre></div><p>函数 <code>f(10)</code> 使用调用时 x 的值，而不是函数定义时 x 的值，这种行为被称为 late-binding 延迟绑定。</p><p>在定义时绑定值使用 default arguemnt 默认参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=n>f</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>y</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>g</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>y</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>f</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>  <span class=c1># 20</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>g</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>  <span class=c1># 30</span>
</span></span></code></pre></div><p>这是因为 default argument 默认参数值仅在函数定义时被求值，因此会捕获变量x的当前值。</p><h2 id=higher-order-functions>Higher Order Functions<a hidden class=anchor aria-hidden=true href=#higher-order-functions>#</a></h2><p>Python 支持 &ldquo;higher-order functions&rdquo; 高阶函数的概念，这意味着函数可以作为参数传递给其他函数，存储数据结构中，并作为结果返回。
有时候会说函数是 &ldquo;first-class&rdquo; 一等公民，意味着函数和其他数据类型没有区别。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>after</span><span class=p>(</span><span class=n>seconds</span><span class=p>,</span> <span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>greeting</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Hello World&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>after</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=n>greeting</span><span class=p>)</span>
</span></span></code></pre></div><p>在这个例子中，<code>after()</code> 函数的 <code>func</code> 参数就是所谓的 &ldquo;callback function&rdquo; 回调函数，这是指 after 会回调作为参数的函数。</p><p>当函数作为数据传递的时候，它会显示地携带函数定时时，关于环境的信息。
例如下面这个例子，<code>greeting()</code> 函数是这样使用变量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;Guido&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>greeting</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Hello&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>after</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=n>greeting</span><span class=p>)</span>  <span class=c1># Hello Guido</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>main</span><span class=p>()</span>
</span></span></code></pre></div><p>在这个例子中，变量 <code>name</code> 被 <code>greeting()</code> 调用，但 <code>name</code> 是 <code>main</code> 函数的本地变量。
当 <code>greeting</code> 传递给 <code>after()</code>，该函数会记得其环境，并使用环境中的 name 变量。
该特性被称为 &ldquo;closure&rdquo; 闭包。</p><p><strong>Closure</strong> <strong>闭包</strong>是一个函数及其执行函数体所需的变量所构成的环境。
闭包与嵌套函数在编写基于惰性或延迟求值的概念的代码时尤其有用。
如上面的 <code>after()</code> 函数，它不会接收一个立刻执行的函数，该函数会在之后的某个时间点才被调用，该编程模式在其他场景中也很常见。</p><p>例如，程序可能仅在响应事件时才执行的函数（如按键、鼠标移动、网络数据包到达等）。
在所有这些情况下，函数求值会延迟到发生某些有意义的事件时再进行。
当函数最后执行的时候，闭包确保函数能获取到它所需要的一切。</p><p>你也可以这样编写和创建函数，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>make_greeting</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>greeting</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Hello&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>greeting</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>f</span> <span class=o>=</span> <span class=n>make_greeting</span><span class=p>(</span><span class=s2>&#34;Guido&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>g</span> <span class=o>=</span> <span class=n>make_greeting</span><span class=p>(</span><span class=s2>&#34;Ada&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>()</span>  <span class=c1># Hello Guido</span>
</span></span><span class=line><span class=cl><span class=n>g</span><span class=p>()</span>  <span class=c1># Hello Ada</span>
</span></span></code></pre></div><p>在这个例子中，<code>make_greeting()</code> 函数并不会携带有任何有意义的计算。
相反，它创建并返回了一个真正执行任务的 <code>greeting()</code> 函数。
这种情况只会在函数被求值后发生。</p><p>在上面例子中，<code>f</code> 和 <code>g</code> 函数是两个版本的 <code>greeting()</code> 函数。
尽管创建这些函数的 <code>make_greeting()</code> 函数已不再执行，但 <code>greeting()</code> 函数仍能记住已定义的 <code>name</code> 变量，这是函数闭包的一部分。</p><p>关于闭包需要注意的一点是，对变量名的绑定并非“快照”，而是一个动态过程。
这意味着，闭包指向的是变量名及其最近被赋予的值。
下面示例说明了可能引发的情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>make_greetings</span><span class=p>(</span><span class=n>names</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>funcs</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>name</span> <span class=ow>in</span> <span class=n>names</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>funcs</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=k>lambda</span><span class=p>:</span> <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Hello&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>funcs</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span> <span class=o>=</span> <span class=n>make_greetings</span><span class=p>([</span><span class=s2>&#34;Guido&#34;</span><span class=p>,</span> <span class=s2>&#34;Ada&#34;</span><span class=p>,</span> <span class=s2>&#34;Margaret&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>()</span>  <span class=c1># Hello Margaret</span>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=p>()</span>  <span class=c1># Hello Margaret</span>
</span></span><span class=line><span class=cl><span class=n>c</span><span class=p>()</span>  <span class=c1># Hello Margaret</span>
</span></span></code></pre></div><p>在这个例子中，列表中不同的函数使用 lambda 构造，他们看起来似乎都使用了唯一的 name 值。
但实际上是，所有函数都会使用同一个 name 值，无论该值是在外部 <code>make_greetings()</code> 函数返回时如何设置的。
因为 <code>lambda</code> 函数中的 <code>name</code> 变量是一个自由变量，它会在函数执行时才查找值，而不是在定义时（for 不会创建新的作用域）。</p><p>正确的方式可以使用默认参数进行捕获：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>make_greetings</span><span class=p>(</span><span class=n>names</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>funcs</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>name</span> <span class=ow>in</span> <span class=n>names</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>func</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=k>lambda</span> <span class=n>name</span><span class=o>=</span><span class=n>name</span><span class=p>:</span> <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Hello&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>funcs</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span> <span class=o>=</span> <span class=n>make_greetings</span><span class=p>([</span><span class=s2>&#34;Guido&#34;</span><span class=p>,</span> <span class=s2>&#34;Ada&#34;</span><span class=p>,</span> <span class=s2>&#34;Margaret&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>()</span>  <span class=c1># Hello Guido</span>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=p>()</span>  <span class=c1># Hello Ada</span>
</span></span><span class=line><span class=cl><span class=n>c</span><span class=p>()</span>  <span class=c1># Hello Margaret</span>
</span></span></code></pre></div><p>或者这样</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>make_greetings</span><span class=p>(</span><span class=n>names</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>funcs</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>names</span> <span class=ow>in</span> <span class=n>names</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>greeting</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Hello&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>funcs</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>greeting</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>funcs</span>
</span></span></code></pre></div><h2 id=argument-passing-in-callback-functions>Argument Passing in Callback Functions<a hidden class=anchor aria-hidden=true href=#argument-passing-in-callback-functions>#</a></h2><p>使用 callback function 回调函数时，一个具有挑战性的编码问题是如何向提供的函数传递参数。
考虑之前的 <code>after()</code> 函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>after</span><span class=p>(</span><span class=n>seconds</span><span class=p>,</span> <span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=p>()</span>
</span></span></code></pre></div><p>在这个例子中，<code>func</code> 是硬编码且没有参数的。
如果你想要解析额外的参数，那就不好用了，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>add</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>x</span><span class=si>}</span><span class=s2> + </span><span class=si>{</span><span class=n>y</span><span class=si>}</span><span class=s2> -&gt; </span><span class=si>{</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl><span class=n>after</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span>  <span class=c1># Fails: add() called immediately</span>
</span></span></code></pre></div><p>在这个例子中，在这个例子中，<code>add(2, 3)</code> 函数立即执行并返回结果 5。
随后，<code>after()</code> 函数在 10 秒后尝试执行 <code>5()</code> 时崩溃。</p><p>这显然不是这段代码的本意，这个问题暗示了一个更广泛的设计议题。
即关于函数及函数式编程的整体运用，特别是与函数组合相关的方面。
当函数通过各种方式混合在一起的时候，你通常需要思考函数的输入与输出如何相互连接。</p><p>这个例子的一种解决方案是，使用无参数 lambda 函数打包，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>after</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=k>lambda</span><span class=p>:</span> <span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span>
</span></span></code></pre></div><p>这样的小型 zero-argument 零参数函数有时被称为 &ldquo;thunk&rdquo; (延迟计算或惰性求值)。
基本上，它代表一个表达式，该表达式将在最终被作为无参数函数调用时进行求值。
这可以作为一种通用方法，将任何表达式的求值延迟到稍后的时间点，将表达式放入 lambda 函数中，并在实际需要该值时调用该函数。</p><p>作为 lambda 的一种替代方案，可以使用 <code>functools.partial()</code> 来创建一个部分求值的函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>partial</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>after</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=n>partial</span><span class=p>(</span><span class=n>add</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span>
</span></span></code></pre></div><p><code>partial()</code> 这里扮演一个函数工厂的角色，它不立刻计算结果，而是生成一个新的函数。
在未来需要被调用的时候，才去真实调用该函数。
这是一种有效的方法，可以使非标准函数在回调和其他应用中，匹配预期的调用签名。</p><p>下面是更多例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>d</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>f</span> <span class=o>=</span> <span class=n>partial</span><span class=p>(</span><span class=n>func</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>    <span class=c1># func(1, 2, 3, 4)</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>)</span>  <span class=c1># func(1, 2, 10, 20)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>g</span> <span class=o>=</span> <span class=n>partial</span><span class=p>(</span><span class=n>func</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>d</span><span class=o>=</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>g</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>   <span class=c1># func(1, 2, 3, 4)</span>
</span></span><span class=line><span class=cl><span class=n>g</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>  <span class=c1># func(1, 2, 10, 4)</span>
</span></span></code></pre></div><p><code>partial()</code> 和 <code>lambda</code> 都有类似的目的，但两种方法在语义上有重大区别。
使用 <code>partial()</code> 时，参数会在偏函数首次定义时被求值并绑定；
而使用无参 <code>lambda</code> 时，参数的实际求值和绑定会延迟至该 <code>lambda</code> 函数后续真正执行时才发生（求值都被延迟了）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>f</span> <span class=o>=</span> <span class=k>lambda</span><span class=p>:</span> <span class=n>func</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>g</span> <span class=o>=</span> <span class=n>partial</span><span class=p>(</span><span class=n>func</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=p>()</span>  <span class=c1># 使用当前的 a=10, b=20 的值</span>
</span></span><span class=line><span class=cl><span class=n>g</span><span class=p>()</span>  <span class=c1># 使用初始的 a=2, b=3 的值</span>
</span></span></code></pre></div><p>由于 partials 偏函数会计算出函数结果，由 <code>partial()</code> 创建的可调用对象是可以序列化为字节、保存到文件中，甚至通过网络传输的对象。
但使用 <code>lambda</code> 函数就不可能实现，因此在需要传递函数，尤其是可能传递给不同进程或不同机器上的 Python 解释器的应用场景中，<code>partial()</code> 根据适应性。</p><p>部分函数应用和一种 &ldquo;currying&rdquo; 柯里化的应用密切相关。
柯里化是一种函数式编程的技术，将多参数函数表示为单参数函数的嵌套函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># 3 参数函数</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>+</span> <span class=n>z</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Curried version</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fc</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>lambda</span> <span class=n>y</span><span class=p>:</span> <span class=p>(</span><span class=k>lambda</span> <span class=n>z</span><span class=p>:</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span> <span class=o>+</span> <span class=n>z</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>f</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=n>fc</span><span class=p>(</span><span class=mi>2</span><span class=p>)(</span><span class=mi>3</span><span class=p>)(</span><span class=mi>4</span><span class=p>)</span>
</span></span></code></pre></div><p>回到之前的参数传递问题，另一种传递参数的方法是将其视作外部调用函数的独立参数来接收。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>after</span><span class=p>(</span><span class=n>seconds</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>after</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=n>add</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># 10 秒后调用 add(2, 3)</span>
</span></span></code></pre></div><p>你会发现，在 func() 中传递关键字参数是不被允许的。
这就是这样设计的，因为如果允许使用关键字参数，则可能会和 <code>after</code> 的参数 seconds 产生冲突。
关键字参数可能被保留用于指定 <code>after()</code> 函数本身的选项，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>after</span><span class=p>(</span><span class=n>seconds</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=n>debug</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>debug</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;About to call&#34;</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>)</span>
</span></span></code></pre></div><p>然而并非全无希望，如果需要为 <code>func()</code> 指定关键字参数，仍然可以通过 partial() 实现，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>after</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=n>partial</span><span class=p>(</span><span class=n>add</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=mi>3</span><span class=p>),</span> <span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></div><p>如果想要让 <code>after()</code> 接受关键字参数，一个安全的方式是只允许使用位置参数传递值，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>after</span><span class=p>(</span><span class=n>seconds</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=n>debug</span><span class=o>=</span><span class=kc>False</span><span class=p>,</span> <span class=o>/</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>debug</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;About to call&#34;</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=n>args</span><span class=p>,</span> <span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>after</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=n>add</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
</span></span></code></pre></div><p>另一个让人不安的洞见是，<code>after()</code> 的参数实际上是两个不同函数的参数合并。
或许传递参数的问题可以分解为两个函数，例如这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>after</span><span class=p>(</span><span class=n>seconds</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=n>debug</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>call</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>debug</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;About to call&#34;</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=n>args</span><span class=p>,</span> <span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>call</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>after</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=n>add</span><span class=p>)(</span><span class=mi>2</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
</span></span></code></pre></div><p>现在，<code>after()</code> 函数的参数与 <code>func</code> 函数的参数之间没有任何冲突。
然而，这样做可能会和同事之间发生冲突 XD &mldr;</p><h2 id=returning-results-from-callbacks>Returning Results from Callbacks<a hidden class=anchor aria-hidden=true href=#returning-results-from-callbacks>#</a></h2><p>另一个没有说的问题是关于返回计算结果，例如 <code>aftre()</code> 函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>after</span><span class=p>(</span><span class=n>seconds</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>)</span>
</span></span></code></pre></div><p>在异常处理的时候有两种情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>after</span><span class=p>(</span><span class=s2>&#34;1&#34;</span><span class=p>,</span> <span class=n>add</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># Fails: TypeError (integer is excepted)</span>
</span></span><span class=line><span class=cl><span class=n>after</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>add</span><span class=p>,</span> <span class=s2>&#34;2&#34;</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># Fails: TypeError (can&#39;t concatenate int to str)</span>
</span></span></code></pre></div><p>上例中，两个都抛出 <code>TypeError</code>，但原因却不同。
第一个是 <code>after()</code> 函数导致的错误，第二个是 <code>func()</code> 函数导致的错误。
一个解决思路是将 call function 回调函数中的错误以不同方式封装，使其能够与其他类型的错误分开处理。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>CallbackError</span><span class=p>(</span><span class=ne>Exception</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>after</span><span class=p>(</span><span class=n>seconds</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>err</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=n>CallbackError</span><span class=p>(</span><span class=s2>&#34;Callback function failed&#34;</span><span class=p>)</span> <span class=kn>from</span> <span class=nn>err</span>
</span></span></code></pre></div><p>这段修改后的代码将来自所提供回调函数的错误隔离到其自身的异常类型中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=n>after</span><span class=p>(</span><span class=n>delay</span><span class=p>,</span> <span class=n>add</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>except</span> <span class=n>CallbackError</span> <span class=k>as</span> <span class=n>err</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;It failed, Reason&#34;</span><span class=p>,</span> <span class=n>err</span><span class=o>.</span><span class=n>__cause__</span><span class=p>)</span>
</span></span></code></pre></div><p>如果 <code>after()</code> 本身的执行出现问题，该异常将未经捕获地向外传播。
另一方面，与所提供回调函数实际执行相关的问题会被捕获并报告为 CallbackError。
这一切都相当微妙，在实践中，异常处理很难。
这种方式让责任归属更加明确，同时 <code>after()</code> 的行为也更容易记录。
如果回调函数出现问题，则总是报告为 <code>CallbackError</code>。</p><p>另一种方法是将结果包装到实例中去，包含了结果和错误信息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Result</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>exc</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_exc</span> <span class=o>=</span> <span class=n>exc</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>result</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_exc</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=bp>self</span><span class=o>.</span><span class=n>_exc</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_value</span>
</span></span></code></pre></div><p>然后使用这个类作为 <code>after()</code> 函数的返回值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>after</span><span class=p>(</span><span class=n>seconds</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>seconds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Result</span><span class=p>(</span><span class=n>value</span><span class=o>=</span><span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>err</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Result</span><span class=p>(</span><span class=n>exc</span><span class=o>=</span><span class=n>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>r</span> <span class=o>=</span> <span class=n>after</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>add</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>r</span><span class=o>.</span><span class=n>result</span><span class=p>())</span>  <span class=c1># 5</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>after</span><span class=p>(</span><span class=s2>&#34;1&#34;</span><span class=p>,</span> <span class=n>add</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># TypeError</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=n>after</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>add</span><span class=p>,</span> <span class=s2>&#34;2&#34;</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># Return a &#34;Result&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>t</span><span class=o>.</span><span class=n>result</span><span class=p>())</span>
</span></span></code></pre></div><p>第二种方法的工作原理是将回调函数的结果推迟到一个独立的步骤中。
如果 <code>after()</code> 出现问题，会立刻报告；
而如果回调函数 <code>func()</code> 出现问题，则会在用户尝试通过调用 <code>result()</code> 方法获取结果时报告。</p><p>这种将结果封装在特定实例中，以便后续解包的编程风格在现代编程语言中正变得越来越普遍。
一个这样做的动机是因为能够促进类型提示，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>after</span><span class=p>(</span><span class=n>seconds</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></div><p>尽管在大多数 Python 代码中，这类模式并不常见，但在处理线程和进程等并发原语时，会频繁出现。
例如，在使用线程池时，所谓的 Fruture 实例就表现出这种行为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>concurrent.futures</span> <span class=kn>import</span> <span class=n>ThreadPoolExecutor</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>pool</span> <span class=o>=</span> <span class=n>ThreadPoolExecutor</span><span class=p>(</span><span class=mi>16</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>r</span> <span class=o>=</span> <span class=n>pool</span><span class=o>.</span><span class=n>submit</span><span class=p>(</span><span class=n>add</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># Returns a Future</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>r</span><span class=o>.</span><span class=n>result</span><span class=p>())</span>           <span class=c1># Unwarp the Future result</span>
</span></span></code></pre></div><h2 id=decorators>Decorators<a hidden class=anchor aria-hidden=true href=#decorators>#</a></h2><p>装饰器是一个函数，它能够为另一个函数创建包装器。
包装的主要目的是为了修改或增强被包装对象的行为。
语法上，装饰器使用 <code>@</code> 符号来表示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=nd>@decorate</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></div><p>前面代码是下面的简写形式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>func</span> <span class=o>=</span> <span class=n>decorate</span><span class=p>(</span><span class=n>func</span><span class=p>)</span>
</span></span></code></pre></div><p>在这个例子中，定义了函数 <code>func()</code>，但马上将该函数作为参数传递给 <code>docorate()</code>，并返回一个新的对象替代掉原始的 <code>func</code> 函数。</p><p>下面看一个具体的例子，使用 <code>@trace</code> 装饰器为函数添加调试信息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>trace</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>call</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Calling&#34;</span><span class=p>,</span> <span class=n>func</span><span class=o>.</span><span class=vm>__name__</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>call</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example</span>
</span></span><span class=line><span class=cl><span class=nd>@trace</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>square</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span>
</span></span></code></pre></div><p>这段代码中，<code>trace</code> 创建了一个装饰器，输出函数的调试信息，然后再调用函数。
看上去十分简单，但在实际中，函数还会含有一些元信息，例如函数名称、doc string 和 type hints 类型提示等。
如果直接使用上面的函数来包装，会将这些信息隐藏。
因此，编写装饰器时常用 <code>@wraps()</code> 装饰器，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>wraps</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>trace</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nd>@wraps</span><span class=p>(</span><span class=n>func</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>call</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Calling&#34;</span><span class=p>,</span> <span class=n>func</span><span class=o>.</span><span class=vm>__name__</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>call</span>
</span></span></code></pre></div><p><code>@wraps()</code> 装饰器会将函数的元数据复制到要替换的函数上，在这个例子中 <code>func()</code> 函数的元数据被复制到了 <code>call()</code> 包装器函数上。</p><p>使用装饰器时，其必须放在函数的上面一行，一个函数可以应用更多的装饰器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=nd>@docorator1</span>
</span></span><span class=line><span class=cl><span class=nd>@docorator2</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><p>在这个例子中，装饰器等同于这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>func</span> <span class=o>=</span> <span class=n>docorator1</span><span class=p>(</span><span class=n>decorator2</span><span class=p>(</span><span class=n>func</span><span class=p>))</span>
</span></span></code></pre></div><p>装饰器的顺序可能会很重要。
例如在类定义中，<code>@classmethod</code> 和 <code>@staticmethod</code> 总是需要放到最外层。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>SomeClass</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>  <span class=c1># Yes</span>
</span></span><span class=line><span class=cl>    <span class=nd>@calssmethod</span>
</span></span><span class=line><span class=cl>    <span class=nd>@trace</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>a</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@trace</span>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>a</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>           <span class=c1># No. Fails</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span></code></pre></div><p>这种放置限制的原因与 <code>@classmethod</code> 返回的值有关。
有时装饰器会返回一个不同于普通函数的对象。
如果最外层装饰器未预料到这种情况，则会崩溃。
在这种情况下，<code>@classmethod</code> 会创建一个类方法描述符对象。
除非 <code>@trace</code> 装饰器在设计时已考虑到这一点，否则装饰器顺序不当会使装饰器失效。</p><p>装饰器也能够接受参数，例如，修改 <code>@trace</code> 装饰器来支持自定义信息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=nd>@trace</span><span class=p>(</span><span class=s2>&#34;You called </span><span class=si>{func.__name}</span><span class=s2>&#34;</span><span class=p>)</span>  <span class=c1># f-string 是立刻求值的，不能在这里使用</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><p>提供参数的装饰器语义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Create the decorator function</span>
</span></span><span class=line><span class=cl><span class=n>temp</span> <span class=o>=</span> <span class=n>trace</span><span class=p>(</span><span class=s2>&#34;You called </span><span class=si>{func.__name__}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Apply it to func</span>
</span></span><span class=line><span class=cl><span class=n>func</span> <span class=o>=</span> <span class=n>temp</span><span class=p>(</span><span class=n>func</span><span class=p>)</span>
</span></span></code></pre></div><p>在这种情况下，接受参数的最外层函数负责创建装饰器函数。
随后，该函数会与待装饰的函数一同调用，以获取最终结果。</p><p>以下是装饰器可能实现的样子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>wraps</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>trace</span><span class=p>(</span><span class=n>message</span><span class=p>):</span>      <span class=c1># message: 装饰参数</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>decorate</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>  <span class=c1># func: 装饰函数</span>
</span></span><span class=line><span class=cl>        <span class=nd>@wraps</span><span class=p>(</span><span class=n>func</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>wrapper</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>message</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>func</span><span class=o>=</span><span class=n>func</span><span class=p>))</span>  <span class=c1># str.format() 延迟求值</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>wrapper</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>decorate</span>
</span></span></code></pre></div><p>这种实现的一个有趣特性是，外层函数实际上是一种 &ldquo;decorator factory&rdquo; 装饰器工厂。</p><p>假如这样写代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=nd>@trace</span><span class=p>(</span><span class=s2>&#34;You called </span><span class=si>{func.__name__}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func1</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@trace</span><span class=p>(</span><span class=s2>&#34;You called </span><span class=si>{func.__name__}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func2</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><p>但这样会显得很繁琐，你可以通过调用外部装饰器函数一次，并重复使用其结果来简化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>logged</span> <span class=o>=</span> <span class=n>trace</span><span class=p>(</span><span class=s2>&#34;You called </span><span class=si>{func.__name__}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@logged</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func1</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@logged</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func2</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><p>装饰器不一定要替换原始函数。
有时，装饰器仅执行诸如注册之类的操作。
例如，如果你正在构建一个事件处理器的注册列表，你可能希望定义一个这样工作的装饰器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=nd>@eventhandler</span><span class=p>(</span><span class=s2>&#34;BUTTON&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_button</span><span class=p>(</span><span class=n>msg</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@eventhandler</span><span class=p>(</span><span class=s2>&#34;RESET&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_reset</span><span class=p>(</span><span class=n>msg</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></div><p>下面是管理装饰器定义:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># Event handler decorator</span>
</span></span><span class=line><span class=cl><span class=n>_event_handlers</span> <span class=o>=</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>eventhandler</span><span class=p>(</span><span class=n>event</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>register_function</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>_event_handlers</span><span class=p>[</span><span class=n>event</span><span class=p>]</span> <span class=o>=</span> <span class=n>func</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>func</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>register_function</span>
</span></span></code></pre></div><h2 id=map-filter-and-reduce>Map, Filter, and Reduce<a hidden class=anchor aria-hidden=true href=#map-filter-and-reduce>#</a></h2><p>熟悉函数式编程的程序员可能想知道常见的列表操作，如 map 映射, filter 过滤和 reduce 归约。
多部分这些功能都可以对列表推导式和生成器表达式有效：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>square</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>nums</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>squares</span> <span class=o>=</span> <span class=p>[</span><span class=n>square</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>nums</span><span class=p>]</span> <span class=c1># [1, 4, 9, 16, 25]</span>
</span></span></code></pre></div><p>你甚至不需要这个单行函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>squares</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=o>*</span> <span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>nums</span><span class=p>]</span>
</span></span></code></pre></div><p>其中也可以进行过滤 filtering</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>nums</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>]</span>  <span class=c1># [3, 4 ,5]</span>
</span></span></code></pre></div><p>内置函数 <code>map()</code>，其功能与使用生成器表达式映射函数相同。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>squares</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=o>*</span><span class=n>x</span><span class=p>,</span> <span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>squares</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span></code></pre></div><p>该内置函数会创建一个过滤值的生成器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=nb>filter</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>,</span> <span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span></code></pre></div><p>如果要累加或减去值，使用 <code>functools.reduce()</code>，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>reduce</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>nums</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>total</span> <span class=o>=</span> <span class=n>reduce</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>,</span> <span class=n>nums</span><span class=p>)</span>  <span class=c1># 15</span>
</span></span><span class=line><span class=cl><span class=n>product</span> <span class=o>=</span> <span class=n>reduce</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span><span class=p>,</span> <span class=n>nums</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1># 120</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>pairs</span> <span class=o>=</span> <span class=n>reduce</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>),</span> <span class=n>nums</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>  <span class=c1># (((((None, 1), 2), 3), 4), 5)</span>
</span></span></code></pre></div><p><code>reduce()</code> 接受一个两个参数的函数，一个可迭代对象和一个初始值。
从左到右对提供的可迭代对象jinx值累积，这有时被称为 &ldquo;left-fold&rdquo; 左折叠操作。</p><p>下面是伪代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>reduce</span><span class=p>(</span><span class=n>func</span><span class=p>,</span> <span class=n>items</span><span class=p>,</span> <span class=n>initial</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>initial</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>item</span> <span class=ow>in</span> <span class=n>items</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></div><p>经验表明，使用 <code>reduce()</code> 有时会令人赶到困惑。
此外，常见的归约操作，如 <code>sum()</code>、<code>min()</code> 和 <code>max()</code> 已内置在语言中。
使用这些内置操作比 <code>reduce()</code> 更加容易理解。</p><h2 id=function-introspection-attributes-and-signatures>Function Introspection, Attributes, and Signatures<a hidden class=anchor aria-hidden=true href=#function-introspection-attributes-and-signatures>#</a></h2><p>如前所述，函数也是对象，这意味着他们可以被复制给变量、存储在数据结构中，并可以像程序中其他类型数据一样使用。
他们也可以通过多种方式进行查看。
下表展示了函数的一些常见属性，其中许多属性在调试、日志记录以及其他涉及函数的操作中非常有用。</p><table><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td><code>f.__name__</code></td><td>Function name</td></tr><tr><td><code>f.__qualname__</code></td><td>Fully qualified name</td></tr><tr><td><code>f.__module__</code></td><td>Name of module in which defined</td></tr><tr><td><code>f.__doc__</code></td><td>Documentation string</td></tr><tr><td><code>f.__annotations__</code></td><td>Type hints</td></tr><tr><td><code>f.__globals__</code></td><td>Dictionary that is the global namespace</td></tr><tr><td><code>f.__closure__</code></td><td>Closure variables</td></tr><tr><td><code>f.__code__</code></td><td>Underlying code object</td></tr></tbody></table><ul><li><p><code>f.__qualname__</code> 是包含嵌套格式的完整路径名 <code>外层类名.内层类名.方法名</code> 或 <code>外层函数.内层函数名</code></p></li><li><p><code>f.__module__</code> 是一个包含模块名称的字符串</p></li><li><p><code>f.__globals__</code> 是一个字典，包含函数定义时的全局命名空间，类似这样</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;__name__&#39;</span><span class=p>:</span> <span class=s1>&#39;__main__&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;__doc__&#39;</span><span class=p>:</span> <span class=kc>None</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;__package__&#39;</span><span class=p>:</span> <span class=kc>None</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;__loader__&#39;</span><span class=p>:</span> <span class=o>&lt;...&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;__spec__&#39;</span><span class=p>:</span> <span class=kc>None</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;__annotations__&#39;</span><span class=p>:</span> <span class=p>{},</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;__builtins__&#39;</span><span class=p>:</span> <span class=o>&lt;</span><span class=n>module</span> <span class=s1>&#39;builtins&#39;</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;__file__&#39;</span><span class=p>:</span> <span class=s1>&#39;test.py&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;x&#39;</span><span class=p>:</span> <span class=mi>10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=s1>&#39;f&#39;</span><span class=p>:</span> <span class=o>&lt;</span><span class=n>function</span> <span class=n>f</span> <span class=n>at</span> <span class=mi>0</span><span class=n>x</span><span class=o>...&gt;</span>
</span></span><span class=line><span class=cl>  <span class=c1># ... 还有很多内置属性</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p><code>f.__closure__</code> 保存了嵌套函数中闭包变量的引用值</p><p>这可能不太显眼，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>add</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>do_add</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>do_add</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=vm>__closure__</span>
</span></span><span class=line><span class=cl><span class=c1># (</span>
</span></span><span class=line><span class=cl><span class=c1>#   &lt;cell at 0x1072ae200: int object at 0x105a6dc48&gt;,</span>
</span></span><span class=line><span class=cl><span class=c1>#   &lt;cell at 0x1072af550: int object at 0x105a6dc68&gt;</span>
</span></span><span class=line><span class=cl><span class=c1># )</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=vm>__closure__</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>cell_contents</span> <span class=c1># 2</span>
</span></span></code></pre></div></li><li><p><code>f.__code__</code> 对象代表编译过的函数体字节码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=vm>__code__</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;code object do_add at 0x107062b40, file &#34;&lt;ipython-input-3-ae9516cf2be1&gt;&#34;, line 2&gt;</span>
</span></span></code></pre></div></li></ul><p>函数还可以添加任意属性，例如</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>statements</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=o>.</span><span class=n>secure</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=o>.</span><span class=n>private</span> <span class=o>=</span> <span class=mi>1</span>
</span></span></code></pre></div><p>属性在函数体内不可见，他们不是局部变量，也不会在执行环境中以名称形式出现。
使用函数属性的主要方式，是存储元数据。
有时框架或各种元编程技术会利用函数标记。
一个例子是抽象基类中方法所使用的 <code>@asbtractmethod</code> 装饰器，该装饰器只为函数添加属性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>abstractmethod</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=o>.</span><span class=n>__isabstractmethod__</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>func</span>
</span></span></code></pre></div><p>其他一些代码会寻找这个属性，并利用它来为示例创建过程添加额外的检查。</p><p>若想深入了解某个函数的参数信息，可以通过调用 <code>inspect.signature()</code> 函数获取其签名。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>inspect</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>debug</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>float</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl><span class=n>sig</span> <span class=o>=</span> <span class=n>inspect</span><span class=o>.</span><span class=n>signature</span><span class=p>(</span><span class=n>func</span><span class=p>)</span>
</span></span></code></pre></div><p>签名对象提供了许多便捷功能，用于打印和获取参数的详细信息，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># Print out the signature in a nice form</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>sig</span><span class=p>)</span>  <span class=c1># (x: int, y: float, debug=False) -&gt; float</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Get a list of</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=n>sig</span><span class=o>.</span><span class=n>parameters</span><span class=p>))</span>  <span class=c1># [ &#39;x&#39;, &#39;y&#39;, &#39;debug&#39;]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Iterate over the parameters and print various metadata</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>p</span> <span class=ow>in</span> <span class=n>sig</span><span class=o>.</span><span class=n>parameters</span><span class=o>.</span><span class=n>values</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;name&#34;</span><span class=p>,</span> <span class=n>p</span><span class=o>.</span><span class=n>names</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;annotation&#34;</span><span class=p>,</span> <span class=n>p</span><span class=o>.</span><span class=n>annotation</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;kind&#34;</span><span class=p>,</span> <span class=n>p</span><span class=o>.</span><span class=n>kind</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;default&#34;</span><span class=p>,</span> <span class=n>p</span><span class=o>.</span><span class=n>default</span><span class=p>)</span>
</span></span></code></pre></div><p>签名的描述函数属性的元数据，作为一条数据，签名有多种用途。</p><p>对签名的一个有用操作是比较，例如可以通过一下方式检查两个函数是否具有相同的签名：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func1</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func2</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>assert</span> <span class=n>inspect</span><span class=o>.</span><span class=n>signature</span><span class=p>(</span><span class=n>func1</span><span class=p>)</span> <span class=o>==</span> <span class=n>inspect</span><span class=o>.</span><span class=n>signature</span><span class=p>(</span><span class=n>func2</span><span class=p>)</span>
</span></span></code></pre></div><p>这种比较在一些框架里面可能会很有用。
例如，一个框架可以通过签名对比检查你编写的函数或方法是否符合预期的原型。</p><p>如果存储在函数的 <code>__signature__</code> 属性中，签名将在帮助信息中显示，并在后续使用 <code>inspect.signature</code> 时返回。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=o>.</span><span class=n>__signature__</span> <span class=o>=</span> <span class=n>inspect</span><span class=o>.</span><span class=n>signature</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>:</span> <span class=kc>None</span><span class=p>)</span>
</span></span></code></pre></div><p>在这个例子中，可选参数 <code>z</code> 在检查 <code>func</code> 是被隐藏。
相反，附加的签名将由 <code>inspect.signature()</code> 返回。</p><h2 id=environment-inspection>Environment Inspection<a hidden class=anchor aria-hidden=true href=#environment-inspection>#</a></h2><p>可以使用内置方法 <code>globals()</code> 和 <code>locals()</code> 来查看函数的执行环境。
<code>globals()</code> 返回当前作为全局命名空间使用的字典，和属性 <code>func.__globals__</code> 属性相同。
这通常就是保存外层模块内容的那个字典。
<code>locals()</code> 返回一个包含本地变量和闭包变量的字典，该字典并非真实保存这些变量的数据结构。
修改 <code>locals()</code> 字典中的某个条目不会影响底层变量，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl>    <span class=n>locs</span> <span class=o>=</span> <span class=nb>locals</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>locs</span><span class=p>[</span><span class=s2>&#34;y&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>30</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>locs</span><span class=p>[</span><span class=s2>&#34;y&#34;</span><span class=p>])</span>  <span class=c1># 30</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>          <span class=c1># 20</span>
</span></span></code></pre></div><p>如果想要改变变量，需要将其拷贝回来</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl>    <span class=n>locs</span> <span class=o>=</span> <span class=nb>locals</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>locs</span><span class=p>[</span><span class=s2>&#34;y&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>30</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=n>locs</span><span class=p>[</span><span class=s2>&#34;y&#34;</span><span class=p>]</span>
</span></span></code></pre></div><p>一个函数可以使用 <code>inspect.currentframe()</code> 获取其栈帧。
一个函数可以通过沿着栈帧的 <code>f.f_back</code> 属性追踪栈跟踪，从而获取其调用者的栈帧。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>inspect</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>spam</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>z</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>    <span class=n>grok</span><span class=p>(</span><span class=n>z</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>grok</span><span class=p>(</span><span class=n>a</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>a</span> <span class=o>*</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>inspect</span><span class=o>.</span><span class=n>currentframe</span><span class=p>()</span><span class=o>.</span><span class=n>f_locals</span><span class=p>)</span>  <span class=c1># {&#39;a&#39;: 5, &#39;b&#39;: 50}</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>inspect</span><span class=o>.</span><span class=n>currentframe</span><span class=p>()</span><span class=o>.</span><span class=n>f_back</span><span class=o>.</span><span class=n>f_locals</span><span class=p>)</span>  <span class=c1># {&#39;x&#39;: 2, &#39;y&#39;: 3, &#39;z&#39;: 5}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>spam</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span></code></pre></div><p>后时候，你会看到使用 <code>sys._getframe()</code> 来获取栈帧</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>grok</span><span class=p>(</span><span class=n>a</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>a</span> <span class=o>*</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>_getframe</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>f_locals</span><span class=p>)</span>  <span class=c1># myself</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>_getframe</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>f_locals</span><span class=p>)</span>  <span class=c1># my caller</span>
</span></span></code></pre></div><p>下表一些常用的帧属性</p><table><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td>f.f_back</td><td>Previous stack frame (toward the caller)</td></tr><tr><td>f.f_code</td><td>Code object being executed</td></tr><tr><td>f.f_locals</td><td>Dictionary of local variables (locals())</td></tr><tr><td>f.f_globals</td><td>Dictionary used for global variables (globals())</td></tr><tr><td>f.f_bulltins</td><td>Dictionary used for built-in names</td></tr><tr><td>f.f_lineno</td><td>Line number</td></tr><tr><td>f.f_lasti</td><td>Current instruction. This is an index into the bytecode string of f_code</td></tr><tr><td>f.f_trace</td><td>Function called at start of each source code line</td></tr></tbody></table><p>查看帧段是一直调试和代码检查的有效方法，例如下面例子，可以查看调用者函数选中的变量值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>inspect</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>ChainMap</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>debug</span><span class=p>(</span><span class=o>*</span><span class=n>varnames</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span> <span class=o>=</span> <span class=n>inspect</span><span class=o>.</span><span class=n>currentframe</span><span class=p>()</span><span class=o>.</span><span class=n>f_back</span>
</span></span><span class=line><span class=cl>    <span class=nb>vars</span> <span class=o>=</span> <span class=n>ChainMap</span><span class=p>(</span><span class=n>f</span><span class=o>.</span><span class=n>f_locals</span><span class=p>,</span> <span class=n>f</span><span class=o>.</span><span class=n>f_globals</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>f</span><span class=o>.</span><span class=n>f_code</span><span class=o>.</span><span class=n>co_filename</span><span class=si>}</span><span class=s2>:</span><span class=si>{</span><span class=n>f</span><span class=o>.</span><span class=n>f_lineno</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>name</span> <span class=ow>in</span> <span class=n>varnames</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;    </span><span class=si>{</span><span class=n>name</span><span class=si>}</span><span class=s2> = </span><span class=si>{</span><span class=nb>vars</span><span class=p>[</span><span class=n>name</span><span class=p>]</span><span class=si>!r}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example use</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>z</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>    <span class=n>debug</span><span class=p>(</span><span class=s2>&#34;x&#34;</span><span class=p>,</span> <span class=s2>&#34;y&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>z</span>
</span></span></code></pre></div><h2 id=dynamic-code-execution-and-creation>Dynamic Code Execution and Creation<a hidden class=anchor aria-hidden=true href=#dynamic-code-execution-and-creation>#</a></h2><p><code>exec(str, [, globals [, locals]])</code> 函数执行一条含有任意代码的字符串，提供给 <code>exec()</code> 的代码会被执行，就好像代码实际上出现在 exec 操作的位置一样。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=p>[</span><span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>13</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>exec</span><span class=p>(</span><span class=s2>&#34;for i in a: print(i)&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>传递给 <code>exec()</code> 的代码会在调用者的本地和全局命名空间中执行。
然而，要注意对本地变量的修改不会有效果。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>    <span class=n>exec</span><span class=p>(</span><span class=s2>&#34;x = 20&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>  <span class=c1># 10</span>
</span></span></code></pre></div><p>这是因为，<code>locals</code> 只是一个收集了局部变量的快照字典 <code>{'x': 20}</code>，而不是实际的局部变量本身。
<code>globals</code> 返回的是模块的全局字典，模块级变量确实就是存在字典里。</p><p><code>exec()</code> 还可以接受 1 或 2 个字典对象，分别作为要执行代码的全局和本地命名空间。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=nb>globals</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;x&#34;</span><span class=p>:</span> <span class=mi>7</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;y&#34;</span><span class=p>:</span> <span class=mi>10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;birds&#34;</span><span class=p>:</span> <span class=p>[</span><span class=s2>&#34;Parrot&#34;</span><span class=p>,</span> <span class=s2>&#34;Swallow&#34;</span><span class=p>,</span> <span class=s2>&#34;Albatros&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>locs</span> <span class=o>=</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用上面字典中定义的全局、本地命名空间</span>
</span></span><span class=line><span class=cl><span class=n>exec</span><span class=p>(</span><span class=s1>&#39;z = 3 * x + 4 * y&#39;</span><span class=p>,</span> <span class=n>globs</span><span class=p>,</span> <span class=n>locs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>exec</span><span class=p>(</span><span class=s1>&#39;for b in birds: print(b)&#39;</span><span class=p>,</span> <span class=n>globs</span><span class=p>,</span> <span class=n>locs</span><span class=p>)</span>
</span></span></code></pre></div><p>省略参数情况见下表</p><table><thead><tr><th>情况</th><th>globals</th><th>locals</th><th>读</th><th>写</th></tr></thead><tbody><tr><td>都提供</td><td>globs</td><td>locs</td><td>先 locs → globs</td><td>写入 locs</td></tr><tr><td>只提供 globals</td><td>globs</td><td>globs</td><td>globs</td><td>写入 globs</td></tr><tr><td>只提供 locals</td><td>当前模块 globals</td><td>locs</td><td>locs → globals</td><td>写入 locs</td></tr><tr><td>都省略</td><td>当前作用域</td><td>当前作用域</td><td>当前作用域</td><td>当前作用域</td></tr></tbody></table><p>一种常见的动态代码执行是函数和方法的创建。
例如，这里有个函数创建了 <code>__init__()</code> 方法为类添加一系列名称：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>make_init</span><span class=p>(</span><span class=o>*</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>parms</span> <span class=o>=</span> <span class=s1>&#39;,&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>names</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>code</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;def __init__(self, </span><span class=si>{</span><span class=n>parms</span><span class=si>}</span><span class=s2>):</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>name</span> <span class=ow>in</span> <span class=n>names</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>code</span> <span class=o>+=</span> <span class=sa>f</span><span class=s2>&#34; self.</span><span class=si>{</span><span class=n>name</span><span class=si>}</span><span class=s2> = </span><span class=si>{</span><span class=n>name</span><span class=si>}</span><span class=se>\n</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>d</span> <span class=o>=</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>exec</span><span class=p>(</span><span class=n>code</span><span class=p>,</span> <span class=n>d</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>d</span><span class=p>[</span><span class=s2>&#34;__init__&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example use</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Vector</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=fm>__init__</span> <span class=o>=</span> <span class=n>make_init</span><span class=p>(</span><span class=s1>&#39;x&#39;</span><span class=p>,</span> <span class=s1>&#39;y&#39;</span><span class=p>,</span> <span class=s1>&#39;z&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 等价于</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Vector</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>z</span> <span class=o>=</span> <span class=n>z</span>
</span></span></code></pre></div><p>该技术在标准库的很多地方都使用了，例如 <code>namedtuple()</code>, <code>@dataclass</code> 和依赖动态代码创建的类似 feature。</p><h2 id=asynchronous-functions-and-await>Asynchronous Functions and Await<a hidden class=anchor aria-hidden=true href=#asynchronous-functions-and-await>#</a></h2><p>Python 提供了一些执行异步代码的特性，包括所谓的 &ldquo;async&rdquo; 函数 (coroutines) 或 awaitables。
他们大多和并发以及 <code>asyncio</code> 库相关，但有一些库构建在这之上。</p><p>一个异步函数或叫协程函数，定义方式是在函数前面添加 <code>async</code> 关键字：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>greeting</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Hello </span><span class=si>{</span><span class=n>name</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>调用该函数并不会执行，而会得到一个 coroutine 协程对象，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>greeting</span><span class=p>(</span><span class=s2>&#34;Guido&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;coroutine object greeting at 0x101476dc8&gt;</span>
</span></span></code></pre></div><p>要运行函数必须在其他代码的监督下执行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>greeting</span><span class=p>(</span><span class=s2>&#34;Guido&#34;</span><span class=p>))</span>  <span class=c1># Hello Guido</span>
</span></span></code></pre></div><p>这个例子展示了异步函数最重要的特性，即他们永远不会自己执行。
他们的运行总是需要某种管理器或代码库的介入。
虽然不一定像示例中的那样使用 asyncio，但异步函数的执行始终离不开某种外部机制的调度。</p><p>除了被管理之外，异步函数的执行方式和其他 Python 函数相同。
语句按顺序执行，所有常见的控制流特性均使用。
如果要返回结果，使用常见的 <code>return</code> 就行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>make_greeting</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=sa>f</span><span class=s2>&#34;Hello </span><span class=si>{</span><span class=n>name</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span></code></pre></div><p>外部用于执行异步函数的 <code>run()</code> 函数会给返回所给定的返回值。
例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>make_greeting</span><span class=p>(</span><span class=s2>&#34;Paula&#34;</span><span class=p>))</span>  <span class=c1># Hello Paula</span>
</span></span></code></pre></div><p>异步函数可以使用 <code>await</code> 调用其他异步函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>make_greeting</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=sa>f</span><span class=s2>&#34;Hello </span><span class=si>{</span><span class=n>name</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>name</span> <span class=ow>in</span> <span class=p>[</span><span class=s2>&#34;Paula&#34;</span><span class=p>,</span> <span class=s2>&#34;Thomas&#34;</span><span class=p>,</span> <span class=s2>&#34;Lewis&#34;</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>=</span> <span class=k>await</span> <span class=n>make_greeting</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></div><p><code>await</code> 的使用仅在封闭的异步函数定义中有效，它也是确保异步函数执行的必要部分。
如果省略 <code>await</code> 代码会出错，该关键字也引出了一个函数染色问题。
即无法直接从非异步函数中，调用异步函数来编写代码。</p><p>在同一应用程序中将异步与非异步功能结合使用时，可能会涉及相当大的复杂性。
尤其是在考虑涉及高阶函数、回调和装饰器等编程技巧时。
大多数情况下，对异步函数的支持必须作为特殊情况来构建。</p><p>Python 在迭代器和上下文管理器协议就是这样做的。
例如，一个异步上下文管理器可以使用 <code>__aenter__()</code> 和 <code>__aexit__()</code> 方法在类上定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>AsyncManager</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>yow</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=fm>__aenter__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=fm>__aexit__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>ty</span><span class=p>,</span> <span class=n>val</span><span class=p>,</span> <span class=n>tb</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span>
</span></span></code></pre></div><p>注意这些方法是 async 异步函数，并可以使用 <code>await</code> 执行其他 async 函数。
如果要使用该管理器，必须在异步函数内使用 <code>async with</code> 语法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>with</span> <span class=n>AsyncManager</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span> <span class=k>as</span> <span class=n>m</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>m</span><span class=o>.</span><span class=n>yow</span><span class=p>()</span>
</span></span></code></pre></div><p>一个类可以使用 <code>__aiter__()</code> 和 <code>__anext__()</code> 来定义异步生成器，这些被 <code>async for</code> 语句和异步函数使用。</p><h2 id=final-words-thoughts-on-functions-and-compoistion>Final Words: Thoughts on Functions and Compoistion<a hidden class=anchor aria-hidden=true href=#final-words-thoughts-on-functions-and-compoistion>#</a></h2><p>任何语言都是由组件组合构建而成的。
在 Python 中，这种组合包括多种库和对象。
然而，一切的基础都是函数。
函数是系统构建的粘合剂，也是数据流动的基本机制。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://starslayerx.github.io/tags/python/>Python</a></li></ul><nav class=paginav><a class=prev href=https://starslayerx.github.io/posts/python-pep-683-immoral-objects/><span class=title>« Prev</span><br><span>Python PEP 683: Immoral Objects</span>
</a><a class=next href=https://starslayerx.github.io/posts/python-tricks-part-4-objects-types-and-protocols/><span class=title>Next »</span><br><span>Python Tricks Part 4: Objects, Types and Protocols</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 5: Functions on x" href="https://x.com/intent/tweet/?text=Python%20Tricks%20Part%205%3a%20Functions&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-5-functions%2f&amp;hashtags=Python"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 5: Functions on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-5-functions%2f&amp;title=Python%20Tricks%20Part%205%3a%20Functions&amp;summary=Python%20Tricks%20Part%205%3a%20Functions&amp;source=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-5-functions%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 5: Functions on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-5-functions%2f&title=Python%20Tricks%20Part%205%3a%20Functions"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 5: Functions on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-5-functions%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 5: Functions on whatsapp" href="https://api.whatsapp.com/send?text=Python%20Tricks%20Part%205%3a%20Functions%20-%20https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-5-functions%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 5: Functions on telegram" href="https://telegram.me/share/url?text=Python%20Tricks%20Part%205%3a%20Functions&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-5-functions%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 5: Functions on ycombinator" href="https://news.ycombinator.com/submitlink?t=Python%20Tricks%20Part%205%3a%20Functions&u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-5-functions%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>