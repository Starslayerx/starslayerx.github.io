<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Starslayerx' Blog</title><meta name=keywords content><meta name=description content="Posts - Starslayerx' Blog"><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://starslayerx.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://starslayerx.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/posts/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="A personal blog about technology, programming, and daily notes"><meta property="og:locale" content="en-US"><meta property="og:type" content="website"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Posts"><meta name=twitter:description content="A personal blog about technology, programming, and daily notes"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://starslayerx.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Documenting REST APIs with OpenAPI</h2></header><div class=entry-content><p>本章介绍如何使用 OpenAPI 来为 API 编写文档. OpenAPI 是描述 RESTful API 最流行的标准, 拥有丰富的生态系统, 可以用于测试、验证和可视化 API. 大多数编程语言都支持 OpenAPI 规范的库.
OpenAPI 使用 JSON Schema 来描述 API 的结构和模型, 因此首先介绍 JSON Schema 的工作原理. JSON Schema 是一种用于定义 JSON 文档结构的规范, 包括文档中值的类型和格式.
Using JSON Schema to model data 使用 JSON Schema 对数据建模
JSON Schema 是一种规范标准, 用于定义 JSON 文档的结构及其属性的类型和格式. JSON Schema 规范通常定义一个具有特定属性或特性的对象, 由键值对的关联数组表示, 如下面这样:
{ "status": { "type": "string" } } 在 JSON Schema 规范中, 每个属性都以键值对的形式出现, 其中值是该属性的描述符 一个属性最基本的描述符就是 type, 上面例子中, 指定类型为字符串 JSON Schema 支持以下基本数据类型:
...</p></div><footer class=entry-footer><span title='2025-08-25 08:00:00 +0800 +0800'>August 25, 2025</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>1727 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Documenting REST APIs with OpenAPI" href=https://starslayerx.github.io/posts/documenting-rest-apis-with-openapi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis List</h2></header><div class=entry-content><p>List 列表 Redis 的列表是一种线性的有序结构, 可以按照元素被推入列表的顺序来存储元素, 这些元素即可以是文字顺序, 也可以是二进制顺序, 且元素可重复出现.
LPUSH: 将元素推入列表左端
LPUSH list item [item item ...] LPUSH 命令会返回当前元素数量
RPUSH: 将元素推入列表右端
RPUSH list item [item item ...] LPUSHX, RPUSHX: 只对已存在的列表执行推入操作
上面两条命令, 在列表不存在的情况下, 会自动创建空列表, 并将元素推入列表中.
且上面命令每次只能推入一个元素
LPOP: 弹出列表最左端的元素, 并返回被移出的元素
POP list 空列表 POP 会返回空值 (nil)
RPOP: 弹出列表最右端的元素
RPOP list RPOPLPUSH: 将列表右端弹出的元素推入列表左端
RPOPLPUSH source target source 和 target 可以是相同列表, 也可以是不同列表. 但不能为空列表, 否则会返回空(nil)
示例: 先入先出队列 许多电商网站都会在节日时推出一些秒杀活动, 这些活动会放出数量有限的商品供用户抢购, 秒杀系统的一个特点就是短时间内会有大量用户进行相同的购买操作, 如果使用事务或者锁去实现秒杀程序, 那么会因为锁和事务的重试性而导致性能低下, 并且由于重试的存在, 成功购买商品的用户可能并不是最早购买操作的用户, 因此这种秒杀系统并不公平.
解决方法之一就是把用户的购买操作都放入先进先出队列里面, 然后以队列的方式处理用户购买操作, 这样的程序就可以不使用锁或者事务实现秒杀系统, 且更加公平.
...</p></div><footer class=entry-footer><span title='2025-08-24 08:00:00 +0800 +0800'>August 24, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>489 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Redis List" href=https://starslayerx.github.io/posts/redis-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Rust Alternaitve Tools</h2></header><div class=entry-content><p>常用工具的 rust 替代品.
Introduction 在 Unix 生态中, 许多命令行工具都是用 C 编写的, 经过几十年的优化, 性能和稳定性都非常优秀. 然而, 近年来, Rust 以其安全性、内存管理优势和现代化开发体验, 成为系统级工具开发的理想选择.
首先更新 cargo, 不同系统都可以使用 cargo 安装, 当然也可以使用系统的包管理器安装
rustup update stable 有需要的话修改源, 一般在 ~/.cargo/config.toml, 下面是科大源
[source.crates-io] replace-with = 'ustc' [source.ustc] registry = "sparse+https://mirrors.ustc.edu.cn/crates.io-index/" [registries.ustc] index = "sparse+https://mirrors.ustc.edu.cn/crates.io-index/" Filesystem & Archiving 文件系统与归档 exa 替代 ls: 彩色支持 Git 状态的 ls 替代品
常用参数: -1: 一行显示一个文件 -l: 显示文件细节信息 -F: 在目录文件名末添加斜杠符号 -T: 树状显示 -R: 递归显示所有文件 --icons: 显示图标 zoxide 替代 cd: 基于访问频率的快速目录跳转工具
常用参数: z foo # 匹配 foo 的路径 z foo bar # 匹配 foo & bar 的路径 z - # 回到之前目录 zi foo # fzf File & Text Processing 文件与文本处理 bat 替代 cat: 具备语法高亮、行号显示、Git 集成等功能, 让查看文件内容更加美观 ripgrep 替代 grep: 使用 Rust 编写的极速文本搜索工具, 支持递归搜索、正则表达式、忽略规则(.gitignore)等 fd 替代 find: 提供简单直观的语法、更快的搜索性能, 并默认支持彩色输出和忽略 .gitignore 文件 System Monitoring & Management 系统监控与管理 bottom 替代 top / htop: 一个现代化的系统资源监控工具, 支持 CPU、内存、磁盘、网络等多种指标显示, 并提供交互式界面 procs 替代 ps: 更人性化的进程信息显示, 支持彩色输出、树状显示、搜索与过滤 Wrapping up Rust 的安全性和高性能使其成为编写现代 Linux 工具的理想选择. 这些替代品不仅提供了更好的用户体验, 还利用 Rust 的并发优势和零成本抽象提升了性能. 其他一些 rust 工具:
...</p></div><footer class=entry-footer><span title='2025-08-23 08:00:00 +0800 +0800'>August 23, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>160 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Rust Alternaitve Tools" href=https://starslayerx.github.io/posts/rust-alternaitve-tools/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Tokei</h2></header><div class=entry-content><p>Tokei 介绍 Tokei是一款 Rust 编写的开源工具, 用于统计项目代码行数, 支持上百种语言, 能够扫描整个代码库, 包括:
语言 文件数量 代码行数 注释行数 空行数 得益于 Rust 的高性能实现, Tokei 即使在超大规模代码库中也能保持极快的统计速度
(Rust 轮子真不错)
安装 brew install tokei 或者
cargo install tokei 使用 在项目根目录执行
tokei . 输出类似下面这样
=============================================================================== Language Files Lines Code Comments Blanks =============================================================================== Dockerfile 1 25 9 8 8 Python 52 2914 2372 96 446 TOML 1 65 58 0 7 YAML 2 49 45 0 4 ------------------------------------------------------------------------------- Markdown 1 194 0 158 36 |- BASH 1 13 13 0 0 (Total) 207 13 158 36 =============================================================================== Total 57 3247 2484 262 501 ===============================================================================</p></div><footer class=entry-footer><span title='2025-08-22 08:00:00 +0800 +0800'>August 22, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>93 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Tokei" href=https://starslayerx.github.io/posts/tokei/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis Hash</h2></header><div class=entry-content><p>散列 Redis 散列键 hash key 会将一个键和一个散列在数据库里关联起来, 散列中可以存任意多个字段 field. 与字符串一样, 散列字段和值既可以是文本数据, 也可以是二进制数据.
HSET: 为字段设置值
HEST hash field value 若已给定的字段是否已经存在与散列中, 该设置为一次更新操作, 覆盖旧值后返回0.
相反, 则为一次创建操作, 命令将在散列里面关联起给定的字段和值, 然后返回1.
HSETNX: 只在字段不存在的情况下设置值
HSETNX hash field value HSETNX 命令在字段不存在且成功设置值时, 返回1.
字段已存在并设置值未成功时, 返回0.
HGET: 获取字段的值
HGET hash field 若查找的不存在的散列或字段, 则会返回空(nil)
示例: 短网址生成 为了给用户提供更多空间, 并记录用户在网站上的链接点击行为, 大部分社交网站都会将用户输入的网址转换为短网址. 当用户点击段网址时, 后台就会进行数据统计, 并引导用户跳转到原地址.
创建短网址本质上就是, 要创建出短网址ID与目标网址之间的映射, 并让用户访问短网址时, 根据短网址的ID映射记录中找出与之相对应的目标网址.
短网址 ID 目标网址 RqRRz8n http://redisdoc.com/geo/index.html RUwtQBx http://item.jd.com/117910607.html HINCRBY: 对字段存储的整数值执行加法或减法操作
HINCRBY hash field increment 与字符串 INCRBY 命令一样, 如果散列字段里面存储着能够被 Redis 解释为整数的数字, 那么用户就可以使用 HINCRBY 命令为该字段的值加上指定的整数增量.
该命令执行成功后, 将返回字段当前的值为命令的结果. 若要执行减法操作, increment 传入负数即可.
...</p></div><footer class=entry-footer><span title='2025-08-21 08:00:00 +0800 +0800'>August 21, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>557 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Redis Hash" href=https://starslayerx.github.io/posts/redis-hash/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HTTP Methods, Status Codes and Payloads</h2></header><div class=entry-content><p>本篇文章基于 REST api 介绍HTTP请求方法、HTTP响应码和API数据载荷, 是之前介绍 REST 那篇文章的延伸
HTTP Status Codes 1xx group: Signals that an operation is in progress 2xx group: Signals that a request was successfully processed 3xx group: Signals that a resource has been moved to a new location 4xx group: Signals that someting was wrong with the request 5xx group: Signals that there was an error while processing the request 在之前文章中, 定义的 HTTP status code 如下:
POST /orders: 201 (Created) - 资源成功创建 GET /orders: 200 (OK) - 请求成功处理 GET /orders/{order_id}: 200 (OK) - 请求成功处理 PUT /orders/{order_id}: 200 (OK) - 资源成功更新 DELETE /orders/{order_id}: 204 (No Content) - 请求被成功处理, 但是没有响应内容, 对比其他方法, DELETE 请求不需要 payload 来删除资源 POST /orders/{order_id}/chanel: 200 (OK) - 取消成功, 由于并不创建任何资源, 故返回200 POST /orders/{orders\id}/pay: 200 (OK) - 支付成功, 同样由于未创建资源, 返回200 上面全是成功的响应, 下面介绍错误响应
...</p></div><footer class=entry-footer><span title='2025-08-20 08:00:00 +0800 +0800'>August 20, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>575 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to HTTP Methods, Status Codes and Payloads" href=https://starslayerx.github.io/posts/http-methods-status-codes-and-payloads/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis String</h2></header><div class=entry-content><p>介绍Redis中的字符串键
字符串 字符串建是 Redis 最基本的键值对类型, 这种类型的键值对会在数据库中把单独的一个值关联起来, 被关联的键和值可以为文本, 也可以是图片, 视屏, 音频等二进制数据.
SET: 为字符串键设置值 O(1)
SET key value
```Redis SET number "10086" > OK SET book "Redis in action" > OK ``` 对于已经存在的 key, 再次赋值会覆盖原值, 若不想覆盖后面添加参数 NX, 相反, 默认 XX 允许覆盖 ```Redis SET key "10086" NX > (nil) SET key "10086" XX > OK ``` GET: 获取字符串键的值 O(1)
GET key
```Redis GET number > "10086" ``` 对于不存在的值, 返回空 ```Redis GET key_new > (nil) ``` GETSET: 获取旧值并更新值 O(1)
...</p></div><footer class=entry-footer><span title='2025-08-19 08:00:00 +0800 +0800'>August 19, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>974 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Redis String" href=https://starslayerx.github.io/posts/redis-string/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>IEEE-754 Introduce</h2></header><div class=entry-content><p>IEEE 754 标准数值类型及分类
整数 Integer 整数是没有小数部分的值, 在计算机内通常有两种表示方式:
有符号整数: 可以表示正数和负数, 最常用的是二补码表示. 例如 8 位二进制的范围为[-2^7, 2^7-1] 无符号整数: 仅表示非负数, 8 位二进制的范围为 [0, 2^8-1] 其中补码(Two’s Complement)用于表示负数
正数补码与原码相同 负数的补码 = 该数绝对值的二进制取反 + 1 通过补码, 可以使得加减运算统一, 溢出检测更加简单
浮点数 Floating-point 浮点数用于表示带小数的实数, 尤其适合科学计算和近似表示很大或很小的数值. IEEE 754 定义了浮点数的标准格式, 类似科学计数法:
value = (-1)^(sign) x mantissa x 2^(exponent) 浮点数由三部分组成:
符号位 sign: 0/1代表正负 阶码 exponent: 通常使用偏移表示法 尾数 fraction/mantissa: 小数部分 常见浮点数类型:
单精度 float32: 1 位符号 + 8 位阶码 + 23 位尾数 双精度 float64: 1 位符号 + 11 位阶码 + 52 位尾数 浮点数的分类 Categories 以 64 精度为例
...</p></div><footer class=entry-footer><span title='2025-08-18 08:00:00 +0800 +0800'>August 18, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>363 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to IEEE-754 Introduce" href=https://starslayerx.github.io/posts/ieee-754-introduce/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Designing and Building REST APIs</h2></header><div class=entry-content><p>这篇文章延续之前微服务的内容, 将介绍关于 REST API 的以下几个方面:
REST API 的设计原则 Richardson maturity model (RMM) 如何帮助理解 REST 的优势和设计原则 REST API 中资源(resource)和端点(endpoints)设计的概念 表达性状态转移 representational state transfer (REST) 描述了一种通过网络进行通信的应用程序架构风格. 最初, REST 的概念包含了一组用于设计分布式、可扩展 Web 应用的约束条件. 随着时间推移, 出现了更为细致的协议和规范, 为 REST API 的设计提供了明确的指导方针. 如今, REST 已经成为构建 Web API 的最流行选择.
下面将继续在 CoffeeMesh 项目上, 设计相关订单 API.
What is REST? REST 由 Roy Fielding 在他的博士论文 “Architectural Styles and the Design of Network-based Software Atchitecture” (PhD diss. University of California,Irvine,2000,p. 109) 中创造.
...</p></div><footer class=entry-footer><span title='2025-08-17 08:00:00 +0800 +0800'>August 17, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>878 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Designing and Building REST APIs" href=https://starslayerx.github.io/posts/designing-and-building-rest-apis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Intorduce UUID</h2></header><div class=entry-content><p>UUID(Universally Unique Identifier, 通用唯一标识符) 是一种标准化的128位标识符, 用于在分布式系统中生成几乎不会重复的唯一 ID. 最早于 IETF 制定为 RFC 4122 标准, 保证在不同机器、不同时间生成的 ID 也能保持全局唯一.
UUID 通常以16进制表示, 采用5段结构, 用连字符 - 分隔, 例如:
550e8400-e29b-41d4-a716-446655440000 有如下特点:
全局唯一 无中心依赖 不可预测 跨平台通用 UUID 有以下不同版本:
版本 生成 特点 v1 基于时间戳 + MAC 地址 按时间排序，含生成设备信息 v3 基于命名空间的 MD5 哈希 输入相同则输出相同(MD5 已不再安全) v4 基于操作系统的随机数生成 完全随机, 最常用 v5 基于命名空间的 SHA-1 哈希 与 v3 类似, 但使用 SHA-1 v6~v8 现代版本(草案) 提高排序性能和隐私保护 其中, 对于需要时间有序的使用 v1, 大多数通用场景使用 v4
UUID 的应用场景
数据库主键(分布式环境避免冲突) 会话标识(Session ID、Token) 文件命名(防止重名) 分布式系统节点 ID 追踪请求链路(Trace ID) 示例代码
...</p></div><footer class=entry-footer><span title='2025-08-16 08:00:00 +0800 +0800'>August 16, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>138 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Intorduce UUID" href=https://starslayerx.github.io/posts/intorduce-uuid/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://starslayerx.github.io/posts/page/7/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://starslayerx.github.io/posts/page/9/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>