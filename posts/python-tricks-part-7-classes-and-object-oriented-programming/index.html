<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python Tricks Part 7: Classes and Object-Oriented Programming | Starslayerx' Blog</title><meta name=keywords content="Python"><meta name=description content='使用 vars() 方法返回对象的属性和值的字典对象，不带参数时，返回当前局部作用域的变量字典
vars()  # 相当于 locals()

class Person:
    name: str
    age: int

    def __init__(self, name, age):
        self.name = name
        self.age = age
        self.city = "Beijing"
p = Person("Alice", 25)
print(vars(p))
Attribute Access
一个示例只有三种基础的方法：getting, setting 和 deleting 属性
class Attribute:
    owner: str
    blance: float

    def __init__(self, owner: str, balance: float):
        self.owner = owner
        self.balance = balance

    def __repr__(self):
        return f"Account({self.owner!r}, {self.balance!r})"

    def deposite(self, amount: float):
        self.balance += amount

    def withdraw(self, amount: float):
        self.balance -= amount

    def inquiry(self) -> float:
        return self.balance
例如
a = Account("Guido", 1000.0)
a.owner         # get
a.balance = 75  # set
del a.balance   # delete
Python 中的一切都是一个动态过程，几乎没有什么限制。
例如，可以给已创建的对象添加新属性：
a = Account("Guido", 1000.0)
a.creation_date = "2019-02-14"
a.nickname = "Fromer BDFL"
有时候不适用点 . 操作符来执行任务，而是通过将属性名传递给 getattr(), setattr() 和 delattr() 函数来实现。
hasattr() 函数允许你测试一个已存在的属性：
a = Account("Guido", 1000.0)
getattr(a, "owner")
setattr(a, "balance", 750.0)
delattr(a, "balance")
hasattr(a, "balance")
# False
getattr(a, "withdraw")(100)  # Method Call
# a = Account("Guido", 650.0)
getattr() 函数可以携带一个默认值，如果想要查看一个可能不存在的属性，可以这样实现：'><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/posts/python-tricks-part-7-classes-and-object-oriented-programming/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://starslayerx.github.io/posts/python-tricks-part-7-classes-and-object-oriented-programming/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/posts/python-tricks-part-7-classes-and-object-oriented-programming/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Python Tricks Part 7: Classes and Object-Oriented Programming"><meta property="og:description" content='使用 vars() 方法返回对象的属性和值的字典对象，不带参数时，返回当前局部作用域的变量字典
vars() # 相当于 locals() class Person: name: str age: int def __init__(self, name, age): self.name = name self.age = age self.city = "Beijing" p = Person("Alice", 25) print(vars(p)) Attribute Access 一个示例只有三种基础的方法：getting, setting 和 deleting 属性
class Attribute: owner: str blance: float def __init__(self, owner: str, balance: float): self.owner = owner self.balance = balance def __repr__(self): return f"Account({self.owner!r}, {self.balance!r})" def deposite(self, amount: float): self.balance += amount def withdraw(self, amount: float): self.balance -= amount def inquiry(self) -> float: return self.balance 例如
a = Account("Guido", 1000.0) a.owner # get a.balance = 75 # set del a.balance # delete Python 中的一切都是一个动态过程，几乎没有什么限制。 例如，可以给已创建的对象添加新属性：
a = Account("Guido", 1000.0) a.creation_date = "2019-02-14" a.nickname = "Fromer BDFL" 有时候不适用点 . 操作符来执行任务，而是通过将属性名传递给 getattr(), setattr() 和 delattr() 函数来实现。 hasattr() 函数允许你测试一个已存在的属性：
a = Account("Guido", 1000.0) getattr(a, "owner") setattr(a, "balance", 750.0) delattr(a, "balance") hasattr(a, "balance") # False getattr(a, "withdraw")(100) # Method Call # a = Account("Guido", 650.0) getattr() 函数可以携带一个默认值，如果想要查看一个可能不存在的属性，可以这样实现：'><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-13T08:00:00+08:00"><meta property="article:modified_time" content="2026-01-13T08:00:00+08:00"><meta property="article:tag" content="Python"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Python Tricks Part 7: Classes and Object-Oriented Programming"><meta name=twitter:description content='使用 vars() 方法返回对象的属性和值的字典对象，不带参数时，返回当前局部作用域的变量字典
vars()  # 相当于 locals()

class Person:
    name: str
    age: int

    def __init__(self, name, age):
        self.name = name
        self.age = age
        self.city = "Beijing"
p = Person("Alice", 25)
print(vars(p))
Attribute Access
一个示例只有三种基础的方法：getting, setting 和 deleting 属性
class Attribute:
    owner: str
    blance: float

    def __init__(self, owner: str, balance: float):
        self.owner = owner
        self.balance = balance

    def __repr__(self):
        return f"Account({self.owner!r}, {self.balance!r})"

    def deposite(self, amount: float):
        self.balance += amount

    def withdraw(self, amount: float):
        self.balance -= amount

    def inquiry(self) -> float:
        return self.balance
例如
a = Account("Guido", 1000.0)
a.owner         # get
a.balance = 75  # set
del a.balance   # delete
Python 中的一切都是一个动态过程，几乎没有什么限制。
例如，可以给已创建的对象添加新属性：
a = Account("Guido", 1000.0)
a.creation_date = "2019-02-14"
a.nickname = "Fromer BDFL"
有时候不适用点 . 操作符来执行任务，而是通过将属性名传递给 getattr(), setattr() 和 delattr() 函数来实现。
hasattr() 函数允许你测试一个已存在的属性：
a = Account("Guido", 1000.0)
getattr(a, "owner")
setattr(a, "balance", 750.0)
delattr(a, "balance")
hasattr(a, "balance")
# False
getattr(a, "withdraw")(100)  # Method Call
# a = Account("Guido", 650.0)
getattr() 函数可以携带一个默认值，如果想要查看一个可能不存在的属性，可以这样实现：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://starslayerx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python Tricks Part 7: Classes and Object-Oriented Programming","item":"https://starslayerx.github.io/posts/python-tricks-part-7-classes-and-object-oriented-programming/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python Tricks Part 7: Classes and Object-Oriented Programming","name":"Python Tricks Part 7: Classes and Object-Oriented Programming","description":"使用 vars() 方法返回对象的属性和值的字典对象，不带参数时，返回当前局部作用域的变量字典\nvars() # 相当于 locals() class Person: name: str age: int def __init__(self, name, age): self.name = name self.age = age self.city = \u0026#34;Beijing\u0026#34; p = Person(\u0026#34;Alice\u0026#34;, 25) print(vars(p)) Attribute Access 一个示例只有三种基础的方法：getting, setting 和 deleting 属性\nclass Attribute: owner: str blance: float def __init__(self, owner: str, balance: float): self.owner = owner self.balance = balance def __repr__(self): return f\u0026#34;Account({self.owner!r}, {self.balance!r})\u0026#34; def deposite(self, amount: float): self.balance += amount def withdraw(self, amount: float): self.balance -= amount def inquiry(self) -\u0026gt; float: return self.balance 例如\na = Account(\u0026#34;Guido\u0026#34;, 1000.0) a.owner # get a.balance = 75 # set del a.balance # delete Python 中的一切都是一个动态过程，几乎没有什么限制。 例如，可以给已创建的对象添加新属性：\na = Account(\u0026#34;Guido\u0026#34;, 1000.0) a.creation_date = \u0026#34;2019-02-14\u0026#34; a.nickname = \u0026#34;Fromer BDFL\u0026#34; 有时候不适用点 . 操作符来执行任务，而是通过将属性名传递给 getattr(), setattr() 和 delattr() 函数来实现。 hasattr() 函数允许你测试一个已存在的属性：\na = Account(\u0026#34;Guido\u0026#34;, 1000.0) getattr(a, \u0026#34;owner\u0026#34;) setattr(a, \u0026#34;balance\u0026#34;, 750.0) delattr(a, \u0026#34;balance\u0026#34;) hasattr(a, \u0026#34;balance\u0026#34;) # False getattr(a, \u0026#34;withdraw\u0026#34;)(100) # Method Call # a = Account(\u0026#34;Guido\u0026#34;, 650.0) getattr() 函数可以携带一个默认值，如果想要查看一个可能不存在的属性，可以这样实现：\n","keywords":["Python"],"articleBody":"使用 vars() 方法返回对象的属性和值的字典对象，不带参数时，返回当前局部作用域的变量字典\nvars() # 相当于 locals() class Person: name: str age: int def __init__(self, name, age): self.name = name self.age = age self.city = \"Beijing\" p = Person(\"Alice\", 25) print(vars(p)) Attribute Access 一个示例只有三种基础的方法：getting, setting 和 deleting 属性\nclass Attribute: owner: str blance: float def __init__(self, owner: str, balance: float): self.owner = owner self.balance = balance def __repr__(self): return f\"Account({self.owner!r}, {self.balance!r})\" def deposite(self, amount: float): self.balance += amount def withdraw(self, amount: float): self.balance -= amount def inquiry(self) -\u003e float: return self.balance 例如\na = Account(\"Guido\", 1000.0) a.owner # get a.balance = 75 # set del a.balance # delete Python 中的一切都是一个动态过程，几乎没有什么限制。 例如，可以给已创建的对象添加新属性：\na = Account(\"Guido\", 1000.0) a.creation_date = \"2019-02-14\" a.nickname = \"Fromer BDFL\" 有时候不适用点 . 操作符来执行任务，而是通过将属性名传递给 getattr(), setattr() 和 delattr() 函数来实现。 hasattr() 函数允许你测试一个已存在的属性：\na = Account(\"Guido\", 1000.0) getattr(a, \"owner\") setattr(a, \"balance\", 750.0) delattr(a, \"balance\") hasattr(a, \"balance\") # False getattr(a, \"withdraw\")(100) # Method Call # a = Account(\"Guido\", 650.0) getattr() 函数可以携带一个默认值，如果想要查看一个可能不存在的属性，可以这样实现：\na = Account(\"Guido\", 1000.0) getattr(s, \"balance\", \"unknown\") # 1000.0 getattr(s, \"crieation_date\", \"unknown\") # unknown 当向访问属性一样访问方法的时候，可以获取一个对象叫做 bound method 绑定方法。\na = Account(\"Guido\", 1000.0) w = a.withdraw # “","wordCount":"4105","inLanguage":"en","image":"https://starslayerx.github.io/images/og-default.avif","datePublished":"2026-01-13T08:00:00+08:00","dateModified":"2026-01-13T08:00:00+08:00","author":{"@type":"Person","name":"Starslayerx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://starslayerx.github.io/posts/python-tricks-part-7-classes-and-object-oriented-programming/"},"publisher":{"@type":"Organization","name":"Starslayerx' Blog","logo":{"@type":"ImageObject","url":"https://starslayerx.github.io/favicon.svg"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Python Tricks Part 7: Classes and Object-Oriented Programming</h1><div class=post-meta><span title='2026-01-13 08:00:00 +0800 +0800'>January 13, 2026</span>&nbsp;·&nbsp;<span>20 min</span>&nbsp;·&nbsp;<span>4105 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#attribute-access>Attribute Access</a></li><li><a href=#scoping-rules>Scoping Rules</a></li><li><a href=#inheritance>Inheritance</a></li><li><a href=#avoiding-inheritance-via-composition>Avoiding Inheritance via Composition</a></li><li><a href=#avoiding-inheritance-via-functions>Avoiding Inheritance via Functions</a></li><li><a href=#dynamic-binding-and-duck-typing>Dynamic Binding and Duck Typing</a></li><li><a href=#the-danger-of-inheriting-from-build-in-types>The Danger of Inheriting from Build-in Types</a></li><li><a href=#class-variables-and-methods>Class Variables and Methods</a></li><li><a href=#static-methods>Static Methods</a></li><li><a href=#a-world-about-design-patterns>A World About Design Patterns</a></li><li><a href=#data-encapsulation-and-private-attributes>Data Encapsulation and Private Attributes</a></li><li><a href=#type-hinting>Type Hinting</a></li><li><a href=#properties>Properties</a></li><li><a href=#types-interfaces-and-abstract-base-classes>Types, Interfaces, and Abstract Base Classes</a></li><li><a href=#multiple-inheritance-interfaces-and-mixins>Multiple Inheritance, Interfaces, and Mixins</a></li><li><a href=#type-based-dispatch>Type-based Dispatch</a></li><li><a href=#class-decorators>Class Decorators</a></li><li><a href=#supervised-inheritance>Supervised Inheritance</a></li><li><a href=#the-object-life-cycle-and-memmory-management>The Object Life Cycle and Memmory Management</a></li><li><a href=#weak-references>Weak References</a></li><li><a href=#internal-object-representation-and-attribute-binding>Internal Object Representation and Attribute Binding</a></li><li><a href=#proxies-wrappers-and-delegation>Proxies, Wrappers and Delegation</a></li><li><a href=#reducing-momory-use-with-__slots__>Reducing momory use with <code>__slots__</code></a></li><li><a href=#descriptors>Descriptors</a></li></ul></nav></div></details></div><div class=post-content><p>使用 <code>vars()</code> 方法返回对象的属性和值的字典对象，不带参数时，返回当前局部作用域的变量字典</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=nb>vars</span><span class=p>()</span>  <span class=c1># 相当于 locals()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>    <span class=n>age</span><span class=p>:</span> <span class=nb>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>age</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>age</span> <span class=o>=</span> <span class=n>age</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>city</span> <span class=o>=</span> <span class=s2>&#34;Beijing&#34;</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>Person</span><span class=p>(</span><span class=s2>&#34;Alice&#34;</span><span class=p>,</span> <span class=mi>25</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>vars</span><span class=p>(</span><span class=n>p</span><span class=p>))</span>
</span></span></code></pre></div><h2 id=attribute-access>Attribute Access<a hidden class=anchor aria-hidden=true href=#attribute-access>#</a></h2><p>一个示例只有三种基础的方法：getting, setting 和 deleting 属性</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Attribute</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>owner</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>    <span class=n>blance</span><span class=p>:</span> <span class=nb>float</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>balance</span><span class=p>:</span> <span class=nb>float</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__repr__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=sa>f</span><span class=s2>&#34;Account(</span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>owner</span><span class=si>!r}</span><span class=s2>, </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>balance</span><span class=si>!r}</span><span class=s2>)&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deposite</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>:</span> <span class=nb>float</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>+=</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>withdraw</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>:</span> <span class=nb>float</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>-=</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inquiry</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>float</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>balance</span>
</span></span></code></pre></div><p>例如</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s2>&#34;Guido&#34;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>owner</span>         <span class=c1># get</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>balance</span> <span class=o>=</span> <span class=mi>75</span>  <span class=c1># set</span>
</span></span><span class=line><span class=cl><span class=k>del</span> <span class=n>a</span><span class=o>.</span><span class=n>balance</span>   <span class=c1># delete</span>
</span></span></code></pre></div><p>Python 中的一切都是一个动态过程，几乎没有什么限制。
例如，可以给已创建的对象添加新属性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s2>&#34;Guido&#34;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>creation_date</span> <span class=o>=</span> <span class=s2>&#34;2019-02-14&#34;</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>nickname</span> <span class=o>=</span> <span class=s2>&#34;Fromer BDFL&#34;</span>
</span></span></code></pre></div><p>有时候不适用点 <code>.</code> 操作符来执行任务，而是通过将属性名传递给 <code>getattr()</code>, <code>setattr()</code> 和 <code>delattr()</code> 函数来实现。
<code>hasattr()</code> 函数允许你测试一个已存在的属性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s2>&#34;Guido&#34;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>getattr</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=s2>&#34;owner&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>setattr</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=s2>&#34;balance&#34;</span><span class=p>,</span> <span class=mf>750.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>delattr</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=s2>&#34;balance&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>hasattr</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=s2>&#34;balance&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># False</span>
</span></span><span class=line><span class=cl><span class=nb>getattr</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=s2>&#34;withdraw&#34;</span><span class=p>)(</span><span class=mi>100</span><span class=p>)</span>  <span class=c1># Method Call</span>
</span></span><span class=line><span class=cl><span class=c1># a = Account(&#34;Guido&#34;, 650.0)</span>
</span></span></code></pre></div><p><code>getattr()</code> 函数可以携带一个默认值，如果想要查看一个可能不存在的属性，可以这样实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s2>&#34;Guido&#34;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>getattr</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=s2>&#34;balance&#34;</span><span class=p>,</span> <span class=s2>&#34;unknown&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 1000.0</span>
</span></span><span class=line><span class=cl><span class=nb>getattr</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=s2>&#34;crieation_date&#34;</span><span class=p>,</span> <span class=s2>&#34;unknown&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># unknown</span>
</span></span></code></pre></div><p>当向访问属性一样访问方法的时候，可以获取一个对象叫做 bound method 绑定方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s2>&#34;Guido&#34;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>w</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=n>withdraw</span>
</span></span><span class=line><span class=cl><span class=c1># “&lt;bound method Account.withdraw of Account(&#39;Guido&#39;, 1000.0)&gt;</span>
</span></span></code></pre></div><p>绑定方法是一个对象，即包含示例 self，又包含实现该方法的函数。
当使用圆括号 parentheses 和参数调用 bound method 的时候，它会执行该方法，并将附加的实例作为第一个参数。</p><h2 id=scoping-rules>Scoping Rules<a hidden class=anchor aria-hidden=true href=#scoping-rules>#</a></h2><p>尽管类为方法定义了一个独立的命名空间，但该命名空间并不作为解析方法内部所用的作用域。
因此，在实现类时，对属性和方法的引用必须完全限定。
例如，在方法中，总是通过 <code>self.</code> 来引用类属性。
缺少类级别作用域是 Python 与 C++ 或 Java 的一个不同之处，如果使用这些语言，<code>this</code> 指针就像 <code>self</code> 参数一样。
但在 Python 中需要显示地去调用。</p><h2 id=inheritance>Inheritance<a hidden class=anchor aria-hidden=true href=#inheritance>#</a></h2><p>继承 inheritance 是一个创建新类的机制，该类专门修改或优化现有类的行为。
原始的类被称为 base class, superclass 或 parent class，新类被称为派生类 derived class, child class 或 subtype。
当一个类通过继承创建时，它会继承基类定义的属性。
但派生类可以重新定义其中任何属性，并添加新属性。</p><p>继承通过在类声明中以逗号分割的基类名称列表来指定。
若未指明基类，则会隐式继承 object 类，object 是 Python 对象的根类，它提供了一些常用方法的默认实现。</p><p>有时派生类型重新定义了某个方法，如果仍然想要调用基类方法，使用 <code>super()</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>EvilAccount</span><span class=p>(</span><span class=n>Account</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inquiry</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mf>1.10</span> <span class=o>*</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>inquiry</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>inquiry</span>
</span></span></code></pre></div><p>此外，类可以可以添加额外的属性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>EvilAccount</span><span class=p>(</span><span class=n>Account</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>,</span> <span class=n>factor</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>factor</span> <span class=o>=</span> <span class=n>factor</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inquiry</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>factor</span> <span class=o>*</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>inquiry</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>inquiry</span><span class=p>()</span>
</span></span></code></pre></div><p>添加属性时一个棘手的问题在于处理已有的 <code>__init__()</code> 方法。
本例中，定义了一个新版本的 <code>__init__()</code> 方法，其中加入了额外的实例变量 <code>factor</code>。
然而，当重定义 <code>__init__()</code> 时，子类需要通过 <code>super().__init__()</code> 来初始化父类。
如果忘记这一步，将导致对象仅完成部分初始化，进而引发程序崩溃。
由于父类的初始化需要额外参数，这些参数仍需传递给子类的 <code>__init__()</code> 方法。</p><p>继承还可能通过下面方法导致代码出问题：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__repr__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=sa>f</span><span class=s2>&#34;Account(</span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>owner</span><span class=si>!r}</span><span class=s2>, </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>balance</span><span class=si>!r}</span><span class=s2>)&#34;</span>
</span></span></code></pre></div><p>该方法的目的是辅助调试输出信息，但这里缺硬编码了 Account，会导致继承对象调试时显示不符预期：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>EvilAccount</span><span class=p>(</span><span class=n>Account</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>EvilAccount</span><span class=p>(</span><span class=s2>&#34;Eval&#34;</span><span class=p>,</span> <span class=mf>10.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>a</span>
</span></span><span class=line><span class=cl><span class=c1># Account(&#39;Eva&#39;, 10)</span>
</span></span><span class=line><span class=cl><span class=nb>type</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;class &#39;EvilaAccount&#39;&gt;</span>
</span></span></code></pre></div><p>解决方案是使用 <code>type()</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__repr__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=o>.</span><span class=n>__name</span><span class=si>}</span><span class=s2>(</span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>owner</span><span class=si>!r}</span><span class=s2>, </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>balance</span><span class=si>!r}</span><span class=s2>)&#34;</span>
</span></span></code></pre></div><p>继承建立在类型系统中建立了一种关系，使得任何子类都能通过类型检查：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>EvilAccount</span><span class=p>(</span><span class=s2>&#34;Eva&#34;</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>isinstance</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>Account</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># True</span>
</span></span></code></pre></div><p>这就是所谓的 “是一个” 关系，有时 “是一个” 继承关系被用来定义对象类型的本体论或分类体系。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Food</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Sandwith</span><span class=p>(</span><span class=n>Food</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>RoastBeef</span><span class=p>(</span><span class=n>Sandwith</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>GrilledChess</span><span class=p>(</span><span class=n>Sandwith</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Taco</span><span class=p>(</span><span class=n>Food</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><p>在实践中，这种组织可能会相当困难且充满风险。</p><p>比如要添加一个 HotDog 类型，那是应该属于 Sandwith 还是 Taco，或者两者都是？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>HotDog</span><span class=p>(</span><span class=n>Sandwith</span><span class=p>,</span> <span class=n>Taco</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><h2 id=avoiding-inheritance-via-composition>Avoiding Inheritance via Composition<a hidden class=anchor aria-hidden=true href=#avoiding-inheritance-via-composition>#</a></h2><p>关于继承的一个警示性用法即所谓的 implementation inheritance 实现继承。
假设你想实现一个栈数据结构，一个快速的方法是从列表继承并添加一个新方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stack</span><span class=p>(</span><span class=nb>list</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>push</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Stack</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>  <span class=c1># 1</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>  <span class=c1># 2</span>
</span></span></code></pre></div><p>这就是 implementation inheritance，但这样会让用户感到困惑：为什么这个栈有个 <code>sort()</code> 方法？</p><p>一种通常更好的实现是 compoistion 组合。
并不是建立一个栈并直接继承列表，而是建立一个单独的栈类型，然后将列表作为其中一个元素添加进去。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_items</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>push</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_tiems</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>pop</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_items</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__len__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_items</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Stack</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>  <span class=c1># 3</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>  <span class=c1># 2</span>
</span></span></code></pre></div><p>该对象的工作方式与之前完全相同，但它的功能完全专注于栈的实现。
没有多余的列表方法，设计目的更加清晰明确。</p><p>对此实现的一个小扩展可能是将内部列表作为可选参数接受。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>container</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>container</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>container</span> <span class=o>=</span> <span class=nb>list</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_items</span> <span class=o>=</span> <span class=n>container</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>push</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_items</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>pop</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_items</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__len__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>container</span><span class=p>)</span>
</span></span></code></pre></div><p>这种方法的优点之一是促进了组件间的松耦合。
例如，想要创建一个栈，可以将其元素存储在数组而非列表中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>array</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>Stack</span><span class=p>(</span><span class=n>container</span><span class=o>=</span><span class=n>array</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=s2>&#34;i&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=mi>23</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>push</span><span class=p>(</span><span class=s2>&#34;a lot&#34;</span><span class=p>)</span>  <span class=c1># Type Error .</span>
</span></span></code></pre></div><p>这也被称为 &ldquo;dependency injection&rdquo; 依赖注入。
并非手动硬编码使用 <code>list</code>，而是让其依赖任何用户决定使用的容器来实现接口。</p><h2 id=avoiding-inheritance-via-functions>Avoiding Inheritance via Functions<a hidden class=anchor aria-hidden=true href=#avoiding-inheritance-via-functions>#</a></h2><p>有时候会编写只有一个方法需要修改的类，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>DataParser</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>parse</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>lines</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>records</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>lines</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>row</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;,&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>record</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>make_record</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>records</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>records</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>make_record</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>NotImplementedError</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PortfolioDataParser</span><span class=p>(</span><span class=n>DataParser</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>make_record</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;name&#34;</span><span class=p>:</span> <span class=n>row</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;shares&#34;</span><span class=p>:</span> <span class=nb>int</span><span class=p>(</span><span class=n>row</span><span class=p>[</span><span class=mi>1</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;price&#34;</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=n>row</span><span class=p>[</span><span class=mi>2</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>parser</span> <span class=o>=</span> <span class=n>PortfolioDataParser</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=n>parser</span><span class=o>.</span><span class=n>parse</span><span class=p>(</span><span class=nb>open</span><span class=p>(</span><span class=s2>&#34;portfolio.csv&#34;</span><span class=p>))</span>
</span></span></code></pre></div><p>如果只写了一个方法的类，考虑使用函数。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parse_data</span><span class=p>(</span><span class=n>lines</span><span class=p>,</span> <span class=n>make_record</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>records</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>lines</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>row</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;,&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>record</span> <span class=o>=</span> <span class=n>make_record</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>records</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>records</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>make_dict</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;name&#34;</span><span class=p>:</span> <span class=n>row</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;shares&#34;</span><span class=p>:</span> <span class=nb>int</span><span class=p>(</span><span class=n>row</span><span class=p>[</span><span class=mi>1</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;price&#34;</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=n>row</span><span class=p>[</span><span class=mi>2</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=n>parse_data</span><span class=p>(</span><span class=nb>open</span><span class=p>(</span><span class=s1>&#39;portfolio.cs&#39;</span><span class=p>),</span> <span class=n>make_dict</span><span class=p>)</span>
</span></span></code></pre></div><p>现在代码简洁多了，即使以后要增加更多方法，将他们再加入类也不迟。
Premature 过早抽象通常不是一件好事。</p><h2 id=dynamic-binding-and-duck-typing>Dynamic Binding and Duck Typing<a hidden class=anchor aria-hidden=true href=#dynamic-binding-and-duck-typing>#</a></h2><p>动态绑定是 Python 在运行时查找对象属性的机制，它使得 Python 能处理实例而无需考虑类型。
在 Python 中，变量名没有关联的类型。
因此，属性绑定过程与对象 obj 的类型无关。
如果使用 <code>obj.name</code> 方法，则任何有 name 属性的对象都能工作。
这种行为有时候被称为 duck typing 鸭子类型，这来自一句格言：如果它看上去像鸭子，叫声像鸭子，走路和鸭子一样，那么就是一只鸭子。</p><p>Python 程序员经常依赖这个特性。
例如你想要制作一个自定义已存在版本的对象，要么继承该对象，要么创建一个有类似行为的新对象。
后一种方法通常用于保持程序组件之间的松耦合关系。
例如，只要某个对象具有特定的一系列方法，编写的代码就可以与之协同工作。
最常见的就是标准库中的 <code>iterable</code> 对象，有许多不同类型的对象可以与 <code>for</code> 循环工作并产生值。
然而，这些类并未继承任何特殊的可迭代基类。
他们只是实现了执行迭代所需要的方法，一切便可以运行。</p><h2 id=the-danger-of-inheriting-from-build-in-types>The Danger of Inheriting from Build-in Types<a hidden class=anchor aria-hidden=true href=#the-danger-of-inheriting-from-build-in-types>#</a></h2><p>Python 允许继承内置类型，然而这样做会引发危险。
例如，假设你决定继承字典类，并强制将所有 key 转为大写。
为了实现这个功能，你可能需要重新定义 <code>__setitem__()</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>udict</span><span class=p>(</span><span class=nb>dict</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__setitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__setitem__</span><span class=p>(</span><span class=n>key</span><span class=o>.</span><span class=n>upper</span><span class=p>(),</span> <span class=n>value</span><span class=p>)</span>
</span></span></code></pre></div><p>这样确实能运行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>u</span> <span class=o>=</span> <span class=n>udict</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>u</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=s1>&#39;Guido&#39;</span>
</span></span><span class=line><span class=cl><span class=n>u</span><span class=p>[</span><span class=s1>&#39;number&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>37</span>
</span></span><span class=line><span class=cl><span class=n>u</span>
</span></span><span class=line><span class=cl><span class=c1># { &#39;NAME&#39;: &#39;Guido&#39;, &#39;NUMBER&#39;: 37 }</span>
</span></span></code></pre></div><p>但进一步测试发现只是部分能正常工作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>u</span> <span class=o>=</span> <span class=n>udict</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=n>number</span><span class=o>=</span><span class=mi>37</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>u</span>
</span></span><span class=line><span class=cl><span class=c1># { &#39;name&#39;: &#39;Guido&#39;, &#39;number&#39;: 37 }</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>u</span><span class=o>.</span><span class=n>update</span><span class=p>(</span><span class=n>color</span><span class=o>=</span><span class=s1>&#39;blue&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># { &#39;name&#39;: &#39;Guido&#39;, &#39;number&#39;: 37, &#39;color&#39;: &#39;blue&#39;}</span>
</span></span></code></pre></div><p>这是因为 Python 的内置类似是使用 c 实现的，而不是其他 Python 类型。</p><p>collections 模块有一些特殊的类型 UserDict, UserList 和 UserString，这些类型可以用于实现 dict, list 和 str 的安全子类型。
例如，这种解决方案能够正常工作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>UserDict</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>udict</span><span class=p>(</span><span class=n>UserDict</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__setitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__setitem__</span><span class=p>(</span><span class=n>key</span><span class=o>.</span><span class=n>upper</span><span class=p>(),</span> <span class=n>value</span><span class=p>)</span>
</span></span></code></pre></div><p>大部分继承内置类型的需要都是可以避免的，如果真的要使用优先考虑 Stack 的实现方式。</p><h2 id=class-variables-and-methods>Class Variables and Methods<a hidden class=anchor aria-hidden=true href=#class-variables-and-methods>#</a></h2><p>在类型定义中，所有函数都默认操作示例，第一个参数永远都是 <code>self</code>。
然而，该类本身也是一个对象，并可以被修改。
例如，你可以在类中追踪创建了多少个实例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>num_accounts</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>        <span class=n>Account</span><span class=o>.</span><span class=n>num_accounts</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__repr__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=sa>f</span><span class=s1>&#39;</span><span class=si>{</span><span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=o>.</span><span class=vm>__name__</span> <span class=p>({</span><span class=bp>self</span><span class=o>.</span><span class=n>owner</span><span class=err>!</span><span class=n>r</span><span class=p>},</span> <span class=p>{</span><span class=bp>self</span><span class=o>.</span><span class=n>balance</span><span class=err>!</span><span class=n>r</span><span class=p>})</span><span class=si>}</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deposit</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>+=</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>withdraw</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>deposit</span><span class=p>(</span><span class=o>-</span><span class=n>amount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inquiry</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>balance</span>
</span></span></code></pre></div><p>类变量在 <code>__init__()</code> 之外定义，当修改后使用该类，而不是 <code>self</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s1>&#39;Eva&#39;</span><span class=p>,</span> <span class=mf>10.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>Account</span><span class=o>.</span><span class=n>num_accounts</span>
</span></span><span class=line><span class=cl><span class=c1># 2</span>
</span></span></code></pre></div><p>有点不同寻常的是，类变量可以通过示例访问：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>num_accounts</span>
</span></span><span class=line><span class=cl><span class=c1># 2</span>
</span></span></code></pre></div><p>之所以这样操作，是因为当示例本身没有匹配的属性时，属性查找会转向检查其关联的类。
Python 查找方法字段也是一样的机制。</p><p>因此，也可以定义一个类方法，类方法应用于类本身，而非实例。
一个常见用途是定义替代的示例构造函数。
例如，加入存在一个需求，需要从一种传统的企业输出格式创建账户实例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>&lt;account&gt;
</span></span></span><span class=line><span class=cl><span class=s1>    &lt;owner&gt;Guido&lt;/owner&gt;
</span></span></span><span class=line><span class=cl><span class=s1>    &lt;amount&gt;1000.0&lt;/amount&gt;
</span></span></span><span class=line><span class=cl><span class=s1>&lt;/account&gt;
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span></code></pre></div><p>为了实现通过类方法创建实例，可以使用 <code>@classmethod</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>from_xml</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=n>date</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=kn>from</span> <span class=nn>xml.etree.ElementTree</span> <span class=kn>import</span> <span class=n>XML</span>
</span></span><span class=line><span class=cl>        <span class=n>doc</span> <span class=o>=</span> <span class=n>XML</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>cls</span><span class=p>(</span><span class=n>doc</span><span class=o>.</span><span class=n>findtext</span><span class=p>(</span><span class=s1>&#39;owner&#39;</span><span class=p>),</span> <span class=nb>float</span><span class=p>(</span><span class=n>doc</span><span class=o>.</span><span class=n>findtext</span><span class=p>(</span><span class=s1>&#39;amount&#39;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># example</span>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>&lt;account&gt;
</span></span></span><span class=line><span class=cl><span class=s1>    &lt;owner&gt;Guido&lt;/owner&gt;
</span></span></span><span class=line><span class=cl><span class=s1>    &lt;amount&gt;1000.0&lt;/amount&gt;
</span></span></span><span class=line><span class=cl><span class=s1>&lt;/account&gt;
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=o>.</span><span class=n>from_xml</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span></code></pre></div><p>类方法的第一个参数永远是类本身。
按照惯例，一般叫做 <code>cls</code>，在这个例子中 <code>cls</code> 设置在 Account 上。
如果一个类方法的目的是创建新实例，则必须采取明确的步骤来实现。
在类的最后一行 <code>cls(..., ...)</code> 和 <code>Account(..., ...)</code> 效果是一样的。</p><p>将类作为参数传递这一做法，解决了与继承相关的一个重要问题。
加入你要继承该类创建一个子类，然后想要创建一个实例，你会发现类方法仍然有用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>EvilAccount</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>e</span> <span class=o>=</span> <span class=n>EvilAccount</span><span class=o>.</span><span class=n>from_xml</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>  <span class=c1># Create an &#39;EvilAccount&#39;</span>
</span></span></code></pre></div><p>之所以仍然能运行是因为 <code>EvilAccount</code> 作为 <code>cls</code> 传入了方法。
因此最后一行 <code>from_xml</code> 创建的是 <code>EvilAccount</code> 对象。</p><p>类变量和方法有时候会结合使用，以匹配控制实例的运行方式。
另一例子，考虑下面的 <code>Date</code> 类型：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Date</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>datefmt</span> <span class=o>=</span> <span class=s1>&#39;</span><span class=si>{year}</span><span class=s1>-</span><span class=si>{month:02d}</span><span class=s1>-</span><span class=si>{day:02d}</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>year</span><span class=p>,</span> <span class=n>month</span><span class=p>,</span> <span class=n>day</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>year</span> <span class=o>=</span> <span class=n>year</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>month</span> <span class=o>=</span> <span class=n>month</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>day</span> <span class=o>=</span> <span class=n>day</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__str__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>datefmt</span><span class=o>.</span><span class=n>format</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>year</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>year</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>month</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>month</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>day</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>day</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>from_timestamp</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=n>ts</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>tm</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>localtime</span><span class=p>(</span><span class=n>ts</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>cls</span><span class=p>(</span><span class=n>tm</span><span class=o>.</span><span class=n>tm_year</span><span class=p>,</span> <span class=n>tm</span><span class=o>.</span><span class=n>tm_mon</span><span class=p>,</span> <span class=n>tm</span><span class=o>.</span><span class=n>tm_mday</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>today</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>cls</span><span class=o>.</span><span class=n>from_timestamp</span><span class=p>(</span><span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>())</span>
</span></span></code></pre></div><p>该类包含一个类变量 <code>datefmt</code> 用于调整 <code>__str__()</code> 方法的输出，这是一个可以通过继承进行自定义的功能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>MDYDate</span><span class=p>(</span><span class=n>Date</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>datefmt</span> <span class=o>=</span> <span class=s1>&#39;</span><span class=si>{month}</span><span class=s1>/</span><span class=si>{day}</span><span class=s1>/</span><span class=si>{year}</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DMYDate</span><span class=p>(</span><span class=n>Date</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>datefmt</span> <span class=o>=</span> <span class=s1>&#39;</span><span class=si>{day}</span><span class=s1>/</span><span class=si>{month}</span><span class=s1>/</span><span class=si>{year}</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Date</span><span class=p>(</span><span class=mi>1967</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>9</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>  <span class=c1># 1967-04-09</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=n>MDYDate</span><span class=p>(</span><span class=mi>1967</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>9</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>b</span><span class=p>)</span>  <span class=c1># 4/9/1967</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>c</span> <span class=o>=</span> <span class=n>DMYDate</span><span class=p>(</span><span class=mi>1967</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>9</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>  <span class=c1># 9/4/1967</span>
</span></span></code></pre></div><p>通过类型变量和继承配置，是调整实例的行为的常见方法。
类方法的使用对于实现该功能至关重要，因为他们确保了创建出正确类型的对象。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>MDYDate</span><span class=o>.</span><span class=n>today</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=n>DMYDate</span><span class=o>.</span><span class=n>today</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>  <span class=c1># 2/13/2019</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>b</span><span class=p>)</span>  <span class=c1># 13/2/2019</span>
</span></span></code></pre></div><p>通过类方法进行实例构造是目前最常见的应用。
这类方法通常遵循一个命名惯例，即在方法名前加上 <code>from_</code> 前缀，例如 <code>from_timestamp()</code>。
在标准库和第三方库中，经常会看到这种命名惯例用于标识类方法。
例如，字典类九有一个类方法，用于根据一组创建预初始化的字典。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=nb>dict</span><span class=o>.</span><span class=n>from_keys</span><span class=p>([</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=s1>&#39;b&#39;</span><span class=p>,</span> <span class=s1>&#39;c&#39;</span><span class=p>],</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># {&#39;a&#39;: 0, &#39;b&#39;: 0, &#39;c&#39;: 0}</span>
</span></span></code></pre></div><p>关于类方法需要注意的一点是，Python 并未将其与实例方法置于独立的命名空间中管理。
结果是，仍然可以通过实例来访问该方法。
例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>d</span> <span class=o>=</span> <span class=n>Date</span><span class=p>(</span><span class=mi>1967</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>9</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=n>d</span><span class=o>.</span><span class=n>today</span><span class=p>()</span>  <span class=c1># Calls Date.now(Date)</span>
</span></span></code></pre></div><h2 id=static-methods>Static Methods<a hidden class=anchor aria-hidden=true href=#static-methods>#</a></h2><p>有时一个类仅被用作命名空间，用于存放通过 <code>@staticmethod</code> 声明的静态方法。
不同于普通的方法或类方法，静态方法不接受一个 <code>self</code> 或 <code>cls</code> 参数。
一个静态方法 static method 只是刚好在类里面定义的一个函数。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Ops</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>add</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>sub</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>x</span> <span class=o>-</span> <span class=n>y</span>
</span></span></code></pre></div><p>通常不会去创建一个类实例，相反，会直接通过类来调用这些函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Ops</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># 5</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=n>Ops</span><span class=o>.</span><span class=n>sub</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>  <span class=c1># -1</span>
</span></span></code></pre></div><p>有时，其他类会使用这样的静态方法集和来实现 &ldquo;swappable&rdquo; 可交换或 &ldquo;configurable&rdquo; 可配置的行为。
或者作为某种松散模拟导入模块功能的方式。
考虑在之前的 <code>Account</code> 类使用继承：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__repr__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=sa>f</span><span class=s1>&#39;</span><span class=si>{}</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deposit</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>+=</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>withdraw</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>-=</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inquiry</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># A speical &#34;Evil&#34; account</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>EvilAccount</span><span class=p>(</span><span class=n>Account</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deposit</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>+=</span> <span class=mf>0.95</span> <span class=o>*</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inquiry</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mf>1.10</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>balance</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>balance</span>
</span></span></code></pre></div><p>这里使用继承的方式有些奇怪。
它引入了两种不同类型的对象（<code>Account</code> 和 <code>EvilAccount</code>）。
而且没有明显的方法可以将现有的 <code>Account</code> 实例转换为 <code>EvilAccount</code>，或者反过来，因为这涉及到改变实例类型。</p><p>或许，让 evil 以某种账户策略的形式显现出来反而更好。
以下是使用静态方法重新构建 <code>Account</code> 的一种方案</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>StandardPolicy</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deposit</span><span class=p>(</span><span class=n>account</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>account</span><span class=o>.</span><span class=n>balance</span> <span class=o>+=</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>withdraw</span><span class=p>(</span><span class=n>account</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>account</span><span class=o>.</span><span class=n>balance</span> <span class=o>-=</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inquiry</span><span class=p>(</span><span class=n>account</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>account</span><span class=o>.</span><span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>EvilPolicy</span><span class=p>(</span><span class=n>StandardPolicy</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deposite</span><span class=p>(</span><span class=n>account</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>account</span><span class=o>.</span><span class=n>balance</span> <span class=o>+=</span> <span class=mf>0.95</span> <span class=o>*</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inquiry</span><span class=p>(</span><span class=n>account</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mf>1.10</span> <span class=o>*</span> <span class=n>account</span><span class=o>.</span><span class=n>balance</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>account</span><span class=o>.</span><span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>,</span> <span class=o>*</span><span class=p>,</span> <span class=n>policy</span><span class=o>=</span><span class=n>StandardPolicy</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>policy</span> <span class=o>=</span> <span class=n>policy</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__repr__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=sa>f</span><span class=s1>&#39;Account(</span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>policy</span><span class=si>}</span><span class=s1>, </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>owner</span><span class=si>!r}</span><span class=s1>, </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>balance</span><span class=si>!r}</span><span class=s1>)&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deposit</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>policy</span><span class=o>.</span><span class=n>deposit</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>withdraw</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>policy</span><span class=o>.</span><span class=n>withdraw</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inquiry</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>policy</span><span class=o>.</span><span class=n>inquiry</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
</span></span></code></pre></div><p>在这个 reformulation 重构中，只创建一种 <code>Account</code> 类型。
但是，它有一个特殊的 <code>policy</code> 属性，提供了多种方法的实现。
如果需要，<code>Account</code> 实例的 policy 可以动态修改：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>policy</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;class &#39;StandardPolicy&#39;&gt;</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>policy</span> <span class=o>=</span> <span class=n>EvilPolicy</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>policy</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;class &#39;EvilPolicy&#39;&gt;</span>
</span></span></code></pre></div><p>在这里使用 <code>@staticmethod</code> 的一个原因是，无需创建 StandardPolicy 或 EvilPolicy 的实例。
这些类的的目标是组织一捆方法，而不是存储与 Account 相关的额外实例数据。</p><p>尽管 Python 的松耦合特性确实允许策略升级以持有自设数据。
将静态方法改为普通的实例方法。
例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>EvilPolicy</span><span class=p>(</span><span class=n>StandardPolicy</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>deposit_factor</span><span class=p>,</span> <span class=n>inquiry_factor</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>deposit_factor</span> <span class=o>=</span> <span class=n>deposit_factor</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>inquiry_factor</span> <span class=o>=</span> <span class=n>inquiry_factor</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deposite</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>account</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>account</span><span class=o>.</span><span class=n>balance</span> <span class=o>+=</span> <span class=bp>self</span><span class=o>.</span><span class=n>deposit_factor</span> <span class=o>*</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inquiry</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>inquiry_factor</span> <span class=o>*</span> <span class=n>account</span><span class=o>.</span><span class=n>balance</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>account</span><span class=o>.</span><span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>,</span> <span class=n>policy</span><span class=o>=</span><span class=n>EvilPolicy</span><span class=p>(</span><span class=mf>0.95</span><span class=p>,</span> <span class=mf>1.10</span><span class=p>))</span>
</span></span></code></pre></div><p>这种将方法委托为支持类的做饭，是状态机及类似对象常用的实现策略。
每个允许状态都可以封装成独立的方法类（通常为静态类）。
如此例中的策略属性可变实例变量，便可用来存储与当前运行状态相关的具体实现细节。</p><h2 id=a-world-about-design-patterns>A World About Design Patterns<a hidden class=anchor aria-hidden=true href=#a-world-about-design-patterns>#</a></h2><p>在编写面向对象程序时，有时会过于执着于实现特定的命名设计模式。
例如，策略模式 strategy pattern，享元模式 flyweight pattern，单例模式 singleton pattern 等。
这些多出于 Design Pattern 设计模式这本书。</p><p>如果你熟悉这些模式，这些内容当然可以应用到 Python 中。
然而，许多这些设计模式的设计目标是围绕着 C++ 或 Java 严格的类型系统设计的。
Python 的动态类型特性使得许多的这类模式变得过时或根本不再必要。</p><p>尽管如此，编写“优秀软件”有几个核心原则。
例如，致力于编写易于调试、可测试且可扩展的代码。
基本的特性包括为类编写 <code>__repr()__</code> 方法，组合优先于继承，并运行依赖注入，这些对实现目标很有帮助。
Python 程序员也喜欢编写被认为 Pythonic 的代码。
通常，这意味着创建遵循各种内置协议的对象，例如迭代、容器、上下文管理器等。
例如，Python 程序员不会视图从 Java 编程书中照搬某种复杂的数据遍历模式，而更可能通过生成器函数配合 for 循环来实现。
或者，干脆用几次字典查找就能替代整个模式。</p><h2 id=data-encapsulation-and-private-attributes>Data Encapsulation and Private Attributes<a hidden class=anchor aria-hidden=true href=#data-encapsulation-and-private-attributes>#</a></h2><p>在 Python 中所有的属性和方法都是公共的，这意味着他们都将没有访问限制。
在面向对象应用中，这通常不是所期望的，因为人们希望隐藏或封装内部实现细节。
为了解决这个问题，Python 依赖命名约定来表示预期的使用方式。
一个管理是使用单下划线 <code>_</code> 表示内部实现。</p><p>例如，这里有个 <code>Account</code> 类，其中 <code>balance</code> 属性是 “私有” 的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__repr__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=sa>f</span><span class=s1>&#39;Account(</span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>owner</span><span class=si>!r}</span><span class=s1>, </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>_balance</span><span class=si>!r}</span><span class=s1>)&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>deposit</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_balance</span> <span class=o>+=</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>withdraw</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_balance</span> <span class=o>-=</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inquiry</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_balance</span>
</span></span></code></pre></div><p>这段代码中，<code>_balance</code> 意味着内部细节。
没有任何阻止用户直接访问，但使用单下划线是一个强烈的信号。</p><p>一个灰色地带是，内部属性是否对子类可访问。
例如，之前的继承示例是否允许直接访问其父类的 <code>_balance</code> 属性？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>EvilAccount</span><span class=p>(</span><span class=n>Account</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inquiry</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mf>1.10</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>_balance</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_balance</span>
</span></span></code></pre></div><p>通常来说，这在 Python 中是可接受的。
此外，IDE 和其他工具可能会暴露这些属性。
如果是 C++、Java 类似的面向对象语言，这类似将 <code>_balance</code> 视为所谓的 “受保护” 属性。</p><p>如果希望使用一种更加 “私有” 的属性，名称前缀使用双下划线 <code>__</code>。
所有类似 <code>__name</code> 的名称都会自动重命名为 <code>_Classname__name</code> 的形式。
这确保了超类中使用的私有名称不会被子类中相同的名称所覆盖。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>__x</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>__spam</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>  <span class=c1># _A__spam()</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;A.__spam&#39;</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>__x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>bar</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>__spam</span><span class=p>()</span>  <span class=c1># Calls A.__spam()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>(</span><span class=n>A</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>A</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>__x</span> <span class=o>=</span> <span class=mi>37</span>  <span class=c1># self._B__x</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>__spam</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>  <span class=c1># _B__spam()</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;B.__spam&#39;</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>__x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>grok</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>__spam</span><span class=p>()</span>    <span class=c1># Calls B.__spam()</span>
</span></span></code></pre></div><p>在这个例子中，有两个不同的对 <code>__x</code> 属性的赋值。
此外，看起来 B 视图通过继承来重写 <code>__spam()</code> 方法。
然而事实并非如此，名称修饰机制回味每个定义生成唯一的名称。</p><p>使用 <code>vars()</code> 方法清楚显示对象 b 的属性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=nb>vars</span><span class=p>(</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># {&#39;_A__x&#39;: 3, &#39;_B__x&#39;: 37}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=o>.</span><span class=n>_A_spam</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># 3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=o>.</span><span class=n>_B__spame</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># 37</span>
</span></span></code></pre></div><p>尽管这种方案营造了数据隐藏的假象，但实际上并没有严格的机制来真正阻止对类中 “私有” 属性的访问。
如果知道类名和对应的属性名称，仍然可以通过修改后的名称访问。
如果这样的私有属性访问对你仍然是个问题，那么应该考虑严格的代码审核。</p><p>要注意 name mangling 名称修饰在定义时就确定了，不会影响运行时。
它不会在方法执行期间发生，也不会给程序执行增加额外开销。</p><p>在实践中，最好不要过度思考私有名称。
使用单下划线就和很常见的做法，双下划线反而更少见。
即使你可以通过一些方法实现真正的私有属性，但额外的努力会增加复杂度，这并不值得。</p><h2 id=type-hinting>Type Hinting<a hidden class=anchor aria-hidden=true href=#type-hinting>#</a></h2><p>用户自定义类的属性对其类型或值没有限制。
实际上，你可以使用任何想要的类型。
如果担心这方面的问题，那就不要这样做，也可以使用外部工具例如 linters 和 type checkers。
为此，类允许为特定属性指定可选的类型提示。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>owner</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>    <span class=n>_balance</span><span class=p>:</span> <span class=nb>float</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span></code></pre></div><p>包含类型提示对运行没有任何影响，但可以为编辑器提供额外的信息。</p><h2 id=properties>Properties<a hidden class=anchor aria-hidden=true href=#properties>#</a></h2><p>如前文所述，Python 对运行时类型没有限制。
然而，强制类型是可能的，如果将属性放到叫做 &ldquo;property&rdquo; 的管理之下。
Property 属性是一种特殊类型的特性，通过用户定义的方法拦截特性访问，并处理它。
这些方法在管理属性时有完全的自由。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>  <span class=c1># 会调用 @owner.setter</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@property</span>
</span></span><span class=line><span class=cl>    <span class=c1># 将 owner() 变成只读属性，可以通过 instnce.owner 访问 self._owner</span>
</span></span><span class=line><span class=cl>    <span class=c1># 实际上会调用 getter 方法</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>owner</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_owner</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@owner.setter</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>owner</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 验证数据后存入 _owner, value 是 __init__() 里面的 owner</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=nb>str</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s1>&#39;Expected str&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=nb>all</span><span class=p>(</span><span class=n>c</span> <span class=ow>in</span> <span class=n>string</span><span class=o>.</span><span class=n>ascii_uppercase</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s1>&#39;Must be uppercase ASCII&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>10</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s1>&#39;Must be 10 characters or less&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_owner</span> <span class=o>=</span> <span class=n>value</span>
</span></span></code></pre></div><p><code>@property</code> 装饰器用于将 attribute 变为一个 property。
在这个例子中，应用在 <code>owner</code> attribute 上。
该装饰器总是首先应用在一个获取 attribute 属性值的方法之上。
这个例子中，该方法会返回存储在私有属性 <code>_owner</code> 里的真实值。
<code>@owner.setter</code> 装饰器用于选择性的实现一个设置属性值的方法，这里的 <code>@owner.</code> 是前面的 property，而不是下面的函数。
该方法在将值存储到私有属性 <code>_owner</code> 之前，会执行各种类型和值的检查。</p><p>Properties 的一个关键特性是，相关联的名称变得 &ldquo;magical&rdquo;。
也就是说，对该属性任何访问都会通过 <code>getter/setter</code> 方法进行，而不需要修改任何已有的代码。
例如 <code>Account.__init__()</code> 无需任何改动，这看起来有些奇怪，
因为 <code>__init__()</code> 执行的是 <code>self.owner = owner</code> 的赋值，而不是直接通过私有属性 <code>self._owner</code>。
这是刻意为之，<code>owner</code> 属性的整个设计目的就是为了在设置属性时进行验证。
在创建示例时，会希望通过这种验证。</p><p>由于每次访问属性时，都会自动调用方法，因此实际值需要以不同名称存储。
这就是为什么 getter 和 setter 方法使用 <code>_owner</code>。
不能使用 <code>owner</code> 作为存储位置，因为那样会导致无限递归。</p><p>通常，属性允许拦截任何特定的属性名。
可以实现获取、设置或删除属性值的方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>SomeClass</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nd>@property</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>attr</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Getting&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@attr.setter</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>attr</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Setting&#39;</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@attr.deleter</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>attr</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Deleting&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>SomeClass</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>attr</span>       <span class=c1># Getting</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>attr</span> <span class=o>=</span> <span class=mi>13</span>  <span class=c1># Setting</span>
</span></span><span class=line><span class=cl><span class=k>del</span> <span class=n>s</span><span class=o>.</span><span class=n>attr</span>   <span class=c1># Deleting</span>
</span></span></code></pre></div><p>没有必要实现所有部分的 property，实际上，使用 properties 实现只读计算数据属性更常见。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Box</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__int__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>width</span> <span class=o>=</span> <span class=n>width</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>height</span> <span class=o>=</span> <span class=n>height</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@property</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>area</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>width</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>height</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@property</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>perimeter</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>2</span><span class=o>*</span><span class=bp>self</span><span class=o>.</span><span class=n>width</span> <span class=o>+</span> <span class=mi>2</span><span class=o>*</span><span class=bp>self</span><span class=o>.</span><span class=n>height</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># use example</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=n>Box</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>b</span><span class=o>.</span><span class=n>area</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>b</span><span class=o>.</span><span class=n>perimeter</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=o>.</span><span class=n>area</span> <span class=o>=</span> <span class=mi>5</span> <span class=c1># Error: can&#39;t set attribute</span>
</span></span></code></pre></div><p>Python 程序员通常并不注意到，方法本身是一种隐式处理的 property:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>SomeClass</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>yow</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Yow!&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>当用户创建一个实例，如 <code>s = SomeClass()</code> 然后访问 <code>s.yow</code>，原始的函数 <code>yow</code> 并没有返回。
反而是一个 bound method 绑定方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>yow</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;bound method SomeClass.yow of &lt;__main__.SomeClass object at 0x1079ce090&gt;&gt;</span>
</span></span></code></pre></div><p>当函数放在类中的时候，其行为很像 property。
具体来说，函数会神奇地拦截属性访问，并在幕后创建绑定方法。
当使用 <code>@staticmethod</code> 和 <code>@classmethod</code> 定义 static 和 class 方法的时候，实际上是在修改这个过程。
<code>@staticmethod</code> 将方法函数直接返回，不进行任何特殊的包装和处理。</p><h2 id=types-interfaces-and-abstract-base-classes>Types, Interfaces, and Abstract Base Classes<a hidden class=anchor aria-hidden=true href=#types-interfaces-and-abstract-base-classes>#</a></h2><p>当创建一个类的实例时，该实例的类型是类本身。
要测试一个对象是否属于某个类，使用内置函数 <code>isinstance(obj, cls)</code>。
返回 <code>True</code> 表示 obj 属于 cls 类型，或者任何继承 cls 的子类型。
此外，还有内置函数 <code>issubclass(A, B)</code> 内置函数来判断 A 是否是 B 的子类。</p><p>关于类型的一个常见用途是编程接口的规范。
例如，可以设计一个顶级基类来规定编程接口的具体要求。
该基类可能被用于类型提示 或 者防御类型检查 <code>isinstance()</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stream</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>receive</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=ne>NotImplementedError</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>send</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=ne>NotImplementedError</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=ne>NotImplementedError</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>send_request</span><span class=p>(</span><span class=n>stream</span><span class=p>,</span> <span class=n>request</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>stream</span><span class=p>,</span> <span class=n>Stream</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=s1>&#39;Excepted a Stream&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>stream</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>request</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>stream</span><span class=o>.</span><span class=n>receive</span><span class=p>()</span>
</span></span></code></pre></div><p>对于此类代码的预期，并非直接使用 Stream。
相反，不同的类会继承 Stream 并实现需要的功能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>SocketStream</span><span class=p>(</span><span class=n>Stream</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>receive</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>send</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PipeStream</span><span class=p>(</span><span class=n>Stream</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>receive</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>send</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>SocketStream</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>send_request</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>request</span><span class=p>)</span>
</span></span></code></pre></div><p>在本例中，值得讨论的一点是 <code>send_request</code> 中的运行时的强制检查，是否应该使用类型提示代替呢？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>send_request</span><span class=p>(</span><span class=n>stream</span><span class=p>:</span> <span class=n>Stream</span><span class=p>,</span> <span class=n>request</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>stream</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>request</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>stream</span><span class=o>.</span><span class=n>receive</span><span class=p>()</span>
</span></span></code></pre></div><p>鉴于类型提示并非强制执行，如何根据某个接口来验证一个参数，实际上取决于你希望这种验证什么时候发生。</p><p>在大型代码框架和应用中，使用接口类型更加常见。
但这种方法的问题是如何确保子类实现要求的接口。
例如，如果一个子类没有现其中的某个方法，或者拼写错了，则该问题将难以被发现。
然而，当后面调用该方法的时候，程序就会崩溃，这往往发生在凌晨 3 点。</p><p>为了避免这个问题，使用 <code>abc</code> 模块将接口定义为抽象基类 &ldquo;abstract base class&rdquo; 是一种常见的做法。
该模块定义了一个基类 <code>ABC</code> 和 一个 <code>@abstractmethod</code> 装饰器来描述接口。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>abc</span> <span class=kn>import</span> <span class=n>ABC</span><span class=p>,</span> <span class=n>abstractmethod</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stream</span><span class=p>(</span><span class=n>ABC</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nd>@abstractmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>receive</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@abstractmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>send</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>msg</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@abstractmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span></code></pre></div><p>一个抽象基类不应该被实例化，这样做会导致报错。</p><p>下面再编写类型继承该抽象基类：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>SocketStream</span><span class=p>(</span><span class=n>Stream</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>read</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>  <span class=c1># 方法写错了</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>send</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>msg</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span></code></pre></div><p>一个抽象基类能够在实例化的时候就捕获到该错误，这种提早捕获结果的方法非常有用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>SocketStream</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># Traceback (most recent call last):</span>
</span></span><span class=line><span class=cl><span class=c1>#   File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;</span>
</span></span><span class=line><span class=cl><span class=c1># TypeError: Can&#39;t instantiate abstract class SocketStream with abstract methods receive</span>
</span></span></code></pre></div><p>虽然抽象基类无法实例化，但是它可以为子类创建方法与 properties。
更多的是，一个基类中的抽象方法仍然能被子类调用。
例如在子类中可以使用 <code>super().receive()</code> 调用基类方法。</p><h2 id=multiple-inheritance-interfaces-and-mixins>Multiple Inheritance, Interfaces, and Mixins<a hidden class=anchor aria-hidden=true href=#multiple-inheritance-interfaces-and-mixins>#</a></h2><p>Python 支持多重继承 multiple inheritance (不是多层继承 multilevel inheritance)，如果子类继承多个父类，则子类会继承父类所有的特性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Duck</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>walk</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Widdle&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Trombonist</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>noise</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Blat!&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DuckBonist</span><span class=p>(</span><span class=n>Duck</span><span class=p>,</span> <span class=n>Trombonist</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>d</span> <span class=o>=</span> <span class=n>DuckBonist</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>d</span><span class=o>.</span><span class=n>walk</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>d</span><span class=o>.</span><span class=n>noise</span><span class=p>()</span>
</span></span></code></pre></div><p>看上去这是一个整洁的想法，但实际会显露出很多问题。
例如，如果两个父类都定义了 <code>__int__()</code> 方法怎么办？
或这两个方法都有 <code>noise()</code> 方法呢？
突然，你意识到多重继承充满了危险。</p><p>多重继承应该被视为一种高度专业化的代码组织和复用工具，而非通用编程技术。
具体而言，随意选取一组互不相关的类，通过多重继承将他们组合成奇怪的 “鸭子音乐家” 式混合体，并非标准做法。
实际上，永远不应该这样做。</p><p>一个更常见的多重继承使用是组织类型和接口关系。
例如，上面介绍了抽象基类的概念。
抽象基类的目的是为了指定编程接口。
例如，你可能有多个抽象基类：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>abc</span> <span class=kn>import</span> <span class=n>ABC</span><span class=p>,</span> <span class=n>abstractmethod</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stream</span><span class=p>(</span><span class=n>ABC</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nd>@abstractmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>receive</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@abstractmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>send</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>msf</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@abstractmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Iterable</span><span class=p>(</span><span class=n>ABC</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nd>@abstractmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__iter__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span></code></pre></div><p>对于这些类型，可以使用子类通过多重继承指定接口：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>MessageStream</span><span class=p>(</span><span class=n>Stream</span><span class=p>,</span> <span class=n>Iterable</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>receive</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>send</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__iter__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span></code></pre></div><p>多重继承的使用不是关于实施，而是类型关系。
没有代码复用，继承关系主要用于进行类型检查。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>m</span> <span class=o>=</span> <span class=n>MessageStream</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>isinstance</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>Stream</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>isinstance</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>Iterable</span><span class=p>)</span>
</span></span></code></pre></div><p>另一种多重继承的用法是定义 &ldquo;mixin&rdquo; 类型。
一个 minix 类用于修改或扩展其他类的功能。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Duck</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>noise</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;Quark&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>waddle</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>reutrn</span> <span class=s1>&#39;Waddle&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Trombonist</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>noise</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;Blat!&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>match</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;Colmp&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Cyclist</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>noise</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;On your left!&#39;</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>pedal</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;Pedaling&#39;</span>
</span></span></code></pre></div><p>这些类完全和彼此无关，他们之间没有继承关系，并实现了不同的方法。
然而，他们又一个共性，就是都实现了 <code>noise()</code> 方法。
一此为参考，定义如下修饰符 modifier 类：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>LoudMixin</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>noise</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>noise</span><span class=p>()</span><span class=o>.</span><span class=n>upper</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>AnnoyingMixin</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>noise</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>noise</span><span class=p>()</span> <span class=o>*</span> <span class=mi>3</span>
</span></span></code></pre></div><p>看上去这些类好像有问题，因为他们试图通过使用 <code>super()</code> 访问不存在的父类。
实际上，实例化调用 <code>noise()</code> 方法确实会报错。
这些是 minix 类型，正常的使用方式是将他们与其他实现了该方法的类结合起来：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>LoudDuck</span><span class=p>(</span><span class=n>LoudMixin</span><span class=p>,</span> <span class=n>Duck</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>AnnoyingTrombonist</span><span class=p>(</span><span class=n>AnnoyingMixin</span><span class=p>,</span> <span class=n>Trombonist</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>AnnoyingLoudCyclist</span><span class=p>(</span><span class=n>AnnoyingMixin</span><span class=p>,</span> <span class=n>LoudMixin</span><span class=p>,</span> <span class=n>Cyclist</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>d</span> <span class=o>=</span> <span class=n>LoudDuck</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>d</span><span class=o>.</span><span class=n>noise</span><span class=p>()</span>  <span class=c1># &#39;QUACk&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=n>AnnoyingTrombonist</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>t</span><span class=o>.</span><span class=n>noise</span><span class=p>()</span>  <span class=c1># &#39;Blat!Blat!Blat!&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>c</span> <span class=o>=</span> <span class=n>AnnoyingLoudCyclist</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>c</span><span class=o>.</span><span class=n>noise</span><span class=p>()</span>  <span class=c1># &#39;ON YOUR LEFT!ON YOUR LEFT!ON YOUR LEFT!&#39;</span>
</span></span></code></pre></div><p>由于 mixin 类型和普通类的定义相同，因此建议在类名后面添加 &ldquo;Mixin&rdquo; 以表明该类的目的。</p><p>无论是否使用继承，Python 都会构建一个线性的类链称为 &ldquo;Method Resolution Order&rdquo;，即 MRO。
这个通过类中的 <code>__mro__</code> 属性可以访问，下面是一些单继承的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>(</span><span class=n>Base</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>(</span><span class=n>A</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Base</span><span class=o>.</span><span class=vm>__mro__</span>  <span class=c1>#                                             (&lt;class &#39;__main__.Base&#39;&gt;, &lt;class &#39;object&#39;&gt;)</span>
</span></span><span class=line><span class=cl><span class=n>A</span><span class=o>.</span><span class=vm>__mro__</span>     <span class=c1>#                       (&lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.Base&#39;&gt;, &lt;class &#39;object&#39;&gt;)</span>
</span></span><span class=line><span class=cl><span class=n>B</span><span class=o>.</span><span class=vm>__mro__</span>     <span class=c1># (&lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.Base&#39;&gt;, &lt;class &#39;object&#39;&gt;)</span>
</span></span></code></pre></div><p>MRO 规定了属性查找的顺序，当访问一个类的属性和方法的时候，会按照 MRO 的顺序进行查找。</p><p>为了支持多重继承，Python 实现了 “协作式多重继承” cooperative multiple inheritance。
通过协作式继承，所有的类都根据下面两个规则放在 MRO 列表中：</p><ol><li>子类必须在父类之间被检查</li><li>如果继承多个父类，则必须按照子类中父类的写入顺序进行检查</li></ol><p>然而，实际实现的算法会十分复制，并不是简单的深度优先或广度优先遍历。
该算法称为 C3 linerization algorithm (C3 线性算法)，paper &ldquo;A Monotonic Superclass Linerizaiton for Dylan&rdquo; (K. Barrett, et al, presented at OOPSLA'96).
该算法的微妙之处在于某些类层次构造会被 Python 拒绝，抛出 <code>TypeError</code>，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>X</span><span class=p>:</span> <span class=k>pass</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Y</span><span class=p>(</span><span class=n>X</span><span class=p>):</span> <span class=k>pass</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Z</span><span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>Y</span><span class=p>):</span> <span class=k>pass</span>  <span class=c1># TypeError. Can&#39;t create consistent MRO</span>
</span></span></code></pre></div><p>在这个例子中，X 在 Y 前面，因此 MRO 先检查 X 再检查 Y，但是 Y 继承自 X，导致 Y 又在 X 前面，这就产生了冲突。
这种问题一般很少出现，如果出现这说明有严重的设计问题。</p><p><code>super()</code>函数的行为与底层的方法解析顺序（MRO）紧密相关。
具体而言，它的作用是将属性委托给 MRO 中的下一个类。
这一机制取决于使用<code>super()</code>的类所在的位置。
例如，当 <code>AnnoyingMixin</code> 类使用 <code>super()</code> 方法，他会查看 MRO 的实例来找到自己的位置。
随后，它将属性委托给下一个类。</p><p>在这个列子中，在 <code>AnnoyingLoudCyclist</code> 类使用 <code>super().noise()</code> 会触发 <code>LoudMixin.noise()</code>。</p><p>设计协作式多重继承和 mixin 十分有挑战性，但这仍有一些设计指导原则。
首先，在方法解析顺序 (MRO) 中，子类总是优先于任何基类被检查。
因此，minix 共用同一个父类实际上很常见，mixin 类通常共享一个共同的父类，且该父类会为方法提供空实现。
如果同时使用多重 mixin 类型，他们将会依次排列。
公共父类应置于最后，以便提供默认或错误检查。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>NoiseMixin</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>noise</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>NotImplementedError</span><span class=p>(</span><span class=s1>&#39;noise() not implemented&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LoudMixin</span><span class=p>(</span><span class=n>NoiseMixin</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>noise</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>noise</span><span class=p>()</span><span class=o>.</span><span class=n>upper</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>AnnoyingMixin</span><span class=p>(</span><span class=n>NoiseMixin</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>noise</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>3</span> <span class=o>*</span> <span class=n>suepr</span><span class=p>()</span><span class=o>.</span><span class=n>noise</span><span class=p>()</span>
</span></span></code></pre></div><p>第二个指导放针是所有的 mixin 方法的实现都应该相同的函数签名。
Mixin 的一个问题是他们是可选的，并通常以不可预测的顺序混合在一起。
为了让这个能正常工作，必须确保涉及 <code>super()</code> 的操作无论后续无论出现哪个类都能成功执行。
为此，调用链中的所有方法都必须具有兼容的调用签名。</p><p>最后，要确保在任何位置都使用 <code>super()</code>。
有时你会遇到一个类直接调用其父类：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>yow</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Base.yow&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>(</span><span class=n>Base</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>yow</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;A.yow&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>Base</span><span class=o>.</span><span class=n>yow</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>(</span><span class=n>Base</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>yow</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;B.yow&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>Base</span><span class=o>.</span><span class=n>yow</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>yow</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>C</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>B</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>c</span> <span class=o>=</span> <span class=n>C</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>c</span><span class=o>.</span><span class=n>yow</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># A.yow</span>
</span></span><span class=line><span class=cl><span class=c1># Base.yow</span>
</span></span></code></pre></div><p>这样的类型使用多重继承就不安全，这样会打破调用链并导致混乱。
这个例子中，从未调用过 <code>B.yow()</code> 即使它是继承的一部分。
如果要使用多重继承，应该考虑使用 <code>super()</code> 而不是直接调用父类方法。</p><h2 id=type-based-dispatch>Type-based Dispatch<a hidden class=anchor aria-hidden=true href=#type-based-dispatch>#</a></h2><p>有时候需要编写根据特定类型进行分发的代码。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>Duck</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>handle_duck</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>Trombonist</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>handle_trombonist</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>elif</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>obj</span><span class=p>,</span> <span class=n>Cyclist</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>handle_cyclist</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>raise</span> <span class=ne>RuntimeError</span><span class=p>(</span><span class=s1>&#39;Unknown object&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>编写一长串的 if-else 块脆弱又不优雅，一个解决方案是通过字典进行调度：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>handlers</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Duck</span><span class=p>:</span> <span class=n>handle_duck</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Trombonist</span><span class=p>:</span> <span class=n>handle_trombonist</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Cyclist</span><span class=p>:</span> <span class=n>handle_cyclist</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Dispatch</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dispatch</span><span class=p>(</span><span class=n>obj</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span> <span class=o>=</span> <span class=n>handlers</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=nb>type</span><span class=p>(</span><span class=n>obj</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>func</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>reutrn</span> <span class=n>func</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>RuntimeError</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;No handler of </span><span class=si>{</span><span class=n>obj</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>有时调度功能通过类接口 <code>getattr()</code> 实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Dispatcher</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>handle</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>obj</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>ty</span> <span class=ow>in</span> <span class=nb>type</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span><span class=o>.</span><span class=vm>__mro__</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>meth</span> <span class=o>=</span> <span class=nb>getattr</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=sa>f</span><span class=s1>&#39;handle_</span><span class=si>{</span><span class=n>ty</span><span class=o>.</span><span class=vm>__name__</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>meth</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>meth</span><span class=p>(</span><span class=n>objt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>RuntimeError</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;No handler for </span><span class=si>{</span><span class=n>obj</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>handle_Duck</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>obj</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>handle_Trombonist</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>obj</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>handle_Cyclist</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>obj</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example</span>
</span></span><span class=line><span class=cl><span class=n>dispatcher</span> <span class=o>=</span> <span class=n>Dispatcher</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>dispatcher</span><span class=o>.</span><span class=n>handle</span><span class=p>(</span><span class=n>Duck</span><span class=p>())</span>     <span class=c1># handle_Duck()</span>
</span></span><span class=line><span class=cl><span class=n>dispatcher</span><span class=o>.</span><span class=n>handle</span><span class=p>(</span><span class=n>Cyclist</span><span class=p>())</span>  <span class=c1># handle_Cyclist()</span>
</span></span></code></pre></div><h2 id=class-decorators>Class Decorators<a hidden class=anchor aria-hidden=true href=#class-decorators>#</a></h2><p>有时，在定义类之后，可能希望执行额外的处理步骤。
例如，将类添加到注册表中，或生成额外的支持代码。
解决此类问题的一种方法就是使用类装饰器。
一个类装饰器是接受一个类作为参数，并返回一个类的函数。</p><p>例如这个维护注册表的问题：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>_registry</span> <span class=o>=</span> <span class=p>{</span> <span class=p>}</span>  <span class=c1># 注册表</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>register_decorder</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>mt</span> <span class=ow>in</span> <span class=bp>cls</span><span class=o>.</span><span class=n>mimetypes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>_registry</span><span class=p>[</span><span class=n>mt</span><span class=o>.</span><span class=n>mimetype</span><span class=p>]</span> <span class=o>=</span> <span class=bp>cls</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=bp>cls</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Factory function that uses the registry</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>create_decoder</span><span class=p>(</span><span class=n>mimetype</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>_registry</span><span class=p>[</span><span class=n>mimetype</span><span class=p>]()</span>
</span></span></code></pre></div><p>在这个例子中，<code>register_decorder()</code> 函数会查找类内部的 <code>mimetypes</code> 属性。
如果找到该项，就会使用它将该类加入一个字典中，该字典用于将 MIME 类型映射到类对象。
为了使用这个函数，在类定义之前将其作为装饰器使用。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=nd>@register_decoder</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TextDecoder</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>mimetyeps</span> <span class=o>=</span> <span class=p>[</span> <span class=s1>&#39;text/plain&#39;</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>decode</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@regisger_docoder</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>HTMLDecoder</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>mimetypes</span> <span class=o>=</span> <span class=p>[</span> <span class=s1>&#39;text/html&#39;</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>decode</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@register_decorder</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ImageDecoder</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>mimetype</span> <span class=o>=</span> <span class=p>[</span> <span class=s1>&#39;image/png&#39;</span><span class=p>,</span> <span class=s1>&#39;image/jpg&#39;</span><span class=p>,</span> <span class=s1>&#39;image/gif&#39;</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>decode</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example usage</span>
</span></span><span class=line><span class=cl><span class=n>decoder</span> <span class=o>=</span> <span class=n>create_decoder</span><span class=p>(</span><span class=s1>&#39;image/jpg&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>类装饰器能够自由修改类的内容。
例如，他们甚至可能重写现存的方法。
这是替代 mixin 类型和使用多重继承的一种方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>loud</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>orig_noise</span> <span class=o>=</span> <span class=bp>cls</span><span class=o>.</span><span class=n>noise</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>noise</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>orig_noise</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=o>.</span><span class=n>upper</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=bp>cls</span><span class=o>.</span><span class=n>noise</span> <span class=o>=</span> <span class=n>noise</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=bp>cls</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>annoying</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>orig_noise</span> <span class=o>=</span> <span class=bp>cls</span><span class=o>.</span><span class=n>noise</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>noise</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>orig_noise</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>    <span class=bp>cls</span><span class=o>.</span><span class=n>noise</span> <span class=o>=</span> <span class=n>noise</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=bp>cls</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@annoying</span>
</span></span><span class=line><span class=cl><span class=nd>@loud</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Cyclist</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>noise</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;One your left&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>pedal</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;Pedaling&#39;</span>
</span></span></code></pre></div><p>这个例子产生的结果和之前的 mixin 相同，但并没有使用多重继承和 <code>super()</code>。
在每个装饰器内，<code>cls.noise</code> 和 <code>spuer()</code> 的效果相同。
但是，由于装饰器仅在应用时执行一次，后续对 <code>noise()</code> 的调用会运行得更快一些。</p><p>类装饰器可以用于创建全新的代码。
例如，编写类的一个常见任务是编写有用的 <code>__repr__()</code> 方法以提升调试效率。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Point</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__repr__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=sa>f</span><span class=s1>&#39;</span><span class=si>{</span><span class=nb>type</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span><span class=o>.</span><span class=vm>__name__</span><span class=si>}</span><span class=s1>(</span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>x</span><span class=si>!r}</span><span class=s1>, </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>y</span><span class=si>!r}</span><span class=s1>)&#39;</span>
</span></span></code></pre></div><p>总是编写该方法挺麻烦的，或许可以实现一个类装饰器来完成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>inspect</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>with_repr</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>args</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>inspect</span><span class=o>.</span><span class=n>signature</span><span class=p>(</span><span class=bp>cls</span><span class=p>)</span><span class=o>.</span><span class=n>parameters</span><span class=p>)</span>  <span class=c1># 获取参数列表</span>
</span></span><span class=line><span class=cl>    <span class=n>argvals</span> <span class=o>=</span> <span class=s1>&#39;, &#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=s1>&#39;{self.</span><span class=si>%s</span><span class=s1>!r}&#39;</span> <span class=o>%</span> <span class=n>arg</span> <span class=k>for</span> <span class=n>arg</span> <span class=ow>in</span> <span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>code</span> <span class=o>=</span> <span class=s1>&#39;def __repr__(self):</span><span class=se>\n</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>    <span class=n>code</span> <span class=o>+=</span> <span class=sa>f</span><span class=s1>&#39;  return f&#34;</span><span class=si>{</span><span class=bp>cls</span><span class=o>.</span><span class=vm>__name__</span><span class=si>}</span><span class=s1>(</span><span class=si>{</span><span class=n>argvals</span><span class=si>}</span><span class=s1>)&#34;</span><span class=se>\n</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>    <span class=n>locs</span> <span class=o>=</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>exec</span><span class=p>(</span><span class=n>code</span><span class=p>,</span> <span class=n>locs</span><span class=p>)</span>  <span class=c1># 执行字符串代码，生成函数</span>
</span></span><span class=line><span class=cl>    <span class=bp>cls</span><span class=o>.</span><span class=fm>__repr__</span> <span class=o>=</span> <span class=n>locs</span><span class=p>[</span><span class=s1>&#39;__repr__&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=bp>cls</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example</span>
</span></span><span class=line><span class=cl><span class=nd>@with_repr</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>Point</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>y</span>
</span></span></code></pre></div><p>在这个例子中，<code>__repr__()</code> 方法是从 <code>__init__()</code> 方法的调用签名自动生成的。
该方法由一串文本字符创建，并传递给 <code>exec()</code> 函数，然后在绑定到类上。</p><p>类似的代码生成技术在标准库中也存在。
例如，定义数据结构的一种便捷方法是使用数据类：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>dataclasses</span> <span class=kn>import</span> <span class=n>dataclass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@dataclass</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Point</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>:</span> <span class=nb>int</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=p>:</span> <span class=nb>int</span>
</span></span></code></pre></div><p>dataclass 会自动从类的类型提示创建 <code>__init__()</code> 和 <code>__repr__()</code> 这样的方法，这些方法都使用 <code>exec()</code> 创建。
然而，这种方法的缺点之一是启动性能较差。
使用 <code>exec()</code> 动态创建的代码会绕过 Python 通常对模块应用的编译优化。
因此，以这种方式定义大量类会显著减慢代码的导入速度。</p><h2 id=supervised-inheritance>Supervised Inheritance<a hidden class=anchor aria-hidden=true href=#supervised-inheritance>#</a></h2><p>有时候想要给类添加额外的功能，类装饰器是实现的方式之一。
然而，父类也可以代表其子类执行额外的操作。
这是通过实现一个 <code>__init_subclass__(cls)</code> 类方法来完成的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>__init_subclass__</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Initalizing&#39;</span><span class=p>,</span> <span class=bp>cls</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>(</span><span class=n>Base</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>(</span><span class=n>Base</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><p>只要 <code>__init_subclass__()</code> 方法存在，无论子类继承有多深都会自动触发执行。
许多通常通过类装饰器完成的任务，现在可以通过 <code>__init_subclass__()</code> 来实现：</p><p>例如，类注册：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>DecoderBase</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>_registry</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>__init_subclass__</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>mt</span> <span class=ow>in</span> <span class=bp>cls</span><span class=o>.</span><span class=n>mimetypes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>DecoderBase</span><span class=o>.</span><span class=n>_registry</span><span class=p>[</span><span class=n>mt</span><span class=o>.</span><span class=n>mimetype</span><span class=p>]</span> <span class=o>=</span> <span class=bp>cls</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>create_decoder</span><span class=p>(</span><span class=n>mimetype</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>DecoderBase</span><span class=o>.</span><span class=n>_registry</span><span class=p>[</span><span class=n>mimetype</span><span class=p>]()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TextDecoder</span><span class=p>(</span><span class=n>DecoderBase</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>mimetypes</span> <span class=o>=</span> <span class=p>[</span> <span class=s1>&#39;text/plain&#39;</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>decode</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>HTMLDecoder</span><span class=p>(</span><span class=n>DecoderBase</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>mimetypes</span> <span class=o>=</span> <span class=p>[</span> <span class=s1>&#39;text/html&#39;</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>decode</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ImageDecoder</span><span class=p>(</span><span class=n>DecoderBase</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>mimetypes</span> <span class=o>=</span> <span class=p>[</span> <span class=s1>&#39;image/png&#39;</span><span class=p>,</span> <span class=s1>&#39;image/jpg&#39;</span><span class=p>,</span> <span class=s1>&#39;image/gif&#39;</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>decode</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>decoder</span> <span class=o>=</span> <span class=n>create_decoder</span><span class=p>(</span><span class=s1>&#39;image/jpg&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>这里是一个类从 <code>__init__()</code> 方法自动创建 <code>__repr__()</code> 方法的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>inspect</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>__init_subclass__</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Create a __repr__ method</span>
</span></span><span class=line><span class=cl>        <span class=n>args</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>inspect</span><span class=o>.</span><span class=n>signature</span><span class=p>(</span><span class=bp>cls</span><span class=p>)</span><span class=o>.</span><span class=n>parameters</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>argvals</span> <span class=o>=</span> <span class=s1>&#39;, &#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=s1>&#39;{self.</span><span class=si>%s</span><span class=s1>!r}&#39;</span> <span class=o>%</span> <span class=n>arg</span> <span class=k>for</span> <span class=n>arg</span> <span class=ow>in</span> <span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>code</span> <span class=o>=</span> <span class=s1>&#39;def __repr__(self):</span><span class=se>\n</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>        <span class=n>code</span> <span class=o>+=</span> <span class=s1>&#39;  return f&#34;</span><span class=si>{cls.__name__}</span><span class=s1>(</span><span class=si>{argvals}</span><span class=s1>)&#34;</span><span class=se>\n</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl>        <span class=n>locs</span> <span class=o>=</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>exec</span><span class=p>(</span><span class=n>code</span><span class=p>,</span> <span class=n>locs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>cls</span><span class=o>.</span><span class=fm>__repr__</span> <span class=o>=</span> <span class=n>locs</span><span class=p>[</span><span class=s1>&#39;__repr__&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Point</span><span class=p>(</span><span class=n>Base</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>y</span>
</span></span></code></pre></div><p>如果使用了多层继承，则应该使用 <code>super()</code> 来确保所有实现了 <code>__init_subclass__()</code> 的类都能被调用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>__init_subclass__</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;A.init_subclass&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>__init_subclass__</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>__init_subclass__</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;B.init_subclass&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>__init_subclass__</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 应该能看到两个类的输出</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>C</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>B</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><p>通过 <code>__init_subclass__</code> 来实现 supervising inheritance 监督继承是 Python 最强大的自定义特性之一。
大部分力量源于其隐含特性，一个顶级基类可以借此悄无声息地监督整个子类层次结构。
这种监督机制可以注册类、重写方法、执行验证等操作。</p><h2 id=the-object-life-cycle-and-memmory-management>The Object Life Cycle and Memmory Management<a hidden class=anchor aria-hidden=true href=#the-object-life-cycle-and-memmory-management>#</a></h2><p>当定义一个类时，实现的类就是创建新实例的工厂。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Amount</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Amount</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=n>Amount</span><span class=p>(</span><span class=s1>&#39;Eva&#39;</span><span class=p>,</span> <span class=mf>25.0</span><span class=p>)</span>
</span></span></code></pre></div><p>实例的创建通过两个步骤完成:
首先使用特殊方法 <code>__new__()</code> 创建新实例，然后使用 <code>__init__()</code> 对其进行初始化。</p><p>例如 <code>a = Account('Guido', 1000.0)</code> 会执行以下步骤：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=o>.</span><span class=fm>__new__</span><span class=p>(</span><span class=n>Accound</span><span class=p>,</span> <span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>Account</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>Account</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span></code></pre></div><p>除了第一个参数接收的类本身而非实例外，<code>__new__()</code> 通常接收与 <code>__init__()</code> 相同的参数。
有时候会看到 <code>__new__()</code> 仅传入单个参数调用。
然而，<code>__new__()</code> 的默认实现通常只是直接忽略它们。
有时候会看到 <code>__new__()</code> 仅被传入单个参数调用。</p><p>比如这样写也可以：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=o>.</span><span class=fm>__new__</span><span class=p>(</span><span class=n>Account</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>Account</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span></code></pre></div><p>直接使用 <code>__new__()</code> 方法并不常见，但有时会用它来创建实例，同时绕过对 <code>__init__()</code> 方法的调用。</p><p>类方法就有这样的，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Date</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>year</span><span class=p>,</span> <span class=n>month</span><span class=p>,</span> <span class=n>day</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>year</span> <span class=o>=</span> <span class=n>year</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>month</span> <span class=o>=</span> <span class=n>month</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>day</span> <span class=o>=</span> <span class=n>day</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@classmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>today</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>localtime</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span> <span class=o>=</span> <span class=bp>cls</span><span class=o>.</span><span class=fm>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>)</span>  <span class=c1># Make instance</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>year</span> <span class=o>=</span> <span class=n>t</span><span class=o>.</span><span class=n>tm_year</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>month</span> <span class=o>=</span> <span class=n>t</span><span class=o>.</span><span class=n>tm_month</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>day</span> <span class=o>=</span> <span class=n>t</span><span class=o>.</span><span class=n>tm_year</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span>
</span></span></code></pre></div><p>执行对象序列化的模块，如 pickle 在反序列化对象时也会利用 <code>__new__()</code> 方法来重新创建实例。
这是在不调用 <code>__init__()</code> 的情况下完成的。</p><p>有时，类会定义 <code>__new__()</code> 方法，以改变实例创建的某些方面。
典型的应用包括实例缓存 instance caching、单例模式 singleton 和不可变性 immutability。</p><p>假如你希望 Date 类实现日期驻留，缓存 Date 实例并复用有相同年月日的现有对象。
这是一种实现方式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Date</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>_cache</span> <span class=o>=</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=n>year</span><span class=p>,</span> <span class=n>month</span><span class=p>,</span> <span class=n>day</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span> <span class=o>=</span> <span class=n>Date</span><span class=o>.</span><span class=n>_cache</span><span class=o>.</span><span class=n>get</span><span class=p>((</span><span class=n>year</span><span class=p>,</span> <span class=n>month</span><span class=p>,</span> <span class=n>day</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span> <span class=o>=</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>year</span> <span class=o>=</span> <span class=n>year</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>month</span> <span class=o>=</span> <span class=n>month</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>day</span> <span class=o>=</span> <span class=n>day</span>
</span></span><span class=line><span class=cl>            <span class=n>Date</span><span class=o>.</span><span class=n>_cache</span><span class=p>[</span><span class=n>year</span><span class=p>,</span> <span class=n>month</span><span class=p>,</span> <span class=n>day</span><span class=p>]</span> <span class=o>=</span> <span class=bp>self</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>year</span><span class=p>,</span> <span class=n>month</span><span class=p>,</span> <span class=n>day</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>d</span> <span class=o>=</span> <span class=n>Date</span><span class=p>(</span><span class=mi>2012</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>21</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>e</span> <span class=o>=</span> <span class=n>Date</span><span class=p>(</span><span class=mi>2012</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>21</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>assert</span> <span class=n>d</span> <span class=ow>is</span> <span class=n>e</span>  <span class=c1># same object</span>
</span></span></code></pre></div><p>在这个例子中，类维护一个内部字典，用于存储先前创建的 Date 实例。
在创建新的 Date 对象时，会首先查询缓存。
如果找到匹配项，则返回该实例。
否则，会创建并初始化新的实例。</p><p>此解决方案的一个微秒之处在于其空的 <code>__init__()</code> 方法。
即使已经缓存了，每次调用 <code>Date()</code> 仍然会调用 <code>__init__()</code>。
为了避免这个情况，该方法仅执行空操作，实例的实际创建发生在首次创建实例时的 <code>__new__()</code> 方法中。</p><p>有方法可以避免对 <code>__init__()</code> 的额外调用，但这需要一些巧妙的技巧。
避免这种情况的一种方法是让 <code>__new__()</code> 返回一个完全不同的类型实例。
另一种解决方案是使用元类 metaclass。</p><p>实例一但创建就会通过引用计数管理，如果引用计数归零会立刻消毁。
当要消毁实例的时候，解释器首先寻找该对象上的 <code>__del__</code> 方法，然后调用它。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__del__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Deleting Account&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>del</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=c1># Deleting Account</span>
</span></span></code></pre></div><p>有时，程序会使用 <code>del</code> 语句来删除对某个对象的引用。
如果这导致引用计数归零，则会调用 <code>__del__()</code> 方法。
但并不是总会调用该方法，因为该对象往往还有其他引用。
此外，还有许多其他导致对象被删除的方法。</p><p>例如，变量名的重新赋值或函数中变量超出作用域的情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>42</span>  <span class=c1># Deleting Account</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>()</span>  <span class=c1># Deleting Account</span>
</span></span></code></pre></div><p>在实际中，很少需要定义 <code>__del__()</code> 方法。
唯一的例外是，当消毁对象需要进行额外清理操作时，例如关闭文件、断开网络连接或是否其他系统资源。
即使在这些情况下，依赖 <code>__del__()</code> 来实现正确的关闭也是危险的，因为无法保证该方法会在可能被调用的时候执行。
为了清晰的关闭资源，应该提供专门的 <code>close()</code> 方法。
同是也想要让类支持上下文管理器协议，这样就可以使用 <code>with</code> 语句。</p><p>下面是一个覆盖所有情况的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>SomeClass</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>resource</span> <span class=o>=</span> <span class=n>open_resource</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__del__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>resource</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__enter__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__exit__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>ty</span><span class=p>,</span> <span class=n>val</span><span class=p>,</span> <span class=n>tb</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 通过 __del__() 关闭</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>SomeClass</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>del</span> <span class=n>s</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 显示关闭</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>=</span>  <span class=n>SomeClass</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在 context 块结束后关闭</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=n>SomeClass</span><span class=p>()</span> <span class=k>as</span> <span class=n>s</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></div><p>再次强调，在大多数类中都没有必要编写 <code>__del__()</code> 方法。
Python 本身就有垃圾回收机制，没有自己实现的必要，除非在对象消毁过程中有额外的行为需要执行。
即使这样，你可能也不需要 <code>__del__()</code>。类可能早已编写为能自己合理地自我清除。</p><p>除了引用计数和对象消毁本身存在的诸多风险外，还有某些编程模式。
尤其设计父子关系、图结构或缓存的场景，还可能引发所谓的 “引用循环” 问题。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>SomeClass</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__del__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Deleting&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>parent</span> <span class=o>=</span> <span class=n>SomeClass</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>child</span> <span class=o>=</span> <span class=n>SomeClass</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 创建一个父子循环引用</span>
</span></span><span class=line><span class=cl><span class=n>parent</span><span class=o>.</span><span class=n>child</span> <span class=o>=</span> <span class=n>child</span>
</span></span><span class=line><span class=cl><span class=n>child</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=n>parent</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 尝试删除：没有输出 Deleting</span>
</span></span><span class=line><span class=cl><span class=k>del</span> <span class=n>parent</span>
</span></span><span class=line><span class=cl><span class=k>del</span> <span class=n>child</span>
</span></span></code></pre></div><p>在这个例子中，变量名称被消毁了，但 <code>__del__()</code> 方法却没有被调用。
这两个对象每个内部都有另一个的引用。因此，引用计数无法降到 0。
为了应对这种情况，一个特殊的循环检测垃圾回收器会定期运行。
最终这些对象会被回收，但很难预测何时会发生。
如果想要强制垃圾回收，可以运行 <code>gc.collect()</code>。
<code>gc</code> 模块还包含多种与循环垃圾回收及内存监控相关的其他技能。</p><p>由于垃圾回收的不可预测性，<code>__del__()</code> 方法在使用上存在一些限制。
首先，任何从 <code>__del__()</code> 方法中传播出的异常都会被打印到 <code>sys.stderr</code>，除此之外将被忽略。
其次，<code>__del__()</code> 方法应避免涉及获取锁或其他资源的操作。
这样做可能导致死锁，当 <code>__del__()</code> 在信号处理和线程的第七层内部回调圈中执行无关函数时意外触发。
如果一定要使用 <code>__del__</code> 方法，请保持其简明。</p><h2 id=weak-references>Weak References<a hidden class=anchor aria-hidden=true href=#weak-references>#</a></h2><p>有时候变量还存在，但你希望他们被回收。
例如上面的 <code>Date</code> 类型，该类型一但添加缓存就无法取消。</p><p>解决上面问题的一种方法是弱引用 <code>weakref</code> 模块。
弱引用是一种引用对象，但是不增加引用计数的方式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>weakref</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>a_ref</span> <span class=o>=</span> <span class=n>weakref</span><span class=o>.</span><span class=n>ref</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;weakref at 0x104617188; to &#39;Account&#39; at 0x1046105c0&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>del</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=n>a_ref</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;weakref at 0x104617188; dead&gt;</span>
</span></span></code></pre></div><p>为了获取弱引用指向的对象，需要像无参函数那样调用它。
这将返回被指向的对象或 <code>None</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>acct</span> <span class=o>=</span> <span class=n>a_ref</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>acct</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>acct</span><span class=o>.</span><span class=n>withdraw</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 简洁写法</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>acct</span> <span class=o>:=</span> <span class=n>a_ref</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>acct</span><span class=o>.</span><span class=n>withdraw</span><span class=p>()</span>
</span></span></code></pre></div><p>弱引用通常与缓存及其他高级内存管理技术结合使用。
下面是一个修改后的 <code>Data</code> 类型，能够自动移除不存在引用的缓存：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>weakref</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Date</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>_cache</span> <span class=o>=</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=n>year</span><span class=p>,</span> <span class=n>month</span><span class=p>,</span> <span class=n>day</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>selfref</span> <span class=o>=</span> <span class=n>Date</span><span class=o>.</span><span class=n>_cache</span><span class=o>.</span><span class=n>get</span><span class=p>((</span><span class=n>year</span><span class=p>,</span> <span class=n>month</span><span class=p>,</span> <span class=n>day</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>selfref</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span> <span class=o>=</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>year</span> <span class=o>=</span> <span class=n>year</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>month</span> <span class=o>=</span> <span class=n>month</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>day</span> <span class=o>=</span> <span class=n>day</span>
</span></span><span class=line><span class=cl>            <span class=n>Date</span><span class=o>.</span><span class=n>_cache</span><span class=p>[</span><span class=n>year</span><span class=p>,</span> <span class=n>month</span><span class=p>,</span> <span class=n>day</span><span class=p>]</span> <span class=o>=</span> <span class=n>weakref</span><span class=o>.</span><span class=n>ref</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span> <span class=o>=</span> <span class=n>selfref</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>year</span><span class=p>,</span> <span class=n>month</span><span class=p>,</span> <span class=n>day</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__del__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>del</span> <span class=n>Date</span><span class=o>.</span><span class=n>_cache</span><span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>year</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>month</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>day</span><span class=p>]</span>
</span></span></code></pre></div><p>支持弱引用要求实例具有可变的 <code>__weakref__</code> 属性。
用户定义的类通常默认有该属性。
然而，内部类型和特定的数据类型不支持。
如果想为这些类型创建弱引用，可以通过添加了 <code>__weakref__</code> 属性的变体来实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>wdict</span><span class=p>(</span><span class=nb>dict</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=vm>__slots__</span> <span class=o>=</span> <span class=p>(</span><span class=s1>&#39;__weakref__&#39;</span><span class=p>,</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>w</span> <span class=o>=</span> <span class=n>wdict</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>w_ref</span> <span class=o>=</span> <span class=n>weakref</span><span class=o>.</span><span class=n>ref</span><span class=p>(</span><span class=n>w</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=internal-object-representation-and-attribute-binding>Internal Object Representation and Attribute Binding<a hidden class=anchor aria-hidden=true href=#internal-object-representation-and-attribute-binding>#</a></h2><p>与实例关联的状态存储在一个字典中，该字典可通过实际的 <code>__dict__</code> 属性访问。
该字典包含每个实例独有的数据，例如这个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1100.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=vm>__dict__</span>
</span></span><span class=line><span class=cl><span class=c1># {&#39;owner&#39;: &#39;Guido&#39;, &#39;balance&#39;: 1100.0}</span>
</span></span></code></pre></div><p>任何时间都可以添加新属性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>number</span> <span class=o>=</span> <span class=mi>123456</span>  <span class=c1># Add attribute &#39;number&#39; to a.__dict__</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=vm>__dict__</span><span class=p>[</span><span class=s1>&#39;number&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>654321</span>
</span></span></code></pre></div><p>对实例的修改总是会反应在其本地的 <code>__dict__</code> 属性中，除非该属性由 property 管理。
同样，如果直接修改 <code>__dict__</code> 则也会反应在实例属性上。</p><p>实例通过一个特殊属性 <code>__class__</code> 与类关联。
类本身也只是一个覆盖在字典上的薄层，这个字典可以在其自身的 <code>__dict__</code> 属性中找到。
类字段是存放方法的地方，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=vm>__class__</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;class &#39;__main__.Account&#39;&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Account</span><span class=o>.</span><span class=vm>__dict__</span><span class=o>.</span><span class=n>keys</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># dict_keys([&#39;__module__&#39;, &#39;__init__&#39;, &#39;__repr__&#39;, &#39;deposit&#39;, &#39;withdraw&#39;, &#39;inquiry&#39;, &#39;__dict__&#39;, &#39;__weakref__&#39;, &#39;__doc__&#39;])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Account</span><span class=o>.</span><span class=vm>__dict__</span><span class=p>[</span><span class=s1>&#39;withdraw&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1># &lt;function Account.withdraw at 0x108204158&gt;</span>
</span></span></code></pre></div><p>类通过特殊属性 <code>__base__</code> 连接到他们的基类 base class，其为一个基类的元组。
<code>__base__</code> 属性只用于提供信息。
继承的实际运行实现依赖于 <code>__mro__</code> 属性，该属性是一个按搜索顺序排列的所有父类元组。
这一底层结构构成了实例属性进行获取、设置和删除等所有操作的基础。</p><p>当属性使用 <code>obj.name = value</code>时，会调用特殊方法 <code>obj.__setattr__('name', value)</code>。
如果同 <code>del obj.name</code> 删除属性，则会调用特殊方法 <code>obj.__delattr__('name')</code>。
这些默认方法用于从 obj 对象的 <code>__dict__</code> 本地变量中修改或删除对象，除非请求的对象是 property 或 descriptor。
这种情况下，set 和 delete 操作将由与该属性关联的函数执行。</p><p>对于属性查找，例如 <code>obj.name</code> 会调用特殊方法 <code>obj.__getattribute('name')</code>。
该方法执行查找属性的搜索过程，其通常会检查属性，查看本地 <code>__dict__</code> 属性，检查类型字典并搜索 MRO。
如果该搜索过程失败，最后会调用类的 <code>obj.__getattr('name')</code> 方法。
如果还失败则抛出异常。</p><p>用户定义的类型可以根据需要实现自己的属性访问函数。
例如，这里有一个表，它限制了可以设置的属性名称：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__setattr__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>name</span> <span class=ow>not</span> <span class=ow>in</span> <span class=p>{</span><span class=s1>&#39;owner&#39;</span><span class=p>,</span> <span class=s1>&#39;balance&#39;</span><span class=p>}:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>AttributeError</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;No attribute </span><span class=si>{</span><span class=n>name</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__setattr__</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>balance</span>  <span class=c1># OK</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>amount</span>   <span class=c1># AttributeError</span>
</span></span></code></pre></div><p>一个重新实现这些方法的类，应该依赖 <code>super()</code> 提供的默认实现来执行属性的实际工作。
这是因为默认实现已经处理了类中更高级的特性，如描述符和属性。
如果不使用 <code>super()</code>，则将需要自行处理这些细节。</p><h2 id=proxies-wrappers-and-delegation>Proxies, Wrappers and Delegation<a hidden class=anchor aria-hidden=true href=#proxies-wrappers-and-delegation>#</a></h2><p>有时，类会围绕另一个对象实现一个包装层，以创建一种代理 proxy 对象。
代理对象保留暴露与另一个对象相同的接口，但由于各种原因，并不通过继承和原始对象关联。
这与组合有所不同，组合是从其他对象创建一个全新的对象，但新对象拥有自己独特的方法和属性。</p><p>这有许多种情况，例如，在分布式计算中，真实的对象实现可能在远程云服务器里。
和服务器交互的客户端可能使用和服务器对象一样的代理对象，但实际上其会将所有对象通过网络传递消息。
一个常见的实现技术涉及使用 <code>__getattr__()</code> 方法，下面是一个简单的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>spam</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;A.spam&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>grok</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;A.grok&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>yow</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;A.yow&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LoggedA</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_a</span> <span class=o>=</span> <span class=n>A</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__getattr__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Accessing&#39;</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># Delegate to internal A instance</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>getattr</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_a</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>LoggedA</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>spam</span><span class=p>()</span>  <span class=c1># Accessing spam\n A.spam</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>yow</span><span class=p>()</span>   <span class=c1># Accessing yow\n A.yow()</span>
</span></span></code></pre></div><p>有时候代理作为继承的替代，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>spam</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;A.spam&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>grok</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;A.grok&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>yow</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;A.yow&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_a</span> <span class=o>=</span> <span class=n>A</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>grok</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;B.grok&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__getattr__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>getattr</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_a</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=n>B</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=o>.</span><span class=n>spam</span><span class=p>()</span>  <span class=c1># A.spam</span>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=o>.</span><span class=n>grok</span><span class=p>()</span>  <span class=c1># B.grok</span>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=o>.</span><span class=n>yow</span><span class=p>()</span>   <span class=c1># A.yow</span>
</span></span></code></pre></div><p>在这个例子中，B 看上去和继承了 A 一样，并重定义了一个方法。
这是观察到的行为，但并未使用继承，相反，B 内部持有一个对 A 的引用。
A 的某些方法可以被重新定义，例如，所有其他方法都通过 <code>__getattr__()</code> 方法进行委托。</p><p>通过 <code>__getattr__()</code> 转发属性查找是一种常见技术。
但注意，它不适用与映射到特殊方法的操作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>ListLink</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_item</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__getattr__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>getattr</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_items</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>ListLink</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>     <span class=c1># ✓</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>  <span class=c1># ✓</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span>        <span class=c1># ✓</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>len</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>  <span class=c1># Fails: No __len__() method</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>    <span class=c1># Fails: No __getitem__() method</span>
</span></span></code></pre></div><p>在此例中，该类成功地将所有标准列表方法转发给内部列表。
然而，Python 的标准运算符均无法使用。
要使其生效，必须显示实现所需要的特殊方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>ListLink</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_items</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__getattr__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>getattr</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_items</span><span class=p>,</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__len__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_items</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__getitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>index</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_item</span><span class=p>[</span><span class=n>index</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__setitem__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>index</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_item</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span>
</span></span></code></pre></div><h2 id=reducing-momory-use-with-__slots__>Reducing momory use with <code>__slots__</code><a hidden class=anchor aria-hidden=true href=#reducing-momory-use-with-__slots__>#</a></h2><p>前面提到过，实例存储在类字典中。
如果要创建大量实例，这会产生大量内存开销。
如果知道属性名称是固定的，可以在一个 <code>__slots__</code> 的特殊变量中指定这些名称。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=vm>__slots__</span> <span class=o>=</span> <span class=p>(</span><span class=s1>&#39;owner&#39;</span><span class=p>,</span> <span class=s1>&#39;balance&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></div><p>Slots 是一种定义提示，允许 Python 对内存和执行速度进行优化。
使用 <code>__slots__</code> 的类实例不再使用字典存储数据。
相反，会使用一个更加紧凑的数组类型。
在创建大量对象的程序中，使用 <code>__slots__</code> 可以显著减少内存占用，并略微提升执行效率。</p><ol><li><p>使用更加紧凑的数据结构，减少内存占用</p></li><li><p>寻址方式不同，原来的 dict 需要计算哈希，现在的使用偏移量 offset，速度更快</p></li></ol><p><code>__slote__</code> 中仅包含实例数据属性。
无需列出方法、属性、类变量或其他任何类级属性。
本质上，这些名称与通常出现在实例 <code>__dict__</code> 字典中的键名称相同。</p><p>要注意在继承使用 <code>__slots__</code> 的基类的时候，子类也许要定义 <code>__slots__</code>，即使不定义任何自己的属性。
如果不这样会，解释器会默认认为需要动态特性，导致子类变得更慢。</p><p><code>__slots__</code> 的存在不会影响诸如 <code>__getattribute__()</code>、<code>__getattr__()</code> 和 <code>__setattr__()</code> 等方法在类中被重新定义的调用。
然而，如果要实现这些方法，注意实例不再拥有 <code>__dict__</code> 属性。</p><h2 id=descriptors>Descriptors<a hidden class=anchor aria-hidden=true href=#descriptors>#</a></h2><p>通常情况下，属性访问对应字典操作。
如果需要更加精细的控制，可通过用户自定义的获取、设置和删除函数路由属性访问。
属性的使用依赖于称为描述符 descriptors 的底层构造。
描述符 descriptors 是管理属性访问的类级对象，通过实现 <code>__get__()</code>、<code>__set__()</code> 或 <code>__delete__()</code> 等特殊方法，可以直接接入属性访问机制并定制相关操作。</p><p>下面是个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Typed</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>excepted_type</span> <span class=o>=</span> <span class=nb>object</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>__set_name__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=bp>cls</span><span class=p>,</span> <span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>key</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__get__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>instance</span><span class=p>,</span> <span class=bp>cls</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>instance</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>instance</span><span class=o>.</span><span class=vm>__dict__</span><span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__set__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>instance</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>excepted_type</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>TypeError</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;Excepted </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>excepted_type</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>isinstance</span><span class=o>.</span><span class=vm>__dict__</span><span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__delete__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>instance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=n>AttrubuteError</span><span class=p>(</span><span class=s1>&#39;Can</span><span class=se>\&#39;</span><span class=s1>t delete attribute&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Integer</span><span class=p>(</span><span class=n>Typed</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>excepted_type</span> <span class=o>=</span> <span class=nb>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Float</span><span class=p>(</span><span class=n>Typed</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>excepted_type</span> <span class=o>=</span> <span class=nb>float</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>String</span><span class=p>(</span><span class=n>Typed</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>excepted_type</span> <span class=o>=</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Example</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>owner</span> <span class=o>=</span> <span class=n>String</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>balance</span> <span class=o>=</span> <span class=n>Float</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>owner</span><span class=p>,</span> <span class=n>balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>owner</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>=</span> <span class=n>balance</span>
</span></span></code></pre></div><p>在这个例子中，<code>Typed</code> 类定义了一个描述符，当属性被赋值时进行类型检查。
如果尝试删除该属性则会引发错误。
<code>Inreger</code>、 <code>Float</code> 和 <code>String</code> 子类则特化了 <code>Typed</code> 以匹配特定类型。
在另一个类中使用这些类，会使这些属性在访问时自动调用相应的 <code>__get__()</code>、<code>__set__()</code> 或 <code>__delete__()</code> 方法。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>Account</span><span class=p>(</span><span class=s1>&#39;Guido&#39;</span><span class=p>,</span> <span class=mf>1000.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=n>owner</span>      <span class=c1># Calls Account.owner.__get__(a, Account)</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>owner</span> <span class=o>=</span> <span class=s1>&#39;Eva&#39;</span>  <span class=c1># Calls Account.owner.__set__(a, &#39;Eva&#39;)</span>
</span></span><span class=line><span class=cl><span class=k>del</span> <span class=n>a</span><span class=o>.</span><span class=n>owner</span>      <span class=c1># Calls Account.owner.__delete__(a)</span>
</span></span></code></pre></div><p>描述符只能在类级别实例化。
在 <code>__init__()</code> 或其他方法内部创建描述符对象，从而基于每个实例创建描述符，这种做法是不合法的。</p><p>描述符的 <code>__set_name__()</code> 方法会在类定义完成后、任何实例创建之前被调用。
它的作用是告知描述符该属性在类中使用的名称。</p><p>例如，<code>balance = Float()</code> 定义会调用 <code>Float.__set_name__(Account, 'balance)</code> 并通知 descriptor 其所属的类及使用的名称。</p><hr><p>这部分越来越难懂了，跳过 ing &mldr;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://starslayerx.github.io/tags/python/>Python</a></li></ul><nav class=paginav><a class=prev href=https://starslayerx.github.io/posts/python-decorators-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/><span class=title>« Prev</span><br><span>Python Decorators: 从入门到实战</span>
</a><a class=next href=https://starslayerx.github.io/posts/python-tricks-part-8-modules-and-packages/><span class=title>Next »</span><br><span>Python Tricks Part 8: Modules and Packages</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 7: Classes and Object-Oriented Programming on x" href="https://x.com/intent/tweet/?text=Python%20Tricks%20Part%207%3a%20Classes%20and%20Object-Oriented%20Programming&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-7-classes-and-object-oriented-programming%2f&amp;hashtags=Python"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 7: Classes and Object-Oriented Programming on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-7-classes-and-object-oriented-programming%2f&amp;title=Python%20Tricks%20Part%207%3a%20Classes%20and%20Object-Oriented%20Programming&amp;summary=Python%20Tricks%20Part%207%3a%20Classes%20and%20Object-Oriented%20Programming&amp;source=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-7-classes-and-object-oriented-programming%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 7: Classes and Object-Oriented Programming on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-7-classes-and-object-oriented-programming%2f&title=Python%20Tricks%20Part%207%3a%20Classes%20and%20Object-Oriented%20Programming"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 7: Classes and Object-Oriented Programming on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-7-classes-and-object-oriented-programming%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 7: Classes and Object-Oriented Programming on whatsapp" href="https://api.whatsapp.com/send?text=Python%20Tricks%20Part%207%3a%20Classes%20and%20Object-Oriented%20Programming%20-%20https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-7-classes-and-object-oriented-programming%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 7: Classes and Object-Oriented Programming on telegram" href="https://telegram.me/share/url?text=Python%20Tricks%20Part%207%3a%20Classes%20and%20Object-Oriented%20Programming&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-7-classes-and-object-oriented-programming%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 7: Classes and Object-Oriented Programming on ycombinator" href="https://news.ycombinator.com/submitlink?t=Python%20Tricks%20Part%207%3a%20Classes%20and%20Object-Oriented%20Programming&u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-7-classes-and-object-oriented-programming%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>