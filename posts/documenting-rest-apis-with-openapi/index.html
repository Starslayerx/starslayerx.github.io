<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Documenting REST APIs with OpenAPI | Starslayerx' Blog</title><meta name=keywords content="REST,OpenAPI"><meta name=description content='本章介绍如何使用 OpenAPI 来为 API 编写文档. OpenAPI 是描述 RESTful API 最流行的标准, 拥有丰富的生态系统, 可以用于测试、验证和可视化 API. 大多数编程语言都支持 OpenAPI 规范的库.
OpenAPI 使用 JSON Schema 来描述 API 的结构和模型, 因此首先介绍 JSON Schema 的工作原理. JSON Schema 是一种用于定义 JSON 文档结构的规范, 包括文档中值的类型和格式.
Using JSON Schema to model data
使用 JSON Schema 对数据建模
JSON Schema 是一种规范标准, 用于定义 JSON 文档的结构及其属性的类型和格式. JSON Schema 规范通常定义一个具有特定属性或特性的对象, 由键值对的关联数组表示, 如下面这样:
{
    "status": {
        "type": "string"
    }
}

在 JSON Schema 规范中, 每个属性都以键值对的形式出现, 其中值是该属性的描述符
一个属性最基本的描述符就是 type, 上面例子中, 指定类型为字符串

JSON Schema 支持以下基本数据类型:'><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/posts/documenting-rest-apis-with-openapi/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://starslayerx.github.io/posts/documenting-rest-apis-with-openapi/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/posts/documenting-rest-apis-with-openapi/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Documenting REST APIs with OpenAPI"><meta property="og:description" content='本章介绍如何使用 OpenAPI 来为 API 编写文档. OpenAPI 是描述 RESTful API 最流行的标准, 拥有丰富的生态系统, 可以用于测试、验证和可视化 API. 大多数编程语言都支持 OpenAPI 规范的库.
OpenAPI 使用 JSON Schema 来描述 API 的结构和模型, 因此首先介绍 JSON Schema 的工作原理. JSON Schema 是一种用于定义 JSON 文档结构的规范, 包括文档中值的类型和格式.
Using JSON Schema to model data 使用 JSON Schema 对数据建模
JSON Schema 是一种规范标准, 用于定义 JSON 文档的结构及其属性的类型和格式. JSON Schema 规范通常定义一个具有特定属性或特性的对象, 由键值对的关联数组表示, 如下面这样:
{ "status": { "type": "string" } } 在 JSON Schema 规范中, 每个属性都以键值对的形式出现, 其中值是该属性的描述符 一个属性最基本的描述符就是 type, 上面例子中, 指定类型为字符串 JSON Schema 支持以下基本数据类型:'><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-25T08:00:00+08:00"><meta property="article:modified_time" content="2025-08-25T08:00:00+08:00"><meta property="article:tag" content="REST"><meta property="article:tag" content="OpenAPI"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Documenting REST APIs with OpenAPI"><meta name=twitter:description content='本章介绍如何使用 OpenAPI 来为 API 编写文档. OpenAPI 是描述 RESTful API 最流行的标准, 拥有丰富的生态系统, 可以用于测试、验证和可视化 API. 大多数编程语言都支持 OpenAPI 规范的库.
OpenAPI 使用 JSON Schema 来描述 API 的结构和模型, 因此首先介绍 JSON Schema 的工作原理. JSON Schema 是一种用于定义 JSON 文档结构的规范, 包括文档中值的类型和格式.
Using JSON Schema to model data
使用 JSON Schema 对数据建模
JSON Schema 是一种规范标准, 用于定义 JSON 文档的结构及其属性的类型和格式. JSON Schema 规范通常定义一个具有特定属性或特性的对象, 由键值对的关联数组表示, 如下面这样:
{
    "status": {
        "type": "string"
    }
}

在 JSON Schema 规范中, 每个属性都以键值对的形式出现, 其中值是该属性的描述符
一个属性最基本的描述符就是 type, 上面例子中, 指定类型为字符串

JSON Schema 支持以下基本数据类型:'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://starslayerx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Documenting REST APIs with OpenAPI","item":"https://starslayerx.github.io/posts/documenting-rest-apis-with-openapi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Documenting REST APIs with OpenAPI","name":"Documenting REST APIs with OpenAPI","description":"本章介绍如何使用 OpenAPI 来为 API 编写文档. OpenAPI 是描述 RESTful API 最流行的标准, 拥有丰富的生态系统, 可以用于测试、验证和可视化 API. 大多数编程语言都支持 OpenAPI 规范的库.\nOpenAPI 使用 JSON Schema 来描述 API 的结构和模型, 因此首先介绍 JSON Schema 的工作原理. JSON Schema 是一种用于定义 JSON 文档结构的规范, 包括文档中值的类型和格式.\nUsing JSON Schema to model data 使用 JSON Schema 对数据建模\nJSON Schema 是一种规范标准, 用于定义 JSON 文档的结构及其属性的类型和格式. JSON Schema 规范通常定义一个具有特定属性或特性的对象, 由键值对的关联数组表示, 如下面这样:\n{ \u0026#34;status\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } 在 JSON Schema 规范中, 每个属性都以键值对的形式出现, 其中值是该属性的描述符 一个属性最基本的描述符就是 type, 上面例子中, 指定类型为字符串 JSON Schema 支持以下基本数据类型:\n","keywords":["REST","OpenAPI"],"articleBody":"本章介绍如何使用 OpenAPI 来为 API 编写文档. OpenAPI 是描述 RESTful API 最流行的标准, 拥有丰富的生态系统, 可以用于测试、验证和可视化 API. 大多数编程语言都支持 OpenAPI 规范的库.\nOpenAPI 使用 JSON Schema 来描述 API 的结构和模型, 因此首先介绍 JSON Schema 的工作原理. JSON Schema 是一种用于定义 JSON 文档结构的规范, 包括文档中值的类型和格式.\nUsing JSON Schema to model data 使用 JSON Schema 对数据建模\nJSON Schema 是一种规范标准, 用于定义 JSON 文档的结构及其属性的类型和格式. JSON Schema 规范通常定义一个具有特定属性或特性的对象, 由键值对的关联数组表示, 如下面这样:\n{ \"status\": { \"type\": \"string\" } } 在 JSON Schema 规范中, 每个属性都以键值对的形式出现, 其中值是该属性的描述符 一个属性最基本的描述符就是 type, 上面例子中, 指定类型为字符串 JSON Schema 支持以下基本数据类型:\nstring: 字符串 number: 整数和十进制数 object: 关联数组 (类似py中的字典) array: 其他数据类型的集合 boolean: 真或假 null: 未初始化的数据 定义一个 object 的例子\n{ \"order\": { \"type\": \"object\", \"properties\": { \"product\": { \"type\": \"string\" }, \"size\": { \"type\": \"string\" }, \"quantity\": { \"type\": \"intger\" } } } } 由于 order 是一个 object, 故 order 属性有 properties. 每个 property 都有自己的类型.\n一个符合规则的 JSON 文档例子如下\n{ \"order\": { \"product\": \"coffee\", \"size\": \"big\", \"quantity\": 1, } } 属性 property 也可以代表一个项目的数组.\norder 对象代表一个对象的数组, 使用 items 关键字来定义数组中的元素.\n{ \"order\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"properties\": { \"product\": { \"type\": \"string\" }, \"size\": { \"type\": \"string\" }, \"quantity\": { \"type\": \"integer\" } } } } } 在上面例子中, order 属性是一个数组 array. 数组类型需要在模式 schema 中有一个额外的属性, 那就是 items 属性, 其定义了数组中包含的每个元素的类型. 这种情况下, 数组中的每个元素都是一个对象, 代表订单中的一个项目.\n一个对象可以包含任意数量的嵌套对象, 但是, 嵌套太多时, 缩进会变得很大, 导致规范难以阅读.\n为了避免这个问题, JSON Schema 允许单独定义每个对象, 并使用 JSON 指针 (JSON pointers) 来引用它们.\nJSON pointers 是一种特殊语法, 运行向统一分规范中的另一个对象定义.\n如下面代码, 可以将 order 数组中的每个项的定义提取为一个名为 OrderItemSchema 的模型. 然后使用一个 JSON 指针和特殊的 $ref 关键字来引用 OrderItemSchema\n{ \"OrderItemSchema\": { \"type\": \"object\", \"properties\": { \"product\": { \"type\": \"string\" }, \"size\": { \"type\": \"string\" }, \"quantity\": { \"type\": \"integer\" } } }, \"Order\": { \"status\": { \"type\": \"string\" }, \"order\": { \"type\": \"array\", \"items\": { \"$ref\": '#/OrderItemSchema' } } } } JSON 指针使用特殊关键字 $ref 和 JSONPath 语法来指向 schema 中的另一个定义.\n在 JSONPath 的语法中, 文档的根(root)使用井号 # 表示, 嵌套属性的关系由斜线(slashes) / 表示. 例如, 如果响应创建 #/OrderItemSchema 模型的 size 属性的指针, 我们会使用如下的语法 #/OrderItemSchema/size.\n通过将通用的模式对象提取成壳重用的模型, 并使用 JSON 指针来引用他们, 从而对规范进行重构, 这有助于避免重复, 并报慈整洁和简洁.\n除了指定类型之外, JSON Schema 还允许指定属性的格式(foramt), 可以自定义格式, 也可以使用 JSON Schema 内置的格式.\n例如, 一个代表日期的属性, 可以使用 data 格式, 这是 JSON Schema 支持的内置格式, 代表一个 ISO 日期(如2025-05-21)\n{ \"created\": { \"type\": \"string\", \"format\": \"date\" } } 除了使用 JSON, JSON Schema 实际上还可以使用 YAML 来编写, 这种格式更加常见且更容易理解. OpenAPI 规范也通常以 YAML 格式提供, 后面部分使用 YAML 格式编写.\nAnatomy of an OpenAPI specification 剖析 OpenAPI 规范\nOpenAPI 是一种用于文档化 Restful API 的标准规范格式. 它允许我们详细描述 API 的每一个元素, 包括其端点 endpoints、请求响应和有效载荷(payloads)的格式、安全方案(security schemes)等等. OpenAPI 最初于2010年以 Swagger 的名称创建, 2015年 Linux 基金会和主要公司的联盟共同赞助成立了 OpenAPI Initiative, 是一个旨在改进构建 RESTful API 的协议和标准的项目. 如今, OpenAPI 是迄今为止用于文档化 RESTful API 最流行的规范格式, 它拥有丰富的生态系统工具, 可用于 API 可视化、测试和验证.\nOpenAPI 包含了和 API 交互所需要的一切信息, 一份 OpenAPI 规范由5个部分构成:\nopenapi: 指明版本 info: API 的基本信息, 例如标题和版本 servers: 包含 API 可用的 URL 列表. 可以列出用于不同环境的多个 URL. paths: 描述 API 公开的端点, 包括预期的有效载荷(payloads)、允许的参数以及响应的格式. 这是规范中最重要的部分, 因为它代表了 API 的接口, 也是使用者为了学习如何与 API 集成会查看的部分. components: 定义了在整个规范中被引用的可重复元素. 例如模式(schemas)、参数、安全方案、请求体和响应等. 模式是对请求和响应中预期属性和类型的定义. OpenAPI 模式是使用 JSON Schema 语法定义的. Documenting the API endpoints 文档化 API 端点\nOpenAPI 的 path 部分描述了 API 接口, 它列出了 API 公开的 URL 路径, 以及实现的 HTTP 方法, 预期的请求类型和返回的响应.\n每个路径都是一个对象, 其属性为它支持的 HTTP 方法, 这里将说明 URL 路径和 HTTP 方法的文档化.\n在之前定义了如下端点:\nPOST /orders: 请求订单. 需要订单的细节信息. GET /orders: 返回订单列表. 接受 URL 查询参数, 并允许过滤结果. GET /orders/{order_id}: 返回订单细节信息 PUT /orders/{order_id}: 更新订单细节信息, 由于这是一个 PUT 端点, 要求订单的全面信息. DELETE /orders/{order_id}: 删除订单 POST /orders/{order_id}/pay: 为订单付款 POST /orders/{order_id}/cancel: 取消订单 下面是 API 订单的高层定义, 声明了 URL 和每个 URL 所实现的 HTTP 方法, 并为每个端点添加了一个操作ID(operation ID), 以便在文档其他部分引用:\npaths: /orders: get: operationId: createOrder /orders/{order_id}: get: operationId: getOrder put: operationId: updateOrder delete: opertaionId: deleteOrder /orders/{order_id}/pay: post: operationId: payOrder /orders/{order_id}/cancel: post: operationId: cancelOrder 现在有了端点, 还需要填充其中的细节.\n对于 GET /orders 端点, 需要描述接受它的参数 对于 POST 和 PUT 端点, 需要描述请求的有效载荷 payloads\n此外, 还需要为每个端点描述其响应 Documenting URL query parameters 文档化 URL 查询参数\nURL query parameter 允许我们过滤和排序 GET endpoint 的结果. 在本章中, 将使用 OpenAPI 定义 URL query parameters. GET /orders endpoint 允许我们使用下面的参数过滤订单:\ncancelled: 订单是否被取消, 类型 boolean limit: 表示返回给用户的订单的最大数量 合并起来使用大概下面这样:\nGET /orders?cancelled=true\u0026limit=5 这个请求向服务器请求一个 5条已经取消 的订单的列表.\npaths: /orders: get: parameters: - name: cancelled in: query required: false schema: type: boolean - name: limit in: query required: false schema: type: integer 定义一个参数需要一个名称 name, 这个名称就是实际 URL 中用来指引它的值. 还需要指定参数的类型, 在 OpenAPI 3.1 区分了四种类型参数: 路径参数(path parameters)、查询参数(query parameters)、头部参数(header parameters)和Cookie 参数(cookie parameters).\n头部参数是在 HTTP 头部字段中的参数, 而 Cookie 参数则放在 Cookie 有效载荷中. 路径参数是 URL 路径的一部分, 通常用于标识一个资源. 查询参数是可选参数, 允许对端点的结果进行过滤和排序.\n使用 schema 关键字参数来定义参数的类型, 并且在相关时, 也会指定参数的格式. Documenting request payloads 文档化请求载荷\n一个请求代表 client 通过 POST 或 PUT 方法向 server 发送的数据. 这节介绍 API endpoints 的 request payloads.\n例如 POST /orders 方法:\n{ \"order\": [ { \"product\": \"cappuccinio\", \"size\": \"big\", \"quantity\": 1 } ] } 这个 payload 包含一个 order 属性, 代表了一系列的物品. 每个物品被定义为下面的3个属性和约束:\nproduct: 用户订购的产品类型 size: 产品的大小. 有3种选择: small, medium 和 big quantity: 产品的数量. 可以是任何大于等于1的整数 下面展示如何为这个有效载荷 payload 定义模式\npaths: /orders: post: operationId: createOrder requestBody: required: true content: application/json: schema: type: object properties: order: type: array items: type: object properties: product: type: string size: type: string enum: - small - medium - big quantity: type: intger required: false default: 1 required: - product - size 通过 HTTP 方法的 requestBody 属性下的 content 属性来定义 payload, 并可以指定不同的有效载荷. 有效载荷可以指定为不同的格式, 在本例中, 只允许 JSON 格式数据, 媒体类型为 application/json.\n这里的有效载荷的模式是一个对象, 有一个属性 order, 其类型为数组, 数组中的元素的对象, 包含3个属性: product(类型为字符串), size(类型为字符串) 和 quantity(类型为整数).\n此外, 还为 size 属性定义了一个枚举(enumeration), 将可接受的值限制为 samll、medium 和 big 3种.\n最后, 还为 quantity 属性提供了默认值 1, 因为它是有效载荷中唯一非必须的字段.\nRefactoring schema definitions to avoid repetition 重构 schema 定义从而避免重复\n在本节将介绍重构模式 refactoring schemas 的策略, 以保持 API 规范的整洁和可读性.\n上面的 POST /orders 端点定义很长, 包含多层缩进, 难以阅读, 意味着会变得难以扩展和维护.\n可以将有效载荷 payload 的模式移动到 API 规范的 components 部分. 该部分用于声明在整个规范中被引用的模式, 每个模式都是一个对象, 其中键是模式的名称, 而值是属性的对象.\npaths: /orders: post: operatoinId: createOrder requestBody: required: true content: application/json: schema: $ref: '#/components/schemas/CreateOrderSchema' ① components: ② schemas: ③ CreateOrderSchema: type: object properties: type: array items: type: object properties: product: type: string size: type: string enum: - samll - medium - big quantity: type: intger required: false default: 1 required: - product - size 使用 JSON pointer 指向文档其他位置 schema 定义在 components 下面 每个 schema 都是一个对象, 其中 key(CreateOrderSchema) 是名称, values(CreateOrderSchema下面的所有内容) 是描述属性 properties 将 POST /orders 请求有效载荷的模式移动到 API 的 components 部分, 能使文档更具可读性. 这样得以保持 path 部分的简洁, 并专注于端点的高层细节. 只需要使用一个 JSON 指针来引用 CreateOrderSchema 模式:\n#/components/schemas/CreateOrderSchema 这份规范现在已经不错了, 但是可以更好. CreateOrderSchema 有些长, 并且包含了多层嵌套定义. 如果 CreateOrderSchema 的复杂性随着时间增长, 将越来越难以维护. 可以通过下面方式重构数组中订单项的定义, 使其更加具有可读性, 这个策略运行 API 的其他部分重用订单项的模式.\ncomponents: schemas: OrderItemSchema: ① type: object properties: product: type: string size: type: string enum: - small - medium - big quantity: type: integer default: 1 CreateOrderSchema: type: object properties: order: type: array items: $ref: '#/OrderItemSchema' ② OrderItemSchema: 订单中的项 CreateOrderSchema: 使用一个 JSON pointer 指向 OrderItemSchema 现在 schemas 看起来就好多了, 并且可以在 /POST /orders/{order_id} 端点中重用它.\n/orders/{order_id} 代表一个单例资源(singleton resource), 因此 URL 包含一个路径参数, 即订单ID. 在 OpenAPI 中, 路径参数使用大括号{} 表示.\npaths: /orders: get: ... /orders/{order_id}: ① parameters: ② - in: path ③ name: order_id ④ required: true ⑤ schema: type: string format: uuid ⑥ put: ⑦ operationId: updateOrder requestBody: ⑧ required: true content: application/json: schema: $ref: '#/components/schemas/CreateOrderSchema 定义订单的资源地址 定义 URL path parameter order_id 参数是 URL 路径的一部分 参数名称 必填参数 具体参数格式(UUID) 为当前 URL 定义 PUT 方法 文档化 request body 的 PUT 端点 Documenting API responses 文档化响应体\nGET /orders/{order_id} 端点的响应类似下面这样:\n{ \"id\": \"924721eb-a1a1-4f13-b384-37e89c0e0875\", \"status\": \"progress\", \"created\": \"2022-05-01\", \"order\": [ { \"product\": \"cappuccino\", \"size\": \"small\", \"quantity\": 1 }, { \"product\": \"croissant\", \"size\": \"medium\", \"quantity\": 2 } ] } 这个有效载荷展示了用户订购的产品, 下单时间以及订单状态. 类似之前 POST 和 PUT 端点定义的请求有效载荷, 因此可以重用之前的模式.\ncomponents: schemas: OrderItemSchema: ... GetOrderSchema: ① type: object properties: status: type: string enum: ② - created - paid - progress - cancelled - displatched - delivered created: type: string format: date-time ③ order: type: array items: $ref: '#/components/schemas/OrderItemSchema' ④ 定义 GetOrderSchema 模式 使用枚举限制状态属性 日期格式的字符串 使用 JSON pointer 引用 OrderItemSchema 在上面的清单中, 使用一个 JSON 指针指向 GetOrderSchema. 另一种重用现有模式的方法是继承.\n在 OpenAPI 中, 可以通过一种称为模式组合(model composition) 的策略来继承和扩展一个模式, 该策略允许将不同模式的属性组合到一个单一的对象定义中. 在这种情况下, 使用特殊关键词 allOf 来表示该对象需要包含列出的所有模式中的属性.\ncomponents: schemas: OrderItemSchema: ... GetOrderSchema: allOf: ① - $ref: '#/components/schemas/CreateOrderSchema' ② - type: object ③ properties: status: type: string enum: - created - paid - progress - cancelled - dispatched - delivered created: type: string format: date-time 使用 allOf 关键字继承其他 schemas 的属性 使用 JSON pointer 引用其他的 schema 使用一个新对象 GetOrderSchema 来包含特有的属性 模型组合(Model composition) 能使规范更简洁、更紧凑, 但它只在模式严格兼容的情况才有效.\n如果决定使用新的属性来扩展 CreateOrderSchema, 那么这个模式可能就不再能用于 GetOrderSchema 模型.\n从这个意义上讲, 有时候更好的做饭是寻找不同模式中的共同元素, 将其定义重构为独立的模式.\n现在有了 GET /orders/{order_id} 端点响应有效载荷的模式, 就可以完善该端点的规范了. 把端点的响应定义为对象, 其中键是响应的状态码, 并描述响应的内容类型及其模式.\npaths: /orders: get: ... /orders/{order_id}: parameters: - in: path name: order_id required: true schema: type: string format: uuid put: ... get: ① summary: Returns the details of a specific order ② operationId: getOrder responses: ③ '200': ④ description: OK ⑤ content: ⑥ application/json: schema: $ref: '#/components/schemas/GetOrderSchema' ⑦ 定义 GET /order/{order_id} endpoint 为该端点提供一个描述 定义一个端点响应 每个响应都是一个对象, 其中 key 为状态码 响应的简单描述 描述响应的内容类型 使用 JSON pointer 引用 GetOrderSchema 根据上面内容可以看到, 在端点的 responses 部分定义了响应模式(schemas), 在这种情况下, 值提供了 200 (OK) 成功响应的规范, 但也可以为其他状态码编写文档.\nCreating generic responses 创建同样响应\n本节介绍如何为 API 端点添加错误响应. 错误响应更具通用性, 因此可以使用 API 规范的 components 部分来提供这些响应的通用定义, 然后在端点中使用他们.\n这里在 API 的 components 部分的 responses 标头下定义通用响应. 下面展示了一个名为 NotFound 的 404 响应通用定义. 与任何其他响应意义, 也会为其有效载荷编写文档, 本例中有效载荷由 Error 模式定义.\ncomponents: responses: ① NotFound: ② description: The specified resource was not found. ③ content: ④ application/json: schema: $ref: '#/components/schemas/Error' ⑤ schemas: OrderItemSchema: ... Error: ⑥ type: object properties: detail: type: string required: - detail 通用响应定义在 components 部分的 responses 下 为这个响应命名 描述这个响应 定义响应内容 引用 Error 模式 定义 Error 有效载荷的模式 上面这份针对 404 响应的规范可以在 /orders/{order_id} URL 路径下的所有端点规范中重复使用, 因为所有这些端点都是专门设计来针对特定资源的.\n在 OpenAPI 的 GitHub 仓库中, 有一个请求是希望允许在 URL 路径下直接包含通用响应, 但目前尚未实现\n下面定义 /orders/{order_id} 的 404 响应模式\npaths: ... /orders/{order_id}: parameters: - in: path name: order_id required: true schema: type: string \"format\": uuid get: summary: Returns the details of a specific order operationId: getOrder responses: '200': description: OK content: application/json: schema: $ref: '#/components/schemas/GetOrderSchema' '404': ① $ref: '#/components/responses/NotFound' ② 定义一个 404 响应 使用 JSON 指针引用 NotFound 响应 剩下的一个端点是 GET /orders, 它返回一个订单列表, 该端点的有效载荷重用了 GetOrderSchema 来定义订单数组中的项目\npaths: /orders: get: ① operationId: getOrders responses: '200': description: A JSON array of orders content: application/json: schema: type: object properties: orders: type: array ② items: $ref: '#/components/schemas/GetOrderSchema' ③ required: - order post: ... /orders/{order_id}: parameters: ... 定义 /orders URL 路径的新 GET 方法 orders 是一个数组 数组的每个项目都由 GetOrderSchema 定义 现在, API 的端点已完全文档化. 可以在端点定义中使用更多的元素, 例如 tags 和 externalDocs. 些属性并非绝对必要, 但可以帮助为 API 提供更多结构, 或使其更易于对端点进行分组.\nDefining the authentication scheme of the API 定义 API 的认证模式\n如果 API 受到到保护, API 规范必须描述用户如何进行身份认证和授权请求. API 安全定义位于规范的 components 部分, 在 securitySchema 标头下.\n通过 OpenAPI, 可以描述不同的安全方案, 例如基于 HTTP 的认证、基于密钥的认证、OAuth2 开放授权 和 OpenID Connect.\n下面描述了3种方案: 一种用于 OpenID Connect, 一种用于 OAuth2, 还有一种用于 Bearer 授权.\n这里使用 OpenID Connect 通过前端应用来授权用户访问\n对于 OpenID Connect, 必须在 openIdConnectUrl 属性下提供一个配置 URL, 该 URL 描述了后端客户端如何认证工作 对于直接的 API 集成, 提供 OAuth 的客户端凭证流(client credentials flow)\n对于 OAuth2, 必须描述可用的授权流(authentication flows), 以及客户端必须用于获取其授权令牌的 URL 和可用的作用域(scopes).\nBearer 授权告诉用户, 他们必须在 Authorization 头部中包含一个 JSON Web Token(JWT) 来授权其请求. components: responses: ... schemas: ... securitySchemes: ① openId: ② type: openIdConnect ③ openIdConnectUrl: https://coffeemesh-dev.eu.auth0.com/.well-known/openid-configuration ④ oauth2: ⑤ type: oauth2 ⑥ flows: ⑦ clientCredentials: ⑧ tokenUrl: https://coffeemesh-dev.eu.auth0.com/oauth/token ⑨ scopes: {} ⑩ bearerAuth: type: http scheme: bearer bearerFormat: JWT ⑪ ... security: - oauth2: - getOrders - createOrder - getOrder - updateOrder - deleteOrder - payOrder - cancelOrder - bearerAuth: - getOrders - createOrder - getOrder - updateOrder - deleteOrder - payOrder - - cancelOrder API components 部分的 securitySchemes 标头下的安全方案 为安全方案提供一个名称(可以是任何名称) 安全方案的类型 描述后端 OpenID Connect 配置的 URL 另一个安全方案的名称 该安全方案的类型 该安全方案下可用的授权流 客户端凭证流的描述 用户可以请求授权令牌的 URL 请求授权令牌时可用的作用域 Bearer 令牌的格式是 JSON Web Token (JWT) Wrapping Up JSON Schema 是一个定义 JSON 文档中属性类型和格式的规范, 它有助于以一种独立于编程语言的方式定义数据验证模型. OpenAPI 是一种用于描述 RESTful API 的标准文档格式, 它使用 JSON Schema 来描述 API 的属性. 通过使用 OpenAPI, 你可以利用围绕该标准构建的整个工具和框架生态系统, 从而使 API 集成变得更加容易. JSON pointer 允许使用 $ref 关键字来引用一个模式(schema). 利用 JSON 指针, 可以创建可重用的模式定义, 这些定义可以在 API 规范的不同部分使用, 从而保持 API 规范的整洁和易于理解. ","wordCount":"1727","inLanguage":"en","image":"https://starslayerx.github.io/images/og-default.avif","datePublished":"2025-08-25T08:00:00+08:00","dateModified":"2025-08-25T08:00:00+08:00","author":{"@type":"Person","name":"Starslayerx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://starslayerx.github.io/posts/documenting-rest-apis-with-openapi/"},"publisher":{"@type":"Organization","name":"Starslayerx' Blog","logo":{"@type":"ImageObject","url":"https://starslayerx.github.io/favicon.svg"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Documenting REST APIs with OpenAPI</h1><div class=post-meta><span title='2025-08-25 08:00:00 +0800 +0800'>August 25, 2025</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>1727 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#using-json-schema-to-model-data>Using JSON Schema to model data</a></li><li><a href=#anatomy-of-an-openapi-specification>Anatomy of an OpenAPI specification</a></li><li><a href=#documenting-the-api-endpoints>Documenting the API endpoints</a></li><li><a href=#documenting-url-query-parameters>Documenting URL query parameters</a></li><li><a href=#documenting-request-payloads>Documenting request payloads</a></li><li><a href=#refactoring-schema-definitions-to-avoid-repetition>Refactoring schema definitions to avoid repetition</a></li><li><a href=#documenting-api-responses>Documenting API responses</a></li><li><a href=#creating-generic-responses>Creating generic responses</a></li><li><a href=#defining-the-authentication-scheme-of-the-api>Defining the authentication scheme of the API</a></li></ul></li><li><a href=#wrapping-up>Wrapping Up</a></li></ul></nav></div></details></div><div class=post-content><p>本章介绍如何使用 OpenAPI 来为 API 编写文档. OpenAPI 是描述 RESTful API 最流行的标准, 拥有丰富的生态系统, 可以用于测试、验证和可视化 API. 大多数编程语言都支持 OpenAPI 规范的库.</p><p>OpenAPI 使用 JSON Schema 来描述 API 的结构和模型, 因此首先介绍 JSON Schema 的工作原理. JSON Schema 是一种用于定义 JSON 文档结构的规范, 包括文档中值的类型和格式.</p><h3 id=using-json-schema-to-model-data>Using JSON Schema to model data<a hidden class=anchor aria-hidden=true href=#using-json-schema-to-model-data>#</a></h3><p><strong>使用 JSON Schema 对数据建模</strong></p><p>JSON Schema 是一种规范标准, 用于定义 JSON 文档的结构及其属性的类型和格式. JSON Schema 规范通常定义一个具有特定属性或特性的对象, 由键值对的关联数组表示, 如下面这样:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;status&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;string&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol><li>在 JSON Schema 规范中, 每个属性都以键值对的形式出现, 其中值是该属性的描述符</li><li>一个属性最基本的描述符就是 <code>type</code>, 上面例子中, 指定类型为字符串</li></ol><p>JSON Schema 支持以下基本数据类型:</p><ul><li><code>string</code>: 字符串</li><li><code>number</code>: 整数和十进制数</li><li><code>object</code>: 关联数组 (类似py中的字典)</li><li><code>array</code>: 其他数据类型的集合</li><li><code>boolean</code>: 真或假</li><li><code>null</code>: 未初始化的数据</li></ul><p>定义一个 object 的例子</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;order&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;object&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;properties&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;product&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;string&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;size&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;string&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;quantity&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;intger&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>由于 order 是一个 object, 故 order 属性有 properties. 每个 property 都有自己的类型.<br>一个符合规则的 JSON 文档例子如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;order&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;product&#34;</span><span class=p>:</span> <span class=s2>&#34;coffee&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;size&#34;</span><span class=p>:</span> <span class=s2>&#34;big&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;quantity&#34;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>属性 property 也可以代表一个项目的数组.<br>order 对象代表一个对象的数组, 使用 items 关键字来定义数组中的元素.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;order&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;array&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;items&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;object&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;properties&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;product&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;string&#34;</span>
</span></span><span class=line><span class=cl>                <span class=p>},</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;size&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;string&#34;</span>
</span></span><span class=line><span class=cl>                <span class=p>},</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;quantity&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;integer&#34;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在上面例子中, order 属性是一个数组 array. 数组类型需要在模式 schema 中有一个额外的属性, 那就是 items 属性, 其定义了数组中包含的每个元素的类型. 这种情况下, 数组中的每个元素都是一个对象, 代表订单中的一个项目.</p><p>一个对象可以包含任意数量的嵌套对象, 但是, 嵌套太多时, 缩进会变得很大, 导致规范难以阅读.<br>为了避免这个问题, JSON Schema 允许单独定义每个对象, 并使用 JSON 指针 (JSON pointers) 来引用它们.<br>JSON pointers 是一种特殊语法, 运行向统一分规范中的另一个对象定义.</p><p>如下面代码, 可以将 order 数组中的每个项的定义提取为一个名为 <code>OrderItemSchema</code> 的模型. 然后使用一个 JSON 指针和特殊的 <code>$ref</code> 关键字来引用 <code>OrderItemSchema</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;OrderItemSchema&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;object&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;properties&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;product&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;string&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;size&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;string&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;quantity&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;integer&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;Order&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;status&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;string&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;order&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;array&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;items&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nt>&#34;$ref&#34;</span><span class=p>:</span> <span class=err>&#39;#/OrderItemSchema&#39;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>JSON 指针使用特殊关键字 <code>$ref</code> 和 <code>JSONPath</code> 语法来指向 schema 中的另一个定义.<br>在 <code>JSONPath</code> 的语法中, 文档的根(root)使用井号 <code>#</code> 表示, 嵌套属性的关系由斜线(slashes) <code>/</code> 表示.
例如, 如果响应创建 <code>#/OrderItemSchema</code> 模型的 <code>size</code> 属性的指针, 我们会使用如下的语法 <code>#/OrderItemSchema/size</code>.<br>通过将通用的模式对象提取成壳重用的模型, 并使用 JSON 指针来引用他们, 从而对规范进行重构, 这有助于避免重复, 并报慈整洁和简洁.</p><p>除了指定类型之外, JSON Schema 还允许指定属性的格式(foramt), 可以自定义格式, 也可以使用 JSON Schema 内置的格式.<br>例如, 一个代表日期的属性, 可以使用 <code>data</code> 格式, 这是 JSON Schema 支持的内置格式, 代表一个 ISO 日期(如2025-05-21)</p><pre tabindex=0><code>{
    &#34;created&#34;: {
        &#34;type&#34;: &#34;string&#34;,
        &#34;format&#34;: &#34;date&#34;
    }
}
</code></pre><p>除了使用 JSON, JSON Schema 实际上还可以使用 YAML 来编写, 这种格式更加常见且更容易理解. OpenAPI 规范也通常以 YAML 格式提供, 后面部分使用 YAML 格式编写.</p><h3 id=anatomy-of-an-openapi-specification>Anatomy of an OpenAPI specification<a hidden class=anchor aria-hidden=true href=#anatomy-of-an-openapi-specification>#</a></h3><p><strong>剖析 OpenAPI 规范</strong></p><p>OpenAPI 是一种用于文档化 Restful API 的标准规范格式. 它允许我们详细描述 API 的每一个元素, 包括其端点 endpoints、请求响应和有效载荷(payloads)的格式、安全方案(security schemes)等等. OpenAPI 最初于2010年以 Swagger 的名称创建, 2015年 Linux 基金会和主要公司的联盟共同赞助成立了 OpenAPI Initiative, 是一个旨在改进构建 RESTful API 的协议和标准的项目. 如今, OpenAPI 是迄今为止用于文档化 RESTful API 最流行的规范格式, 它拥有丰富的生态系统工具, 可用于 API 可视化、测试和验证.</p><p>OpenAPI 包含了和 API 交互所需要的一切信息, 一份 OpenAPI 规范由5个部分构成:</p><ul><li><code>openapi</code>: 指明版本</li><li><code>info</code>: API 的基本信息, 例如标题和版本</li><li><code>servers</code>: 包含 API 可用的 URL 列表. 可以列出用于不同环境的多个 URL.</li><li><code>paths</code>: 描述 API 公开的端点, 包括预期的有效载荷(payloads)、允许的参数以及响应的格式. 这是规范中最重要的部分, 因为它代表了 API 的接口, 也是使用者为了学习如何与 API 集成会查看的部分.</li><li><code>components</code>: 定义了在整个规范中被引用的可重复元素. 例如模式(schemas)、参数、安全方案、请求体和响应等. 模式是对请求和响应中预期属性和类型的定义. OpenAPI 模式是使用 JSON Schema 语法定义的.</li></ul><h3 id=documenting-the-api-endpoints>Documenting the API endpoints<a hidden class=anchor aria-hidden=true href=#documenting-the-api-endpoints>#</a></h3><p><strong>文档化 API 端点</strong></p><p>OpenAPI 的 <code>path</code> 部分描述了 API 接口, 它列出了 API 公开的 URL 路径, 以及实现的 HTTP 方法, 预期的请求类型和返回的响应.<br>每个路径都是一个对象, 其属性为它支持的 HTTP 方法, 这里将说明 URL 路径和 HTTP 方法的文档化.<br>在之前定义了如下端点:</p><ul><li><code>POST /orders</code>: 请求订单. 需要订单的细节信息.</li><li><code>GET /orders</code>: 返回订单列表. 接受 URL 查询参数, 并允许过滤结果.</li><li><code>GET /orders/{order_id}</code>: 返回订单细节信息</li><li><code>PUT /orders/{order_id}</code>: 更新订单细节信息, 由于这是一个 PUT 端点, 要求订单的全面信息.</li><li><code>DELETE /orders/{order_id}</code>: 删除订单</li><li><code>POST /orders/{order_id}/pay</code>: 为订单付款</li><li><code>POST /orders/{order_id}/cancel</code>: 取消订单</li></ul><p>下面是 API 订单的高层定义, 声明了 URL 和每个 URL 所实现的 HTTP 方法, 并为每个端点添加了一个操作ID(operation ID), 以便在文档其他部分引用:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>paths</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>/orders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>get</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>operationId</span><span class=p>:</span><span class=w> </span><span class=l>createOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=l>/orders/{order_id}:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>get</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>operationId</span><span class=p>:</span><span class=w> </span><span class=l>getOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>put</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>operationId</span><span class=p>:</span><span class=w> </span><span class=l>updateOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>delete</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>opertaionId</span><span class=p>:</span><span class=w> </span><span class=l>deleteOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=l>/orders/{order_id}/pay:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>post</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>operationId</span><span class=p>:</span><span class=w> </span><span class=l>payOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=l>/orders/{order_id}/cancel:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>post</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>operationId</span><span class=p>:</span><span class=w> </span><span class=l>cancelOrder</span><span class=w>
</span></span></span></code></pre></div><p>现在有了端点, 还需要填充其中的细节.</p><ul><li>对于 <code>GET /orders</code> 端点, 需要描述接受它的参数</li><li>对于 <code>POST</code> 和 <code>PUT</code> 端点, 需要描述请求的有效载荷 payloads<br>此外, 还需要为每个端点描述其响应</li></ul><h3 id=documenting-url-query-parameters>Documenting URL query parameters<a hidden class=anchor aria-hidden=true href=#documenting-url-query-parameters>#</a></h3><p><strong>文档化 URL 查询参数</strong></p><p>URL query parameter 允许我们过滤和排序 GET endpoint 的结果. 在本章中, 将使用 OpenAPI 定义 URL query parameters. GET /orders endpoint 允许我们使用下面的参数过滤订单:</p><ul><li><code>cancelled</code>: 订单是否被取消, 类型 boolean</li><li><code>limit</code>: 表示返回给用户的订单的最大数量</li></ul><p>合并起来使用大概下面这样:</p><pre tabindex=0><code>GET /orders?cancelled=true&amp;limit=5
</code></pre><p>这个请求向服务器请求一个 5条已经取消 的订单的列表.</p><pre tabindex=0><code>paths:
  /orders:
    get:
      parameters:
        - name: cancelled
          in: query
          required: false
          schema:
            type: boolean
        - name: limit
          in: query
          required: false
          schema:
            type: integer
</code></pre><p>定义一个参数需要一个名称 name, 这个名称就是实际 URL 中用来指引它的值. 还需要指定参数的类型, 在 OpenAPI 3.1 区分了四种类型参数: 路径参数(path parameters)、查询参数(query parameters)、头部参数(header parameters)和Cookie 参数(cookie parameters).</p><ul><li>头部参数是在 HTTP 头部字段中的参数, 而 Cookie 参数则放在 Cookie 有效载荷中.</li><li>路径参数是 URL 路径的一部分, 通常用于标识一个资源.</li><li>查询参数是可选参数, 允许对端点的结果进行过滤和排序.<br>使用 <code>schema</code> 关键字参数来定义参数的类型, 并且在相关时, 也会指定参数的格式.</li></ul><h3 id=documenting-request-payloads>Documenting request payloads<a hidden class=anchor aria-hidden=true href=#documenting-request-payloads>#</a></h3><p><strong>文档化请求载荷</strong></p><p>一个请求代表 client 通过 POST 或 PUT 方法向 server 发送的数据. 这节介绍 API endpoints 的 request payloads.<br>例如 <code>POST /orders</code> 方法:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;order&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;product&#34;</span><span class=p>:</span> <span class=s2>&#34;cappuccinio&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;size&#34;</span><span class=p>:</span> <span class=s2>&#34;big&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;quantity&#34;</span><span class=p>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个 payload 包含一个 order 属性, 代表了一系列的物品. 每个物品被定义为下面的3个属性和约束:</p><ul><li>product: 用户订购的产品类型</li><li>size: 产品的大小. 有3种选择: small, medium 和 big</li><li>quantity: 产品的数量. 可以是任何大于等于1的整数</li></ul><p>下面展示如何为这个有效载荷 payload 定义模式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>paths</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>/orders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>post</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>operationId</span><span class=p>:</span><span class=w> </span><span class=l>createOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>requestBody</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>required</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>content</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>application/json</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>schema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>object</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>properties</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nt>order</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>array</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                  </span><span class=nt>items</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>object</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=nt>properties</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                      </span><span class=nt>product</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                      </span><span class=nt>size</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=nt>enum</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                          </span>- <span class=l>small</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                          </span>- <span class=l>medium</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                          </span>- <span class=l>big</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                      </span><span class=nt>quantity</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>intger</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=nt>required</span><span class=p>:</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=nt>default</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=nt>required</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                      </span>- <span class=l>product</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                      </span>- <span class=l>size</span><span class=w>
</span></span></span></code></pre></div><p>通过 HTTP 方法的 <code>requestBody</code> 属性下的 <code>content</code> 属性来定义 payload, 并可以指定不同的有效载荷. 有效载荷可以指定为不同的格式, 在本例中, 只允许 JSON 格式数据, 媒体类型为 <code>application/json</code>.<br>这里的有效载荷的模式是一个对象, 有一个属性 <code>order</code>, 其类型为数组, 数组中的元素的对象, 包含3个属性: <code>product</code>(类型为字符串), <code>size</code>(类型为字符串) 和 <code>quantity</code>(类型为整数).<br>此外, 还为 <code>size</code> 属性定义了一个枚举(enumeration), 将可接受的值限制为 <code>samll</code>、<code>medium</code> 和 <code>big</code> 3种.<br>最后, 还为 <code>quantity</code> 属性提供了默认值 <code>1</code>, 因为它是有效载荷中唯一非必须的字段.</p><h3 id=refactoring-schema-definitions-to-avoid-repetition>Refactoring schema definitions to avoid repetition<a hidden class=anchor aria-hidden=true href=#refactoring-schema-definitions-to-avoid-repetition>#</a></h3><p><strong>重构 schema 定义从而避免重复</strong></p><p>在本节将介绍重构模式 refactoring schemas 的策略, 以保持 API 规范的整洁和可读性.<br>上面的 <code>POST /orders</code> 端点定义很长, 包含多层缩进, 难以阅读, 意味着会变得难以扩展和维护.<br>可以将有效载荷 payload 的模式移动到 API 规范的 <code>components</code> 部分. 该部分用于声明在整个规范中被引用的模式, 每个模式都是一个对象, 其中键是模式的名称, 而值是属性的对象.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>paths</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>/orders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>post</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>operatoinId</span><span class=p>:</span><span class=w> </span><span class=l>createOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>requestBody</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>required</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>content</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>application/json</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>schema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>$ref</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;#/components/schemas/CreateOrderSchema&#39;</span><span class=w>    </span><span class=l>①</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>components</span><span class=p>:</span><span class=w>   </span><span class=l>②</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>schemas</span><span class=p>:</span><span class=w>    </span><span class=l>③</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>CreateOrderSchema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>object</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>properties</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>array</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>items</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>object</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>properties</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>product</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>size</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>enum</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span>- <span class=l>samll</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span>- <span class=l>medium</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span>- <span class=l>big</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>quantity</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>intger</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>required</span><span class=p>:</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>default</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>required</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span>- <span class=l>product</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span>- <span class=l>size</span><span class=w>
</span></span></span></code></pre></div><ol><li>使用 JSON pointer 指向文档其他位置</li><li>schema 定义在 components 下面</li><li>每个 schema 都是一个对象, 其中 key(CreateOrderSchema) 是名称, values(CreateOrderSchema下面的所有内容) 是描述属性 properties</li></ol><p>将 <code>POST /orders</code> 请求有效载荷的模式移动到 API 的 <code>components</code> 部分, 能使文档更具可读性. 这样得以保持 <code>path</code> 部分的简洁, 并专注于端点的高层细节. 只需要使用一个 JSON 指针来引用 <code>CreateOrderSchema</code> 模式:</p><pre tabindex=0><code>#/components/schemas/CreateOrderSchema
</code></pre><p>这份规范现在已经不错了, 但是可以更好. <code>CreateOrderSchema</code> 有些长, 并且包含了多层嵌套定义. 如果 <code>CreateOrderSchema</code> 的复杂性随着时间增长, 将越来越难以维护. 可以通过下面方式重构数组中订单项的定义, 使其更加具有可读性, 这个策略运行 API 的其他部分重用订单项的模式.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>components</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>schemas</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>OrderItemSchema</span><span class=p>:</span><span class=w>                     </span><span class=l>①</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>object</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>properties</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>product</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>size</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>enum</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span>- <span class=l>small</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span>- <span class=l>medium</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span>- <span class=l>big</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>quantity</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>integer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>default</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>CreateOrderSchema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>object</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>properties</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>order</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>array</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>items</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>$ref</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;#/OrderItemSchema&#39;</span><span class=w>    </span><span class=l>②</span><span class=w>
</span></span></span></code></pre></div><ol><li><code>OrderItemSchema</code>: 订单中的项</li><li><code>CreateOrderSchema</code>: 使用一个 JSON pointer 指向 <code>OrderItemSchema</code></li></ol><p>现在 schemas 看起来就好多了, 并且可以在 <code>/POST /orders/{order_id}</code> 端点中重用它.<br><code>/orders/{order_id}</code> 代表一个单例资源(singleton resource), 因此 URL 包含一个路径参数, 即订单ID. 在 OpenAPI 中, 路径参数使用大括号<code>{}</code> 表示.</p><pre tabindex=0><code>paths:
  /orders:
    get:
      ...

  /orders/{order_id}:          ①
    parameters:                ②
      - in: path               ③
        name: order_id         ④
        required: true         ⑤
        schema:
          type: string
          format: uuid         ⑥
    put:                       ⑦
      operationId: updateOrder
      requestBody:             ⑧
        required: true
        content:
          application/json:
            schema:
           $ref: &#39;#/components/schemas/CreateOrderSchema
</code></pre><ol><li>定义订单的资源地址</li><li>定义 URL path parameter</li><li><code>order_id</code> 参数是 URL 路径的一部分</li><li>参数名称</li><li>必填参数</li><li>具体参数格式(UUID)</li><li>为当前 URL 定义 PUT 方法</li><li>文档化 request body 的 PUT 端点</li></ol><h3 id=documenting-api-responses>Documenting API responses<a hidden class=anchor aria-hidden=true href=#documenting-api-responses>#</a></h3><p><strong>文档化响应体</strong></p><p><code>GET /orders/{order_id}</code> 端点的响应类似下面这样:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-JSON data-lang=JSON><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;924721eb-a1a1-4f13-b384-37e89c0e0875&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;status&#34;</span><span class=p>:</span> <span class=s2>&#34;progress&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;created&#34;</span><span class=p>:</span> <span class=s2>&#34;2022-05-01&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;order&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;product&#34;</span><span class=p>:</span> <span class=s2>&#34;cappuccino&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;size&#34;</span><span class=p>:</span> <span class=s2>&#34;small&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;quantity&#34;</span><span class=p>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;product&#34;</span><span class=p>:</span> <span class=s2>&#34;croissant&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;size&#34;</span><span class=p>:</span> <span class=s2>&#34;medium&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;quantity&#34;</span><span class=p>:</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个有效载荷展示了用户订购的产品, 下单时间以及订单状态. 类似之前 <code>POST</code> 和 <code>PUT</code> 端点定义的请求有效载荷, 因此可以重用之前的模式.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>components</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>schemas</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>OrderItemSchema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>GetOrderSchema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=l>①</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>object</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>properties</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>status</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>enum</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>②</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=l>created</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=l>paid</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=l>progress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=l>cancelled</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=l>displatched</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=l>delivered</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>created</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>format</span><span class=p>:</span><span class=w> </span><span class=l>date-time</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>③</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>order</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>array</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>items</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>$ref</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;#/components/schemas/OrderItemSchema&#39;</span><span class=w>  </span><span class=l>④</span><span class=w>
</span></span></span></code></pre></div><ol><li>定义 <code>GetOrderSchema</code> 模式</li><li>使用枚举限制状态属性</li><li>日期格式的字符串</li><li>使用 JSON pointer 引用 <code>OrderItemSchema</code></li></ol><p>在上面的清单中, 使用一个 JSON 指针指向 <code>GetOrderSchema</code>. 另一种重用现有模式的方法是继承.</p><p>在 OpenAPI 中, 可以通过一种称为模式组合(model composition) 的策略来继承和扩展一个模式, 该策略允许将不同模式的属性组合到一个单一的对象定义中. 在这种情况下, 使用特殊关键词 <code>allOf</code> 来表示该对象需要包含列出的所有模式中的属性.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>components</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>schemas</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>OrderItemSchema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>GetOrderSchema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>allOf</span><span class=p>:</span><span class=w>                                                </span><span class=l>①</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>$ref</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;#/components/schemas/CreateOrderSchema&#39;</span><span class=w>    </span><span class=l>②</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>object                                      ③</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>properties</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>status</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>enum</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span>- <span class=l>created</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span>- <span class=l>paid</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span>- <span class=l>progress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span>- <span class=l>cancelled</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span>- <span class=l>dispatched</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span>- <span class=l>delivered</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>created</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>format</span><span class=p>:</span><span class=w> </span><span class=l>date-time</span><span class=w>
</span></span></span></code></pre></div><ol><li>使用 <code>allOf</code> 关键字继承其他 schemas 的属性</li><li>使用 JSON pointer 引用其他的 schema</li><li>使用一个新对象 <code>GetOrderSchema</code> 来包含特有的属性</li></ol><p><strong>模型组合(Model composition)</strong> 能使规范更简洁、更紧凑, 但它只在模式严格兼容的情况才有效.<br>如果决定使用新的属性来扩展 <code>CreateOrderSchema</code>, 那么这个模式可能就不再能用于 <code>GetOrderSchema</code> 模型.<br>从这个意义上讲, 有时候更好的做饭是寻找不同模式中的共同元素, 将其定义重构为独立的模式.</p><p>现在有了 <code>GET /orders/{order_id}</code> 端点响应有效载荷的模式, 就可以完善该端点的规范了. 把端点的响应定义为对象, 其中键是响应的状态码, 并描述响应的内容类型及其模式.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>paths</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>/orders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>get</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=l>/orders/{order_id}:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>parameters</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>in</span><span class=p>:</span><span class=w> </span><span class=l>path</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>order_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>required</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>schema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>format</span><span class=p>:</span><span class=w> </span><span class=l>uuid</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>put</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>get</span><span class=p>:</span><span class=w>                                                      </span><span class=l>①</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>summary</span><span class=p>:</span><span class=w> </span><span class=l>Returns the details of a specific order        ②</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>operationId</span><span class=p>:</span><span class=w> </span><span class=l>getOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>responses</span><span class=p>:</span><span class=w>                                              </span><span class=l>③</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>&#39;200&#39;</span><span class=p>:</span><span class=w>                                                </span><span class=l>④</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>description</span><span class=p>:</span><span class=w> </span><span class=l>OK                                     ⑤</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>content</span><span class=p>:</span><span class=w>                                            </span><span class=l>⑥</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>application/json</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>schema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nt>$ref</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;#/components/schemas/GetOrderSchema&#39;</span><span class=w>   </span><span class=l>⑦</span><span class=w>
</span></span></span></code></pre></div><ol><li>定义 <code>GET /order/{order_id}</code> endpoint</li><li>为该端点提供一个描述</li><li>定义一个端点响应</li><li>每个响应都是一个对象, 其中 key 为状态码</li><li>响应的简单描述</li><li>描述响应的内容类型</li><li>使用 JSON pointer 引用 <code>GetOrderSchema</code></li></ol><p>根据上面内容可以看到, 在端点的 <code>responses</code> 部分定义了响应模式(schemas), 在这种情况下, 值提供了 <code>200 (OK)</code> 成功响应的规范, 但也可以为其他状态码编写文档.</p><h3 id=creating-generic-responses>Creating generic responses<a hidden class=anchor aria-hidden=true href=#creating-generic-responses>#</a></h3><p><strong>创建同样响应</strong></p><p>本节介绍如何为 API 端点添加错误响应. 错误响应更具通用性, 因此可以使用 API 规范的 <code>components</code> 部分来提供这些响应的通用定义, 然后在端点中使用他们.<br>这里在 API 的 <code>components</code> 部分的 <code>responses</code> 标头下定义通用响应. 下面展示了一个名为 <code>NotFound</code> 的 404 响应通用定义. 与任何其他响应意义, 也会为其有效载荷编写文档, 本例中有效载荷由 <code>Error</code> 模式定义.</p><pre tabindex=0><code>components:
  responses:                                                ①
    NotFound:                                               ②
      description: The specified resource was not found.    ③
      content:                                              ④
        application/json:
          schema:
            $ref: &#39;#/components/schemas/Error&#39;              ⑤

  schemas:
    OrderItemSchema:
      ...
    Error:                                                  ⑥
      type: object
      properties:
        detail:
          type: string
      required:
        - detail
</code></pre><ol><li>通用响应定义在 <code>components</code> 部分的 <code>responses</code> 下</li><li>为这个响应命名</li><li>描述这个响应</li><li>定义响应内容</li><li>引用 <code>Error</code> 模式</li><li>定义 <code>Error</code> 有效载荷的模式</li></ol><p>上面这份针对 404 响应的规范可以在 <code>/orders/{order_id}</code> URL 路径下的所有端点规范中重复使用, 因为所有这些端点都是专门设计来针对特定资源的.</p><blockquote><p>在 OpenAPI 的 <a href=https://github.com/OAI/OpenAPI-Specification/issues/521>GitHub</a> 仓库中, 有一个请求是希望允许在 URL 路径下直接包含通用响应, 但目前尚未实现</p></blockquote><p>下面定义 <code>/orders/{order_id}</code> 的 404 响应模式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>paths</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=l>/orders/{order_id}:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>parameters</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>in</span><span class=p>:</span><span class=w> </span><span class=l>path</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>order_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>required</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>schema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>&#34;format&#34;: </span><span class=l>uuid</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>get</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>summary</span><span class=p>:</span><span class=w> </span><span class=l>Returns the details of a specific order</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>operationId</span><span class=p>:</span><span class=w> </span><span class=l>getOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>responses</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>&#39;200&#39;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>description</span><span class=p>:</span><span class=w> </span><span class=l>OK</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>content</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>application/json</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>schema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nt>$ref</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;#/components/schemas/GetOrderSchema&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>&#39;404&#39;</span><span class=p>:</span><span class=w>                </span><span class=l>①</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>$ref</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;#/components/responses/NotFound&#39;</span><span class=w>  </span><span class=l>②</span><span class=w>
</span></span></span></code></pre></div><ol><li>定义一个 404 响应</li><li>使用 JSON 指针引用 <code>NotFound</code> 响应</li></ol><p>剩下的一个端点是 <code>GET /orders</code>, 它返回一个订单列表, 该端点的有效载荷重用了 <code>GetOrderSchema</code> 来定义订单数组中的项目</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>paths</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>/orders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>get</span><span class=p>:</span><span class=w>                               </span><span class=l>①</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>operationId</span><span class=p>:</span><span class=w> </span><span class=l>getOrders</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>responses</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>&#39;200&#39;</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>description</span><span class=p>:</span><span class=w> </span><span class=l>A JSON array of orders</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>content</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>application/json</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>schema</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>object</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nt>properties</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                  </span><span class=nt>orders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>array        ②</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=nt>items</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                      </span><span class=nt>$ref</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;#/components/schemas/GetOrderSchema&#39;</span><span class=w>  </span><span class=l>③</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nt>required</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                  </span>- <span class=l>order</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>post</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=l>/orders/{order_id}:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>parameters</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=l>...</span><span class=w>
</span></span></span></code></pre></div><ol><li>定义 <code>/orders</code> URL 路径的新 <code>GET</code> 方法</li><li><code>orders</code> 是一个数组</li><li>数组的每个项目都由 <code>GetOrderSchema</code> 定义</li></ol><p>现在, API 的端点已完全文档化. 可以在端点定义中使用更多的元素, 例如 <code>tags</code> 和 <code>externalDocs</code>. 些属性并非绝对必要, 但可以帮助为 API 提供更多结构, 或使其更易于对端点进行分组.</p><h3 id=defining-the-authentication-scheme-of-the-api>Defining the authentication scheme of the API<a hidden class=anchor aria-hidden=true href=#defining-the-authentication-scheme-of-the-api>#</a></h3><p><strong>定义 API 的认证模式</strong></p><p>如果 API 受到到保护, API 规范必须描述用户如何进行身份认证和授权请求. API 安全定义位于规范的 <code>components</code> 部分, 在 <code>securitySchema</code> 标头下.</p><p>通过 OpenAPI, 可以描述不同的安全方案, 例如基于 HTTP 的认证、基于密钥的认证、OAuth2 开放授权 和 OpenID Connect.<br>下面描述了3种方案: 一种用于 OpenID Connect, 一种用于 OAuth2, 还有一种用于 Bearer 授权.</p><ul><li>这里使用 OpenID Connect 通过前端应用来授权用户访问<br>对于 OpenID Connect, 必须在 <code>openIdConnectUrl</code> 属性下提供一个配置 URL, 该 URL 描述了后端客户端如何认证工作</li><li>对于直接的 API 集成, 提供 OAuth 的客户端凭证流(client credentials flow)<br>对于 OAuth2, 必须描述可用的授权流(authentication flows), 以及客户端必须用于获取其授权令牌的 URL 和可用的作用域(scopes).<br>Bearer 授权告诉用户, 他们必须在 <code>Authorization</code> 头部中包含一个 JSON Web Token(JWT) 来授权其请求.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>components</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>responses</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>schemas</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>securitySchemes</span><span class=p>:</span><span class=w> </span><span class=l>①</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>openId</span><span class=p>:</span><span class=w> </span><span class=l>②</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>openIdConnect ③</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>openIdConnectUrl</span><span class=p>:</span><span class=w> </span><span class=l>https://coffeemesh-dev.eu.auth0.com/.well-known/openid-configuration ④</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>oauth2</span><span class=p>:</span><span class=w> </span><span class=l>⑤</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>oauth2 ⑥</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>flows</span><span class=p>:</span><span class=w> </span><span class=l>⑦</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>clientCredentials</span><span class=p>:</span><span class=w> </span><span class=l>⑧</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>tokenUrl</span><span class=p>:</span><span class=w> </span><span class=l>https://coffeemesh-dev.eu.auth0.com/oauth/token ⑨</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>scopes</span><span class=p>:</span><span class=w> </span>{}<span class=w> </span><span class=l>⑩</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>bearerAuth</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>http</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>scheme</span><span class=p>:</span><span class=w> </span><span class=l>bearer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>bearerFormat</span><span class=p>:</span><span class=w> </span><span class=l>JWT ⑪</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nn>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>security</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>oauth2</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>getOrders</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>createOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>getOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>updateOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>deleteOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>payOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>cancelOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>bearerAuth</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>getOrders</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>createOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>getOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>updateOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>deleteOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>payOrder</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- - <span class=l>cancelOrder</span><span class=w>
</span></span></span></code></pre></div><ol><li>API components 部分的 securitySchemes 标头下的安全方案</li><li>为安全方案提供一个名称(可以是任何名称)</li><li>安全方案的类型</li><li>描述后端 OpenID Connect 配置的 URL</li><li>另一个安全方案的名称</li><li>该安全方案的类型</li><li>该安全方案下可用的授权流</li><li>客户端凭证流的描述</li><li>用户可以请求授权令牌的 URL</li><li>请求授权令牌时可用的作用域</li><li>Bearer 令牌的格式是 JSON Web Token (JWT)</li></ol><h2 id=wrapping-up>Wrapping Up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><ul><li>JSON Schema 是一个定义 JSON 文档中属性类型和格式的规范, 它有助于以一种独立于编程语言的方式定义数据验证模型.</li><li>OpenAPI 是一种用于描述 RESTful API 的标准文档格式, 它使用 JSON Schema 来描述 API 的属性. 通过使用 OpenAPI, 你可以利用围绕该标准构建的整个工具和框架生态系统, 从而使 API 集成变得更加容易.</li><li>JSON pointer 允许使用 <code>$ref</code> 关键字来引用一个模式(schema). 利用 JSON 指针, 可以创建可重用的模式定义, 这些定义可以在 API 规范的不同部分使用, 从而保持 API 规范的整洁和易于理解.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://starslayerx.github.io/tags/rest/>REST</a></li><li><a href=https://starslayerx.github.io/tags/openapi/>OpenAPI</a></li></ul><nav class=paginav><a class=prev href=https://starslayerx.github.io/posts/redis-set/><span class=title>« Prev</span><br><span>Redis Set</span>
</a><a class=next href=https://starslayerx.github.io/posts/redis-list/><span class=title>Next »</span><br><span>Redis List</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Documenting REST APIs with OpenAPI on x" href="https://x.com/intent/tweet/?text=Documenting%20REST%20APIs%20with%20OpenAPI&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocumenting-rest-apis-with-openapi%2f&amp;hashtags=REST%2cOpenAPI"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Documenting REST APIs with OpenAPI on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocumenting-rest-apis-with-openapi%2f&amp;title=Documenting%20REST%20APIs%20with%20OpenAPI&amp;summary=Documenting%20REST%20APIs%20with%20OpenAPI&amp;source=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocumenting-rest-apis-with-openapi%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Documenting REST APIs with OpenAPI on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocumenting-rest-apis-with-openapi%2f&title=Documenting%20REST%20APIs%20with%20OpenAPI"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Documenting REST APIs with OpenAPI on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocumenting-rest-apis-with-openapi%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Documenting REST APIs with OpenAPI on whatsapp" href="https://api.whatsapp.com/send?text=Documenting%20REST%20APIs%20with%20OpenAPI%20-%20https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocumenting-rest-apis-with-openapi%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Documenting REST APIs with OpenAPI on telegram" href="https://telegram.me/share/url?text=Documenting%20REST%20APIs%20with%20OpenAPI&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocumenting-rest-apis-with-openapi%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Documenting REST APIs with OpenAPI on ycombinator" href="https://news.ycombinator.com/submitlink?t=Documenting%20REST%20APIs%20with%20OpenAPI&u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocumenting-rest-apis-with-openapi%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>