<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker - Containers | Starslayerx' Blog</title><meta name=keywords content="Docker"><meta name=description content="像 VMware 或 KVM 这类虚拟化系统, 他们运行在虚拟化层上运行完整的 Linux 内核与操作系统.
这种架构能提供极强的隔离性, 因为每个虚拟机都搭载独立的内核, 这些内核各自运行在硬甲虚拟化层之上的隔离内存空间中.
而容器技术有着根本性差异, 所有容器共享同一个内核, 工作负载间的隔离性全通过内核机制实现, 这种模式被称为操作系统级虚拟化 operating system virtualization.
runc/libcontainer 提供了一个很好的定义:
A container is a self-contained execution environment that shares the kernel of the host system and is isolated from other containers in the system.
容器最大的优势就在于性能, 当运行一个进程的时候, 只有小部分的代码在内核中用于管理容器.
如今, 容器几乎在任何地方运行. Docker 和 OCI 镜像提供了生成环境中软件的打包格式, 并为 Kubernetes 和大多数 &ldquo;serverless&rdquo; 云技术打下了基础.

所谓的 serverless 技术并不是真的没有服务器: 它们依赖其他人的服务器来完成工作, 这样应用开发者就无需关心管理硬甲和操作系统了.

Creating a Container
创建容器的命令 docker container run 实际上是包装在一起的两条命令.
第一件事是从基本的镜像中创建一个容器, 可以通过 docker container create 命令实现.
第二件事是执行容器, 同样地, 可以通过 docker container start 命令实现."><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/posts/docker-containers/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://starslayerx.github.io/posts/docker-containers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/posts/docker-containers/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Docker - Containers"><meta property="og:description" content="像 VMware 或 KVM 这类虚拟化系统, 他们运行在虚拟化层上运行完整的 Linux 内核与操作系统. 这种架构能提供极强的隔离性, 因为每个虚拟机都搭载独立的内核, 这些内核各自运行在硬甲虚拟化层之上的隔离内存空间中.
而容器技术有着根本性差异, 所有容器共享同一个内核, 工作负载间的隔离性全通过内核机制实现, 这种模式被称为操作系统级虚拟化 operating system virtualization.
runc/libcontainer 提供了一个很好的定义: A container is a self-contained execution environment that shares the kernel of the host system and is isolated from other containers in the system.
容器最大的优势就在于性能, 当运行一个进程的时候, 只有小部分的代码在内核中用于管理容器. 如今, 容器几乎在任何地方运行. Docker 和 OCI 镜像提供了生成环境中软件的打包格式, 并为 Kubernetes 和大多数 “serverless” 云技术打下了基础.
所谓的 serverless 技术并不是真的没有服务器: 它们依赖其他人的服务器来完成工作, 这样应用开发者就无需关心管理硬甲和操作系统了. Creating a Container 创建容器的命令 docker container run 实际上是包装在一起的两条命令. 第一件事是从基本的镜像中创建一个容器, 可以通过 docker container create 命令实现. 第二件事是执行容器, 同样地, 可以通过 docker container start 命令实现."><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-23T08:00:00+08:00"><meta property="article:modified_time" content="2025-09-23T08:00:00+08:00"><meta property="article:tag" content="Docker"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Docker - Containers"><meta name=twitter:description content="像 VMware 或 KVM 这类虚拟化系统, 他们运行在虚拟化层上运行完整的 Linux 内核与操作系统.
这种架构能提供极强的隔离性, 因为每个虚拟机都搭载独立的内核, 这些内核各自运行在硬甲虚拟化层之上的隔离内存空间中.
而容器技术有着根本性差异, 所有容器共享同一个内核, 工作负载间的隔离性全通过内核机制实现, 这种模式被称为操作系统级虚拟化 operating system virtualization.
runc/libcontainer 提供了一个很好的定义:
A container is a self-contained execution environment that shares the kernel of the host system and is isolated from other containers in the system.
容器最大的优势就在于性能, 当运行一个进程的时候, 只有小部分的代码在内核中用于管理容器.
如今, 容器几乎在任何地方运行. Docker 和 OCI 镜像提供了生成环境中软件的打包格式, 并为 Kubernetes 和大多数 &ldquo;serverless&rdquo; 云技术打下了基础.

所谓的 serverless 技术并不是真的没有服务器: 它们依赖其他人的服务器来完成工作, 这样应用开发者就无需关心管理硬甲和操作系统了.

Creating a Container
创建容器的命令 docker container run 实际上是包装在一起的两条命令.
第一件事是从基本的镜像中创建一个容器, 可以通过 docker container create 命令实现.
第二件事是执行容器, 同样地, 可以通过 docker container start 命令实现."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://starslayerx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Docker - Containers","item":"https://starslayerx.github.io/posts/docker-containers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker - Containers","name":"Docker - Containers","description":"像 VMware 或 KVM 这类虚拟化系统, 他们运行在虚拟化层上运行完整的 Linux 内核与操作系统. 这种架构能提供极强的隔离性, 因为每个虚拟机都搭载独立的内核, 这些内核各自运行在硬甲虚拟化层之上的隔离内存空间中.\n而容器技术有着根本性差异, 所有容器共享同一个内核, 工作负载间的隔离性全通过内核机制实现, 这种模式被称为操作系统级虚拟化 operating system virtualization.\nrunc/libcontainer 提供了一个很好的定义: A container is a self-contained execution environment that shares the kernel of the host system and is isolated from other containers in the system.\n容器最大的优势就在于性能, 当运行一个进程的时候, 只有小部分的代码在内核中用于管理容器. 如今, 容器几乎在任何地方运行. Docker 和 OCI 镜像提供了生成环境中软件的打包格式, 并为 Kubernetes 和大多数 \u0026ldquo;serverless\u0026rdquo; 云技术打下了基础.\n所谓的 serverless 技术并不是真的没有服务器: 它们依赖其他人的服务器来完成工作, 这样应用开发者就无需关心管理硬甲和操作系统了. Creating a Container 创建容器的命令 docker container run 实际上是包装在一起的两条命令. 第一件事是从基本的镜像中创建一个容器, 可以通过 docker container create 命令实现. 第二件事是执行容器, 同样地, 可以通过 docker container start 命令实现.\n","keywords":["Docker"],"articleBody":"像 VMware 或 KVM 这类虚拟化系统, 他们运行在虚拟化层上运行完整的 Linux 内核与操作系统. 这种架构能提供极强的隔离性, 因为每个虚拟机都搭载独立的内核, 这些内核各自运行在硬甲虚拟化层之上的隔离内存空间中.\n而容器技术有着根本性差异, 所有容器共享同一个内核, 工作负载间的隔离性全通过内核机制实现, 这种模式被称为操作系统级虚拟化 operating system virtualization.\nrunc/libcontainer 提供了一个很好的定义: A container is a self-contained execution environment that shares the kernel of the host system and is isolated from other containers in the system.\n容器最大的优势就在于性能, 当运行一个进程的时候, 只有小部分的代码在内核中用于管理容器. 如今, 容器几乎在任何地方运行. Docker 和 OCI 镜像提供了生成环境中软件的打包格式, 并为 Kubernetes 和大多数 “serverless” 云技术打下了基础.\n所谓的 serverless 技术并不是真的没有服务器: 它们依赖其他人的服务器来完成工作, 这样应用开发者就无需关心管理硬甲和操作系统了. Creating a Container 创建容器的命令 docker container run 实际上是包装在一起的两条命令. 第一件事是从基本的镜像中创建一个容器, 可以通过 docker container create 命令实现. 第二件事是执行容器, 同样地, 可以通过 docker container start 命令实现.\n之前的命令参数中, 端口参数 -p/--publish argument 和环境变量参数 -e/--env 都只能在创建容器的时候设置.\nBasic Configuration Conatiner name 当创建一个容器的时候, 默认情况下会使用 Dockerfile 设置的值, 但是可以在创建的时候通过命令行参数覆盖. 默认情况下, Docker 会使用名人名称的组合随机命名容器, 这就会出现类似 ecstatic-babbage 和 serene-albattani 这样的容器名. 如果要给容器一个具体的名字, 使用参数 --name\ndocker container create --name=\"awesome-service\" ubuntu:latest sleep 120 创建后就可以启动容器了\ndocker container start awesome-service 它将会在 120 秒后自动退出, 但也可以通过命令提前关闭\ndocker container stop awesome-service 任何一个名称都只能给一个容器使用. 如果运行两次命令, 将会得到一个报错. 要么使用 docker container rm 删除之前的容器, 要么换一个名字.\nLabels Labels 是可以作为 Docker 镜像和容器元数据的键值对. 当 Linux 容器创建后, 他们将自动继承父镜像的标签.\n当然也可以为容器添加新的标签:\ndocker container run --rm -d --name has-some-labels \\ -l deployer=Ahmed -l tester=Asako \\ ubuntu:latest sleep 1000 然后就可以基于 metadata 来搜索和过滤容器, 通过 docker container ls 命令实现:\ndocker container ls -a -f label=deployer=Ahmed CONTAINER ID IMAGE COMMAND … NAMES 845731631ba4 ubuntu:latest \"sleep 1000\" … has-some-labels 可以使用 docker container inspect 命令查看容器所有的 labels\ndocker container inspect has-some-labels ... \"Labels\": { \"deployer\": \"Ahmed\", \"tester\": \"Asako\" } ... 这个容器运行了命令 sleep 1000, 这样 1000 秒后容器就会自动停止.\nHostname 默认情况下，当开启一个容器的时候，Docker 会将 host 宿主机上特定的系统文件复制到 host 上面的容器配置目录中，包括 /etc/hostname，并使用挂载将文件复制到容器中。可以下面这样启动一个没有额外配置的默认容器：\ndocker container run --rm -ti ubuntu:latest /bin/bas 这条命令 docker container run 实际在背后运行了 docker container create 和 docker container start 两条命令。\n--rm 参数告诉 Docker 当容器存在时将其删除 -t 参数告诉 Docker 分配一个伪终端 -t 参数告诉 Docker 这将是一次交互式的会话，以及我们想将 STDIN 开启 如果镜像中没有定义 ENTRYPOINT，那么命令中的最后一个参数就是在容器中运行的可执行文件及其命令行参数，在本例中为 /bin/bash。 如果镜像中定义了 ENTRYPOINT，那么最后一个参数将作为命令行参数列表传递给 ENTRYPOINT 进程。\n如果到容器内部运行 mount 命令，会看到下面这样的输出：\nroot@4464f3966c8c:/# mount overlay on / type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/QGANRL2RXF5OAGF6BR3VJBYKV7:/var/lib/docker/overlay2/l/FTZKGGCRTA67I47MV56GWNKXTJ,upperdir=/var/lib/docker/overlay2/9dc4a47989317b4297d540bb99e6d25b14b4db15eaa18e444f43877dfa6088f8/diff,workdir=/var/lib/docker/overlay2/9dc4a47989317b4297d540bb99e6d25b14b4db15eaa18e444f43877dfa6088f8/work) proc on /proc type proc (rw,nosuid,nodev,noexec,relatime) tmpfs on /dev type tmpfs (rw,nosuid,size=65536k,mode=755) devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=666) sysfs on /sys type sysfs (ro,nosuid,nodev,noexec,relatime) cgroup on /sys/fs/cgroup type cgroup2 (ro,nosuid,nodev,noexec,relatime) mqueue on /dev/mqueue type mqueue (rw,nosuid,nodev,noexec,relatime) shm on /dev/shm type tmpfs (rw,nosuid,nodev,noexec,relatime,size=65536k) /dev/vda1 on /etc/resolv.conf type ext4 (rw,relatime,discard) /dev/vda1 on /etc/hostname type ext4 (rw,relatime,discard) /dev/vda1 on /etc/hosts type ext4 (rw,relatime,discard) devpts on /dev/console type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=666) proc on /proc/bus type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/fs type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/irq type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/sys type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/sysrq-trigger type proc (ro,nosuid,nodev,noexec,relatime) tmpfs on /proc/interrupts type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/kcore type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/keys type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/timer_list type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/scsi type tmpfs (ro,relatime) tmpfs on /sys/firmware type tmpfs (ro,relatime) 当看到 root@hashID 时，一般说明在容器内部运行\n默认 hostname 是容器 ID，但可以使用 --name 参数指定容器名称（用于管理，如 docker ps 看到的名称） 默认用户为 root，可以通过 --user 参数指定进入容器后的用户 上面的绑定挂载中，我们感兴趣的是这一行：\n/dev/vda1 on /etc/hostname type ext4 (rw,relatime,discard) 前面的设备名称可能不同，但挂载点都是 /etc/hostname，这回将容器的 /etc/hostname 链接到 Docker 为容器准备的主机文件，该文件默认包含容器 ID，并没有完全限制域名。（容器的主机名不带域名后缀，例如为 4464f3966c8c 而不是 4464f3966c8c.example.com）\n如果要设置具体的 hostname，可以使用 --hostname 参数传入一个具体的值：\ndocker container run --rm -ti --hostname=\"mycnotainer.example.com\" \\ ubuntu:latest /bin/bash Domain Name Services 如同 /etc/hostname，resolv.conf 文件设置的 Domain Name Service (DNS) 通过主机和容器的绑定挂载管理。\n/dev/vda1 on /etc/resolv.conf type ext4 (rw,relatime,discard) 默认情况下，会直接复制宿主机的 resolv.conf 文件，如果不想要默认配置，可以使用 --dns (nameserver) 和 --dns-search (search) 参数复写容器的行为：\ndocker container run --rm -ti --dns=8.8.8.8 --dns=8.8.4.4 \\ --dns-search=exmaple.com --dns-search=example2.com \\ ubuntu:latest /bin/bash 如果不想设置 search domain，使用 --dns-search=.\n容器中的文件为下面这样：\nroot@97b634b9bb5b:/# more /etc/resolv.conf # Generated by Docker Engine. # This file can be edited; Docker Engine will not make further changes once it # has been modified. nameserver 8.8.8.8 nameserver 8.8.4.4 search exmaple.com example2.com # Based on host file: '/etc/resolv.conf' (legacy) # Overrides: [nameservers search] MAC address 另一个可以设置的重要信息是容器的 media access control (MAC) 地址。\n如果没有任何配置，容器会接受一个计算出的 MAC 地址，并以 02:42:ac:11 为前缀（以 02 开头的 MAC 表示“本地管理的（Locally Administered）”地址，不与全球 OUI 冲突）。 如果要设置这个值，使用类似下面方法：\ndocker container run --rm -ti --mac-address=\"a2:11:aa:22:bb:33\" \\ ubuntu:latest /bin/bash WARNING 警告\n自定义 MAC 地址的时候要小心，当两个系统使用同样 MAC 地址的时候，可能会引起 ARP contention（ARP 冲突）。 如果确实有自定义 MAC 地址的需求，建议使用 x2-, x6-, xA- 和 xE- 开头的地址。\nStorage Volumes 有时使用容器默认分配的磁盘空间，或者容器是暂时的，这种并不适合手头的工作，因此需要在容器部署之间的持久化存储。\n这时候，可以使用 --mount/-v 参数将 host 上的目录或单独的文件挂载到容器中。 下面的例子将 /mnt/session_data 挂载到容器的 /data 目录：\ndocker container run --rm -ti \\ --mount type=bind, target=/mnt/session_data,source=/data \\ ubuntu:latest /bin/bash 可以使用 -v 参数简化，使用冒号 : 将源文件与目标文件分开，还在末尾添加 ro 以只读方式挂载\ndocker container run --rm -ti \\ -v /mnt/session_data:/data:ro \\ ubuntu:latest /bin/bash host 和容器中挂载的文件都无需预先存在，如果主机挂载点的文件不存在，会直接创建对应的目录文件，这可能会导致一些问题。\nSELINUX AND VOLUME MOUNTS\nSELINUX (Secuirty-Enhanced Linux) 是一个内置于 Linux 内核的强制访问控制器 (MAC) 安全系统。 其核心思想是“默认拒绝”。\n传统 Linux 使用自主访问控制 (DAC)，基于用户/组/权限 (rwx)。 SELinux 在此基础上，为每个进程、文件、目录等对象都打上了一个安全上下文标签。策略规则规定了 “哪个进程的标签” 可以访问 “哪个文件的标签”。 如果在 Docker host 启动了 SELinux，挂载文件目录的时候，可能会遇到一个 “Permission Denied” 报错。 可以使用 Docker z/Z 选择来处理挂载问题：\n小写的 z 选项表示绑定挂载内容可多容器共享 大写的 Z 选项表示绑定挂载内容是私有且不共享的 例如下面这样\ndocker container run --rm -v /app/dhcpd/etc:/etc/dhcpd:z dhcpd 还可以告诉 Docker 容器以只读方式运行，这样任何进程就无法修改根目录文件了（任何在 / 下尝试写入的操作都会失败，除非该路径被单独挂载为可写卷）。 在之前的例子中，可以使用 --read-only=true 命令：\ndocker container run --rm -ti --read-only=true -v /mnt/session_data:/data \\ ubuntu:latest /bin/bash 有时，即使容器为可读的，也有必要使 /tmp 这样目录可写。 这种情况下，可以使用 docker container run 命令配置 --mount type=tmpfs 参数，已将 tmpfs 文件系统挂载到容器中。 tmpfs 文件系统完全在内存中，速度非常快，同时也是临时的，关闭容器就会释放。 下面示例展示启动一个容器，在 /tmp 处挂载一个 256 MB 的 tmpfs 文件系统：\ndocker container run --rm -ti --read-only=true \\ --mount type=tmpfs,destination=/tmp,tmpfs-size=256M \\ ubuntu:latest /bin/bash 容器如下：\nroot@a1b02391f02d:/# df -h /tmp Filesystem Size Used Avail Use% Mounted on tmpfs 256M 0 256M 0% /tmp root@a1b02391f02d:/# grep /tmp /etc/mtab tmpfs /tmp tmpfs rw,nosuid,nodev,noexec,relatime,size=262144k 0 0 WARNING\n容器应该尽可能设计为无状态的，管理存储会有不必要的依赖，使得部署场景更加复杂。\nResource Quotas 虚拟机通常可以细致的控制 OS 的内容和 CPU 以及其他资源。\n当使用 Docker 时，必须利用 linux 内核的 cgroup 功能来控制资源可用性。 Docker 容器的运行命令 docker container run 命令在创建容器时直接支持设置 CPU, 内存, swap 和 I/O 限制。\nNOTE\n这些限制通常在容器创建的时候设置，如果需要修改这些配置，使用 docker container update 命令或部署一个新的容器。\nDocker 支持多种资源的限制，但是必须要在内核中开启相应的功能提供给 Docker。 可能需要通过命令行将这些功能开启，运行命令 docker system info 来查看内核相关限制支持。 如果缺失任何支持，将会有类似下面这样的输出：\nWARNING: No swap limit support CPU shares docker 有好几种限制 CPU 使用的容器应用。原始的最常用的方法是 cpu shares。\n系统中所有 CPU 核心的计算能力被视为总份额池。Docker 分配数字 1024 代表完整的池。 通过设置容器的 CPU 共享，可以设置容器获取多少 CPU shares。 如果希望容器最多获取系统一半的 CPU shares，那么就要分配 512 的份额。 这并发独占份额，即使将 1024 份额分配给一个容器，也不会影响其他容器的运行。\n更准确的说，它提示调度器容器运行的时间。 假如有一个容器分配了 1024 份额，另外两个分配 512 份额，他们都将被调度相同次数。 但是如果每个进程的正常 CPU 时间是 100 微秒，那么 512 份额的容器将运行 50 微秒，1024 份额的容器将运行 100 微秒。\n下面使用 stress 命令在容器内进行压力测试，下面命令将创建 2 条 CPU 密集计算，1 条 I/O 密集计算和两个内存分配程序，并分配 6 个 CPU 核心。\ndocker container run --rm -ti spkane/train-os \\ stress -v --cpu 6 --io 1 --vm 2 --vm-bytes 128M --timeout 120s 如果想运行同样的压力测试，但只分配一般的 CPU 运行时间，可以这样做：\ndocker container run --rm -ti --cpu-shares 512 spkane/train-os \\ stress -v --cpu 6 --io 1 --vm 2 --vm-bytes 128M --timeout 120s 与虚拟机不同，Docker基于cgroup对CPU份额的限制可能会产生意想不到的后果。 它不是硬性限制，而是相对限制，类似于nice命令。 例如，一个被限制为一半CPU份额的容器，如果运行在一个不怎么繁忙的系统上，由于CPU不繁忙，CPU份额的限制效果有限，因为调度器池中没有竞争。 当第二个大量使用CPU的容器部署到同一个系统时，突然间，第一个容器上的限制效果就会变得明显。 在限制容器和分配资源时，应仔细考虑这一点。\nCPU pinning 可以将一个容器绑定到一个或多个 CPU 核心。 这意味着这个容器的工作只会调度到分配给他的核心上。 如果要隔离 CPU 或者提高缓存效率，这会很有用。\n下面命令将容器绑定到前 2 个 CPU 上：\ndocker container run --rm -ti \\ --cpu-shares 512 --cpu-set=0 spkane/train-os \\ stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M --timeout 120s WARNING\n--cpu-set 参数是从 0 开始的，因此第一个 CPU 是 0。 如果让 Docker 使用一个不存在的 CPU 核心，将会得到一个无法启动容器的报错。\n在 Linux 内核中使用 CPU Completely Fair Scheduler (CFS)，可以使用 --cpu-quota 参数更改 CPU quota 来启动容器。\nCFS 完全公平调度器：\nLinux 内核中的默认 CPU 调度器 目标是为所有进程提供“公平”的 CPU 时间 通过时间片轮转和优先级来分配 CPU 资源 CPU quota:\n不同于 CPU shares 这是一个硬性限制 限制一个容器在一个时间周期内可以使用的 CPU 时间 即使系统空闲，也不能超过这个限制 限制最多使用 50% CPU:\ndocker container run --cpu-period=100000 --cpu-quota=50000 image cpu-period: 时间周期（默认 100000 微秒 = 100ms）\nCPU 使用率 = (cpu-quota / cpu-period) × 100%\nSimplifying CPU quotas CPU shares 和 CPU quotas 是 Docker 中管理 CPU 限制的基本机制，但现在 Docker 已经发展了很多。 只需要简单地告诉 Docker 希望容器提供多少 CPU，它就会自动完成底层 cgroups 所需的计算。\n参数 --cpus 可以设置一个 0.01 至 CPU 核心数的浮点数：\ndocker container run --rm -ti --cpus=\".25\" spkane/train-os \\ stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M --timout 60s 如果要调整容器的资源限制，可以使用 update 命令，如下：\ndocker container update --cpus=\"1.5\" 092c5dc8504 92b797f12af1 Memory 内存可以使用类似 CPU 限制的功能。但不同的是，内存是硬性限制，分配多少就只能用那么多，且会有一定的默认分配。 由于虚拟内存的存在，实际上可以为容器分配比系统内存更多的内存，容器将使用 swap 存储这些内容，就像 linux 中的进程一样。\n下面使用 --memory 参数命令开启一个限制内存的命令：\ndocker conatiner run --rm -ti --memory 512m spkane/train-os \\ stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M --timout 10s 当单独使用 --memory 参数时，会同时设置 RAM 和 swap 的大小，这里就设置了 512m 的 RAM 和 512m 的 swap 大小。 Docker 支持 b, k, m, g 单位。\n如果要单独设置 swap 大小，或者关闭它，使用 --memory-swap 参数：\ndocker container run --rm -ti --memory 512m --memory-swap=768m \\ spkane/train-os stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M \\ --timeout 10s 如果将 --memory-swap 设置为 -1，那么容器将可以使用系统上任意大的 swap 空间。 如果将 --memory-swap 设置为和 --memory 相同的正数，则容器将无法使用任何 swap 空间。\n当内存快满的时候，Docker 容器将会让 linux 内核认为系统内存快满了，它将会尝试杀死进程以释放内存。 例如下面命令：\ndocker container run --rm -ti --memory 100m spkane/train-os \\ stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M --timeout 10s 会有类似下面的报错\nstress: FAIL: [1] (461) failed run completed in 0s 这是因为容器尝试分配的内存大于运行的内存， Linux OOM (kernel out-of-memory) killer 被激活，并杀死子进程，父进程清理进程，并报错退出。\n可以使用命令 sudo dmesg 查看相关信息，该 OOM 事件也会被 Docker 记录，可以使用 docker system events 监控\ndocker system events 该命令是一个阻塞命令，它会持续监听 Docker daemon 守护进程的事件，因此直接开启该命令看不到之前的报错信息。\nBlock I/O 很多容器实际上都是无状态容器，大多数都不需要 I/O 限制。 但 Docker 还是提供了基于 cgroup 机制的限制功能。\n第一种方式是为容器的 block I/O 设备设置优先级。 可以通过设置默认的 blkio.weight cgroup 状态实现，该属性设置为 0 表示禁止，或者 10~1000 之间的一个数，默认为 500。 该限制类似 CPU shares，系统会将所有可用的 I/O 划分为 1000 份，并在 cgroup 切片中的每个进程之间进行分配，其中分配的权重会影响每个进程可用的 I/O 量。\n通过参数 --blkio-weight 设置权重，也可以使用参数 --blkio-weight-device 指定特殊的设备。 和 CPU shares 一样，在实际操作中调整合适的权重比较困难，但是可以通过限制每秒最大的字节数/操作数来使管理变得更加容易。 例如下面参数：\n--devices-read-bps: 限制设备读取速率 (bytes per second) --devices-read-iops: 限制设备读取速率 (IO per second) --devices-write-bps: 限制设备写速率 (bytes per second) --devices-write-iops: 限制设备写速率 (IO per second) 可以使用 Linux I/O tester bonnie 来测试对容器性能的影响：\ntime docker container run --rm -ti spkane/train-os:latest \\ bonnie++ -u 500:500 -d /tmp -r 1024 -s 2048 -x 1 real 0m27.715s user 0m0.027s sys 0m0.030s 这个根据经验，更加推荐使用 --device-read-iops 和 --dvice-write-iops 参数来设置 block I/O 限制。\nulimits 在 Linux 引入 cgroups 之前，还有另一种方式可以限制进程可用的系统资源： 通过 ulimit 命令 设置用户级资源限制。 这种机制至今仍然可用，并且在许多传统使用场景下依然非常有用。\n下面的示例展示了可以通过 ulimit 命令设置“软限制（soft limit）”和“硬限制（hard limit）”的系统资源类型：\ncore file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 5835 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 10240 cpu time (seconds, -t) unlimited max user processes (-u) 1024 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 可以在 Docker 守护进程（daemon） 的启动配置中设置默认的用户限制，使其应用到每一个容器上。 例如，下面的命令告诉 Docker 守护进程：启动所有容器时，将打开文件数的软限制设为 50，硬限制设为 150：\nsudo dockerd --default-ulimit nofile=50:150 然后，可以在启动特定容器时使用 --ulimit 参数覆盖这些默认值，例如：\ndocker container run --rm -d --ulimit nofile=150:300 nginx 此外，还有一些更高级的命令可用于创建容器时设置限制，但上述内容涵盖了多数常见场景。 Docker 客户端文档中列出了所有可用选项，并会随着每次 Docker 发布而更新。\nStarting a Container 创建容器后，并不会默认运行，这是一个设置的过程，而不是运行过程。\n$ docker container create -p 6379:6379 redis:2.8 Unable to find image 'redis:2.8' locally 2.8: Pulling from library/redis 51f5c6a04d83: Pull complete 6c8ccd839b1d: Pull complete 0fded1c9651d: Pull complete 7f1aa6a73799: Pull complete fbe8a4f1aa87: Pull complete 1a9852d2edd3: Pull complete 128182e1e85d: Pull complete b94de088b6d8: Pull complete Digest: sha256:e507029ca6a11b85f8628ff16d7ff73ae54582f16fd757e64431f5ca6d27a13c Status: Downloaded newer image for redis:2.8 d14e339f67f70c21783e242ce706b705e5355facf0a5d97a797a9f3bbc701ff7 上面最后一行就是容器的哈希，可以使用该哈希来启动容器，如果没有记录下来该哈希，可以使用下面命令查看容器：\n$ docker container ls -a --filter ancestor=redis:2.8 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d14e339f67f7 redis:2.8 \"docker-entrypoint.s…\" 3 minutes ago Created pensive_cori 可以使用下面命令来启动容器\ndocker container start d14e339f67f7 NOTE\n这里的哈希可以是完整的，也可以是部分的，甚至无论长度只要满足唯一性即可。\n现在容器应该正常运行了，但运行在后台无法知道是否报错：\ndocker container ls Auto-Restarting a Container 在许多情况下，我们希望容器在退出后自动重启。 许多容器存活时间很短，但对于生产环境，可能希望他们能够始终保持运行。 如果要运行一个复杂系统，可以使用 scheduler。\n最简单是情况下，使用 --restart 参数告诉 docker 容器重新运行命令，该参数有 4 类可选值：\nno: 永不重启 always: 总是重启 no-failure: 当以非 0 退出码的时候重启，如果设置成 no-failure:3 则会在尝试重启 3 次失败后放弃重启 unless-stopped: 总是重启，除非有意停止，例如 docker container stop 可以重新运行之前的内存受限的例子来展示，这里使用 --restart 参数而不是 --rm 参数：\ndocker container run -ti --restart=on-failure:3 --memory 100m spkane/train-os \\ stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M --timeout 120s Stoping a Container 容器可以停止与启动，你可能认为容器的暂停和启动是类似的，但实际上两者并不相同。 当进程停止的时候，并不是暂停了，而是退出了。 而容器停止 stop 的时候，它不再在 docker container ls 输出中显示，一但重启 docker 就会尝试启动所有关机时关闭的容器。 即容器进程退出，但会保留容器状态，重启的使用再运行。 如果只是想暂停容器，而不停止任何进程，应该使用 pause 命令，docker container pause 和 docker container unpause。\n如果要查看已经停止的容器，使用 docker container ls -a 命令查看。 这意味着，虽然内存和临时文件 temporary file system (tmpfs) 会暂时丢失，但所有其他的文件内容和元数据，包括环境变量和端口信息都会在容器重启的时候恢复。\n容器与服务器上任何其他进程以基本相同的方式与系统交互，这意味着我们可以向容器中的进程发送 Unix 信号，而它们可以做出响应。 在之前的 docker container stop 示例中，向容器发送了 SIGTERM 信号，并等待容器优雅地退出。 容器遵循与Linux上任何其他进程组接收到的相同的过程组信号传播。\n一个正常的 docker container stop 会向进程发送 SIGTERM 信号。 如果希望容器在经过一定时间后仍未停止时被强制杀死，可以使用 -t 参数，例如：\ndocker container stop -t 25 d14e339f67f7 这样在 25 秒后，如果容器仍未关闭，则会发送一个 SIGKILL 信号将其强制关闭。\nKilling a Container 当一个进程不正常的时候，docker container stop 可能无法解决问题。 如果希望容器立刻退出，可以使用 docker container kill，类似 linux kill 命令，该命令也可以发送信号\ndocker container kill --signal=USR1 092c5dc85044 任何标准的 Unix signal 都可以通过该方法传入容器\nPausing and Unpausing Container 暂停容器使用了 cgroup freezer 实现，这样基本上是组织进程被调度，直到 unfreeze 此进程。 这将阻止容器进行任何操作，保持状态不变，包括内存内容。 不同于 stop 命令通过 SIGSOTP 信号停止容器，而暂停容器不会向容器发送任何关于其状态变化的信息，这是一个重要区别。\n命令 docker container pause 092c5dc85044 暂停容器，之后开使用 docker container unpause 092c5dc85044 继续运行容器。\nCleaning Up Containers and Images 当运行很多命令后，会在系统上积累大量的镜像层和容器层。\n可以使用命令 docker container ls -a 查看所有容器，在删除镜像之前，需要先暂停使用该镜像的所有容器才行。\n也可以列出系统上的所有镜像，使用命令 docker image ls，然后使用下面命令删除：\ndocker image rm 0256c63af7db 有时，尤其是再部署循环的时候，需要将整个系统的镜像或容器都从系统中剃除，最简单的就是使用下面的方法：\ndocker system prune 如果要将所有未使用的镜像都剃除，而不只是悬空镜像，使用 -a 参数：\ndocker system prune -a 如果要删除所有的容器或镜像，可以使用下面的组合命令\ndocker container rm $(docker container ls -a -q) docker image rm $(docker image -q) 上面两个命令都支持一个过滤参数，用于微调删除命令或特定情况\n例如移除所有非 0 状态的容器\ndocker contaienr rm $(docker container ls -a -q --filter 'exited!=0') 或者删除所有没标签的容器\ndocker image rm $(docker images -q -f \"dangling=true\") Windows Containers 自从 2016 年以来 Windows 已经支持运行含本地原生应用的 Windows 容器。 包含原生 Windows 应用的 Windows 容器可以使用特殊的 Docker 命令管理。 下面将演示 Windows 10+ 通过 Hyper-V 使用 Docker。\n第一件需要做的事情就是从 Linux 容器切换到 Windows 容器，选择“Switch to Windows Containers…”，这个过程会消耗一定的时间。 可以使用下面命令在 PowerShell 测试 Windows 容器：\ndocker container run --rm -it mrc.microsoft.com/powershell 要实现同样功能，可以编写下面的 Dockerfile\nFROM mcr.microsoft.com/powershell SHELL [\"pwsh\", \"-command\"] RUN Add-Content C:\\helloworld.ps1` 'Write-Host \"Hello World from Windows\"'` CMD [\"pwsh\", \"C:\\\\helloworld.ps1\"] 再次点击 “Switch to Linux Containers…” 切换回 Linux 容器。\n","wordCount":"1877","inLanguage":"en","image":"https://starslayerx.github.io/images/og-default.avif","datePublished":"2025-09-23T08:00:00+08:00","dateModified":"2025-09-23T08:00:00+08:00","author":{"@type":"Person","name":"Starslayerx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://starslayerx.github.io/posts/docker-containers/"},"publisher":{"@type":"Organization","name":"Starslayerx' Blog","logo":{"@type":"ImageObject","url":"https://starslayerx.github.io/favicon.svg"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Docker - Containers</h1><div class=post-meta><span title='2025-09-23 08:00:00 +0800 +0800'>September 23, 2025</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>1877 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#creating-a-container>Creating a Container</a><ul><li><a href=#basic-configuration>Basic Configuration</a><ul><li><a href=#conatiner-name>Conatiner name</a></li><li><a href=#labels>Labels</a></li><li><a href=#hostname>Hostname</a></li><li><a href=#domain-name-services>Domain Name Services</a></li><li><a href=#mac-address>MAC address</a></li><li><a href=#storage-volumes>Storage Volumes</a></li><li><a href=#resource-quotas>Resource Quotas</a></li></ul></li><li><a href=#starting-a-container>Starting a Container</a></li><li><a href=#auto-restarting-a-container>Auto-Restarting a Container</a></li><li><a href=#stoping-a-container>Stoping a Container</a></li><li><a href=#killing-a-container>Killing a Container</a></li><li><a href=#pausing-and-unpausing-container>Pausing and Unpausing Container</a></li><li><a href=#cleaning-up-containers-and-images>Cleaning Up Containers and Images</a></li><li><a href=#windows-containers>Windows Containers</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>像 VMware 或 KVM 这类虚拟化系统, 他们运行在虚拟化层上运行完整的 Linux 内核与操作系统.
这种架构能提供极强的隔离性, 因为每个虚拟机都搭载独立的内核, 这些内核各自运行在硬甲虚拟化层之上的隔离内存空间中.</p><p>而容器技术有着根本性差异, 所有容器共享同一个内核, 工作负载间的隔离性全通过内核机制实现, 这种模式被称为操作系统级虚拟化 <em>operating system virtualization</em>.</p><p><a href=https://github.com/opencontainers/runc/blob/main/libcontainer/README.md>runc/libcontainer</a> 提供了一个很好的定义:
A container is a self-contained execution environment that shares the kernel of the host system and is isolated from other containers in the system.</p><p>容器最大的优势就在于性能, 当运行一个进程的时候, 只有小部分的代码在内核中用于管理容器.
如今, 容器几乎在任何地方运行. Docker 和 OCI 镜像提供了生成环境中软件的打包格式, 并为 Kubernetes 和大多数 &ldquo;serverless&rdquo; 云技术打下了基础.</p><ul><li>所谓的 serverless 技术并不是真的没有服务器: 它们依赖其他人的服务器来完成工作, 这样应用开发者就无需关心管理硬甲和操作系统了.</li></ul><h2 id=creating-a-container>Creating a Container<a hidden class=anchor aria-hidden=true href=#creating-a-container>#</a></h2><p>创建容器的命令 <code>docker container run</code> 实际上是包装在一起的两条命令.
第一件事是从基本的镜像中创建一个容器, 可以通过 <code>docker container create</code> 命令实现.
第二件事是执行容器, 同样地, 可以通过 <code>docker container start</code> 命令实现.</p><p>之前的命令参数中, 端口参数 <code>-p/--publish argument</code> 和环境变量参数 <code>-e/--env</code> 都只能在创建容器的时候设置.</p><h3 id=basic-configuration>Basic Configuration<a hidden class=anchor aria-hidden=true href=#basic-configuration>#</a></h3><h4 id=conatiner-name>Conatiner name<a hidden class=anchor aria-hidden=true href=#conatiner-name>#</a></h4><p>当创建一个容器的时候, 默认情况下会使用 Dockerfile 设置的值, 但是可以在创建的时候通过命令行参数覆盖.
默认情况下, Docker 会使用名人名称的组合随机命名容器, 这就会出现类似 <em>ecstatic-babbage</em> 和 <em>serene-albattani</em> 这样的容器名.
如果要给容器一个具体的名字, 使用参数 <code>--name</code></p><pre tabindex=0><code>docker container create --name=&#34;awesome-service&#34; ubuntu:latest sleep 120
</code></pre><p>创建后就可以启动容器了</p><pre tabindex=0><code>docker container start awesome-service
</code></pre><p>它将会在 120 秒后自动退出, 但也可以通过命令提前关闭</p><pre tabindex=0><code>docker container stop awesome-service
</code></pre><blockquote><p>任何一个名称都只能给一个容器使用. 如果运行两次命令, 将会得到一个报错.
要么使用 <code>docker container rm</code> 删除之前的容器, 要么换一个名字.</p></blockquote><h4 id=labels>Labels<a hidden class=anchor aria-hidden=true href=#labels>#</a></h4><p>Labels 是可以作为 Docker 镜像和容器元数据的键值对.
当 Linux 容器创建后, 他们将自动继承父镜像的标签.</p><p>当然也可以为容器添加新的标签:</p><pre tabindex=0><code>docker container run --rm -d --name has-some-labels \
    -l deployer=Ahmed -l tester=Asako \
    ubuntu:latest sleep 1000
</code></pre><p>然后就可以基于 metadata 来搜索和过滤容器, 通过 <code>docker container ls</code> 命令实现:</p><pre tabindex=0><code>docker container ls -a -f label=deployer=Ahmed

CONTAINER ID  IMAGE         COMMAND       … NAMES
845731631ba4  ubuntu:latest &#34;sleep 1000&#34;  … has-some-labels
</code></pre><p>可以使用 <code>docker container inspect</code> 命令查看容器所有的 labels</p><pre tabindex=0><code>docker container inspect has-some-labels
...
&#34;Labels&#34;: {
    &#34;deployer&#34;: &#34;Ahmed&#34;,
    &#34;tester&#34;: &#34;Asako&#34;
}
...
</code></pre><p>这个容器运行了命令 sleep 1000, 这样 1000 秒后容器就会自动停止.</p><h4 id=hostname>Hostname<a hidden class=anchor aria-hidden=true href=#hostname>#</a></h4><p>默认情况下，当开启一个容器的时候，Docker 会将 host 宿主机上特定的系统文件复制到 host 上面的容器配置目录中，包括 <code>/etc/hostname</code>，并使用挂载将文件复制到容器中。可以下面这样启动一个没有额外配置的默认容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti ubuntu:latest /bin/bas<span class=err>
</span></span></span></code></pre></div><p>这条命令 <code>docker container run</code> 实际在背后运行了 <code>docker container create</code> 和 <code>docker container start</code> 两条命令。</p><ul><li><code>--rm</code> 参数告诉 Docker 当容器存在时将其删除</li><li><code>-t</code> 参数告诉 Docker 分配一个伪终端</li><li><code>-t</code> 参数告诉 Docker 这将是一次交互式的会话，以及我们想将 STDIN 开启</li></ul><p>如果镜像中没有定义 <code>ENTRYPOINT</code>，那么命令中的最后一个参数就是在容器中运行的可执行文件及其命令行参数，在本例中为 <code>/bin/bash</code>。
如果镜像中定义了 <code>ENTRYPOINT</code>，那么最后一个参数将作为命令行参数列表传递给 <code>ENTRYPOINT</code> 进程。</p><p>如果到容器内部运行 mount 命令，会看到下面这样的输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>root@4464f3966c8c:/# mount<span class=err>
</span></span></span><span class=line><span class=cl>overlay on / <span class=nb>type</span> overlay <span class=o>(</span>rw,relatime,lowerdir<span class=o>=</span>/var/lib/docker/overlay2/l/QGANRL2RXF5OAGF6BR3VJBYKV7:/var/lib/docker/overlay2/l/FTZKGGCRTA67I47MV56GWNKXTJ,upperdir<span class=o>=</span>/var/lib/docker/overlay2/9dc4a47989317b4297d540bb99e6d25b14b4db15eaa18e444f43877dfa6088f8/diff,workdir<span class=o>=</span>/var/lib/docker/overlay2/9dc4a47989317b4297d540bb99e6d25b14b4db15eaa18e444f43877dfa6088f8/work<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>proc on /proc <span class=nb>type</span> proc <span class=o>(</span>rw,nosuid,nodev,noexec,relatime<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>tmpfs on /dev <span class=nb>type</span> tmpfs <span class=o>(</span>rw,nosuid,size<span class=o>=</span>65536k,mode<span class=o>=</span>755<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>devpts on /dev/pts <span class=nb>type</span> devpts <span class=o>(</span>rw,nosuid,noexec,relatime,gid<span class=o>=</span>5,mode<span class=o>=</span>620,ptmxmode<span class=o>=</span>666<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>sysfs on /sys <span class=nb>type</span> sysfs <span class=o>(</span>ro,nosuid,nodev,noexec,relatime<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>cgroup on /sys/fs/cgroup <span class=nb>type</span> cgroup2 <span class=o>(</span>ro,nosuid,nodev,noexec,relatime<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>mqueue on /dev/mqueue <span class=nb>type</span> mqueue <span class=o>(</span>rw,nosuid,nodev,noexec,relatime<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>shm on /dev/shm <span class=nb>type</span> tmpfs <span class=o>(</span>rw,nosuid,nodev,noexec,relatime,size<span class=o>=</span>65536k<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>/dev/vda1 on /etc/resolv.conf <span class=nb>type</span> ext4 <span class=o>(</span>rw,relatime,discard<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>/dev/vda1 on /etc/hostname <span class=nb>type</span> ext4 <span class=o>(</span>rw,relatime,discard<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>/dev/vda1 on /etc/hosts <span class=nb>type</span> ext4 <span class=o>(</span>rw,relatime,discard<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>devpts on /dev/console <span class=nb>type</span> devpts <span class=o>(</span>rw,nosuid,noexec,relatime,gid<span class=o>=</span>5,mode<span class=o>=</span>620,ptmxmode<span class=o>=</span>666<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>proc on /proc/bus <span class=nb>type</span> proc <span class=o>(</span>ro,nosuid,nodev,noexec,relatime<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>proc on /proc/fs <span class=nb>type</span> proc <span class=o>(</span>ro,nosuid,nodev,noexec,relatime<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>proc on /proc/irq <span class=nb>type</span> proc <span class=o>(</span>ro,nosuid,nodev,noexec,relatime<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>proc on /proc/sys <span class=nb>type</span> proc <span class=o>(</span>ro,nosuid,nodev,noexec,relatime<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>proc on /proc/sysrq-trigger <span class=nb>type</span> proc <span class=o>(</span>ro,nosuid,nodev,noexec,relatime<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>tmpfs on /proc/interrupts <span class=nb>type</span> tmpfs <span class=o>(</span>rw,nosuid,size<span class=o>=</span>65536k,mode<span class=o>=</span>755<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>tmpfs on /proc/kcore <span class=nb>type</span> tmpfs <span class=o>(</span>rw,nosuid,size<span class=o>=</span>65536k,mode<span class=o>=</span>755<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>tmpfs on /proc/keys <span class=nb>type</span> tmpfs <span class=o>(</span>rw,nosuid,size<span class=o>=</span>65536k,mode<span class=o>=</span>755<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>tmpfs on /proc/timer_list <span class=nb>type</span> tmpfs <span class=o>(</span>rw,nosuid,size<span class=o>=</span>65536k,mode<span class=o>=</span>755<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>tmpfs on /proc/scsi <span class=nb>type</span> tmpfs <span class=o>(</span>ro,relatime<span class=o>)</span><span class=err>
</span></span></span><span class=line><span class=cl>tmpfs on /sys/firmware <span class=nb>type</span> tmpfs <span class=o>(</span>ro,relatime<span class=o>)</span><span class=err>
</span></span></span></code></pre></div><p>当看到 <code>root@hashID</code> 时，一般说明在容器内部运行</p><ul><li>默认 hostname 是容器 ID，但可以使用 <code>--name</code> 参数指定容器名称（用于管理，如 docker ps 看到的名称）</li><li>默认用户为 root，可以通过 <code>--user</code> 参数指定进入容器后的用户</li></ul><p>上面的绑定挂载中，我们感兴趣的是这一行：</p><pre tabindex=0><code>/dev/vda1 on /etc/hostname type ext4 (rw,relatime,discard)
</code></pre><p>前面的设备名称可能不同，但挂载点都是 <code>/etc/hostname</code>，这回将容器的 <code>/etc/hostname</code> 链接到 Docker 为容器准备的主机文件，该文件默认包含容器 ID，并没有完全限制域名。（容器的主机名不带域名后缀，例如为 <code>4464f3966c8c</code> 而不是 <code>4464f3966c8c.example.com</code>）</p><p>如果要设置具体的 hostname，可以使用 <code>--hostname</code> 参数传入一个具体的值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti --hostname<span class=o>=</span><span class=s2>&#34;mycnotainer.example.com&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl>    ubuntu:latest /bin/bash<span class=err>
</span></span></span></code></pre></div><h4 id=domain-name-services>Domain Name Services<a hidden class=anchor aria-hidden=true href=#domain-name-services>#</a></h4><p>如同 <code>/etc/hostname</code>，<code>resolv.conf</code> 文件设置的 Domain Name Service (DNS) 通过主机和容器的绑定挂载管理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>/dev/vda1 on /etc/resolv.conf <span class=nb>type</span> ext4 <span class=o>(</span>rw,relatime,discard<span class=o>)</span><span class=err>
</span></span></span></code></pre></div><p>默认情况下，会直接复制宿主机的 <code>resolv.conf</code> 文件，如果不想要默认配置，可以使用 <code>--dns</code> (nameserver) 和 <code>--dns-search</code> (search) 参数复写容器的行为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti --dns<span class=o>=</span>8.8.8.8 --dns<span class=o>=</span>8.8.4.4 <span class=se>\
</span></span></span><span class=line><span class=cl>    --dns-search<span class=o>=</span>exmaple.com --dns-search<span class=o>=</span>example2.com <span class=se>\
</span></span></span><span class=line><span class=cl>    ubuntu:latest /bin/bash<span class=err>
</span></span></span></code></pre></div><p>如果不想设置 search domain，使用 <code>--dns-search=.</code></p><p>容器中的文件为下面这样：</p><pre tabindex=0><code>root@97b634b9bb5b:/# more /etc/resolv.conf
# Generated by Docker Engine.
# This file can be edited; Docker Engine will not make further changes once it
# has been modified.

nameserver 8.8.8.8
nameserver 8.8.4.4
search exmaple.com example2.com

# Based on host file: &#39;/etc/resolv.conf&#39; (legacy)
# Overrides: [nameservers search]
</code></pre><h4 id=mac-address>MAC address<a hidden class=anchor aria-hidden=true href=#mac-address>#</a></h4><p>另一个可以设置的重要信息是容器的 media access control (MAC) 地址。</p><p>如果没有任何配置，容器会接受一个计算出的 MAC 地址，并以 <code>02:42:ac:11</code> 为前缀（以 02 开头的 MAC 表示“本地管理的（Locally Administered）”地址，不与全球 OUI 冲突）。
如果要设置这个值，使用类似下面方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti --mac-address<span class=o>=</span><span class=s2>&#34;a2:11:aa:22:bb:33&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl>    ubuntu:latest /bin/bash<span class=err>
</span></span></span></code></pre></div><blockquote><p>WARNING 警告</p></blockquote><p>自定义 MAC 地址的时候要小心，当两个系统使用同样 MAC 地址的时候，可能会引起 ARP contention（ARP 冲突）。
如果确实有自定义 MAC 地址的需求，建议使用 <code>x2-</code>, <code>x6-</code>, <code>xA-</code> 和 <code>xE-</code> 开头的地址。</p><h4 id=storage-volumes>Storage Volumes<a hidden class=anchor aria-hidden=true href=#storage-volumes>#</a></h4><p>有时使用容器默认分配的磁盘空间，或者容器是暂时的，这种并不适合手头的工作，因此需要在容器部署之间的持久化存储。</p><p>这时候，可以使用 <code>--mount/-v</code> 参数将 host 上的目录或单独的文件挂载到容器中。
下面的例子将 <code>/mnt/session_data</code> 挂载到容器的 <code>/data</code> 目录：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti <span class=se>\
</span></span></span><span class=line><span class=cl>    --mount <span class=nv>type</span><span class=o>=</span>bind, <span class=nv>target</span><span class=o>=</span>/mnt/session_data,source<span class=o>=</span>/data <span class=se>\
</span></span></span><span class=line><span class=cl>    ubuntu:latest /bin/bash<span class=err>
</span></span></span></code></pre></div><p>可以使用 <code>-v</code> 参数简化，使用冒号 <code>:</code> 将源文件与目标文件分开，还在末尾添加 <code>ro</code> 以只读方式挂载</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti <span class=se>\
</span></span></span><span class=line><span class=cl>    -v /mnt/session_data:/data:ro <span class=se>\
</span></span></span><span class=line><span class=cl>    ubuntu:latest /bin/bash<span class=err>
</span></span></span></code></pre></div><p>host 和容器中挂载的文件都无需预先存在，如果主机挂载点的文件不存在，会直接创建对应的目录文件，这可能会导致一些问题。</p><blockquote><p>SELINUX AND VOLUME MOUNTS</p></blockquote><p>SELINUX (Secuirty-Enhanced Linux) 是一个内置于 Linux 内核的强制访问控制器 (MAC) 安全系统。
其核心思想是“默认拒绝”。</p><ul><li>传统 Linux 使用自主访问控制 (DAC)，基于用户/组/权限 (rwx)。</li><li>SELinux 在此基础上，为每个进程、文件、目录等对象都打上了一个安全上下文标签。策略规则规定了 “哪个进程的标签” 可以访问 “哪个文件的标签”。</li></ul><p>如果在 Docker host 启动了 SELinux，挂载文件目录的时候，可能会遇到一个 &ldquo;Permission Denied&rdquo; 报错。
可以使用 Docker <code>z/Z</code> 选择来处理挂载问题：</p><ul><li>小写的 <code>z</code> 选项表示绑定挂载内容可多容器共享</li><li>大写的 <code>Z</code> 选项表示绑定挂载内容是私有且不共享的</li></ul><p>例如下面这样</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -v /app/dhcpd/etc:/etc/dhcpd:z dhcpd<span class=err>
</span></span></span></code></pre></div><p>还可以告诉 Docker 容器以只读方式运行，这样任何进程就无法修改根目录文件了（任何在 <code>/</code> 下尝试写入的操作都会失败，除非该路径被单独挂载为可写卷）。
在之前的例子中，可以使用 <code>--read-only=true</code> 命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti --read-only<span class=o>=</span><span class=nb>true</span> -v /mnt/session_data:/data <span class=se>\
</span></span></span><span class=line><span class=cl>    ubuntu:latest /bin/bash<span class=err>
</span></span></span></code></pre></div><p>有时，即使容器为可读的，也有必要使 <code>/tmp</code> 这样目录可写。
这种情况下，可以使用 <code>docker container run</code> 命令配置 <code>--mount type=tmpfs</code> 参数，已将 tmpfs 文件系统挂载到容器中。
tmpfs 文件系统完全在内存中，速度非常快，同时也是临时的，关闭容器就会释放。
下面示例展示启动一个容器，在 <code>/tmp</code> 处挂载一个 256 MB 的 tmpfs 文件系统：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti --read-only<span class=o>=</span><span class=nb>true</span> <span class=se>\
</span></span></span><span class=line><span class=cl>    --mount <span class=nv>type</span><span class=o>=</span>tmpfs,destination<span class=o>=</span>/tmp,tmpfs-size<span class=o>=</span>256M <span class=se>\
</span></span></span><span class=line><span class=cl>    ubuntu:latest /bin/bash<span class=err>
</span></span></span></code></pre></div><p>容器如下：</p><pre tabindex=0><code>root@a1b02391f02d:/# df -h /tmp
Filesystem      Size  Used Avail Use% Mounted on
tmpfs           256M     0  256M   0% /tmp

root@a1b02391f02d:/# grep /tmp /etc/mtab
tmpfs /tmp tmpfs rw,nosuid,nodev,noexec,relatime,size=262144k 0 0
</code></pre><blockquote><p>WARNING</p></blockquote><p>容器应该尽可能设计为无状态的，管理存储会有不必要的依赖，使得部署场景更加复杂。</p><h4 id=resource-quotas>Resource Quotas<a hidden class=anchor aria-hidden=true href=#resource-quotas>#</a></h4><p>虚拟机通常可以细致的控制 OS 的内容和 CPU 以及其他资源。</p><p>当使用 Docker 时，必须利用 linux 内核的 cgroup 功能来控制资源可用性。
Docker 容器的运行命令 <code>docker container run</code> 命令在创建容器时直接支持设置 CPU, 内存, swap 和 I/O 限制。</p><blockquote><p>NOTE</p></blockquote><p>这些限制通常在容器创建的时候设置，如果需要修改这些配置，使用 <code>docker container update</code> 命令或部署一个新的容器。</p><p>Docker 支持多种资源的限制，但是必须要在内核中开启相应的功能提供给 Docker。
可能需要通过命令行将这些功能开启，运行命令 <code>docker system info</code> 来查看内核相关限制支持。
如果缺失任何支持，将会有类似下面这样的输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>WARNING: No swap limit support<span class=err>
</span></span></span></code></pre></div><h5 id=cpu-shares>CPU shares<a hidden class=anchor aria-hidden=true href=#cpu-shares>#</a></h5><p>docker 有好几种限制 CPU 使用的容器应用。原始的最常用的方法是 cpu shares。</p><p>系统中所有 CPU 核心的计算能力被视为总份额池。Docker 分配数字 1024 代表完整的池。
通过设置容器的 CPU 共享，可以设置容器获取多少 CPU shares。
如果希望容器最多获取系统一半的 CPU shares，那么就要分配 512 的份额。
这并发独占份额，即使将 1024 份额分配给一个容器，也不会影响其他容器的运行。</p><p>更准确的说，它提示调度器容器运行的时间。
假如有一个容器分配了 1024 份额，另外两个分配 512 份额，他们都将被调度相同次数。
但是如果每个进程的正常 CPU 时间是 100 微秒，那么 512 份额的容器将运行 50 微秒，1024 份额的容器将运行 100 微秒。</p><p>下面使用 <code>stress</code> 命令在容器内进行压力测试，下面命令将创建 2 条 CPU 密集计算，1 条 I/O 密集计算和两个内存分配程序，并分配 6 个 CPU 核心。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti spkane/train-os <span class=se>\
</span></span></span><span class=line><span class=cl>    stress -v --cpu <span class=m>6</span> --io <span class=m>1</span> --vm <span class=m>2</span> --vm-bytes 128M --timeout 120s<span class=err>
</span></span></span></code></pre></div><p>如果想运行同样的压力测试，但只分配一般的 CPU 运行时间，可以这样做：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti --cpu-shares <span class=m>512</span> spkane/train-os <span class=se>\
</span></span></span><span class=line><span class=cl>    stress -v --cpu <span class=m>6</span> --io <span class=m>1</span> --vm <span class=m>2</span> --vm-bytes 128M --timeout 120s<span class=err>
</span></span></span></code></pre></div><p>与虚拟机不同，Docker基于cgroup对CPU份额的限制可能会产生意想不到的后果。
它不是硬性限制，而是相对限制，类似于nice命令。
例如，一个被限制为一半CPU份额的容器，如果运行在一个不怎么繁忙的系统上，由于CPU不繁忙，CPU份额的限制效果有限，因为调度器池中没有竞争。
当第二个大量使用CPU的容器部署到同一个系统时，突然间，第一个容器上的限制效果就会变得明显。
在限制容器和分配资源时，应仔细考虑这一点。</p><h5 id=cpu-pinning>CPU pinning<a hidden class=anchor aria-hidden=true href=#cpu-pinning>#</a></h5><p>可以将一个容器绑定到一个或多个 CPU 核心。
这意味着这个容器的工作只会调度到分配给他的核心上。
如果要隔离 CPU 或者提高缓存效率，这会很有用。</p><p>下面命令将容器绑定到前 2 个 CPU 上：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti <span class=se>\
</span></span></span><span class=line><span class=cl>    --cpu-shares <span class=m>512</span> --cpu-set<span class=o>=</span><span class=m>0</span> spkane/train-os <span class=se>\
</span></span></span><span class=line><span class=cl>    stress -v --cpu <span class=m>2</span> --io <span class=m>1</span> --vm <span class=m>2</span> --vm-bytes 128M --timeout 120s<span class=err>
</span></span></span></code></pre></div><blockquote><p>WARNING</p></blockquote><p><code>--cpu-set</code> 参数是从 0 开始的，因此第一个 CPU 是 0。
如果让 Docker 使用一个不存在的 CPU 核心，将会得到一个无法启动容器的报错。</p><p>在 Linux 内核中使用 CPU Completely Fair Scheduler (CFS)，可以使用 <code>--cpu-quota</code> 参数更改 CPU quota 来启动容器。</p><p>CFS 完全公平调度器：</p><ul><li>Linux 内核中的默认 CPU 调度器</li><li>目标是为所有进程提供“公平”的 CPU 时间</li><li>通过时间片轮转和优先级来分配 CPU 资源</li></ul><p>CPU quota:</p><ul><li>不同于 CPU shares 这是一个硬性限制</li><li>限制一个容器在一个时间周期内可以使用的 CPU 时间</li><li>即使系统空闲，也不能超过这个限制</li></ul><p>限制最多使用 50% CPU:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --cpu-period<span class=o>=</span><span class=m>100000</span> --cpu-quota<span class=o>=</span><span class=m>50000</span> image<span class=err>
</span></span></span></code></pre></div><p>cpu-period: 时间周期（默认 100000 微秒 = 100ms）</p><p>CPU 使用率 = (cpu-quota / cpu-period) × 100%</p><h5 id=simplifying-cpu-quotas>Simplifying CPU quotas<a hidden class=anchor aria-hidden=true href=#simplifying-cpu-quotas>#</a></h5><p>CPU shares 和 CPU quotas 是 Docker 中管理 CPU 限制的基本机制，但现在 Docker 已经发展了很多。
只需要简单地告诉 Docker 希望容器提供多少 CPU，它就会自动完成底层 cgroups 所需的计算。</p><p>参数 <code>--cpus</code> 可以设置一个 0.01 至 CPU 核心数的浮点数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti --cpus<span class=o>=</span><span class=s2>&#34;.25&#34;</span> spkane/train-os <span class=se>\
</span></span></span><span class=line><span class=cl>    stress -v --cpu <span class=m>2</span> --io <span class=m>1</span> --vm <span class=m>2</span> --vm-bytes 128M --timout 60s<span class=err>
</span></span></span></code></pre></div><p>如果要调整容器的资源限制，可以使用 <code>update</code> 命令，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container update --cpus<span class=o>=</span><span class=s2>&#34;1.5&#34;</span> 092c5dc8504 92b797f12af1<span class=err>
</span></span></span></code></pre></div><h5 id=memory>Memory<a hidden class=anchor aria-hidden=true href=#memory>#</a></h5><p>内存可以使用类似 CPU 限制的功能。但不同的是，内存是硬性限制，分配多少就只能用那么多，且会有一定的默认分配。
由于虚拟内存的存在，实际上可以为容器分配比系统内存更多的内存，容器将使用 swap 存储这些内容，就像 linux 中的进程一样。</p><p>下面使用 <code>--memory</code> 参数命令开启一个限制内存的命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker conatiner run --rm -ti --memory 512m spkane/train-os <span class=se>\
</span></span></span><span class=line><span class=cl>    stress -v --cpu <span class=m>2</span> --io <span class=m>1</span> --vm <span class=m>2</span> --vm-bytes 128M --timout 10s<span class=err>
</span></span></span></code></pre></div><p>当单独使用 <code>--memory</code> 参数时，会同时设置 RAM 和 swap 的大小，这里就设置了 512m 的 RAM 和 512m 的 swap 大小。
Docker 支持 b, k, m, g 单位。</p><p>如果要单独设置 swap 大小，或者关闭它，使用 <code>--memory-swap</code> 参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti --memory 512m --memory-swap<span class=o>=</span>768m <span class=se>\
</span></span></span><span class=line><span class=cl>    spkane/train-os stress -v --cpu <span class=m>2</span> --io <span class=m>1</span> --vm <span class=m>2</span> --vm-bytes 128M <span class=se>\
</span></span></span><span class=line><span class=cl>    --timeout 10s<span class=err>
</span></span></span></code></pre></div><p>如果将 <code>--memory-swap</code> 设置为 -1，那么容器将可以使用系统上任意大的 swap 空间。
如果将 <code>--memory-swap</code> 设置为和 <code>--memory</code> 相同的正数，则容器将无法使用任何 swap 空间。</p><p>当内存快满的时候，Docker 容器将会让 linux 内核认为系统内存快满了，它将会尝试杀死进程以释放内存。
例如下面命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -ti --memory 100m spkane/train-os <span class=se>\
</span></span></span><span class=line><span class=cl>    stress -v --cpu <span class=m>2</span> --io <span class=m>1</span> --vm <span class=m>2</span> --vm-bytes 128M --timeout 10s<span class=err>
</span></span></span></code></pre></div><p>会有类似下面的报错</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>stress: FAIL: <span class=o>[</span>1<span class=o>]</span> <span class=o>(</span>461<span class=o>)</span> failed run completed in 0s<span class=err>
</span></span></span></code></pre></div><p>这是因为容器尝试分配的内存大于运行的内存， Linux OOM (kernel out-of-memory) killer 被激活，并杀死子进程，父进程清理进程，并报错退出。</p><p>可以使用命令 <code>sudo dmesg</code> 查看相关信息，该 OOM 事件也会被 Docker 记录，可以使用 <code>docker system events</code> 监控</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker system events<span class=err>
</span></span></span></code></pre></div><p>该命令是一个阻塞命令，它会持续监听 Docker daemon 守护进程的事件，因此直接开启该命令看不到之前的报错信息。</p><h5 id=block-io>Block I/O<a hidden class=anchor aria-hidden=true href=#block-io>#</a></h5><p>很多容器实际上都是无状态容器，大多数都不需要 I/O 限制。
但 Docker 还是提供了基于 cgroup 机制的限制功能。</p><p>第一种方式是为容器的 block I/O 设备设置优先级。
可以通过设置默认的 <code>blkio.weight</code> cgroup 状态实现，该属性设置为 0 表示禁止，或者 10~1000 之间的一个数，默认为 500。
该限制类似 CPU shares，系统会将所有可用的 I/O 划分为 1000 份，并在 cgroup 切片中的每个进程之间进行分配，其中分配的权重会影响每个进程可用的 I/O 量。</p><p>通过参数 <code>--blkio-weight</code> 设置权重，也可以使用参数 <code>--blkio-weight-device</code> 指定特殊的设备。
和 CPU shares 一样，在实际操作中调整合适的权重比较困难，但是可以通过限制每秒最大的字节数/操作数来使管理变得更加容易。
例如下面参数：</p><ul><li><code>--devices-read-bps</code>: 限制设备读取速率 (bytes per second)</li><li><code>--devices-read-iops</code>: 限制设备读取速率 (IO per second)</li><li><code>--devices-write-bps</code>: 限制设备写速率 (bytes per second)</li><li><code>--devices-write-iops</code>: 限制设备写速率 (IO per second)</li></ul><p>可以使用 Linux I/O tester <a href=https://www.coker.com.au/bonnie>bonnie</a> 来测试对容器性能的影响：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl><span class=nb>time</span> docker container run --rm -ti spkane/train-os:latest <span class=se>\
</span></span></span><span class=line><span class=cl>    bonnie++ -u 500:500 -d /tmp -r <span class=m>1024</span> -s <span class=m>2048</span> -x <span class=m>1</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl>real 0m27.715s<span class=err>
</span></span></span><span class=line><span class=cl><span class=k>user</span><span class=w> </span><span class=s>0m0.027s</span><span class=err>
</span></span></span><span class=line><span class=cl>sys  0m0.030s<span class=err>
</span></span></span></code></pre></div><p>这个根据经验，更加推荐使用 <code>--device-read-iops</code> 和 <code>--dvice-write-iops</code> 参数来设置 block I/O 限制。</p><h5 id=ulimits>ulimits<a hidden class=anchor aria-hidden=true href=#ulimits>#</a></h5><p>在 Linux 引入 cgroups 之前，还有另一种方式可以限制进程可用的系统资源：
通过 <code>ulimit</code> 命令 设置用户级资源限制。
这种机制至今仍然可用，并且在许多传统使用场景下依然非常有用。</p><p>下面的示例展示了可以通过 <code>ulimit</code> 命令设置“软限制（soft limit）”和“硬限制（hard limit）”的系统资源类型：</p><pre tabindex=0><code class=language-bash$ data-lang=bash$>core file size (blocks, -c) 0
data seg size (kbytes, -d) unlimited
scheduling priority (-e) 0
file size (blocks, -f) unlimited
pending signals (-i) 5835
max locked memory (kbytes, -l) 64
max memory size (kbytes, -m) unlimited
open files (-n) 1024
pipe size (512 bytes, -p) 8
POSIX message queues (bytes, -q) 819200
real-time priority (-r) 0
stack size (kbytes, -s) 10240
cpu time (seconds, -t) unlimited
max user processes (-u) 1024
virtual memory (kbytes, -v) unlimited
file locks (-x) unlimited
</code></pre><p>可以在 Docker 守护进程（daemon） 的启动配置中设置默认的用户限制，使其应用到每一个容器上。
例如，下面的命令告诉 Docker 守护进程：启动所有容器时，将打开文件数的软限制设为 50，硬限制设为 150：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>sudo dockerd --default-ulimit <span class=nv>nofile</span><span class=o>=</span>50:150<span class=err>
</span></span></span></code></pre></div><p>然后，可以在启动特定容器时使用 <code>--ulimit</code> 参数覆盖这些默认值，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -d --ulimit <span class=nv>nofile</span><span class=o>=</span>150:300 nginx<span class=err>
</span></span></span></code></pre></div><p>此外，还有一些更高级的命令可用于创建容器时设置限制，但上述内容涵盖了多数常见场景。
Docker 客户端文档中列出了所有可用选项，并会随着每次 Docker 发布而更新。</p><h3 id=starting-a-container>Starting a Container<a hidden class=anchor aria-hidden=true href=#starting-a-container>#</a></h3><p>创建容器后，并不会默认运行，这是一个设置的过程，而不是运行过程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>$ docker container create -p 6379:6379 redis:2.8<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl>Unable to find image <span class=s1>&#39;redis:2.8&#39;</span> locally<span class=err>
</span></span></span><span class=line><span class=cl>2.8: Pulling from library/redis<span class=err>
</span></span></span><span class=line><span class=cl>51f5c6a04d83: Pull complete<span class=err>
</span></span></span><span class=line><span class=cl>6c8ccd839b1d: Pull complete<span class=err>
</span></span></span><span class=line><span class=cl>0fded1c9651d: Pull complete<span class=err>
</span></span></span><span class=line><span class=cl>7f1aa6a73799: Pull complete<span class=err>
</span></span></span><span class=line><span class=cl>fbe8a4f1aa87: Pull complete<span class=err>
</span></span></span><span class=line><span class=cl>1a9852d2edd3: Pull complete<span class=err>
</span></span></span><span class=line><span class=cl>128182e1e85d: Pull complete<span class=err>
</span></span></span><span class=line><span class=cl>b94de088b6d8: Pull complete<span class=err>
</span></span></span><span class=line><span class=cl>Digest: sha256:e507029ca6a11b85f8628ff16d7ff73ae54582f16fd757e64431f5ca6d27a13c<span class=err>
</span></span></span><span class=line><span class=cl>Status: Downloaded newer image <span class=k>for</span> redis:2.8<span class=err>
</span></span></span><span class=line><span class=cl>d14e339f67f70c21783e242ce706b705e5355facf0a5d97a797a9f3bbc701ff7<span class=err>
</span></span></span></code></pre></div><p>上面最后一行就是容器的哈希，可以使用该哈希来启动容器，如果没有记录下来该哈希，可以使用下面命令查看容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>$ docker container ls -a --filter <span class=nv>ancestor</span><span class=o>=</span>redis:2.8<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl>CONTAINER ID   IMAGE       COMMAND                  CREATED         STATUS    PORTS     NAMES<span class=err>
</span></span></span><span class=line><span class=cl>d14e339f67f7   redis:2.8   <span class=s2>&#34;docker-entrypoint.s…&#34;</span>   <span class=m>3</span> minutes ago   Created             pensive_cori<span class=err>
</span></span></span></code></pre></div><p>可以使用下面命令来启动容器</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container start d14e339f67f7<span class=err>
</span></span></span></code></pre></div><blockquote><p>NOTE</p></blockquote><p>这里的哈希可以是完整的，也可以是部分的，甚至无论长度只要满足唯一性即可。</p><p>现在容器应该正常运行了，但运行在后台无法知道是否报错：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container ls<span class=err>
</span></span></span></code></pre></div><h3 id=auto-restarting-a-container>Auto-Restarting a Container<a hidden class=anchor aria-hidden=true href=#auto-restarting-a-container>#</a></h3><p>在许多情况下，我们希望容器在退出后自动重启。
许多容器存活时间很短，但对于生产环境，可能希望他们能够始终保持运行。
如果要运行一个复杂系统，可以使用 scheduler。</p><p>最简单是情况下，使用 <code>--restart</code> 参数告诉 docker 容器重新运行命令，该参数有 4 类可选值：</p><ul><li><code>no</code>: 永不重启</li><li><code>always</code>: 总是重启</li><li><code>no-failure</code>: 当以非 0 退出码的时候重启，如果设置成 <code>no-failure:3</code> 则会在尝试重启 3 次失败后放弃重启</li><li><code>unless-stopped</code>: 总是重启，除非有意停止，例如 <code>docker container stop</code></li></ul><p>可以重新运行之前的内存受限的例子来展示，这里使用 <code>--restart</code> 参数而不是 <code>--rm</code> 参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run -ti --restart<span class=o>=</span>on-failure:3 --memory 100m spkane/train-os <span class=se>\
</span></span></span><span class=line><span class=cl>    stress -v --cpu <span class=m>2</span> --io <span class=m>1</span> --vm <span class=m>2</span> --vm-bytes 128M --timeout 120s<span class=err>
</span></span></span></code></pre></div><h3 id=stoping-a-container>Stoping a Container<a hidden class=anchor aria-hidden=true href=#stoping-a-container>#</a></h3><p>容器可以停止与启动，你可能认为容器的暂停和启动是类似的，但实际上两者并不相同。
当进程停止的时候，并不是暂停了，而是退出了。
而容器停止 stop 的时候，它不再在 <code>docker container ls</code> 输出中显示，一但重启 docker 就会尝试启动所有关机时关闭的容器。
即容器进程退出，但会保留容器状态，重启的使用再运行。
如果只是想暂停容器，而不停止任何进程，应该使用 pause 命令，<code>docker container pause</code> 和 <code>docker container unpause</code>。</p><p>如果要查看已经停止的容器，使用 <code>docker container ls -a</code> 命令查看。
这意味着，虽然内存和临时文件 temporary file system (tmpfs) 会暂时丢失，但所有其他的文件内容和元数据，包括环境变量和端口信息都会在容器重启的时候恢复。</p><p>容器与服务器上任何其他进程以基本相同的方式与系统交互，这意味着我们可以向容器中的进程发送 Unix 信号，而它们可以做出响应。
在之前的 <code>docker container stop</code> 示例中，向容器发送了 SIGTERM 信号，并等待容器优雅地退出。
容器遵循与Linux上任何其他进程组接收到的相同的过程组信号传播。</p><p>一个正常的 <code>docker container stop</code> 会向进程发送 SIGTERM 信号。
如果希望容器在经过一定时间后仍未停止时被强制杀死，可以使用 -t 参数，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container stop -t <span class=m>25</span> d14e339f67f7<span class=err>
</span></span></span></code></pre></div><p>这样在 25 秒后，如果容器仍未关闭，则会发送一个 SIGKILL 信号将其强制关闭。</p><h3 id=killing-a-container>Killing a Container<a hidden class=anchor aria-hidden=true href=#killing-a-container>#</a></h3><p>当一个进程不正常的时候，<code>docker container stop</code> 可能无法解决问题。
如果希望容器立刻退出，可以使用 <code>docker container kill</code>，类似 linux kill 命令，该命令也可以发送信号</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container <span class=nb>kill</span> --signal<span class=o>=</span>USR1 092c5dc85044<span class=err>
</span></span></span></code></pre></div><p>任何标准的 Unix signal 都可以通过该方法传入容器</p><h3 id=pausing-and-unpausing-container>Pausing and Unpausing Container<a hidden class=anchor aria-hidden=true href=#pausing-and-unpausing-container>#</a></h3><p>暂停容器使用了 <a href=https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.txt>cgroup freezer</a> 实现，这样基本上是组织进程被调度，直到 unfreeze 此进程。
这将阻止容器进行任何操作，保持状态不变，包括内存内容。
不同于 stop 命令通过 SIGSOTP 信号停止容器，而暂停容器不会向容器发送任何关于其状态变化的信息，这是一个重要区别。</p><p>命令 <code>docker container pause 092c5dc85044</code> 暂停容器，之后开使用 <code>docker container unpause 092c5dc85044</code> 继续运行容器。</p><h3 id=cleaning-up-containers-and-images>Cleaning Up Containers and Images<a hidden class=anchor aria-hidden=true href=#cleaning-up-containers-and-images>#</a></h3><p>当运行很多命令后，会在系统上积累大量的镜像层和容器层。</p><p>可以使用命令 <code>docker container ls -a</code> 查看所有容器，在删除镜像之前，需要先暂停使用该镜像的所有容器才行。</p><p>也可以列出系统上的所有镜像，使用命令 <code>docker image ls</code>，然后使用下面命令删除：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker image rm 0256c63af7db<span class=err>
</span></span></span></code></pre></div><p>有时，尤其是再部署循环的时候，需要将整个系统的镜像或容器都从系统中剃除，最简单的就是使用下面的方法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker system prune<span class=err>
</span></span></span></code></pre></div><p>如果要将所有未使用的镜像都剃除，而不只是悬空镜像，使用 <code>-a</code> 参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker system prune -a<span class=err>
</span></span></span></code></pre></div><p>如果要删除所有的容器或镜像，可以使用下面的组合命令</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container rm <span class=k>$(</span>docker container ls -a -q<span class=k>)</span><span class=err>
</span></span></span><span class=line><span class=cl>docker image rm <span class=k>$(</span>docker image -q<span class=k>)</span><span class=err>
</span></span></span></code></pre></div><p>上面两个命令都支持一个过滤参数，用于微调删除命令或特定情况</p><p>例如移除所有非 0 状态的容器</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker contaienr rm <span class=k>$(</span>docker container ls -a -q --filter <span class=s1>&#39;exited!=0&#39;</span><span class=k>)</span><span class=err>
</span></span></span></code></pre></div><p>或者删除所有没标签的容器</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker image rm <span class=k>$(</span>docker images -q -f <span class=s2>&#34;dangling=true&#34;</span><span class=k>)</span><span class=err>
</span></span></span></code></pre></div><h3 id=windows-containers>Windows Containers<a hidden class=anchor aria-hidden=true href=#windows-containers>#</a></h3><p>自从 2016 年以来 Windows 已经支持运行含本地原生应用的 Windows 容器。
包含原生 Windows 应用的 Windows 容器可以使用特殊的 Docker 命令管理。
下面将演示 Windows 10+ 通过 Hyper-V 使用 Docker。</p><p>第一件需要做的事情就是从 Linux 容器切换到 Windows 容器，选择“Switch to Windows Containers&mldr;”，这个过程会消耗一定的时间。
可以使用下面命令在 PowerShell 测试 Windows 容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Docker data-lang=Docker><span class=line><span class=cl>docker container run --rm -it mrc.microsoft.com/powershell<span class=err>
</span></span></span></code></pre></div><p>要实现同样功能，可以编写下面的 Dockerfile</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=s>mcr.microsoft.com/powershell</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=k>SHELL</span> <span class=p>[</span><span class=s2>&#34;pwsh&#34;</span><span class=p>,</span> <span class=s2>&#34;-command&#34;</span><span class=p>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=k>RUN</span> Add-Content C:<span class=se>\h</span>elloworld.ps1<span class=sb>`</span><span class=err>
</span></span></span><span class=line><span class=cl>    <span class=s1>&#39;Write-Host &#34;Hello World from Windows&#34;&#39;</span><span class=sb>`</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;pwsh&#34;</span><span class=p>,</span> <span class=s2>&#34;C:\\helloworld.ps1&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>再次点击 &ldquo;Switch to Linux Containers&mldr;&rdquo; 切换回 Linux 容器。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://starslayerx.github.io/tags/docker/>Docker</a></li></ul><nav class=paginav><a class=prev href=https://starslayerx.github.io/posts/python-standrad-library-file-and-directory-access-pathlib/><span class=title>« Prev</span><br><span>Python Standrad Library - File and Directory Access - pathlib</span>
</a><a class=next href=https://starslayerx.github.io/posts/uv-python-package-manager/><span class=title>Next »</span><br><span>uv - Python package manager</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker - Containers on x" href="https://x.com/intent/tweet/?text=Docker%20-%20Containers&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocker-containers%2f&amp;hashtags=Docker"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker - Containers on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocker-containers%2f&amp;title=Docker%20-%20Containers&amp;summary=Docker%20-%20Containers&amp;source=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocker-containers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker - Containers on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocker-containers%2f&title=Docker%20-%20Containers"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker - Containers on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocker-containers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker - Containers on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20-%20Containers%20-%20https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocker-containers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker - Containers on telegram" href="https://telegram.me/share/url?text=Docker%20-%20Containers&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocker-containers%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker - Containers on ycombinator" href="https://news.ycombinator.com/submitlink?t=Docker%20-%20Containers&u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fdocker-containers%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>