<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python Tricks Part 8: Modules and Packages | Starslayerx' Blog</title><meta name=keywords content="Python"><meta name=description content="Python 程序由 modules 和 packages 组成，使用 import 语句导入。
Modules and the import Statement
任何 Python 源文件都可以作为一个模块导入，例如下面 module.py 代码：
a = 37

def func():
    print(f'func says that a is {a}')

class SomeClass:
    def method(self):
        print('method says hi')

print('loaded module')
改文件包含一些常见的编程元素，包括一个全局变量、一个函数、一个类定义 和 最后的语句。
通过下面方法导入：
import module

module.a
module.func()
s = module.SomeClass()
s.method()
执行 import 会发送下面这几件事：

加载模块源码，如果找不到抛出 ImportError
创建新模块对象。该对象作为模块内所有全局定义 global defintions 的容器，被称为 “命名空间” namespace
该模块源码在新创建的模块命名空间内执行
如果没有错误发生，调用者会创建一个名称，指向新的模块对象。该名称与模块名称一致，但不包含任何文件后缀。

这些步骤中，第一步是最复杂的。新手容易犯的错误就是使用错误的名称或将代码放到了未知的位置。
且模块文件必须放在 sys.path 所包含的文件路径中，且文件名称要遵循和 python 变量一样的规则。
剩下的步骤都隔离在一个模块中，因此不用担心不同模块间命名冲突的问题。
Python import 会执行所有导入的源码，因此导入上面模块会输出 loaded module。"><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/posts/python-tricks-part-8-modules-and-packages/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://starslayerx.github.io/posts/python-tricks-part-8-modules-and-packages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/posts/python-tricks-part-8-modules-and-packages/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Python Tricks Part 8: Modules and Packages"><meta property="og:description" content="Python 程序由 modules 和 packages 组成，使用 import 语句导入。
Modules and the import Statement 任何 Python 源文件都可以作为一个模块导入，例如下面 module.py 代码：
a = 37 def func(): print(f'func says that a is {a}') class SomeClass: def method(self): print('method says hi') print('loaded module') 改文件包含一些常见的编程元素，包括一个全局变量、一个函数、一个类定义 和 最后的语句。 通过下面方法导入：
import module module.a module.func() s = module.SomeClass() s.method() 执行 import 会发送下面这几件事：
加载模块源码，如果找不到抛出 ImportError 创建新模块对象。该对象作为模块内所有全局定义 global defintions 的容器，被称为 “命名空间” namespace 该模块源码在新创建的模块命名空间内执行 如果没有错误发生，调用者会创建一个名称，指向新的模块对象。该名称与模块名称一致，但不包含任何文件后缀。 这些步骤中，第一步是最复杂的。新手容易犯的错误就是使用错误的名称或将代码放到了未知的位置。 且模块文件必须放在 sys.path 所包含的文件路径中，且文件名称要遵循和 python 变量一样的规则。
剩下的步骤都隔离在一个模块中，因此不用担心不同模块间命名冲突的问题。 Python import 会执行所有导入的源码，因此导入上面模块会输出 loaded module。"><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-13T08:00:00+08:00"><meta property="article:modified_time" content="2026-01-13T08:00:00+08:00"><meta property="article:tag" content="Python"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Python Tricks Part 8: Modules and Packages"><meta name=twitter:description content="Python 程序由 modules 和 packages 组成，使用 import 语句导入。
Modules and the import Statement
任何 Python 源文件都可以作为一个模块导入，例如下面 module.py 代码：
a = 37

def func():
    print(f'func says that a is {a}')

class SomeClass:
    def method(self):
        print('method says hi')

print('loaded module')
改文件包含一些常见的编程元素，包括一个全局变量、一个函数、一个类定义 和 最后的语句。
通过下面方法导入：
import module

module.a
module.func()
s = module.SomeClass()
s.method()
执行 import 会发送下面这几件事：

加载模块源码，如果找不到抛出 ImportError
创建新模块对象。该对象作为模块内所有全局定义 global defintions 的容器，被称为 “命名空间” namespace
该模块源码在新创建的模块命名空间内执行
如果没有错误发生，调用者会创建一个名称，指向新的模块对象。该名称与模块名称一致，但不包含任何文件后缀。

这些步骤中，第一步是最复杂的。新手容易犯的错误就是使用错误的名称或将代码放到了未知的位置。
且模块文件必须放在 sys.path 所包含的文件路径中，且文件名称要遵循和 python 变量一样的规则。
剩下的步骤都隔离在一个模块中，因此不用担心不同模块间命名冲突的问题。
Python import 会执行所有导入的源码，因此导入上面模块会输出 loaded module。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://starslayerx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python Tricks Part 8: Modules and Packages","item":"https://starslayerx.github.io/posts/python-tricks-part-8-modules-and-packages/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python Tricks Part 8: Modules and Packages","name":"Python Tricks Part 8: Modules and Packages","description":"Python 程序由 modules 和 packages 组成，使用 import 语句导入。\nModules and the import Statement 任何 Python 源文件都可以作为一个模块导入，例如下面 module.py 代码：\na = 37 def func(): print(f\u0026#39;func says that a is {a}\u0026#39;) class SomeClass: def method(self): print(\u0026#39;method says hi\u0026#39;) print(\u0026#39;loaded module\u0026#39;) 改文件包含一些常见的编程元素，包括一个全局变量、一个函数、一个类定义 和 最后的语句。 通过下面方法导入：\nimport module module.a module.func() s = module.SomeClass() s.method() 执行 import 会发送下面这几件事：\n加载模块源码，如果找不到抛出 ImportError 创建新模块对象。该对象作为模块内所有全局定义 global defintions 的容器，被称为 “命名空间” namespace 该模块源码在新创建的模块命名空间内执行 如果没有错误发生，调用者会创建一个名称，指向新的模块对象。该名称与模块名称一致，但不包含任何文件后缀。 这些步骤中，第一步是最复杂的。新手容易犯的错误就是使用错误的名称或将代码放到了未知的位置。 且模块文件必须放在 sys.path 所包含的文件路径中，且文件名称要遵循和 python 变量一样的规则。\n剩下的步骤都隔离在一个模块中，因此不用担心不同模块间命名冲突的问题。 Python import 会执行所有导入的源码，因此导入上面模块会输出 loaded module。\n","keywords":["Python"],"articleBody":"Python 程序由 modules 和 packages 组成，使用 import 语句导入。\nModules and the import Statement 任何 Python 源文件都可以作为一个模块导入，例如下面 module.py 代码：\na = 37 def func(): print(f'func says that a is {a}') class SomeClass: def method(self): print('method says hi') print('loaded module') 改文件包含一些常见的编程元素，包括一个全局变量、一个函数、一个类定义 和 最后的语句。 通过下面方法导入：\nimport module module.a module.func() s = module.SomeClass() s.method() 执行 import 会发送下面这几件事：\n加载模块源码，如果找不到抛出 ImportError 创建新模块对象。该对象作为模块内所有全局定义 global defintions 的容器，被称为 “命名空间” namespace 该模块源码在新创建的模块命名空间内执行 如果没有错误发生，调用者会创建一个名称，指向新的模块对象。该名称与模块名称一致，但不包含任何文件后缀。 这些步骤中，第一步是最复杂的。新手容易犯的错误就是使用错误的名称或将代码放到了未知的位置。 且模块文件必须放在 sys.path 所包含的文件路径中，且文件名称要遵循和 python 变量一样的规则。\n剩下的步骤都隔离在一个模块中，因此不用担心不同模块间命名冲突的问题。 Python import 会执行所有导入的源码，因此导入上面模块会输出 loaded module。\n如果要在单个 import 中导入多个模块，使用逗号将其分隔，例如：\nimport socket, os, re 有时候一个模块会使用 as 改变名称：\nimport module as mo mo.func() 模块是一等公民，这意味着他们可以被复制给变量、填充数据结构和作为程序数据传递。\nModule Caching 模块的源码只会导入一次，无论使用多少次 import 语句。 一个新手常犯的错误就是，在交互式环境中，先导入了某个模块。 然后该模块更新了，然后重新 import 该模块，但该模块并不会更新。\n可以在 sys.modules 里面找到缓存的模块，为一个字典，键为模块名称，值为模块对象。 如果将对应模块删除，则下一次 import 可以重新导入该模块。\n有时导入语句会在一个模块内，例如：\ndef f(x): import math return math.sin(x) + math.cos(x) 看上去好像这样会导致速度很慢，即每次函数调用都会重新导入一次。 但实际上成本是很低的，只承担一次查询字典的开销。 这样写法主要是风格上的问题，一般倾向于将所有导入放到开头。 另一方面，如果你有一个特殊的很少使用的函数，将导入写在函数内部，可以加快程序导入速度。\nImporting Selected Names from a Module from module import name 该语法将模块特定定义导入当前命名空间。 这和直接 import 不同的地方在于，不是创建一个新的命名空间，而是将该对象引用放入当前命名空间。\nfrom module import func # Imports module and puts func in current namespace func() # Calls module.func() module.func() # Fails. NameError: module 该 from 语句接受逗号分隔的名称列表，来导入多个定义。\nfrom module import func, SomeClass 从语义上来说，from module import name 语句将名称从模块复制到本地命名空间。 Python 会在背后首先执行 import module，然后使用缓存进行赋值 name = sys.modules['module'].name。\n一个常见的误解是人为使用 from 形式的导入更加高效，即只加载模块的一部分。 实际上并非如此，每当一个模块加载时，整个模块都会被加载并存储在缓存中。\n使用 from 形式的 import 不会改变作用域。 当函数寻找变量的时候，它仍然会在定义中的文件中寻找，而不是导入或调用的函数中寻找。\nfrom module import func a = 42 func() # func says that a is 37 func.__module__ # 'module' func.__globals__['a'] # 37 使用星号 asterisk (*) 可以导入所有非下划线开始的定义：\n# Load all definitions into the current namespace from module import * 这种语法不能写在函数内部，否则会报错 SyntaxError。 因为这样会破坏 Python 编译器对局部变量 Local Variables 的优化机制。\n模块可以通过定义 __all__ 列表来精确控制通过 from module import * 导入的集和。\n# module.py __all__ = [ 'func', 'SomeClass' ] a = 37 # Not exported def func(): # Exported ... class SomeClass: # Exported ... 在实践中，使用 from module import * 是不被推荐的。 过度使用会导致混淆，并污染局部命名空间。\nfrom math import * from random import * from statistics import * a = gauss(1.0, 0.25) # From which module ??? 显示导入要好得多\nfrom math import sin, cos, sqrt from random import gauss from statistics import mean a = gauss(1.0, 0.25) Circular Imports 如果两个模块相互导入对方会产生特别的问题。 例如假设你有两个文件：\n# moda.py import modb def func_a(): modb.func_b() class Base: pass # modb.py import moda def func_b(): print('B') class Child(moda.Base): pass 这段对面存在一种奇怪的导入顺序问题。 具体是，使用 import modb 能正常工作，但如果使用 import moda 就会崩溃，并说 moda.Base 没有定义。\n根据控制流，错误原因如下：\n执行 modb.py 文件，Python 首先创建一个 __name__ = __main__ 的模块 第一行为 import moda，会加载模块 moda.py 由于 moda.py 第一行为 import modb，这会导致又去加载 modb 由于模块缓存 sys.module 中没有 modb （而是 __main__），因此又会回到 modb.py 作为导入模块执行 这时候，modb.py 的第一行的导入存在模块缓存内，因此不会循环导入 当执行到 Child 的时候，由于缓存中创建的 moda 并没有加载完全，moda.Base 还未定义，从而导致报错 要修复这个问题，可以将 import modb 语句放到其他地方。 例如将其移动到 func_a() 函数内部：\n# moda.py def func_a(): import modb modb.func_b() class Base: pass 或者也可以将导入写在文件末尾\n# moda.py def func_a(): modb.func_b() class Base: pass import modb # Must after Base is defined 但这两者写法在代码审查中都可能被质疑。 大多数情况下，不会看到导入语句出现在文件末尾。 更好的处理方式一般是将 Child 类定义搬到单独的 base.py 文件中去。\n# modb.py import base def func_b(): print('B') class Child(base.Base): pass Module Roloading and Unloading 目前没有可靠的机制来支持对先前导入的 modules（模块）进行 reloading（重新加载）或 unloading（卸载）。 即使可以通过删除 sys.modules 导入的模块，但这些内容仍然会保存在内存中。 这样因为其他导入的模块会缓存模块变量。 此外，如果模块中定义了类的实例，这些实例会包含指向其类对象的引用，而类对象又持有定义模块的引用。\n模块引用存在于多个位置，这使得修改其实现后重新加载模块通常不切实际。 例如，如果从 sys.modules 里面删除模块，并通过 import 重新导入它， 但这并不会追溯性地改变程序中之前对该模块的所有引用。 相反，将会拥有最近 import 语句导入的一个新模块，和之前旧 import 代码保留的旧模块。\n在 importlib 库中有一个 reload() 函数来重新导入模块。 将之前的模块作为参数导入该模块：\nimport module import importlib importlib.reload(module) # loaded module ","wordCount":"1370","inLanguage":"en","image":"https://starslayerx.github.io/images/og-default.avif","datePublished":"2026-01-13T08:00:00+08:00","dateModified":"2026-01-13T08:00:00+08:00","author":{"@type":"Person","name":"Starslayerx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://starslayerx.github.io/posts/python-tricks-part-8-modules-and-packages/"},"publisher":{"@type":"Organization","name":"Starslayerx' Blog","logo":{"@type":"ImageObject","url":"https://starslayerx.github.io/favicon.svg"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Python Tricks Part 8: Modules and Packages</h1><div class=post-meta><span title='2026-01-13 08:00:00 +0800 +0800'>January 13, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1370 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#modules-and-the-import-statement>Modules and the import Statement</a></li><li><a href=#module-caching>Module Caching</a></li><li><a href=#importing-selected-names-from-a-module>Importing Selected Names from a Module</a></li><li><a href=#circular-imports>Circular Imports</a></li><li><a href=#module-roloading-and-unloading>Module Roloading and Unloading</a></li><li><a href=#module-compliation>Module Compliation</a></li><li><a href=#the-module-search-path>The Module Search Path</a></li><li><a href=#execution-as-the-main-program>Execution as the Main Program</a></li><li><a href=#packages>Packages</a></li><li><a href=#running-a-package-submodule-as-a-script>Running a Package submodule as a script</a></li><li><a href=#controlling-the-package-namespace>Controlling the Package Namespace</a></li><li><a href=#controlling-package-exports>Controlling Package Exports</a></li><li><a href=#package-data>Package data</a></li><li><a href=#module-objects>Module Objects</a></li><li><a href=#deploying-python-packages>Deploying Python Packages</a></li></ul></nav></div></details></div><div class=post-content><p>Python 程序由 modules 和 packages 组成，使用 <code>import</code> 语句导入。</p><h2 id=modules-and-the-import-statement>Modules and the import Statement<a hidden class=anchor aria-hidden=true href=#modules-and-the-import-statement>#</a></h2><p>任何 Python 源文件都可以作为一个模块导入，例如下面 <code>module.py</code> 代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>37</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;func says that a is </span><span class=si>{</span><span class=n>a</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SomeClass</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>method</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;method says hi&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;loaded module&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>改文件包含一些常见的编程元素，包括一个全局变量、一个函数、一个类定义 和 最后的语句。
通过下面方法导入：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>module</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>module</span><span class=o>.</span><span class=n>a</span>
</span></span><span class=line><span class=cl><span class=n>module</span><span class=o>.</span><span class=n>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>module</span><span class=o>.</span><span class=n>SomeClass</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=o>.</span><span class=n>method</span><span class=p>()</span>
</span></span></code></pre></div><p>执行 import 会发送下面这几件事：</p><ol><li>加载模块源码，如果找不到抛出 <code>ImportError</code></li><li>创建新模块对象。该对象作为模块内所有全局定义 global defintions 的容器，被称为 “命名空间” namespace</li><li>该模块源码在新创建的模块命名空间内执行</li><li>如果没有错误发生，调用者会创建一个名称，指向新的模块对象。该名称与模块名称一致，但不包含任何文件后缀。</li></ol><p>这些步骤中，第一步是最复杂的。新手容易犯的错误就是使用错误的名称或将代码放到了未知的位置。
且模块文件必须放在 <code>sys.path</code> 所包含的文件路径中，且文件名称要遵循和 python 变量一样的规则。</p><p>剩下的步骤都隔离在一个模块中，因此不用担心不同模块间命名冲突的问题。
Python <code>import</code> 会执行所有导入的源码，因此导入上面模块会输出 <code>loaded module</code>。</p><p>如果要在单个 <code>import</code> 中导入多个模块，使用逗号将其分隔，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>socket</span><span class=o>,</span> <span class=nn>os</span><span class=o>,</span> <span class=nn>re</span>
</span></span></code></pre></div><p>有时候一个模块会使用 <code>as</code> 改变名称：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>module</span> <span class=k>as</span> <span class=nn>mo</span>
</span></span><span class=line><span class=cl><span class=n>mo</span><span class=o>.</span><span class=n>func</span><span class=p>()</span>
</span></span></code></pre></div><p>模块是一等公民，这意味着他们可以被复制给变量、填充数据结构和作为程序数据传递。</p><h2 id=module-caching>Module Caching<a hidden class=anchor aria-hidden=true href=#module-caching>#</a></h2><p>模块的源码只会导入一次，无论使用多少次 <code>import</code> 语句。
一个新手常犯的错误就是，在交互式环境中，先导入了某个模块。
然后该模块更新了，然后重新 import 该模块，但该模块并不会更新。</p><p>可以在 <code>sys.modules</code> 里面找到缓存的模块，为一个字典，键为模块名称，值为模块对象。
如果将对应模块删除，则下一次 import 可以重新导入该模块。</p><p>有时导入语句会在一个模块内，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nn>math</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>math</span><span class=o>.</span><span class=n>sin</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>+</span> <span class=n>math</span><span class=o>.</span><span class=n>cos</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span></code></pre></div><p>看上去好像这样会导致速度很慢，即每次函数调用都会重新导入一次。
但实际上成本是很低的，只承担一次查询字典的开销。
这样写法主要是风格上的问题，一般倾向于将所有导入放到开头。
另一方面，如果你有一个特殊的很少使用的函数，将导入写在函数内部，可以加快程序导入速度。</p><h2 id=importing-selected-names-from-a-module>Importing Selected Names from a Module<a hidden class=anchor aria-hidden=true href=#importing-selected-names-from-a-module>#</a></h2><p><code>from module import name</code> 该语法将模块特定定义导入当前命名空间。
这和直接 import 不同的地方在于，不是创建一个新的命名空间，而是将该对象引用放入当前命名空间。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>module</span> <span class=kn>import</span> <span class=n>func</span>  <span class=c1># Imports module and puts func in current namespace</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>()</span>  <span class=c1># Calls module.func()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>module</span><span class=o>.</span><span class=n>func</span><span class=p>()</span>  <span class=c1># Fails. NameError: module</span>
</span></span></code></pre></div><p>该 <code>from</code> 语句接受逗号分隔的名称列表，来导入多个定义。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>module</span> <span class=kn>import</span> <span class=n>func</span><span class=p>,</span> <span class=n>SomeClass</span>
</span></span></code></pre></div><p>从语义上来说，<code>from module import name</code> 语句将名称从模块复制到本地命名空间。
Python 会在背后首先执行 <code>import module</code>，然后使用缓存进行赋值 <code>name = sys.modules['module'].name</code>。</p><p>一个常见的误解是人为使用 <code>from</code> 形式的导入更加高效，即只加载模块的一部分。
实际上并非如此，每当一个模块加载时，整个模块都会被加载并存储在缓存中。</p><p>使用 <code>from</code> 形式的 import 不会改变作用域。
当函数寻找变量的时候，它仍然会在定义中的文件中寻找，而不是导入或调用的函数中寻找。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>module</span> <span class=kn>import</span> <span class=n>func</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=p>()</span>  <span class=c1># func says that a is 37</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=o>.</span><span class=vm>__module__</span>  <span class=c1># &#39;module&#39;</span>
</span></span><span class=line><span class=cl><span class=n>func</span><span class=o>.</span><span class=vm>__globals__</span><span class=p>[</span><span class=s1>&#39;a&#39;</span><span class=p>]</span>  <span class=c1># 37</span>
</span></span></code></pre></div><p>使用星号 asterisk (<code>*</code>) 可以导入所有非下划线开始的定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># Load all definitions into the current namespace</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>module</span> <span class=kn>import</span> <span class=o>*</span>
</span></span></code></pre></div><p>这种语法不能写在函数内部，否则会报错 <code>SyntaxError</code>。
因为这样会破坏 Python 编译器对局部变量 Local Variables 的优化机制。</p><p>模块可以通过定义 <code>__all__</code> 列表来精确控制通过 <code>from module import *</code> 导入的集和。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># module.py</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>__all__</span> <span class=o>=</span> <span class=p>[</span> <span class=s1>&#39;func&#39;</span><span class=p>,</span> <span class=s1>&#39;SomeClass&#39;</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>37</span>  <span class=c1># Not exported</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>  <span class=c1># Exported</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SomeClass</span><span class=p>:</span>  <span class=c1># Exported</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></div><p>在实践中，使用 <code>from module import *</code> 是不被推荐的。
过度使用会导致混淆，并污染局部命名空间。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>random</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>statistics</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>gauss</span><span class=p>(</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>0.25</span><span class=p>)</span>  <span class=c1># From which module ???</span>
</span></span></code></pre></div><p>显示导入要好得多</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>sin</span><span class=p>,</span> <span class=n>cos</span><span class=p>,</span> <span class=n>sqrt</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>random</span> <span class=kn>import</span> <span class=n>gauss</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>statistics</span> <span class=kn>import</span> <span class=n>mean</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>gauss</span><span class=p>(</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>0.25</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=circular-imports>Circular Imports<a hidden class=anchor aria-hidden=true href=#circular-imports>#</a></h2><p>如果两个模块相互导入对方会产生特别的问题。
例如假设你有两个文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># moda.py</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>modb</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func_a</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>modb</span><span class=o>.</span><span class=n>func_b</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># modb.py</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>moda</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func_b</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;B&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Child</span><span class=p>(</span><span class=n>moda</span><span class=o>.</span><span class=n>Base</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><p>这段对面存在一种奇怪的导入顺序问题。
具体是，使用 <code>import modb</code> 能正常工作，但如果使用 <code>import moda</code> 就会崩溃，并说 <code>moda.Base</code> 没有定义。</p><p>根据控制流，错误原因如下：</p><ul><li>执行 <code>modb.py</code> 文件，Python 首先创建一个 <code>__name__ = __main__</code> 的模块</li><li>第一行为 <code>import moda</code>，会加载模块 <code>moda.py</code></li><li>由于 <code>moda.py</code> 第一行为 <code>import modb</code>，这会导致又去加载 <code>modb</code></li><li>由于模块缓存 <code>sys.module</code> 中没有 <code>modb</code> （而是 <code>__main__</code>），因此又会回到 <code>modb.py</code> 作为导入模块执行</li><li>这时候，<code>modb.py</code> 的第一行的导入存在模块缓存内，因此不会循环导入</li><li>当执行到 <code>Child</code> 的时候，由于缓存中创建的 <code>moda</code> 并没有加载完全，<code>moda.Base</code> 还未定义，从而导致报错</li></ul><p>要修复这个问题，可以将 <code>import modb</code> 语句放到其他地方。
例如将其移动到 <code>func_a()</code> 函数内部：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># moda.py</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func_a</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nn>modb</span>
</span></span><span class=line><span class=cl>    <span class=n>modb</span><span class=o>.</span><span class=n>func_b</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><p>或者也可以将导入写在文件末尾</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># moda.py</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func_a</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>modb</span><span class=o>.</span><span class=n>func_b</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>modb</span>  <span class=c1># Must after Base is defined</span>
</span></span></code></pre></div><p>但这两者写法在代码审查中都可能被质疑。
大多数情况下，不会看到导入语句出现在文件末尾。
更好的处理方式一般是将 <code>Child</code> 类定义搬到单独的 <code>base.py</code> 文件中去。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># modb.py</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>base</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func_b</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;B&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Child</span><span class=p>(</span><span class=n>base</span><span class=o>.</span><span class=n>Base</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></div><h2 id=module-roloading-and-unloading>Module Roloading and Unloading<a hidden class=anchor aria-hidden=true href=#module-roloading-and-unloading>#</a></h2><p>目前没有可靠的机制来支持对先前导入的 modules（模块）进行 reloading（重新加载）或 unloading（卸载）。
即使可以通过删除 <code>sys.modules</code> 导入的模块，但这些内容仍然会保存在内存中。
这样因为其他导入的模块会缓存模块变量。
此外，如果模块中定义了类的实例，这些实例会包含指向其类对象的引用，而类对象又持有定义模块的引用。</p><p>模块引用存在于多个位置，这使得修改其实现后重新加载模块通常不切实际。
例如，如果从 <code>sys.modules</code> 里面删除模块，并通过 <code>import</code> 重新导入它，
但这并不会追溯性地改变程序中之前对该模块的所有引用。
相反，将会拥有最近 <code>import</code> 语句导入的一个新模块，和之前旧 <code>import</code> 代码保留的旧模块。</p><p>在 <code>importlib</code> 库中有一个 <code>reload()</code> 函数来重新导入模块。
将之前的模块作为参数导入该模块：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>module</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>importlib</span>
</span></span><span class=line><span class=cl><span class=n>importlib</span><span class=o>.</span><span class=n>reload</span><span class=p>(</span><span class=n>module</span><span class=p>)</span>  <span class=c1># loaded module &lt;module &#39;module&#39; from &#39;module.py&#39;&gt;</span>
</span></span></code></pre></div><p><code>reload()</code> 通过导入新的模块源码，并在已存在的模块命名空间顶部执行实现。</p><p>如果其他模块之前通过 <code>import module</code> 这种标准导入语句，则该函数可以当代码自动更新。</p><p>但这里存在很多危险：</p><ol><li>首先 reloading 不是递归的，它只会导入传递给 <code>reload()</code> 的单个模块</li><li>如果导入模块使用 <code>from module import name</code> 的方式导入，则无法重新导入</li><li>最后，如果创建了类的实例，则这些实例仍使用的是旧的类定义</li></ol><p>此外，C/C++ 扩展无法通过任何方式取消或重新导入。</p><h2 id=module-compliation>Module Compliation<a hidden class=anchor aria-hidden=true href=#module-compliation>#</a></h2><p>当模块首次导入时，他们会被编译为字节码。
该代码写在目录 <code>__pycache__</code> 的 <code>.pyc</code> 文件中，该目录通常和运行的 <code>.py</code> 代码目录下。
当程序的不同地方再次导入时，会直接加载编译后的代码，加快 import 速度。</p><p>如果在操作系统中 Python 没有权限创建文件，则也能正常工作，但 import 速度会慢很多。</p><p>另一个需要知道模块缓存的原因是要警惕可能影响它的编程技巧。
高级源编程涉及动态代码生成，和 <code>exec()</code> 函数会削弱字节码缓存的优势。</p><p>一个显著的例子是使用 dataclasses:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>dataclasses</span> <span class=kn>import</span> <span class=n>dataclass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@dataclass</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Point</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>:</span> <span class=nb>float</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=p>:</span> <span class=nb>float</span>
</span></span></code></pre></div><p>Dataclass 通过生成方法函数作为文本块并使用 <code>exec()</code> 执行。
所有这些生成的代码都没有通过 import 系统进行缓存。
对于单个 dataclass 可能注意不到，但如果有 100 个 dataclasses，就会发现他们比正常的类慢 20 倍。</p><h2 id=the-module-search-path>The Module Search Path<a hidden class=anchor aria-hidden=true href=#the-module-search-path>#</a></h2><p>当导入模块的时候，解释器搜索 <code>sys.path</code> 里的路径。
第一个值通常是空字符串 <code>''</code>，指代当前工作目录。
如果运行一个 py 脚本，则第一个值是当前脚本所在的目录。
其他的值通常包括一些列目录名，和 <code>.zip</code> 文件。
<code>sys.path</code> 的顺序即模块搜索顺序。
如果要添加新的搜索路径，将其添加到该列表中。
可以通过设置 <code>PYTHONPATH</code> 环境变量来实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>env <span class=nv>PYTHONPATH</span><span class=o>=</span>/some/path
</span></span></code></pre></div><p>ZIP 文件提供了一种将多个模块放到一个文件中的方法。
例如，假如创建了两个模块 <code>foo.py</code> 和 <code>bar.py</code>，并将他们放到 <code>mymodules.zip</code> 中。
则该文件可以添加到 Python 路径中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s1>&#39;mymodules.zip&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>foo</span><span class=o>,</span> <span class=nn>bar</span>
</span></span></code></pre></div><p>压缩文件内部的路径也可以加入 path:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>sys</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s1>&#39;/tmp/modules.zip/lib/python&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>并且压缩文件不一定要有 <code>.zip</code> 后缀，历史上曾经使用 <code>.egg</code>，该后缀源自于一个早期 python 包管理工具 setuptools。
但 <code>.egg</code> 文件只不过是在 <code>.zip</code> 之上添加了一些元数据罢了（版本号、依赖等）。</p><h2 id=execution-as-the-main-program>Execution as the Main Program<a hidden class=anchor aria-hidden=true href=#execution-as-the-main-program>#</a></h2><p>Python 文件经常作为脚本运行，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>python3 module.py
</span></span></code></pre></div><p>每个模块定义一个变量 <code>__name__</code>，其中包括了模块名。
代码可以检查该变量来确定执行的模块。
在命令行中指定的程序会在 <code>__main__</code> 模块中运行。
有时候程序会根据是否是 <code>__main__</code> 模块来改变其行为。
例如，一个模块可能包含一些测试代码，如果模块在 <code>__main__</code> 模块中就运行，在其他模块中则不运行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># Check if running as a program</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># Yes. Running as the main script</span>
</span></span><span class=line><span class=cl>    <span class=n>statements</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># No, be imported as a module</span>
</span></span><span class=line><span class=cl>    <span class=n>statements</span>
</span></span></code></pre></div><p>库源码文件通常使用这种技巧，来测试或运行示例代码。
假如你在开发一个模块，可以将调试代码放到上面展示的 <code>if</code> 语句中，并在主程序运行模块。</p><p>假如你在创建一个 Python 代码目录，可以使用特殊的 <code>__main__.py</code> 文件。
例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>myapp/
</span></span><span class=line><span class=cl>    foo.py
</span></span><span class=line><span class=cl>    bar.py
</span></span><span class=line><span class=cl>    __main__.py
</span></span></code></pre></div><p>然后可以通过命令 <code>python3 myapp</code> 来运行该模块。
执行会从 <code>__main__.py</code> 开始，将 <code>myapp/</code> 做成压缩文件也可以。</p><h2 id=packages>Packages<a hidden class=anchor aria-hidden=true href=#packages>#</a></h2><p>Python 代码可以被组织成一个 “包”。包是一组模块的集和，这些模块被归在一个共同的高级名称下。
这种分组有助于解决不同应用程序中使用的模块名称之间的冲突，并将你的代码与他人的分开。
包通过创建一个独特的目录名称和一个空的 <code>__init__.py</code> 文件定义。
然后将额外的 Python 文件和子包放到目录中，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>graphics/
</span></span><span class=line><span class=cl>    __init__.py
</span></span><span class=line><span class=cl>    primitive/
</span></span><span class=line><span class=cl>        __init__.py
</span></span><span class=line><span class=cl>        lines.py
</span></span><span class=line><span class=cl>        fill.py
</span></span><span class=line><span class=cl>        text.py
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    graph2d/
</span></span><span class=line><span class=cl>        __init__.py
</span></span><span class=line><span class=cl>        plot2d.py
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    graph3d/
</span></span><span class=line><span class=cl>        __init__.py
</span></span><span class=line><span class=cl>        plot3d.py
</span></span><span class=line><span class=cl>        ...
</span></span><span class=line><span class=cl>    formats/
</span></span><span class=line><span class=cl>        __init__.py
</span></span><span class=line><span class=cl>        gif.py
</span></span><span class=line><span class=cl>        png.py
</span></span><span class=line><span class=cl>        tiff.py
</span></span><span class=line><span class=cl>        jpeg.py
</span></span></code></pre></div><p><code>import</code> 语句用于从包中加载模块，其使用方式与加载简单模块相同，只是现在需要使用更长的名称。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># Full path</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>graphics.primititve.fill</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=n>graphics</span><span class=o>.</span><span class=n>primitive</span><span class=o>.</span><span class=n>fill</span><span class=o>.</span><span class=n>floodfill</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>color</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Load s specific submodule</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>graphics.primitive</span> <span class=kn>import</span> <span class=n>fill</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=n>fill</span><span class=o>.</span><span class=n>floodfill</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>color</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Load a specific function from a submodule</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>graphics.primitive.fill</span> <span class=kn>import</span> <span class=n>floodfill</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span><span class=line><span class=cl><span class=n>floodfill</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>color</span><span class=p>)</span>
</span></span></code></pre></div><p>当包导入的时候，<code>__init__.py</code> 中的代码会先被执行。
该文件可以是空的，也可以包含一些初始化代码。
如果导入深度嵌入的子模块，在遍历目录结构时遇到的所有 <code>__init__.py</code> 文件都会执行。
<code>import graphics.primitive.fill</code> 首先会执行 <code>graphics/</code> 下的 <code>__init__.py</code> 文件，然后是 <code>primitive/</code> 下的 <code>__init__.py</code> 文件。</p><p>一个 <code>import</code> 语句的重要特性是，所有模块的导入都要求绝对的或明确的包路径。
这包括包内部使用的导入语句。
例如，假设模块 <code>graphics.primitives.fill</code> 模块想要导入 <code>graphics.primitives.lines</code> 模块。
则简单的 <code>import lines</code> 无法正常工作，会得到一个 <code>ImportError</code> 错误。
相反，需要完全确定导入路径，像这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># graphics/primitives/fill.py</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Fully qualified submodules import</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>graphics.primitives</span> <span class=kn>import</span> <span class=n>lines</span>
</span></span></code></pre></div><p>遗憾的是，像这样写出完整包名即麻烦又容易出错。
例如，重命名一个包会导致硬编码的导入失效。
因此，更好的选择是相对包导入：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># graphics/primitives/fill.py</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Paskage-relative import</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>.</span> <span class=kn>import</span> <span class=n>lines</span>
</span></span></code></pre></div><p>相对导入只能使用 <code>from module import symbol</code> 这样的语法。
因此 <code>import ..primitives.lines</code> 或 <code>import .lines</code> 这样写是语法错误。
或 <code>from .. import primitives.lines</code> 这样也是不合法的。
总之，相对导入只能在一个 package 包内使用，可以是同一个包内的不同子包，但不能是不同包之间引用。</p><h2 id=running-a-package-submodule-as-a-script>Running a Package submodule as a script<a hidden class=anchor aria-hidden=true href=#running-a-package-submodule-as-a-script>#</a></h2><p>组织成 package 的代码的 runtime 运行时环境和简单的脚本并不相同。
存在一个外层包名、子模块以及相对导入的使用。
其中一个不再支持的特性是无法直接在包的源文件上运行 Python 程序。
例如，<code>graphics/graph2d/plot2d.py</code> 文件有一些测试代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># graphics/graph2d/plot2d.py</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>..primitives</span> <span class=kn>import</span> <span class=n>lines</span><span class=p>,</span> <span class=n>text</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Plot2D</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Testing Plot2D&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>Plot2D</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></div><p>如果直接运行该脚本会得到相对导入导致的崩溃：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python3 graphics/graph2d/plot2d.py
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Traceback <span class=o>(</span>most recent call last<span class=o>)</span>:
</span></span><span class=line><span class=cl>  File <span class=s2>&#34;graphics/graph2d/plot2d.py&#34;</span>, line 1, in &lt;module&gt;
</span></span><span class=line><span class=cl>    from ..primitive import line, text
</span></span><span class=line><span class=cl>ValueError: attempted relative import beyond top-level package
</span></span></code></pre></div><p>也不能进入到模块中去执行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ <span class=nb>cd</span> graphics/graph2d/
</span></span><span class=line><span class=cl>$ python3 plot2d.py
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Traceback <span class=o>(</span>most recent call last<span class=o>)</span>:
</span></span><span class=line><span class=cl>  File <span class=s2>&#34;plot2d.py&#34;</span>, line 1, in &lt;module&gt;
</span></span><span class=line><span class=cl>    from ..primitive import line, text
</span></span><span class=line><span class=cl>ValueError: attempted relative import beyond top-level package
</span></span></code></pre></div><p>如果要将子模块作为 main script 运行，需要使用 <code>-m</code> 参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ python3 -m graphics.graph2d.plot2d
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Testing Plot2D
</span></span></code></pre></div><p><code>-m</code> 参数将模块或包作为主程序，python 会使用正确的环境运行该模块，从而确保 import 能正常工作。
许多 python 的内置模块拥有的 “秘密” 特性可以通过 <code>-m</code> 运行。
最常见的是通过 <code>python3 -m http.server</code> 在当前目录运行一个 web 服务器。
你可以通过自己的包提供类似的功能。
如果 <code>python -m name</code> 对应一个包目录，则 python 会查找 <code>__main__.py</code> 文件，并将其作为脚本运行。</p><h2 id=controlling-the-package-namespace>Controlling the Package Namespace<a hidden class=anchor aria-hidden=true href=#controlling-the-package-namespace>#</a></h2><p>包的主要目的的作为代码的顶层容器。
有时候用户会只导入顶层名称。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>graphics</span>
</span></span></code></pre></div><p>这样导入不指定任何子模块，这会导致这样的代码失效：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>graphics</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>graphics</span><span class=o>.</span><span class=n>primitive</span><span class=o>.</span><span class=n>fill</span><span class=o>.</span><span class=n>floodfill</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>color</span><span class=p>)</span>  <span class=c1># Fails!</span>
</span></span></code></pre></div><p>当仅给出定义包导入时,唯一导入的文件是关联的 <code>__init__.py</code> 文件。
在这个例子中，就是 <code>graphics/__init__.py</code> 文件。</p><p><code>__init__.py</code> 文件的主要目的就是创建与管理顶级包命名空间的内容。
通常这涉及到从更低层级的子目录中导入函数、类和其他对象。
例如，假设 graphics 包含有数百个低级函数，但大部分细节被封装在少数几个高级类中。
<code>__init__.py</code> 文件可能选择值暴露这些类：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># graphics/__init__.py</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>.graph2d.plot2d</span> <span class=kn>import</span> <span class=n>Plot2D</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>.graph3d.plot3d</span> <span class=kn>import</span> <span class=n>Plot3D</span>
</span></span></code></pre></div><p>通过 <code>__init__.py</code> 文件，只有 <code>Plot2D</code> 和 <code>Plot3D</code> 会出现在包顶层。
用户可以这样使用该类：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>graphics</span> <span class=kn>import</span> <span class=n>Plot2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>plt</span> <span class=o>=</span> <span class=n>Plot2D</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
</span></span></code></pre></div><p>这样用户使用起来就十分方便，无需知道你的代码组织结构。</p><h2 id=controlling-package-exports>Controlling Package Exports<a hidden class=anchor aria-hidden=true href=#controlling-package-exports>#</a></h2><p>一个组织上的问题涉及 <code>__init__.py</code> 文件与低处子模块之间的交互。
例如，一个包的不同子模块通常知道那些符号需要导出到顶层。
然而，实际的工作是在 <code>__init__.py</code> 中完成的。
这使得阅读包的代码并理解其组织结构变得困难。</p><p>为了更好地管理子模块，通常会定义一个 <code>__all__</code> 列表。
该列表是命名空间中需要提升一级的包。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># graphics/graph2d/plot2d.py</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>__all__</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;Plot2D&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Plot2D</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></div><p>相关的 <code>__init__.py</code> 文件通过 <code>*</code> 号导入：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># graphics/graph2d/__init__.py</span>
</span></span><span class=line><span class=cl><span class=c1># Only loads names explicitly listed in __all__ variables</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>.plot2d</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Propagate the __all__ up to next level</span>
</span></span><span class=line><span class=cl><span class=n>__all__</span> <span class=o>=</span> <span class=n>plot2d</span><span class=o>.</span><span class=n>__all__</span>
</span></span></code></pre></div><p>这种提升过程会一直持续到顶层的 <code>__init__.py</code>，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># graphics/__init__.py</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>.graph2d</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>.graph3d</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Consolidate exports</span>
</span></span><span class=line><span class=cl><span class=n>__all__</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>graph2d</span><span class=o>.</span><span class=n>__all__</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>graph3d</span><span class=o>.</span><span class=n>__all__</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></div><p>值的注意的是，尽管在用户代码中使用 <code>*</code> 导入并不被推荐，但在包的 <code>__init__.py</code> 中这种做法非常普遍。</p><h2 id=package-data>Package data<a hidden class=anchor aria-hidden=true href=#package-data>#</a></h2><p>有时候包会包含一些数据文件（非代码）。
在包中，<code>__file__</code> 变量会给予关于源文件位置的信息。
但是包会被编译，他们可能被打包成 <code>.zip</code> 文件或其他不常见的格式。
文件中的 <code>__file__</code> 变量可能并不可靠，甚至根本没有定义。
结果导致读取数据文件并不容易，通过文件名和内置函数 <code>open()</code> 也不方便。</p><p>为了读取包数据，使用 <code>pkgutil.get_data(package, resource)</code>。
例如包结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mycode/
</span></span><span class=line><span class=cl>    resources/
</span></span><span class=line><span class=cl>        data.json
</span></span><span class=line><span class=cl>    __init__.py
</span></span><span class=line><span class=cl>    spam.py
</span></span><span class=line><span class=cl>    yow.py
</span></span></code></pre></div><p>为了导入 <code>data.json</code> 文件，可以这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># mycode/spam.py</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pkgutil</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>json</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>func</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># rawdata: bytes 字节流 | None</span>
</span></span><span class=line><span class=cl>    <span class=n>rawdata</span> <span class=o>=</span> <span class=n>pkgutil</span><span class=o>.</span><span class=n>get_data</span><span class=p>(</span><span class=n>__package__</span><span class=p>,</span> <span class=s1>&#39;resources/data.json&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>textdata</span> <span class=o>=</span> <span class=n>rawdata</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s1>&#39;utf-8&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=n>json</span><span class=o>.</span><span class=n>loads</span><span class=p>(</span><span class=n>textdata</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span></code></pre></div><p>实际上，现代 Python 版本更加推荐使用 <code>importlib.resources</code>，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>importlib</span> <span class=kn>import</span> <span class=n>resources</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 1. 获取资源句柄（并未读取文件内容）</span>
</span></span><span class=line><span class=cl><span class=n>source</span> <span class=o>=</span> <span class=n>resources</span><span class=o>.</span><span class=n>file</span><span class=p>(</span><span class=s1>&#39;my_package&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>joinpath</span><span class=p>(</span><span class=s1>&#39;data/config.json&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. 读取文件内容</span>
</span></span><span class=line><span class=cl><span class=n>content</span> <span class=o>=</span> <span class=n>source</span><span class=o>.</span><span class=n>read_text</span><span class=p>(</span><span class=n>encoding</span><span class=o>=</span><span class=s1>&#39;utf-8&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. 第三方库如果需要无物理路径</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=n>resources</span><span class=o>.</span><span class=n>as_file</span><span class=p>(</span><span class=n>source</span><span class=p>)</span> <span class=k>as</span> <span class=n>physical_path</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 即使在压缩包中，Python 也会创建一个临时物理文件</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>physical_path</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=module-objects>Module Objects<a hidden class=anchor aria-hidden=true href=#module-objects>#</a></h2><p>模块是一等公民，下表列出了常用的模块属性：</p><table><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td>__name__</td><td>完整的模块名称</td></tr><tr><td>__doc__</td><td>文档字符串</td></tr><tr><td>__dict__</td><td>模块字典</td></tr><tr><td>__file__</td><td>模块定义所在的文件名</td></tr><tr><td>__package__</td><td>所在包的名称（如果有）</td></tr><tr><td>__path__</td><td>搜索包子模块的子目录列表</td></tr><tr><td>__annotations__</td><td>模块级别的类型提示</td></tr></tbody></table><p>这里的 <code>__dict__</code> 属性是一个字典，代表模块的命名空间。
所有再模块内定义的都在这里。</p><p><code>__name__</code> 属性是通常用于脚本编写，通常会进行类似 <code>if __name__ == '__main__'</code> 的检查。
以判断文件十分作为主程序运行。</p><p><code>__package__</code> 属性包含所在的包 (enclosing package) 名称。
如果设置了该属性，<code>__path__</code> 属性是目录列表，用于定位包的子模块。
通常，它包含一个单一条目，即包的位置。
有时，大型框架会操作 <code>__path__</code> 以包含额外的目录，目的是支持插件和其他高级功能。</p><p>并非所有的模块都具备所有属性。
例如，内置模块可能没有设置 <code>__file__</code> 属性。
同样地，对于顶级模块，与包相关的属性不会被设置。</p><p><code>__doc__</code> 属性是模块的 docstring，这是文件中第一行出现的语句。
<code>__annotations__</code> 属性是一个模块级别的类型提升字典，类似这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># mymodule.py</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>The doc string
</span></span></span><span class=line><span class=cl><span class=s1>&#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Type hints (placed into __annotations__)</span>
</span></span><span class=line><span class=cl><span class=n>x</span><span class=p>:</span> <span class=nb>int</span>
</span></span><span class=line><span class=cl><span class=n>y</span><span class=p>:</span> <span class=nb>float</span>
</span></span><span class=line><span class=cl><span class=o>...</span>
</span></span></code></pre></div><p>和其他类型提升相比，模块级别的类型提升不会改变 Python 的行为。
他们实际上也不定义变量，纯粹是元数据，其他工具可以根据需要选择查看。</p><h2 id=deploying-python-packages>Deploying Python Packages<a hidden class=anchor aria-hidden=true href=#deploying-python-packages>#</a></h2><p>最后关于模块和包的问题是将代码发给他人。
这一个广泛的话题，多年来一直是持续活跃开发的重点。
具体流程参考：<a href=https://packaging.python.org/en/latest/tutorials/packaging-projects/>Python 官方文档</a></p><p>尝试给包起一个独特的名称，以免和其他可能的依赖项冲突。
可以参考 <a href=https://pypi.org>Python 包索引网站</a>来帮助选择名称。
在组织代码结构时，尽量保持简洁。</p><p>考虑到绝对简洁性，分发纯 Python 代码最极简的方式是使用 <code>setuptools</code> 模块。
假设编写来一些代码，项目结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>spam-project/
</span></span><span class=line><span class=cl>    README.txt
</span></span><span class=line><span class=cl>    Documentation.txt
</span></span><span class=line><span class=cl>    spam/  # A package of code
</span></span><span class=line><span class=cl>    __init__.py
</span></span><span class=line><span class=cl>    foo.py
</span></span><span class=line><span class=cl>    bar.py
</span></span><span class=line><span class=cl>    runspam.py  # A script to run as: python runspam.py
</span></span></code></pre></div><p>为了创建分发，在顶层目录创建一个 <code>setup.py</code> 文件，并编写如下代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=c1># setup.py</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>setuptools</span> <span class=kn>import</span> <span class=n>setup</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>setup</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span><span class=o>=</span><span class=s1>&#39;spam&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>version</span><span class=o>=</span><span class=s1>&#39;0.0&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>packages</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;spam&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>scripts</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;runspam.py&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>在这个 <code>setup()</code> 调用中，<code>packages</code> 是所有包目录的列表，<code>scripts</code> 是脚本文件列表。
如果包没有相关内容则省略，<code>name</code> 是包名称，<code>version</code> 是字符串版本号。</p><p>使用 <code>setup.py</code> 文件创建软件分发包足够了，使用下面命令来创建一个源码分发包：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>python3 setup.py sdist
</span></span></code></pre></div><p>这会创建一个存档文件，例如 <code>spam-1.0.tar.gz</code> 或 <code>spam-1.0.zip</code> 到目录 <code>spam/dist</code> 下面。
这就是你给予他人按照的文件。
如果要安装该软件包，使用命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>python3 -m pip install spam-1.0.tar.gz
</span></span></code></pre></div><p>这会将软件安装到本地 Python 环境。
一般会放在 Python 库的 <code>site-packages</code> 目录下面，可以通过 <code>sys.path</code> 查看。</p><p>Scripts 脚本通常会安装在相同的目录下。
如果脚本第一行以 <code>#!</code> 开头，且包含 <code>python</code> 文本，这安装器会重写该行指向本地 Python 地址。
因此，即使硬编码了 Python 地址，也应该仍然能工作。</p><p>这里描述的 <code>setuptools</code> 使用方式是最简化的。
大型项目可能涉及 C/C++ 扩展、复杂的包结构、示例等。
涵盖所有工具以及部署此类代码的方式可以查阅 <a href=https://python.org>https://python.org</a>和 <a href=https://pypi.org>https://pypi.org</a> 以获取最新建议。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://starslayerx.github.io/tags/python/>Python</a></li></ul><nav class=paginav><a class=prev href=https://starslayerx.github.io/posts/python-tricks-part-7-classes-and-object-oriented-programming/><span class=title>« Prev</span><br><span>Python Tricks Part 7: Classes and Object-Oriented Programming</span>
</a><a class=next href=https://starslayerx.github.io/posts/cs144-lab0/><span class=title>Next »</span><br><span>CS144 - lab0</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 8: Modules and Packages on x" href="https://x.com/intent/tweet/?text=Python%20Tricks%20Part%208%3a%20Modules%20and%20Packages&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-8-modules-and-packages%2f&amp;hashtags=Python"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 8: Modules and Packages on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-8-modules-and-packages%2f&amp;title=Python%20Tricks%20Part%208%3a%20Modules%20and%20Packages&amp;summary=Python%20Tricks%20Part%208%3a%20Modules%20and%20Packages&amp;source=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-8-modules-and-packages%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 8: Modules and Packages on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-8-modules-and-packages%2f&title=Python%20Tricks%20Part%208%3a%20Modules%20and%20Packages"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 8: Modules and Packages on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-8-modules-and-packages%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 8: Modules and Packages on whatsapp" href="https://api.whatsapp.com/send?text=Python%20Tricks%20Part%208%3a%20Modules%20and%20Packages%20-%20https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-8-modules-and-packages%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 8: Modules and Packages on telegram" href="https://telegram.me/share/url?text=Python%20Tricks%20Part%208%3a%20Modules%20and%20Packages&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-8-modules-and-packages%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Tricks Part 8: Modules and Packages on ycombinator" href="https://news.ycombinator.com/submitlink?t=Python%20Tricks%20Part%208%3a%20Modules%20and%20Packages&u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-tricks-part-8-modules-and-packages%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>