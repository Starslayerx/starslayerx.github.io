<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Starslayerx' Blog</title><meta name=keywords content><meta name=description content="Posts - Starslayerx' Blog"><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://starslayerx.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://starslayerx.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/posts/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="A personal blog about technology, programming, and daily notes"><meta property="og:locale" content="en-US"><meta property="og:type" content="website"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Posts"><meta name=twitter:description content="A personal blog about technology, programming, and daily notes"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://starslayerx.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python Decorators: 从入门到实战</h2></header><div class=entry-content><p>这篇文章将通过一个**“为阿里云 Qwen API 添加缓存”**的例子，带你彻底理解 Python 装饰器。
首先，我们定义一个基础的调用函数：
import time def call_qwen(messages: list, model: str = 'qwen-max', temperature: float = 0.7): '''调用 Qwen API (模拟)''' print(f'正在请求 API (模型: {model})...') time.sleep(1) # 模拟网络耗时 return {'content': '这是 AI 的回复', 'usage': 100} 1. 函数是一等公民 (First-Class Citizen) 在 Python 中，函数可以像变量一样被传递和赋值。
# 1. 赋值给变量 run_api = call_qwen # 2. 作为参数传递 def logger(func, *args, **kwargs): print('[INFO] Calling qwen ...') return func(*args, **kwargs) logger(call_qwen, [{'role': 'user', 'content': '你好'}]) 2. 闭包 (Closure) 闭包是指函数内部定义了另一个函数，并且内部函数引用了外部函数的变量。它是实现装饰器的基石。
利用闭包，我们可以创建一个带缓存功能的函数：
def make_cached_qwen(): cache = {} # 外部函数的变量，会被内部函数“捕获” def wrapped(messages, **kwargs): # 简单起见，用最后一条消息的内容当 Key key = messages[-1]['content'] if key in cache: print(' 命中缓存') return cache[key] result = call_qwen(messages, **kwargs) cache[key] = result return result return wrapped # 此时 cached_call 就是一个带有自己 “私有缓存字典” 的函数 cached_call = make_cached_qwen() 3. 高阶函数 (High-Order Function) 如果我们想让缓存逻辑通用化，不只针对 call_qwen，我们可以写一个接收函数作为参数的高阶函数：
...</p></div><footer class=entry-footer><span title='2026-01-29 08:00:00 +0800 +0800'>January 29, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>384 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Decorators: 从入门到实战" href=https://starslayerx.github.io/posts/python-decorators-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 7: Classes and Object-Oriented Programming</h2></header><div class=entry-content><p>使用 vars() 方法返回对象的属性和值的字典对象，不带参数时，返回当前局部作用域的变量字典
vars() # 相当于 locals() class Person: name: str age: int def __init__(self, name, age): self.name = name self.age = age self.city = "Beijing" p = Person("Alice", 25) print(vars(p)) Attribute Access 一个示例只有三种基础的方法：getting, setting 和 deleting 属性
class Attribute: owner: str blance: float def __init__(self, owner: str, balance: float): self.owner = owner self.balance = balance def __repr__(self): return f"Account({self.owner!r}, {self.balance!r})" def deposite(self, amount: float): self.balance += amount def withdraw(self, amount: float): self.balance -= amount def inquiry(self) -> float: return self.balance 例如
a = Account("Guido", 1000.0) a.owner # get a.balance = 75 # set del a.balance # delete Python 中的一切都是一个动态过程，几乎没有什么限制。 例如，可以给已创建的对象添加新属性：
a = Account("Guido", 1000.0) a.creation_date = "2019-02-14" a.nickname = "Fromer BDFL" 有时候不适用点 . 操作符来执行任务，而是通过将属性名传递给 getattr(), setattr() 和 delattr() 函数来实现。 hasattr() 函数允许你测试一个已存在的属性：
a = Account("Guido", 1000.0) getattr(a, "owner") setattr(a, "balance", 750.0) delattr(a, "balance") hasattr(a, "balance") # False getattr(a, "withdraw")(100) # Method Call # a = Account("Guido", 650.0) getattr() 函数可以携带一个默认值，如果想要查看一个可能不存在的属性，可以这样实现：
...</p></div><footer class=entry-footer><span title='2026-01-13 08:00:00 +0800 +0800'>January 13, 2026</span>&nbsp;·&nbsp;<span>20 min</span>&nbsp;·&nbsp;<span>4105 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 7: Classes and Object-Oriented Programming" href=https://starslayerx.github.io/posts/python-tricks-part-7-classes-and-object-oriented-programming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 8: Modules and Packages</h2></header><div class=entry-content><p>Python 程序由 modules 和 packages 组成，使用 import 语句导入。
Modules and the import Statement 任何 Python 源文件都可以作为一个模块导入，例如下面 module.py 代码：
a = 37 def func(): print(f'func says that a is {a}') class SomeClass: def method(self): print('method says hi') print('loaded module') 改文件包含一些常见的编程元素，包括一个全局变量、一个函数、一个类定义 和 最后的语句。 通过下面方法导入：
import module module.a module.func() s = module.SomeClass() s.method() 执行 import 会发送下面这几件事：
加载模块源码，如果找不到抛出 ImportError 创建新模块对象。该对象作为模块内所有全局定义 global defintions 的容器，被称为 “命名空间” namespace 该模块源码在新创建的模块命名空间内执行 如果没有错误发生，调用者会创建一个名称，指向新的模块对象。该名称与模块名称一致，但不包含任何文件后缀。 这些步骤中，第一步是最复杂的。新手容易犯的错误就是使用错误的名称或将代码放到了未知的位置。 且模块文件必须放在 sys.path 所包含的文件路径中，且文件名称要遵循和 python 变量一样的规则。
剩下的步骤都隔离在一个模块中，因此不用担心不同模块间命名冲突的问题。 Python import 会执行所有导入的源码，因此导入上面模块会输出 loaded module。
...</p></div><footer class=entry-footer><span title='2026-01-13 08:00:00 +0800 +0800'>January 13, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1370 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 8: Modules and Packages" href=https://starslayerx.github.io/posts/python-tricks-part-8-modules-and-packages/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CS144 - lab0</h2></header><div class=entry-content><p>CS 144: Introduction to Computer Networking, Fall 2025
本篇文章对应 check0.pdf 的内容
3 Network by hand 3.1 Fetch a Web page 这个介绍怎么发送一个 GET 请求
telent cs144.keithw.org http
该命令告诉 telnet 打开一个可靠字节流(reliable byte stream)，并在我电脑上运行一个 http 服务
预计会收到这样的内容
Trying 104.196.238.229... Connected to cs144.keithw.org. Escape character is '^]'. ^] telnet> close Connection closed. 该命令不能使用常见的 Ctrl-C 之类方法退出，而是 Ctrl-] 然后输入 close
GET /hello HTTP/1.1
该命令告诉服务器 URL 的 path 部分
Host: cs144.keithw.org
该命令告诉服务器 URL 的 host 部分
Connection: close
...</p></div><footer class=entry-footer><span title='2026-01-11 08:00:00 +0800 +0800'>January 11, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1431 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to CS144 - lab0" href=https://starslayerx.github.io/posts/cs144-lab0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 6: Generators</h2></header><div class=entry-content><p>生成器是 Python 中一种强大的特性，其通常被介绍为一种定义新型迭代模式的便捷方式。 但生成器从根本上改变了整个函数执行的模式，本篇文章重点关注：生成器、生成器委托、基于生成器的协程，以及生成器的其他内部机制。
Generators and yield 如果一个函数使用 yield 关键字，这定义了一个生成器。 生成器的主要用户是生成用于迭代的值。
例如：
def countdown(n): print("Counting down from", n) while n > 0: yield n n -= 1 # Example use for x in countdown(n): print("T-minus", x) 如果调用该函数则不会开始执行：
c = countdown(10) # &lt;generator object countdown at 0x106faa260> 相反，会创建一个生成器对象。 该生成器对象只有在你迭代它的时候才会开始执行，使用的一种方式是调用 next()。
例如：
next(c) # Counting down from 10 # 10 next(c) # 9 当调用 next() 时，生成器函数会执行语句直到遇到 yield 语句。 yield 语句会返回一个结果，此时函数的执行被挂起，直到再次调用 next()。
当其暂停的时候，函数会保留所有的本地变量和执行环境。 恢复执行时，程序会从 yield 之后的语句继续运行。
next() 是调用生成器上 __next__() 方法的简写形式。 例如，你可以这样：
c.__next__() # 8 c.__next__() # 7 通常不会在生成器直接使用 next()，而是使用 for 或其他一些语句：
...</p></div><footer class=entry-footer><span title='2026-01-09 08:00:00 +0800 +0800'>January 9, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1113 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 6: Generators" href=https://starslayerx.github.io/posts/python-tricks-part-6-generators/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Taskwarrior Server Config Guide</h2></header><div class=entry-content><p>Taskwarrior 3.x 同步服务器配置指南 本文介绍如何使用 Docker 部署 taskchampion-sync-server，为 Taskwarrior 3.x 提供跨设备同步功能。
背景知识 Taskwarrior 是一款强大的命令行任务管理工具。从 3.0 版本开始，官方不再支持 taskd 服务器，改用新的 taskchampion-sync-server。
与 taskd 相比，新同步服务器的优势：
无需手动配置 SSL 证书 无需预先创建用户账户 客户端数据端到端加密 部署和维护更简单 服务器端配置 使用 Docker 部署 创建数据目录并启动容器：
sudo mkdir -p /var/lib/taskchampion-sync-server sudo chmod 777 /var/lib/taskchampion-sync-server docker run -d \ --name taskchampion \ -p 53589:8080 \ -e RUST_LOG=info \ -v taskchampion-data:/var/lib/taskchampion-sync-server \ --restart unless-stopped \ ghcr.io/gothenburgbitfactory/taskchampion-sync-server:main 端口说明：容器内部使用 8080，映射到宿主机的 53589（可自定义）。
配置防火墙 确保服务器防火墙开放相应端口。以常见的云服务器防火墙为例：
类型：入站 行动：允许 协议：TCP 目的端口：53589 验证服务运行 docker ps | grep taskchampion docker logs taskchampion 正常运行时应看到：
...</p></div><footer class=entry-footer><span title='2025-12-27 08:00:00 +0800 +0800'>December 27, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>298 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Taskwarrior Server Config Guide" href=https://starslayerx.github.io/posts/taskwarrior-server-config-guide/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python PEP 683: Immoral Objects</h2></header><div class=entry-content><p>PEP 683 改变了 Python 原有引用计数的一些逻辑，下面简单介绍一下。
CPython 的“引用计数可变性”已经成为并发、性能和未来发展的系统性障碍。
引用对象导致 “逻辑不可变对象” ≠ “物理不可变对象”
在 Cpython 中
None True/False int, str, list 等内建对象 在运行时引用计数会频繁变动，这意味着内存内容在不断被写入，在底层并非真正的 immutable
引用计数写操作降低并发性能
CPU Cache Line 失效
Py_INCREF / Py_DECREF 会写内存 -> cache line invalidation
在多线程 / 多核环境中，同一个全局对象被频繁引用，会造成严重的缓存抖动
fork + Copy-on-Write 失效
父子进程共享内存页
只要引用计数一变 -> 页面被写 -> 触发 COW
只是“多拿了个引用”，却导致整页内存复制
为 free-threading (no GIL) 清扫道路
CPython 的引用计数本质是全局共享的可变状态，在无 GIL 下会产生高频数据竞争。 要么给 refcount 加锁（性能太差），要么让一部分的 refcount 不再变化。
该提案将“对象生命周期模型”划分成了两类对象
对象类型 生命周期 refcount 行为 普通对象 动态 正常增减 不朽对象 解释器级 固定，不参与 gc 这让后续优化和推理都更清晰，也会导致 sys.getrefcount() 不再具有语义价值，测试默认返回 2 的 23 次方减 1。</p></div><footer class=entry-footer><span title='2025-12-23 08:00:00 +0800 +0800'>December 23, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>84 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python PEP 683: Immoral Objects" href=https://starslayerx.github.io/posts/python-pep-683-immoral-objects/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 5: Functions</h2></header><div class=entry-content><p>函数是 Python 的基础模块，本篇会介绍 function application 函数定义、function application 函数应用、scoping rules 作用域规则、closures 闭包、decorators 装饰器和其他函数式编程特性。 特别关注不同的编程习惯 idioms、求值模型以及与函数相关的模式。
Default Arguments 你可以通过在函数定义处赋值的方式，给函数的参数添加默认值，例如：
def split(line, delimiter=","): statements 当一个函数定义了默认参数的时候，其右侧都必须是含有默认值的可选参数。
默认函数参数会在函数首次定义的时候调用一次，这有时会导致出乎意料的行为：
def func(x, items=[]): items.append(x) return items func(1) # returns [1] func(2) # returns [1, 2] func(3) # returns [1, 2, 3] 注意到每次掉都将函数默认值给修改了，要避免这种行为，使用 None 并进行检查：
def func(x, items=None): if not items: items = [] items.append(x) return items 通常来说，建议只使用不可变对象作为默认参数值。
Variadic Arguments 可变参数
如果在最后一个参数前使用 asterisk 星号作为前缀，函数就可以接受可变数量的参数。
def product(first, *args): result = first for x in args: result = result *x return result product(10, 20) # 200 product(2, 3, 4, 5) # 120 在这个例子中，所有的额外参数都作为一个元组放在 args 变量中。 对于元组，你可以使用序列的标准操作处理，如迭代、切片，解包等。
Keyword Arguments 函数参考可以通过显示命名每个参数并指定值来提供函数参数。 这被称为 keyword arguments 关键字参数，例如：
...</p></div><footer class=entry-footer><span title='2025-12-19 08:00:00 +0800 +0800'>December 19, 2025</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>3236 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 5: Functions" href=https://starslayerx.github.io/posts/python-tricks-part-5-functions/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 4: Objects, Types and Protocols</h2></header><div class=entry-content><p>Essential Concepts 每个存储在程序中的数据都是一个对象，每个对象都有一个 identity, type and value （身份、类型和值）。 例如 a = 42 会创建一个整数为 42 的类型，该对象的 identity 是内存中的一个数字，代表其在内存中的位置，a 是这个类的标签，指向这个特定的内存位置，标签本身并非对象的一部分。
object 对象的类型，也被称为 class 类，该类定义了对象的内部数据表示，和支持的方法。 当特定类型的对象创建后，该对象被称为该类的 instance “实例”。 当实例创建后，其 identity 就不会改变。 如果一个对象的值可以被修改，则该对象是可变的 mutable。 如果一个对象的值不可以被修改，则该对象是不可变的 unmutable。 一个持有对其他对象引用的对象，被称为容器。
对象通过其属性来表征，属性是于对象关联的值，通过点 . 运算符来访问。 属性可以是一个简单的值，例如一个数字，也可以是一个被调用以执行某些操作的函数。
这类函数被称为方法，例如下面这个例子
a = 34 # Create an integer n = a.number # Get the numberator (an attribute) b = [1, 2, 3] # Create a list b.append(4) # Add a new element using the append method Object Identity and Type 内置函数 id() 返回对象的 identity，该 identity 是一个整数，通常对应 object 的内存地址。 is 操作符会对比两个对象的 identity，type() 返回对象的类型。
...</p></div><footer class=entry-footer><span title='2025-12-18 08:00:00 +0800 +0800'>December 18, 2025</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>1715 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 4: Objects, Types and Protocols" href=https://starslayerx.github.io/posts/python-tricks-part-4-objects-types-and-protocols/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Shell</h2></header><div class=entry-content><p>Terminal 终端是提供文本用户界面的程序，早期终端是集成设备，键盘和屏幕集成在一起，现在终端知识简单的应用程序。 除了基本的输入输出外，终端还支持将所谓转义序列或转移码，用于光标和屏幕处理，并可能支持颜色。 例如，使用 Ctrl-h 会删除前面一个字符。
环境变量 TERM 可能使用了终端模拟器，其配置可以通过 infocmp 获得
# Reconstructed via infocmp from file: /usr/share/terminfo/74/tmux-256color tmux-256color|tmux with 256 colors, am, hs, km, mir, msgr, xenl, colors#256, cols#80, it#8, lines#24, pairs#32767, acsc=++\,\,--..00``aaffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~, bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z, civis=\E[?25l, clear=\E[H\E[J, cnorm=\E[34h\E[?25h, cr=^M, ... 显示内容看上去很混乱，这些是
Shell shell 是一个运行在终端内部的程序，充当命令解释器。 shell 通过流提供输入和输出处理，支持变量，有一些内置命令，处理命令执行和状态，支持交互式和脚本使用。 最初的 shell 叫做 Bourne shell sh，即作者名字命名，现在通常被 bash 替代，即 “Bourne Again Shell” 的缩写。
file -h /bin/sh Stream shell 为每个进程提供了三个默认的文件描述符 (FD)，用于输入和输出：
...</p></div><footer class=entry-footer><span title='2025-12-18 08:00:00 +0800 +0800'>December 18, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>995 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Shell" href=https://starslayerx.github.io/posts/shell/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://starslayerx.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>