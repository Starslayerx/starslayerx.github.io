<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python Asyncio 02: Asyncio Basics Part 2 | Starslayerx' Blog</title><meta name=keywords content="Python,Asyncio"><meta name=description content='Tasks, coroutines, furtures, and awaitables
Coroutines 和 tasks 都是 await 表达式，那他们的相同线程是哪个？
下面介绍 future 也被称作 awaitable，理解 futures 是理解 asyncio 内部工作的重点。
Introducing futures
Future 代表一个尚未完成的异步操作的最终结果。
from asyncio import Future


my_future = Future()
print(f"Is my_future done? {my_future.done()}")

my_future.set_result(42)
print(f"Is my_future done? {my_future.done()}")

print(f"What is the result of my_future? {my_future.result()}")
输出为
Is my_future done? False
Is my_future done? True
What is the result of my_future? 42
使用构造器 Future 来创建 future，这时 future 没有值，因此调用 done 结果是 False。
然后使用 set_result 设置值，这将 future 标记为 done。
相似的，如果想要在 future 中设置异常，使用 set_exception 方法。'><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-2/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-2/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Python Asyncio 02: Asyncio Basics Part 2"><meta property="og:description" content='Tasks, coroutines, furtures, and awaitables Coroutines 和 tasks 都是 await 表达式，那他们的相同线程是哪个？ 下面介绍 future 也被称作 awaitable，理解 futures 是理解 asyncio 内部工作的重点。
Introducing futures Future 代表一个尚未完成的异步操作的最终结果。
from asyncio import Future my_future = Future() print(f"Is my_future done? {my_future.done()}") my_future.set_result(42) print(f"Is my_future done? {my_future.done()}") print(f"What is the result of my_future? {my_future.result()}") 输出为
Is my_future done? False Is my_future done? True What is the result of my_future? 42 使用构造器 Future 来创建 future，这时 future 没有值，因此调用 done 结果是 False。 然后使用 set_result 设置值，这将 future 标记为 done。 相似的，如果想要在 future 中设置异常，使用 set_exception 方法。'><meta property="og:locale" content="en-US"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-21T08:00:00+08:00"><meta property="article:modified_time" content="2025-11-21T08:00:00+08:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Asyncio"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Python Asyncio 02: Asyncio Basics Part 2"><meta name=twitter:description content='Tasks, coroutines, furtures, and awaitables
Coroutines 和 tasks 都是 await 表达式，那他们的相同线程是哪个？
下面介绍 future 也被称作 awaitable，理解 futures 是理解 asyncio 内部工作的重点。
Introducing futures
Future 代表一个尚未完成的异步操作的最终结果。
from asyncio import Future


my_future = Future()
print(f"Is my_future done? {my_future.done()}")

my_future.set_result(42)
print(f"Is my_future done? {my_future.done()}")

print(f"What is the result of my_future? {my_future.result()}")
输出为
Is my_future done? False
Is my_future done? True
What is the result of my_future? 42
使用构造器 Future 来创建 future，这时 future 没有值，因此调用 done 结果是 False。
然后使用 set_result 设置值，这将 future 标记为 done。
相似的，如果想要在 future 中设置异常，使用 set_exception 方法。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://starslayerx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Python Asyncio 02: Asyncio Basics Part 2","item":"https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python Asyncio 02: Asyncio Basics Part 2","name":"Python Asyncio 02: Asyncio Basics Part 2","description":"Tasks, coroutines, furtures, and awaitables Coroutines 和 tasks 都是 await 表达式，那他们的相同线程是哪个？ 下面介绍 future 也被称作 awaitable，理解 futures 是理解 asyncio 内部工作的重点。\nIntroducing futures Future 代表一个尚未完成的异步操作的最终结果。\nfrom asyncio import Future my_future = Future() print(f\u0026#34;Is my_future done? {my_future.done()}\u0026#34;) my_future.set_result(42) print(f\u0026#34;Is my_future done? {my_future.done()}\u0026#34;) print(f\u0026#34;What is the result of my_future? {my_future.result()}\u0026#34;) 输出为\nIs my_future done? False Is my_future done? True What is the result of my_future? 42 使用构造器 Future 来创建 future，这时 future 没有值，因此调用 done 结果是 False。 然后使用 set_result 设置值，这将 future 标记为 done。 相似的，如果想要在 future 中设置异常，使用 set_exception 方法。\n","keywords":["Python","Asyncio"],"articleBody":"Tasks, coroutines, furtures, and awaitables Coroutines 和 tasks 都是 await 表达式，那他们的相同线程是哪个？ 下面介绍 future 也被称作 awaitable，理解 futures 是理解 asyncio 内部工作的重点。\nIntroducing futures Future 代表一个尚未完成的异步操作的最终结果。\nfrom asyncio import Future my_future = Future() print(f\"Is my_future done? {my_future.done()}\") my_future.set_result(42) print(f\"Is my_future done? {my_future.done()}\") print(f\"What is the result of my_future? {my_future.result()}\") 输出为\nIs my_future done? False Is my_future done? True What is the result of my_future? 42 使用构造器 Future 来创建 future，这时 future 没有值，因此调用 done 结果是 False。 然后使用 set_result 设置值，这将 future 标记为 done。 相似的，如果想要在 future 中设置异常，使用 set_exception 方法。\n注意：在设置值之前如果调用 result 方法，会抛出 invalid state 的报错。\nfuture 也可以在 await 表达式中使用，如果 await 一个 future，就是在说“暂停直到 future 被设置值，并且一但获取值后，就开始处理它”。\n下面是一个网络请求的例子，该请求返回一个 future。 网络请求应该马上完成，但请求会消耗一点时间，在请求完成之前，future 此时并不会被定义。 后面一但请求完成，结果会被设置好，之后就能访问它了。\n这个概念 JavaScript 里的 promises 很像，在 Java 中被称为 completable futures\nimport asyncio from asyncio import Future def make_request() -\u003e Future: future = Future() asyncio.create_task(set_future_value(future)) # Create a task asynchronusly set the value of the future return future async def set_future_value(future) -\u003e None: await asyncio.sleep(1) # waiting 1 second before setting the value of the future future.set_result(42) async def main(): future = make_request() print(f\"Is the future done? {future.done()}\") value = await future # Pause main until the future's value is set print(f\"Is the future done? {future.done()}\") print(value) asyncio.run(main()) 输出如下\nIs the future done? False Is the future done? True 42 实际上在 asyncio 的世界中，很少会需要处理 futures. 例如，会有一些返回 futures 的 asyncio API，和一些要求 futures 的基于回调的代码。 也可能会需要调试一些 asyncio API 代码，asyncio API 严重依赖 futures，因此理解其基本的工作方式很重要。\nThe relationship between futures, tasks, and coroutines 实际上，task 直接继承于 future。\nfuture 可以被看成是一个一段时间内不会拥有的值 task 可以被看作是 future 和 coroutine 的结合 当创建一个 task 的时候，实际上创建了一个运行 coroutine 的空 future。 当 coroutine 完成，将无论是结果还是 exceptinon 都会将其设置到 future。\nTask 和 coroutine 都可以使用 await 关键字，他们都继承于 Awaitable 抽象基类 (abstract base class)。 该方法实现了一个抽象 dunder 双下划线 (double underscore) 方法 __await__。 coroutine 和 future 直接继承了 Awaitable，task 扩展了 future。\nMeasuring coroutine execution time with decorators 首先，可以将每个 await 语句都包装起来，从而跟踪协程的开始和结束时间。\nasync def main(): start = time.time() awati asyncio.sleep(1) end = time.time() print(f\"Sleeping took {end - start} seconds\") 但在有多个协程的情况下，这种方式就会十分混乱。 我们可以创建一个装饰器 decorator 来实现对每个协程在追踪，就叫做 async_timed。\n装饰器是 Python 中的一种模式可以修改函数功能的同时，无需修改函数代码。\nimport time import functools from typing import Callable, Any def async_timed(): def wrapper(func: Callable) -\u003e Callable: @functools.wraps(func) async def wrapped(*args, **kwargs): start = time.time() try: return await func(*args, **kwargs) finally: end = time.time() total = end - start print(f\"finished {func} in {total:.4f} second(s)\") return wrapped return wrapper 现在可以将装饰器作用于任何协程上，这样就能看到运行时间了\nimport asyncio from util import delay, async_timed @async_timed() async def main(): task_one = asyncio.create_task(delay(2)) task_two = asyncio.create_task(delay(3)) await task_one # 注意：task 这里不要加括号 await task_two asyncio.run(main()) 输出文本如下\nStarting with args () {} sleeping for 2 second(s)! sleeping for 3 second(s)! finished sleeping for 2 second(s) finished sleeping for 3 second(s) Finished in 3.0014 second(s) The pitfalls of coroutines and tasks 上面例子可以看到，并发运行能够提升速度，但是如果只是简单地使用 async 来包装成任务，并不一定能够加速运行，反而有时候会降低程序性能。\nCPU-bound 代码在协程/任务中未使用多进程 阻塞 I/O-bound 没有使用多线程 Running CPU-bound code 如果函数运行计算密集任务，例如遍历一个字典或数学计算，如果使用 tasks，将仍然受到 GIL 的限制：\nimport asyncio from util import async_timed @async_timed() async def cpu_bound_work() -\u003e int: counter = 0 for _ in range(100_000_000): counter += 1 return counter @async_timed() async def main(): task_one = asyncio.create_task(cpu_bound_work()) task_two = asyncio.create_task(cpu_bound_work()) await task_one await task_two asyncio.run(main()) 输出是顺序的\nStarting with args () {} Starting with args () {} Finished in 2.7105 second(s) Starting with args () {} Finished in 2.7229 second(s) Finished in 5.4336 second(s) 查看上面输出，可能会人为代码都没有任何问题。但实际上，这会造成性能下降。 尤其是在有其他 coroutines 或 tasks 的情况下。例如，delay 协程。\nimport asyncio from util import async_timed, delay @async_timed() async def cpu_bound_work() -\u003e int: counter = 0 for _ in range(100_000_000): counter += 1 return counter @async_timed() async def main(): task_one = asyncio.create_task(cpu_bound_work()) task_two = asyncio.create_task(cpu_bound_work()) delay_task = asyncio.create_task(delay(4)) await task_one await task_two await delay_task asyncio.run(main()) 输出如下\nStarting with args () {} Starting with args () {} Finished in 2.7227 second(s) Starting with args () {} Finished in 2.7483 second(s) sleeping for 4 second(s)! finished sleeping for 4 second(s) Finished in 9.4727 second(s) 这里的 CPU-bound 任务会阻塞事件循环，这意味着任务会变成两个 2s+ 的 CPU 任务，和一个 4s 的 delay 任务相加。 如果想要在 CPU-bound 仍然使用 async/await，这是可行的，但需要使用 multiprocessing，并告诉 asyncio 在进程池中运行任务。 这个后面章节会介绍。\nRunning blocking APIs 我可能将现存的 I/O-bound 的库包装成协程，然而这会导致同样的问题。 在协程中调用一个 blocking API 会阻塞 main thread，这意味着我们需要暂停其他所有执行中的任务或协程。\n阻塞的例子有 requests 或 time.sleep，通常来说，任何执行 I/O 的非协程或执行耗时的 CPU 操作都可能造成阻塞。 下面以 requests 访问 www.baidu.com 为例，期望应该是用差不多一次的时间，完成 3 次访问请求。\nimport asyncio import requests from util import async_timed @async_timed() async def get_example_status() -\u003e int: return requests.get(\"http://baidu.com\").status_code @async_timed() async def main(): task_1 = asyncio.create_task(get_example_status()) task_2 = asyncio.create_task(get_example_status()) task_3 = asyncio.create_task(get_example_status()) await task_1 await task_2 await task_3 asyncio.run(main()) 输出如下\nStarting with args () {} Starting with args () {} Finished in 0.2021 second(s) Starting with args () {} Finished in 0.1157 second(s) Starting with args () {} Finished in 0.1039 second(s) Finished in 0.4222 second(s) 可以看到实际上花了差不多平均时间的 3 倍，这是因为 requests 库是阻塞的。 如果使用的库不返回一个协程，并且不是使用 await 在自己的协程中，那很可能会导致一个阻塞调用。\n上面的例子中，可以使用 aoihttp 库，该库使用非阻塞 sockets 并且返回协程。 如果要使用 requests 库，需要告诉 asyncio 使用 multiprocessing 库的进程池执行器。\nAccessing and manually managing the event loop 目前，已经介绍了 asyncio.run 来方便地运行应用，并在后台创建事件循环。 但可能有一些 asyncio.run 提供的功能与需要的功能不符，例如让任何剩下的任务完成，而不是等待。 如果想要直接操作 sockets 或控制 tasks 调用在未来特定的时间运行，这将需要访问事件循环。\nCreating an event loop manually 可以使用 asyncio.new_event_loop 方法手动创建一个事件循环，这会创建一个事件循环实例。 通过这种方式，我们可以访问所有 event loop 提供的底层方法。\n事件循环的 run_until_complete 方法接受一个协程，运行它直到完成。 一旦事件循环完成，我们需要关闭和释放资源。 这里应该有一个 finally 块，以防有任何 exceptinons 导致循环没有正常关闭。\nimport asyncio async def main(): await asyncio.sleep(1) loop = asyncio.new_event_loop() try: loop.run_until_complete(main()) finally: loop.close() 这段代码类似 asyncio.run，区别在于它不会取消任何剩余的任务。 如果需要任何特殊的清理逻辑，可以在 finally 块中实现。\nAccessing the event loop 有时我们需要访问正在运行的循环，asyncio 提供 asyncio.get_running_loop 函数来获取当前事件循环。 call_soon 将在事件循环的下一次迭代中调度一个函数运行。\nimport asyncio from util import delay def call_later(): print(\"I'm being called in the future.\") async def main(): loop = asyncio.get_running_loop() loop.call_soon(call_later) await delay(1) asyncio.run(main()) 若当前没有运行中的事件循环，调用此函数会创建一个新的事件循环，这可能导致奇怪的行为。 建议是使用 get_running_loop，在没有事件循环的时候会抛出一个报错，从而避免“惊喜”。\nUsing debug mode asyncio 提供了 debug mode，在这种模式下若协程运行操作 100 毫秒，将会看到几条有用的信息。 此外，如果不 await coroutine 将会抛出报错，这样就能知道何时正确抛出 await。\nUsing asyncio.run asyncio.run 函数有一个 debug 参数，默认是 False，可以将其设置为 True 来开启调试模式。\nasyncio.run(coroutine(), debug=True) 调试模式可以通过参数 -X dev 实现\npython3 -X dev program.py 或者通过python asyncio debug环境变量实现\nPYTHONASYNCIODEBUG=1 python3 program.py 在调试模式下，如果一个协程运行时间过程，就会看到提示信息。 可以使用下面 CPU-bound 代码来测试调试模式\nimport asyncio from util import async_timed @async_timed() async def cpu_bound_work() -\u003e int: counter = 0 for _ in range(100000000): counter += 1 return counter async def main(): task_one = asyncio.create_task(cpu_bound_work()) await task_one asyncio.run(main(), debug=True) 会看到有这样的输出信息\nExecuting ","wordCount":"1049","inLanguage":"en","image":"https://starslayerx.github.io/images/og-default.avif","datePublished":"2025-11-21T08:00:00+08:00","dateModified":"2025-11-21T08:00:00+08:00","author":{"@type":"Person","name":"Starslayerx"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-2/"},"publisher":{"@type":"Organization","name":"Starslayerx' Blog","logo":{"@type":"ImageObject","url":"https://starslayerx.github.io/favicon.svg"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Python Asyncio 02: Asyncio Basics Part 2</h1><div class=post-meta><span title='2025-11-21 08:00:00 +0800 +0800'>November 21, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>1049 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#tasks-coroutines-furtures-and-awaitables>Tasks, coroutines, furtures, and awaitables</a><ul><li><a href=#introducing-futures>Introducing futures</a></li><li><a href=#the-relationship-between-futures-tasks-and-coroutines>The relationship between futures, tasks, and coroutines</a></li><li><a href=#measuring-coroutine-execution-time-with-decorators>Measuring coroutine execution time with decorators</a></li></ul></li><li><a href=#the-pitfalls-of-coroutines-and-tasks>The pitfalls of coroutines and tasks</a><ul><li><a href=#running-cpu-bound-code>Running CPU-bound code</a></li><li><a href=#running-blocking-apis>Running blocking APIs</a></li></ul></li><li><a href=#accessing-and-manually-managing-the-event-loop>Accessing and manually managing the event loop</a><ul><li><a href=#creating-an-event-loop-manually>Creating an event loop manually</a></li><li><a href=#accessing-the-event-loop>Accessing the event loop</a></li></ul></li><li><a href=#using-debug-mode>Using debug mode</a><ul><li><a href=#using-asynciorun>Using asyncio.run</a></li></ul></li><li><a href=#summary>Summary</a></li></ul></nav></div></details></div><div class=post-content><h2 id=tasks-coroutines-furtures-and-awaitables>Tasks, coroutines, furtures, and awaitables<a hidden class=anchor aria-hidden=true href=#tasks-coroutines-furtures-and-awaitables>#</a></h2><p>Coroutines 和 tasks 都是 await 表达式，那他们的相同线程是哪个？
下面介绍 <code>future</code> 也被称作 <code>awaitable</code>，理解 futures 是理解 asyncio 内部工作的重点。</p><h3 id=introducing-futures>Introducing futures<a hidden class=anchor aria-hidden=true href=#introducing-futures>#</a></h3><p>Future 代表一个尚未完成的异步操作的最终结果。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>asyncio</span> <span class=kn>import</span> <span class=n>Future</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>my_future</span> <span class=o>=</span> <span class=n>Future</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Is my_future done? </span><span class=si>{</span><span class=n>my_future</span><span class=o>.</span><span class=n>done</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>my_future</span><span class=o>.</span><span class=n>set_result</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Is my_future done? </span><span class=si>{</span><span class=n>my_future</span><span class=o>.</span><span class=n>done</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;What is the result of my_future? </span><span class=si>{</span><span class=n>my_future</span><span class=o>.</span><span class=n>result</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>输出为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Is my_future done? False
</span></span><span class=line><span class=cl>Is my_future done? True
</span></span><span class=line><span class=cl>What is the result of my_future? 42
</span></span></code></pre></div><p>使用构造器 <code>Future</code> 来创建 future，这时 future 没有值，因此调用 <code>done</code> 结果是 False。
然后使用 <code>set_result</code> 设置值，这将 future 标记为 done。
相似的，如果想要在 future 中设置异常，使用 <code>set_exception</code> 方法。</p><p>注意：在设置值之前如果调用 <code>result</code> 方法，会抛出 invalid state 的报错。</p><p>future 也可以在 await 表达式中使用，如果 await 一个 future，就是在说“暂停直到 future 被设置值，并且一但获取值后，就开始处理它”。</p><p>下面是一个网络请求的例子，该请求返回一个 future。
网络请求应该马上完成，但请求会消耗一点时间，在请求完成之前，future 此时并不会被定义。
后面一但请求完成，结果会被设置好，之后就能访问它了。</p><p>这个概念 JavaScript 里的 promises 很像，在 Java 中被称为 completable futures</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>asyncio</span> <span class=kn>import</span> <span class=n>Future</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>make_request</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=n>Future</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>future</span> <span class=o>=</span> <span class=n>Future</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>set_future_value</span><span class=p>(</span><span class=n>future</span><span class=p>))</span>  <span class=c1># Create a task asynchronusly set the value of the future</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>future</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>set_future_value</span><span class=p>(</span><span class=n>future</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># waiting 1 second before setting the value of the future</span>
</span></span><span class=line><span class=cl>    <span class=n>future</span><span class=o>.</span><span class=n>set_result</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>future</span> <span class=o>=</span> <span class=n>make_request</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Is the future done? </span><span class=si>{</span><span class=n>future</span><span class=o>.</span><span class=n>done</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>value</span> <span class=o>=</span> <span class=k>await</span> <span class=n>future</span>  <span class=c1># Pause main until the future&#39;s value is set</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Is the future done? </span><span class=si>{</span><span class=n>future</span><span class=o>.</span><span class=n>done</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></div><p>输出如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Is the future done? False
</span></span><span class=line><span class=cl>Is the future done? True
</span></span><span class=line><span class=cl>42
</span></span></code></pre></div><p>实际上在 asyncio 的世界中，很少会需要处理 futures.
例如，会有一些返回 futures 的 asyncio API，和一些要求 futures 的基于回调的代码。
也可能会需要调试一些 asyncio API 代码，asyncio API 严重依赖 futures，因此理解其基本的工作方式很重要。</p><h3 id=the-relationship-between-futures-tasks-and-coroutines>The relationship between futures, tasks, and coroutines<a hidden class=anchor aria-hidden=true href=#the-relationship-between-futures-tasks-and-coroutines>#</a></h3><p>实际上，task 直接继承于 future。</p><ul><li>future 可以被看成是一个一段时间内不会拥有的值</li><li>task 可以被看作是 future 和 coroutine 的结合</li></ul><p>当创建一个 task 的时候，实际上创建了一个运行 coroutine 的空 future。
当 coroutine 完成，将无论是结果还是 exceptinon 都会将其设置到 future。</p><p>Task 和 coroutine 都可以使用 await 关键字，他们都继承于 <code>Awaitable</code> 抽象基类 (abstract base class)。
该方法实现了一个抽象 dunder 双下划线 (double underscore) 方法 <code>__await__</code>。
coroutine 和 future 直接继承了 <code>Awaitable</code>，task 扩展了 future。</p><h3 id=measuring-coroutine-execution-time-with-decorators>Measuring coroutine execution time with decorators<a hidden class=anchor aria-hidden=true href=#measuring-coroutine-execution-time-with-decorators>#</a></h3><p>首先，可以将每个 await 语句都包装起来，从而跟踪协程的开始和结束时间。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>awati</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Sleeping took </span><span class=si>{</span><span class=n>end</span> <span class=o>-</span> <span class=n>start</span><span class=si>}</span><span class=s2> seconds&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>但在有多个协程的情况下，这种方式就会十分混乱。
我们可以创建一个装饰器 decorator 来实现对每个协程在追踪，就叫做 <code>async_timed</code>。</p><p>装饰器是 Python 中的一种模式可以修改函数功能的同时，无需修改函数代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>functools</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>typing</span> <span class=kn>import</span> <span class=n>Callable</span><span class=p>,</span> <span class=n>Any</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>async_timed</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>wrapper</span><span class=p>(</span><span class=n>func</span><span class=p>:</span> <span class=n>Callable</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Callable</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nd>@functools.wraps</span><span class=p>(</span><span class=n>func</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>async</span> <span class=k>def</span> <span class=nf>wrapped</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>start</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=k>await</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>finally</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>end</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=n>total</span> <span class=o>=</span> <span class=n>end</span> <span class=o>-</span> <span class=n>start</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;finished </span><span class=si>{</span><span class=n>func</span><span class=si>}</span><span class=s2> in </span><span class=si>{</span><span class=n>total</span><span class=si>:</span><span class=s2>.4f</span><span class=si>}</span><span class=s2> second(s)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>wrapped</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>wrapper</span>
</span></span></code></pre></div><p>现在可以将装饰器作用于任何协程上，这样就能看到运行时间了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>util</span> <span class=kn>import</span> <span class=n>delay</span><span class=p>,</span> <span class=n>async_timed</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@async_timed</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>task_one</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>delay</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>task_two</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>delay</span><span class=p>(</span><span class=mi>3</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>task_one</span>  <span class=c1># 注意：task 这里不要加括号</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>task_two</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></div><p>输出文本如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Starting &lt;function main at 0x100625120&gt; with args () {}
</span></span><span class=line><span class=cl>sleeping for 2 second(s)!
</span></span><span class=line><span class=cl>sleeping for 3 second(s)!
</span></span><span class=line><span class=cl>finished sleeping for 2 second(s)
</span></span><span class=line><span class=cl>finished sleeping for 3 second(s)
</span></span><span class=line><span class=cl>Finished &lt;function main at 0x100625120&gt; in 3.0014 second(s)
</span></span></code></pre></div><h2 id=the-pitfalls-of-coroutines-and-tasks>The pitfalls of coroutines and tasks<a hidden class=anchor aria-hidden=true href=#the-pitfalls-of-coroutines-and-tasks>#</a></h2><p>上面例子可以看到，并发运行能够提升速度，但是如果只是简单地使用 <code>async</code> 来包装成任务，并不一定能够加速运行，反而有时候会降低程序性能。</p><ol><li>CPU-bound 代码在协程/任务中未使用多进程</li><li>阻塞 I/O-bound 没有使用多线程</li></ol><h3 id=running-cpu-bound-code>Running CPU-bound code<a hidden class=anchor aria-hidden=true href=#running-cpu-bound-code>#</a></h3><p>如果函数运行计算密集任务，例如遍历一个字典或数学计算，如果使用 tasks，将仍然受到 GIL 的限制：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>util</span> <span class=kn>import</span> <span class=n>async_timed</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@async_timed</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>cpu_bound_work</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>100_000_000</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>counter</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>counter</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@async_timed</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>task_one</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>cpu_bound_work</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>task_two</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>cpu_bound_work</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>task_one</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>task_two</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></div><p>输出是顺序的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Starting &lt;function main at 0x102bf7420&gt; with args () {}
</span></span><span class=line><span class=cl>Starting &lt;function cpu_bound_work at 0x102639120&gt; with args () {}
</span></span><span class=line><span class=cl>Finished &lt;function cpu_bound_work at 0x102639120&gt; in 2.7105 second(s)
</span></span><span class=line><span class=cl>Starting &lt;function cpu_bound_work at 0x102639120&gt; with args () {}
</span></span><span class=line><span class=cl>Finished &lt;function cpu_bound_work at 0x102639120&gt; in 2.7229 second(s)
</span></span><span class=line><span class=cl>Finished &lt;function main at 0x102bf7420&gt; in 5.4336 second(s)
</span></span></code></pre></div><p>查看上面输出，可能会人为代码都没有任何问题。但实际上，这会造成性能下降。
尤其是在有其他 coroutines 或 tasks 的情况下。例如，<code>delay</code> 协程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>util</span> <span class=kn>import</span> <span class=n>async_timed</span><span class=p>,</span> <span class=n>delay</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@async_timed</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>cpu_bound_work</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>100_000_000</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>counter</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>counter</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@async_timed</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>task_one</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>cpu_bound_work</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>task_two</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>cpu_bound_work</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>delay_task</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>delay</span><span class=p>(</span><span class=mi>4</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>task_one</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>task_two</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>delay_task</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></div><p>输出如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Starting &lt;function main at 0x1028e32e0&gt; with args () {}
</span></span><span class=line><span class=cl>Starting &lt;function cpu_bound_work at 0x10227d120&gt; with args () {}
</span></span><span class=line><span class=cl>Finished &lt;function cpu_bound_work at 0x10227d120&gt; in 2.7227 second(s)
</span></span><span class=line><span class=cl>Starting &lt;function cpu_bound_work at 0x10227d120&gt; with args () {}
</span></span><span class=line><span class=cl>Finished &lt;function cpu_bound_work at 0x10227d120&gt; in 2.7483 second(s)
</span></span><span class=line><span class=cl>sleeping for 4 second(s)!
</span></span><span class=line><span class=cl>finished sleeping for 4 second(s)
</span></span><span class=line><span class=cl>Finished &lt;function main at 0x1028e32e0&gt; in 9.4727 second(s)
</span></span></code></pre></div><p>这里的 CPU-bound 任务会阻塞事件循环，这意味着任务会变成两个 2s+ 的 CPU 任务，和一个 4s 的 delay 任务相加。
如果想要在 CPU-bound 仍然使用 <code>async/await</code>，这是可行的，但需要使用 multiprocessing，并告诉 asyncio 在进程池中运行任务。
这个后面章节会介绍。</p><h3 id=running-blocking-apis>Running blocking APIs<a hidden class=anchor aria-hidden=true href=#running-blocking-apis>#</a></h3><p>我可能将现存的 I/O-bound 的库包装成协程，然而这会导致同样的问题。
在协程中调用一个 blocking API 会阻塞 main thread，这意味着我们需要暂停其他所有执行中的任务或协程。</p><p>阻塞的例子有 <code>requests</code> 或 <code>time.sleep</code>，通常来说，任何执行 I/O 的非协程或执行耗时的 CPU 操作都可能造成阻塞。
下面以 <code>requests</code> 访问 <a href=https://www.baidu.com>www.baidu.com</a> 为例，期望应该是用差不多一次的时间，完成 3 次访问请求。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>requests</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>util</span> <span class=kn>import</span> <span class=n>async_timed</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@async_timed</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>get_example_status</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>requests</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&#34;http://baidu.com&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>status_code</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@async_timed</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>task_1</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>get_example_status</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>task_2</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>get_example_status</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>task_3</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>get_example_status</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>task_1</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>task_2</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>task_3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></div><p>输出如下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Starting &lt;function main at 0x104d363e0&gt; with args () {}
</span></span><span class=line><span class=cl>Starting &lt;function get_example_status at 0x102621120&gt; with args () {}
</span></span><span class=line><span class=cl>Finished &lt;function get_example_status at 0x102621120&gt; in 0.2021 second(s)
</span></span><span class=line><span class=cl>Starting &lt;function get_example_status at 0x102621120&gt; with args () {}
</span></span><span class=line><span class=cl>Finished &lt;function get_example_status at 0x102621120&gt; in 0.1157 second(s)
</span></span><span class=line><span class=cl>Starting &lt;function get_example_status at 0x102621120&gt; with args () {}
</span></span><span class=line><span class=cl>Finished &lt;function get_example_status at 0x102621120&gt; in 0.1039 second(s)
</span></span><span class=line><span class=cl>Finished &lt;function main at 0x104d363e0&gt; in 0.4222 second(s)
</span></span></code></pre></div><p>可以看到实际上花了差不多平均时间的 3 倍，这是因为 requests 库是阻塞的。
如果使用的库不返回一个协程，并且不是使用 <code>await</code> 在自己的协程中，那很可能会导致一个阻塞调用。</p><p>上面的例子中，可以使用 <code>aoihttp</code> 库，该库使用非阻塞 sockets 并且返回协程。
如果要使用 <code>requests</code> 库，需要告诉 asyncio 使用 multiprocessing 库的进程池执行器。</p><h2 id=accessing-and-manually-managing-the-event-loop>Accessing and manually managing the event loop<a hidden class=anchor aria-hidden=true href=#accessing-and-manually-managing-the-event-loop>#</a></h2><p>目前，已经介绍了 <code>asyncio.run</code> 来方便地运行应用，并在后台创建事件循环。
但可能有一些 <code>asyncio.run</code> 提供的功能与需要的功能不符，例如让任何剩下的任务完成，而不是等待。
如果想要直接操作 sockets 或控制 tasks 调用在未来特定的时间运行，这将需要访问事件循环。</p><h3 id=creating-an-event-loop-manually>Creating an event loop manually<a hidden class=anchor aria-hidden=true href=#creating-an-event-loop-manually>#</a></h3><p>可以使用 <code>asyncio.new_event_loop</code> 方法手动创建一个事件循环，这会创建一个事件循环实例。
通过这种方式，我们可以访问所有 event loop 提供的底层方法。</p><p>事件循环的 <code>run_until_complete</code> 方法接受一个协程，运行它直到完成。
一旦事件循环完成，我们需要关闭和释放资源。
这里应该有一个 <code>finally</code> 块，以防有任何 exceptinons 导致循环没有正常关闭。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>loop</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>new_event_loop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>loop</span><span class=o>.</span><span class=n>run_until_complete</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=k>finally</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>loop</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span></code></pre></div><p>这段代码类似 <code>asyncio.run</code>，区别在于它不会取消任何剩余的任务。
如果需要任何特殊的清理逻辑，可以在 <code>finally</code> 块中实现。</p><h3 id=accessing-the-event-loop>Accessing the event loop<a hidden class=anchor aria-hidden=true href=#accessing-the-event-loop>#</a></h3><p>有时我们需要访问正在运行的循环，asyncio 提供 <code>asyncio.get_running_loop</code> 函数来获取当前事件循环。
<code>call_soon</code> 将在事件循环的下一次迭代中调度一个函数运行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>util</span> <span class=kn>import</span> <span class=n>delay</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>call_later</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;I&#39;m being called in the future.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>loop</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>get_running_loop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>loop</span><span class=o>.</span><span class=n>call_soon</span><span class=p>(</span><span class=n>call_later</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>delay</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></div><p>若当前没有运行中的事件循环，调用此函数会创建一个新的事件循环，这可能导致奇怪的行为。
建议是使用 <code>get_running_loop</code>，在没有事件循环的时候会抛出一个报错，从而避免“惊喜”。</p><h2 id=using-debug-mode>Using debug mode<a hidden class=anchor aria-hidden=true href=#using-debug-mode>#</a></h2><p>asyncio 提供了 debug mode，在这种模式下若协程运行操作 100 毫秒，将会看到几条有用的信息。
此外，如果不 await coroutine 将会抛出报错，这样就能知道何时正确抛出 await。</p><h3 id=using-asynciorun>Using asyncio.run<a hidden class=anchor aria-hidden=true href=#using-asynciorun>#</a></h3><p><code>asyncio.run</code> 函数有一个 debug 参数，默认是 <code>False</code>，可以将其设置为 <code>True</code> 来开启调试模式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>coroutine</span><span class=p>(),</span> <span class=n>debug</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span></code></pre></div><p>调试模式可以通过参数 <code>-X dev</code> 实现</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>python3 -X dev program.py
</span></span></code></pre></div><p>或者通过<code>python asyncio debug</code>环境变量实现</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>PYTHONASYNCIODEBUG</span><span class=o>=</span><span class=m>1</span> python3 program.py
</span></span></code></pre></div><p>在调试模式下，如果一个协程运行时间过程，就会看到提示信息。
可以使用下面 CPU-bound 代码来测试调试模式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>util</span> <span class=kn>import</span> <span class=n>async_timed</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@async_timed</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>cpu_bound_work</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>100000000</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>counter</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>counter</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>task_one</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>cpu_bound_work</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>task_one</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(),</span> <span class=n>debug</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span></code></pre></div><p>会看到有这样的输出信息</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Executing &lt;Task finished <span class=nv>name</span><span class=o>=</span><span class=s1>&#39;Task-2&#39;</span> <span class=nv>coro</span><span class=o>=</span>&lt;cpu_bound_work<span class=o>()</span> <span class=k>done</span>, defined at /Users/starslayerx/asyncio/util/async_timer.py:8&gt; <span class=nv>result</span><span class=o>=</span><span class=m>100000000</span> created at /Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/tasks.py:420&gt; took 6.085 seconds
</span></span></code></pre></div><p>当调用被意外阻塞的时候，这样的调试将会很有用。
默认设置下，如果一个协程运行超过 100 毫秒将会显示这个错误，但这可能并不是我们期望的。
可以通过访问事件循环，并修改 <code>slow_callback_duration</code> 来自定义时间，这是个浮点值，单位为秒。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>loop</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>get_event_loop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>loop</span><span class=o>.</span><span class=n>slow_callback_duration</span> <span class=o>=</span> <span class=mf>.250</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>(),</span> <span class=n>debug</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span></code></pre></div><p>这里意思是说时间大于 0.250 秒的会输出调试信息。</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><ul><li>使用 async 关键字创建协程</li><li>使用 await 关键字暂停/调用协程</li><li>使用 asyncio.run 执行单个协程，并作为程序的入口函数</li><li>使用 tasks 并发运行多个协程</li><li>取消协程，取消协程会抛出一个 CancelledError 错误；为协程添加超时时间，使用 asyncio.wait_for 设置超时时间，否则抛出 TimeoutError</li><li>避免在协程中运行 cpu-bound 任务</li><li>使用 debug 调试模式</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://starslayerx.github.io/tags/python/>Python</a></li><li><a href=https://starslayerx.github.io/tags/asyncio/>Asyncio</a></li></ul><nav class=paginav><a class=prev href=https://starslayerx.github.io/posts/fastapi-app-and-request/><span class=title>« Prev</span><br><span>FastAPI app and request</span>
</a><a class=next href=https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-1/><span class=title>Next »</span><br><span>Python Asyncio 02: Asyncio Basics Part 1</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 02: Asyncio Basics Part 2 on x" href="https://x.com/intent/tweet/?text=Python%20Asyncio%2002%3a%20Asyncio%20Basics%20Part%202&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-02-asyncio-basics-part-2%2f&amp;hashtags=Python%2cAsyncio"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 02: Asyncio Basics Part 2 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-02-asyncio-basics-part-2%2f&amp;title=Python%20Asyncio%2002%3a%20Asyncio%20Basics%20Part%202&amp;summary=Python%20Asyncio%2002%3a%20Asyncio%20Basics%20Part%202&amp;source=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-02-asyncio-basics-part-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 02: Asyncio Basics Part 2 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-02-asyncio-basics-part-2%2f&title=Python%20Asyncio%2002%3a%20Asyncio%20Basics%20Part%202"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 02: Asyncio Basics Part 2 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-02-asyncio-basics-part-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 02: Asyncio Basics Part 2 on whatsapp" href="https://api.whatsapp.com/send?text=Python%20Asyncio%2002%3a%20Asyncio%20Basics%20Part%202%20-%20https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-02-asyncio-basics-part-2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 02: Asyncio Basics Part 2 on telegram" href="https://telegram.me/share/url?text=Python%20Asyncio%2002%3a%20Asyncio%20Basics%20Part%202&amp;url=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-02-asyncio-basics-part-2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Python Asyncio 02: Asyncio Basics Part 2 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Python%20Asyncio%2002%3a%20Asyncio%20Basics%20Part%202&u=https%3a%2f%2fstarslayerx.github.io%2fposts%2fpython-asyncio-02-asyncio-basics-part-2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>