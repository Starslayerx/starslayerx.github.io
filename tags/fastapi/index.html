<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>FastAPI | Starslayerx' Blog</title><meta name=keywords content><meta name=description content="A personal blog about technology, programming, and daily notes"><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/tags/fastapi/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://starslayerx.github.io/tags/fastapi/index.xml title=rss><link rel=alternate hreflang=en href=https://starslayerx.github.io/tags/fastapi/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/tags/fastapi/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="FastAPI"><meta property="og:description" content="A personal blog about technology, programming, and daily notes"><meta property="og:locale" content="en-US"><meta property="og:type" content="website"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="FastAPI"><meta name=twitter:description content="A personal blog about technology, programming, and daily notes"></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/tags/>Tags</a></div><h1>FastAPI
<a href=/tags/fastapi/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>FastAPI app and request</h2></header><div class=entry-content><p>在 FastAPI 中，Request 对象和 FastAPI 应用实例 (app) 是核心概念，它们在应用状态管理和依赖注入中扮演着关键角色。 本文将介绍它们的关系、设计理念，以及如何利用 app.state 实现单例模式。
FastAPI 对象 FastAPI 对象是整个应用的核心实例：
from fastapi import FastAPI app = FastAPI(title="示例应用") 核心职责 路由管理：通过 @app.get()、@app.post() 等装饰器定义 URL 到视图函数的映射。 中间件和事件管理：可注册中间件处理请求/响应，支持 startup 与 shutdown 事件。 应用状态管理：提供 app.state，可存放全局单例对象、数据库连接池、配置等。 异常处理与依赖注入：管理异常处理器，并协助依赖注入机制。 单例模式存储 这里要使用 app 的 State 对象存储单例，app 中定义如下
# app self.state: Annotated[ State, Doc( """ A state object for the application. This is the same object for the entire application, it doesn't change from request to request. You normally wouldn't use this in FastAPI, for most of the cases you would instead use FastAPI dependencies. This is simply inherited from Starlette. Read more about it in the [Starlette docs for Applications](https://www.starlette.dev/applications/#storing-state-on-the-app-instance). """ ), ] = State() State 源码如下，简单看就是一个字典
...</p></div><footer class=entry-footer><span title='2025-11-25 08:00:00 +0800 +0800'>November 25, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>388 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to FastAPI app and request" href=https://starslayerx.github.io/posts/fastapi-app-and-request/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fastapi Lifespan Events</h2></header><div class=entry-content><p>Lifespan Events 生命周期事件 通过生命周期事件可以定义在应用开启之前需要执行的代码，这意味着这些代码会在开始接收外部请求之前被执行一次。 同样地，也可以定义应用在关闭的时候定义需要执行的代码，在尽力处理完所有请求后，该代码会被执行一次。
这对于设置需要在整个 app 的请求间共享的资源时非常有用，或者是需要进行清理工作的时候。 例如，一个数据库连接池，或者加载一个共享的机器学习模型。
Use Case 使用示例 下面通过一个例子说明如何使用。
假如你有一个机器学习模型，并且需要让其处理请求，由于请求都共享同一个模型，因此不是一个请求对应一个模型，或一个用户一个模型。 假设模型加载需要一定的时间，因为要从磁盘中读取大量的数据，因此不能每个请求都去加载一次。 你可以在顶层的模块文件中定义加载，但这意味着当进行简单的自动化测试的时候，也会加载该模型，这样就会很慢。
这就是需要解决的问题，需要在请求响应之前加载模型，也不是在代码被加载的时候加载模型。
Lifespan 生命周期 可以通过在 FastAPI app 中使用 lifespan 参数来定义启动和关闭逻辑，以及一个 “context manager” (上下文管理器)。
通过下面这种方法创建一个含 yield 的 function
from contextlib import asynccontextmanager from fastapi impor FastAPI def fake_answer_to_everything_ml_model(x: float): return x * 42 ml_models = {} @asynccontextmanager async def lifespan(app: FastAPI): # Load the ML model ml_models["answer_to_everything"] = fake_answer_to_everything_ml_model yield # Clean up the ML models and release the resources ml_models.clear() app = FastAPI(lifespan=lifespan) @app.get("/predict") async def predict(x: float): result = ml_models["answer_to_everything"](x) return {"result": result} 这里在生成器 yield 之前将模拟的昂贵函数放入机器学习字典中。 这段代码将在应用程序接收请求之前执行，即启动阶段。
...</p></div><footer class=entry-footer><span title='2025-10-24 08:00:00 +0800 +0800'>October 24, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>245 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Fastapi Lifespan Events" href=https://starslayerx.github.io/posts/fastapi-lifespan-events/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fastapi CORS</h2></header><div class=entry-content><p>CORS 或 “Corss-Origin Resource Sharing” 即“跨域资源共享”，指的当前端在浏览器中运行的 JavaScript 代码与后端进行通信，而后端与前端“源”不同的情况。
Origin 源</p></div><footer class=entry-footer><span title='2025-10-11 08:00:00 +0800 +0800'>October 11, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>10 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Fastapi CORS" href=https://starslayerx.github.io/posts/fastapi-cors/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fastapi Background Tasks</h2></header><div class=entry-content><p>Background Tasks 后台任务 你可以定义一个在返回响应之后运行的后台任务。 这对请求之后执行一些操作十分有用，客户端无需一直等待操作任务完成再接收响应。
这包含一些例子：
执行操作后发送电子邮件
由于连接邮件服务器并发送邮件一般会比较“慢”（几秒钟），你可以立刻返回响应并在后台发送邮件请求。 处理数据
例如，你收到了一个文件需要缓慢处理，你可以返回一个 “Accepted” 响应 (HTTP 202) 并在后台处理文件。 Using Background Tasks 使用后台任务 首先要导入 BackgroundTasks 并在执行函数中定义一个路径参数，使用 BackgroundTasks 类型声明。
from fastapi import BackgroundTasks, FastAPI app = FastAPI() def write_notification(email: str, message=""): with open("log.txt", mode="w") as email_file: content = f"notification for {email}: {message}" email_file.write(content) @app.post("/send-notification/{email}") async def send_notification(email: str, backgroud_tasks: Background(Tasks): # Add parameter here background_tasks.add_task(write_notification, email, message="some notification") # add backgroud task here return {"message": "Notification sent in the background"} Create a task function 创建任务函数 创建一个函数放到后台运行，只是一个接收参数的基本函数，可以是 async def 或者就普通的 def 函数，FastAPI 会正确的处理它。
在这个例子中的任务函数将会编写文件，并且写入操作不使用 async 或 await 故使用 def 定义了一个基本的函数。
...</p></div><footer class=entry-footer><span title='2025-10-10 08:00:00 +0800 +0800'>October 10, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>261 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Fastapi Background Tasks" href=https://starslayerx.github.io/posts/fastapi-background-tasks/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fastapi Middleware</h2></header><div class=entry-content><p>Middleware 你可以添加中间件到 FastAPI 应用中。
“中间件” 是一个函数，它在每个请求被特定路径操作之前对其进行处理，同时在每个响应返回之前也对其进行处理。
在到达应用程序之前处理请求 可以在请求中做一些事情，或运行任何需要的代码 将处理后的请求传递给应用程序 之后处理应用程序返回的响应 可以对响应做一些事情，或运行任何需要的代码 然后返回响应 Create a Middleware 创建一个中间件 想要创建一个中间件，你可以在函数上面使用装饰器 @app.middleware("http")，该函数接受：
request 请求 一个函数 call_next 并将会接收 request 作为一个参数 该函数会将 request 传递给对应的路径操作 然后返回对应路由操作生成的 response 你可以修改或者直接返回 response import time from fastapi import FastAPI, Request app = FastAPI() @app.middleware("http") async def add_process_time_header(request: Request, call_next): ... TIP
自定义专属 headers 可以使用 X-prefix 来添加。
但如果你有一个自定义的 header 并想要客户端能够看到这些信息，你需要使用 Starlette’s CORS docs 中的参数参数 expose_headers 将其加入你的 CORS 设置里 (CORS (Corss-Origin Resource Sharing))。
Before and after the response 在响应前后 你也可以在 request 前后运行代码，也可以在 response 前后运行代码。
...</p></div><footer class=entry-footer><span title='2025-10-09 08:00:00 +0800 +0800'>October 9, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>164 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Fastapi Middleware" href=https://starslayerx.github.io/posts/fastapi-middleware/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Microservice with FastAPI</h2></header><div class=entry-content><p>What are microservices ? 什么是微服务? 微服务可以有多种不同的定义方式, 具体取决于希望强调微服务架构的哪个方面, 不同作者会给出略有不同但相关的定义
Sam Newman, 微服务领域最有影响力的作者之一, 给出了一个极简的定义:
“Microservices are small, autonomous services that work together.”
这个定义强调了这样一个事实: 微服务是彼此独立运行的应用程序, 但它们可以协作完成任务. 该定义还强调微服务是 “small (小的)”, 这里的 small 并不是指微服务代码量的大小, 而是指微服务具有狭窄且定义清晰的职责范围, 符合单一职责原则(Single Responsibility Principle) —— 即“只做一件事，并把它做好”.
James Lewis 和 Martin Fowler 撰写的一篇开创性文章提供了一个更详细的定义, 他们将微服务定义为一种架构风格(architectural style)
“an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API”
...</p></div><footer class=entry-footer><span title='2025-08-15 08:00:00 +0800 +0800'>August 15, 2025</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1167 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Microservice with FastAPI" href=https://starslayerx.github.io/posts/microservice-with-fastapi/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>FastAPI Response Model</h2></header><div class=entry-content><p>本篇文章介绍 FastAPI 的返回类型 response model
可以在返回函数的类型注解中声明该接口的响应数据类型
类型注解的用法和输入数据参数一样, 可以使用:
Pydantic 模型 list 列表 dict 字典 scalar 标量值 (int, bool …) @app.post("/items/") async def create_item(item: Item) -> Item: ... @app.get("/items/") async def read_items() -> list[Item]: ... FastAPI 会使用返回类型完成一下事情:
验证返回类型 如果返回的数据无效, 说明业务代码有问题, FastAPI 会返回服务器错误, 而不是把数据发给客户端
在 OpenAPI 中为响应添加 JSON Schema 用于自动生成接口文档, 自动生成客户端代码
最重要的是 它会限制并过滤出数据, 只保留返回类型中定义的字段
response_model Parameter 有时候可能需要返回的数据和类型注解不完全一致, 例如:
可能想返回字典或数据库对象, 但声明的响应类型为 Pydantic 模型 这样 Pydantic 会做数据文档、验证等工作, 即使返回的是字典或 ORM 对象 如果直接用返回类型注解, 编辑器会提示类型不匹配的错误
这种情况下, 可以用路径装饰器的 response_model 参数来声明响应类型, 而不是用返回类型注解
class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list[str] = [] @app.post("/items/", response_model=Item) async def create_item(item: Item) -> Any: return item @app.get("/items/", response_model=list[Item]) async def read_items() -> Any: return [ {"name": "Portal Gun", "price": 42.0}, {"name": "Plumbus", "price": 32.0}, ] 注意:
...</p></div><footer class=entry-footer><span title='2025-08-12 08:00:00 +0800 +0800'>August 12, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>918 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to FastAPI Response Model" href=https://starslayerx.github.io/posts/fastapi-response-model/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fastapi Cookie and Header Parameters</h2></header><div class=entry-content><p>这篇文章介绍 Fastapi 的 Cookie 和 Header 参数
Cookie Parameters 通过定义 Query 和 Path 参数一样定义 Cookie 参数
from typing Annotated from fastapi import Cookie, FastAPI app = FastAPI() @app.get("/items/") async def read_items(ads_id: Annotated[str | None, Cookie()] = None): return {"ads_id": ads_id} Cookie Parameters Models 如果有一组相关的 cookies, 可以使用 Pydantic model 来声明.
这样可以在多个部分复用这个模型, 同时还能一次性为所有参数声明验证规则和元数据.
下面使用 Pydantic 模型定义 Cookies, 然后将参数声明为 Cookie
from typing import Annotated from fastapi import FastAPI, Cookie from pydantic import BaseModel app = FastAPI() class Cookie(BaseModel): session_id: str fatebook_tracker: str | None = None googall_tracker: str | None = None @app.get("/items/") async def read_items(cookies: Annotated[Cookies, Cookie()]): return cookies Forbid Extra Cookies 禁止额外的Cookie 在某些场景下(虽然并不常见), 可能希望限制 API 只能接收特定的 Cookie. 这样, API 就可以"自己"管理 Cookie 同意策略了.
from typing import Annotated from fastapi import FastAPI, Cookie from pydantic import BaseModel app = FastAPI() class Cookies(BaseModel): model_config = {"extra": "forbid"} # forbid extra cookies session_id: str fatebook_tracker: str | None = None googall_tracker: str | None = None @app.get("/items/") async def read_items(cookies: Annotated[Cookies, Cookie()]): return cookies 这样, 如果客户端发送额外的 cookies, 则会收到一个错误响应. 例如, 客户端发送了 santa_tracker 这个额外 Cookie
...</p></div><footer class=entry-footer><span title='2025-08-11 08:00:00 +0800 +0800'>August 11, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>499 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Fastapi Cookie and Header Parameters" href=https://starslayerx.github.io/posts/fastapi-cookie-and-header-parameters/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>FastAPI Body Advanced Uses</h2></header><div class=entry-content><p>本篇文章介绍 FastAPI Request Body 的进阶用法
Body - Multiple Parameters 首先, 可以将Path, Query 和 request body 参数声明自由的写在一起
对于 request body 参数可以是可选的, 并且可设置为默认的 None
from typing import Annotated from fastapi import FastAPI, Path from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None @app.put("/items/{item_id}") async def update_item( item_id: Annotated[int, Path(title="The ID of the item to get", ge=0, le=1000)], # Path q: str | None = None, # Query item: Item | None = None, # body ): results = {"item_id": item_id} if q: results.update({"q": q}) if item: results.update({"item": item}) return results Multiple body parameters 多参数请求体 在上面例子中, FastAPI 期望一个包含 Item 属性的 JSON body, 例如
{ "name": "Foo", "description": "The pretender", "price": 42.0, "tax": 3.2 } 但也可以声明多个body parameters, 例如 item 和 user
...</p></div><footer class=entry-footer><span title='2025-08-09 08:00:00 +0800 +0800'>August 9, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>911 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to FastAPI Body Advanced Uses" href=https://starslayerx.github.io/posts/fastapi-body-advanced-uses/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>FastAPI Parameters and Validations</h2></header><div class=entry-content><p>这篇文章介绍 FastAPI 中的参数验证功能
Query Parameters and String Validations FastAPI 允许为参数声明额外的信息和验证规则
from fastapi import FastAPI app = FastAPI() @app.get("/items/") async def read_items(q: str | None = None): results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]} if q: results.update({"q": q}) return results q 是类型为 str | None 的查询参数, 这意味着它可以是字符串, 也可以是 None. 其默认值是 None, 因此 FastAPI 会识别它为“可选参数”
FastAPI 通过 = None 的默认值知道该参数是非必填的
使用 str | None 还能帮助编辑器提供更好的类型提示和错误检测
Additional validation 额外验证 即使 q 是可选的, 但仍然可以设置条件: 如果提供了 q, 则长度不能超过50个字符
使用 Query 和 Annotated 来实现
from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get("/items/") async def read_items(q: Annotated[str | None, Query(max_length=50)] = None): results = {"items": [{"item_id": "Foo"}, {"item_id": "Bar"}]} if q: results.update({"q": q}) return results 使用 Annotated 包装后, 就可以传递额外的元数据(Query(max_length=5)), 用于校验或者文档
...</p></div><footer class=entry-footer><span title='2025-08-07 08:00:00 +0800 +0800'>August 7, 2025</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>779 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to FastAPI Parameters and Validations" href=https://starslayerx.github.io/posts/fastapi-parameters-and-validations/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://starslayerx.github.io/tags/fastapi/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>