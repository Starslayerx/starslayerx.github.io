<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Hack on Starslayerx' Blog</title><link>https://starslayerx.github.io/tags/hack/</link><description>Recent content in Hack on Starslayerx' Blog</description><image><title>Starslayerx' Blog</title><url>https://starslayerx.github.io/images/og-default.avif</url><link>https://starslayerx.github.io/images/og-default.avif</link></image><generator>Hugo -- 0.154.5</generator><language>en-US</language><lastBuildDate>Mon, 04 Aug 2025 08:00:00 +0800</lastBuildDate><atom:link href="https://starslayerx.github.io/tags/hack/index.xml" rel="self" type="application/rss+xml"/><item><title>Executing arbitrary Python code from a comment</title><link>https://starslayerx.github.io/posts/executing-arbitrary-python-code-from-a-comment/</link><pubDate>Mon, 04 Aug 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/executing-arbitrary-python-code-from-a-comment/</guid><description>&lt;p&gt;通过注释执行任意Python代码&lt;/p&gt;
&lt;h3 id="问题描述"&gt;问题描述&lt;/h3&gt;
&lt;p&gt;Q: 只能控制一行的.py代码中注释的内容(\n\r均会被替换为空字符), 如何执行任意代码?&lt;br&gt;
A: 在注释#中, 构造一个.zip 文件, python 会将该内容当成一个zip包执行, 触发任意代码执行&lt;/p&gt;
&lt;h3 id="解决方案"&gt;解决方案&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从 Python 3.5 起, 可以直接执行一个 .zip 文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python3" data-lang="python3"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="n"&gt;myapp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zip&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;前提是ZIP 包中包含一个顶层的&lt;code&gt;__main__.py&lt;/code&gt;文件, Python 会把它当作 zipapp, 自动解压并运行&lt;code&gt;__main__.py&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python 会从末尾找到 ZIP 的目录结构, 而不是依赖文件头, 所以前面的“垃圾”字节会被忽略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python 源码中的任何行, 只要以 # 开头, 解释器都会忽略后面内容, 因此可以:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把 ZIP 文件的数据藏在 Python 源码中的注释中（开头加 #）&lt;/li&gt;
&lt;li&gt;把 ZIP 数据直接拼接在 Python 文件的后面, 只保证文件头部分是合法 Python&lt;/li&gt;
&lt;li&gt;ZIP 不关心前缀, Python 只要最前面是有效源码, 也不会管后面&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="难点"&gt;难点&lt;/h3&gt;
&lt;p&gt;ZIP 文件头包含&lt;strong&gt;二进制字段&lt;/strong&gt;，比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;偏移量（文件数据相对于 ZIP 开头的位置）&lt;/li&gt;
&lt;li&gt;长度（文件名长度、注释长度等）&lt;/li&gt;
&lt;li&gt;这些值写死在 header 里, 是十六进制整数&lt;/li&gt;
&lt;li&gt;如果这些字节中出现了像 \x00、\xFF 等非 ASCII 内容, Python 就不能把它当注释&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决方法: 暴力穷举合法组合&lt;/p&gt;</description></item></channel></rss>