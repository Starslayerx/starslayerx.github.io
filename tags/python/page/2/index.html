<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python | Starslayerx' Blog</title><meta name=keywords content><meta name=description content="A personal blog about technology, programming, and daily notes"><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/tags/python/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://starslayerx.github.io/tags/python/index.xml title=rss><link rel=alternate hreflang=en href=https://starslayerx.github.io/tags/python/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/tags/python/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Python"><meta property="og:description" content="A personal blog about technology, programming, and daily notes"><meta property="og:locale" content="en-US"><meta property="og:type" content="website"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Python"><meta name=twitter:description content="A personal blog about technology, programming, and daily notes"></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/tags/>Tags</a></div><h1>Python
<a href=/tags/python/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python asyncio 03: A first asyncio application</h2></header><div class=entry-content><p>Working with blocking sockets socket 是在网络中读取和写入数据的一种方式。 可以将 socket 看成一个邮件，将信封放到里面后运送到接收者的地址。
下面使用 Python 的内置 socket 模块来创建一个简单的 server
import socket server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) 这里，给 socket 函数指定了两个参数，第一个是 socket.AF_INET，这个告诉我们要与什么类型的地址进行交互，在这个例子中是 hostname 和 phonenumber。 第二个是 socket.SO_REUSEADDR，这个参数是说我们使用 TCP 协议进行交互。
然后使用 socket.setsockopt 方法将 socket.SOL_SOCKET 标志设置为 1。这将允许在关闭和快速重启应用，避免 address already in use 这类错误，如果不这样做将会消耗操作系统一段时间来解除与 port 的绑定。
使用 socket.socket 创建 socket 后，并不能开始沟通，因为还没有将其绑定到任何地址上面。 在本例中，将使用电脑本地地址 127.0.0.1 和任意 port 8000
server_address = ('127.0.0.1', 8000) server_socket.bind(server_address) 这里将地址设置为 127.0.0.1:8000，这意味着 client 将能够使用该地址向服务器发送数据，如果要向 client 发送数据，也会看到该地址为来源地址。
接下来，在套接字上调用 listen 方法，主动监听来自客户端的连接请求。 随后，通过调用 accept 方法等待连接建立。 该方法会保持阻塞状态直至接收到连接请求，当连接成功时，将返回一个连接对象及客户端地址。 这个连接对象本质上是一个新的套接字，可以用于与客户端进行双向数据通信
server_socket.listen() connection, client_address = server_socket.accept() 有了这些组件，我们便掌握了创建基于套接字的服务器应用所需的所有基础模块。 该应用将等待连接，并在建立连接后打印提示信息。
...</p></div><footer class=entry-footer><span title='2025-12-01 08:00:00 +0800 +0800'>December 1, 2025</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>1975 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python asyncio 03: A first asyncio application" href=https://starslayerx.github.io/posts/python-asyncio-03-a-first-asyncio-application/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Asyncio 02: Asyncio Basics Part 2</h2></header><div class=entry-content><p>Tasks, coroutines, furtures, and awaitables Coroutines 和 tasks 都是 await 表达式，那他们的相同线程是哪个？ 下面介绍 future 也被称作 awaitable，理解 futures 是理解 asyncio 内部工作的重点。
Introducing futures Future 代表一个尚未完成的异步操作的最终结果。
from asyncio import Future my_future = Future() print(f"Is my_future done? {my_future.done()}") my_future.set_result(42) print(f"Is my_future done? {my_future.done()}") print(f"What is the result of my_future? {my_future.result()}") 输出为
Is my_future done? False Is my_future done? True What is the result of my_future? 42 使用构造器 Future 来创建 future，这时 future 没有值，因此调用 done 结果是 False。 然后使用 set_result 设置值，这将 future 标记为 done。 相似的，如果想要在 future 中设置异常，使用 set_exception 方法。
...</p></div><footer class=entry-footer><span title='2025-11-21 08:00:00 +0800 +0800'>November 21, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>1049 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Asyncio 02: Asyncio Basics Part 2" href=https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Asyncio 02: Asyncio Basics Part 1</h2></header><div class=entry-content><p>Introducing coroutines 创建一个协程 coroutine 而不是创建一个函数类型，使用 async def 关键字，而不是 def:
async def coroutine_add_one(number: int) -> int: return number + 1 def add_one(number: int) -> int: return number + 1 function_result = add_one(1) coroutine_result = coroutine_add_one(1) print(f"Function result is {function_result} and the type is {type(function_result)}") print(f"Coroutine result is {coroutine_result} and the type is {type(coroutine_result)}") 输出如下
Function result is 2 and the type is &lt;class 'int'> Coroutine result is &lt;coroutine object coroutine_add_one at 0x103000a00> and the type is &lt;class 'coroutine'> 可以看到，协程返回的不是值，而是一个协程对象。 这里协程并没有执行，而是创建了一个协程对象可在之后运行，要运行一个协程则必须显式地在一个事件循环中运行它。 在 Python 3.7 之后的版本，必须创建事件循环来运行它。 asyncio 库添加了多个函数，抽象了事件循环的管理，例如 asyncio.run()，可以使用它来运行协程：
...</p></div><footer class=entry-footer><span title='2025-11-20 08:00:00 +0800 +0800'>November 20, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>637 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Asyncio 02: Asyncio Basics Part 1" href=https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Asyncio 01: Getting to know asyncio</h2></header><div class=entry-content><p>Python asyncio 基础篇 本篇包含
asyncio 是什么以及如何使用它 concurrency 并发、parallelism 并行、threads 线程和 processes 进程 GIL (global interpreter lock) 全局解释器锁和其带来的并发跳转 非阻塞 sockets 如何只通过一个线程实现并发 基于事件循环 (event-loop-based) 并发的基本原理 异步编程 (asynchronous programming) 意思是可以在主程序之外，额外运行一个特定的长时运行的任务。
一个 coroutine 协程是一种方法，协程是一种方法，当遇到可能长时间运行的任务时，它可以暂停执行，并在任务完成后恢复执行。
asyncio 这个库的名称可能让人人为其只适合编写 I/O 操作，但实际上该库可以和 threading 和 multiprocessing 库结合使用。 基于这种 interoperability 互操作性，可以使用 async/await 关键字让工作流更加容易理解。 这意味着，asyncio 不仅适合 I/O 的并发，也可以在 CPU 密集操作中使用。
所谓的 I/O-bound 和 CPU-bound 是指限制程序运行更快的主要因素，这意味着如果增加该方面的性能，程序就能够在更短的时间内完成。
下面是一些例子
I/O 密集操作：网络请求、文件读取 CPU 密集操作：循环遍历文件夹、计算 pi import requests response = requests.get('https://www.example.com') # 1 items = response.headers.items() headers = [f'{key}: {headers}' for key, header in items] # 2 formatted_headers = '\n'.join(headers) # 3 with open('headers.txt', 'w') as file: # 4 file.write(formatted_headers) I/O-bound 网络请求 CPU-bound 响应处理 CPU-bound 字符串拼接 I/O-bound 写入磁盘 Concurrency 并发 和 Parallelism 并行的区别这里就不多说了。
...</p></div><footer class=entry-footer><span title='2025-11-19 08:00:00 +0800 +0800'>November 19, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>587 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Asyncio 01: Getting to know asyncio" href=https://starslayerx.github.io/posts/python-asyncio-01-getting-to-know-asyncio/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Complete Python Logging Guide</h2></header><div class=entry-content><p>Python logging 基础指南 实际项目中，print() 只能满足基本的输出要求，而 logging 模块提供了更灵活、分级别、可配置的日志系统。
核心概念 Logger 记录器
记录器是拿来写日志的东西
logger = logging.getLogger(__name__) logger.info("开始执行任务") 接收日志消息，按级别判断是否要输出，并交给 Handler
Handler 处理器
决定日志“去哪里”，有下面常见 Handler
StreamHandler: 输出到控制台 FileHandler: 写入文件 RotatingFileHandler: 自动滚动文件 SMTHandler: 发邮件 SocketHandler: 发送到日志服务器 一个 Logger 可以挂多个 Handler
Formatter 格式器
负责日志的格式
'%(asctime)s - %(levelname)s - %(name)s - %(message)s' 所有 Handler 都可以设置自己的 Formatter，不同输出渠道可以呈现不同格式
LogRecord 日志记录对象
每次调用 logging.info("hello") 内部都会生成一个 LogRecord 对象
LogRecord 是日志系统的“消息载体”，包括全部的元数据，例如：
时间戳 模块名 文件名、行号 日志级别 写入消息 message 线程 ID、进程 ID Filter 过滤器
Filter 是更细粒度的筛选工具，可以控制某个模块的日志，阻止某些关键字，基于上下文附加标签等。
简单使用 import logging logging.basicConfig( # 输出 INFO 及以上几倍日志 level=logging.INFO, # 时间 - 模块名 - 级别 - 消息内容 format='%(asctime)s - %(name)s - %(levelname)s - %(message)s' ) logging.info("程序已启动") logging.warning("磁盘空间将不足") logging.error("读取文件失败") 使用 Logger 对象：在较大的项目中，不会使用基础配置，而是为每个模块创建自己的 logger
...</p></div><footer class=entry-footer><span title='2025-11-11 08:00:00 +0100 +0100'>November 11, 2025</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>1920 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Complete Python Logging Guide" href=https://starslayerx.github.io/posts/complete-python-logging-guide/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Standrad Library - File and Directory Access - pathlib</h2></header><div class=entry-content><p>pathlib - Object-oriented filesystem paths 此模块提供表示文件系统路径的类，其语义适用于不同的操作系统。 路径类分为：
用于纯计算无 I/O 的 pure paths 继承 pure paths 但是有 I/O 操作的 concrete paths 基本使用 导入 Path
from pathlib import Path p = Path('.') 列出所有子目录
[x for x in p.iterdir() if x.is_dir()] 列出所有 py 源码文件
list(p.glob('**/*.py')) 在目录树中移动
p = Path('/etc') q = p / 'init.d' / 'reboot' # .resolve() 方法会解析所有符号链接，返回文件绝对路径 # mac os 中的 /etc 实际上是一个符号链接，指向 /private/etc q.resolve() 查询文件路径
q.exists() # 文件是否存在 q.is_dir() # 是否为目录 打开一个文件
q = Path('.') / 'file.py' with q.open() as f: # 读取第一行内容 f.readline() Pure paths 纯路径 Pure path 对象提供路径处理操作，这些操作无需真的访问操作系统。 有三种方法来操作这些类，也被称为 flavours (风格)：
class pathlib.PurePath(*pathsegemnts)
为一个通用的类，代表当前系统的路径风格
>>> PurePath('setup.py') PurePosixPath('setup.py') pathsegments 的每个元素即可以是代表一个路径的字符串，也可以是实现了 os.PathLike 接口的对象，其中 fspath() 方法返回一个字符串，例如另一个路径对象：
...</p></div><footer class=entry-footer><span title='2025-10-03 08:00:00 +0800 +0800'>October 3, 2025</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>1706 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Standrad Library - File and Directory Access - pathlib" href=https://starslayerx.github.io/posts/python-standrad-library-file-and-directory-access-pathlib/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>uv - Python package manager</h2></header><div class=entry-content><p>这篇文章深入介绍 uv 管理 Python 项目的使用
Features Python versions uv python install: 安装 Python 版本 uv python list: 查看可用的 Python 版本 uv python find: 查找安装的 Python 版本 uv python pin: 固定当前项目的 Python 版本 uv python uninstall: 卸载一个 Python 版本 Scripts uv run: 运行一个脚本 uv add --script: 为脚本添加一个依赖 uv remove --script: 移除一个依赖 Projects 使用 pyproject.toml 配置项目
uv init: 创建一个 Python 项目 uv add: 为项目添加依赖 uv remove: 删除项目依赖 uv sync: 同步环境下的依赖 uv lock: 为项目依赖创建一个锁文件 uv run: 在项目环境执行命令 uv tree: 查看项目依赖树 uv build: 将项目构建为分发归档文件 uv publish: 将项目发布到包索引 Tools 允许与安装工具
...</p></div><footer class=entry-footer><span title='2025-09-22 08:00:00 +0800 +0800'>September 22, 2025</span>&nbsp;·&nbsp;<span>11 min</span>&nbsp;·&nbsp;<span>2131 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to uv - Python package manager" href=https://starslayerx.github.io/posts/uv-python-package-manager/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Dealing With Grabage in Python</h2></header><div class=entry-content><p>Grabage Collection In Python 本篇文章介绍 Python 中的 Grabage Collection (GC) 机制介绍
What’s Python Object? Python 对象中有三样东西: 类型(Type)、值(value)和引用计数(reference count), 当给变量命名时, Python 会自动检测其类型, 值在定义对象时声明, 引用计数是指该对象名称的数量.
首先来看一个类
class Person: def __init__(self, name, unique_id, spouse): self.name = name self.unique_id = unique_id self.spouse = spouse def __del__(self): print( # !r: 调用 repr() 来获取该对象的字符串表达式 # !s: str() # !a: ascii() f"Object {self.unique_id!r} is about to be removed from memory. Goodbye!" ) 该 Person 类有以下3个属性:
name: 人名 unique_id: 唯一性 id spouse: 将为 None 或者将存储另一个 Person 对象 有一个特殊方法 __del__(), 这个特殊方法有一定的误导性. 该方法并不像 __len__() 与 len() 或者 __iter__() 与 iter() 那样与 del 关键字相关联. __del__() 特殊方法并不定义当对对象引用时 del 会发送什么, 相反, __del__() 是一个终结器 finaliser: 它在对象被消毁之前从内存中移除之间被调用.
因此, __del__() 中 print() 调用的字符串仅在 Python 即将从内存中移除对象时显示.
...</p></div><footer class=entry-footer><span title='2025-09-08 08:00:00 +0800 +0800'>September 8, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>241 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Dealing With Grabage in Python" href=https://starslayerx.github.io/posts/dealing-with-grabage-in-python/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Asyncio vs Gevents in Python</h2></header><div class=entry-content><p>python 中 asyncio 和 gevent 是两种协程(在一个线程内实现并发)的实现, 这篇文章对比介绍这两者实现.
下面先介绍一下基础概念:
Coroutines 协程 在 Python 中, 协程是可以暂停和继续运行的函数, 使得其是否适合并发编程. 定义使用 async def 语法, 协程运行编写非阻塞的操作. 在协程内, await 关键字用于暂停执行, 直到给定的任务完成, 从而运行其他协程在此其间并发运行.
Event Loop 事件循环 事件循环是一种控制结构, 它不断地处理一系列事件, 处理任务并管理程序的执行流程. 等待事件发生, 处理后再等待下一个事件. 这种机制确保程序能够以高效有序的方式响应事件, 例如用户输入、计时器或者消息.
下面是事件循环如何管理协程:
任务提交: 当向事件循环提交一个协程时, 其被封装在一个 Task 对象中, 然后任务被安排在事件循环上运行.
内部队列: 事件循环使用几个内部数据结构来管理和调度这些任务
就绪队列 (Ready Queue): 包含可以立即运行的任务. I/O 选择器 (I/O Selector): 监控文件描述符, 并根据 I/O 准备情况调度任务 计划回调 (Scheduled Callbacks): 管理计划在一定延迟后运行的任务. 调度: 事件循环不断检查这些队列和数据结构, 以确定哪些任务已准备好执行. 然后它运行这些任务, 在遇到 await 语句时, 根据需要暂停和恢复它们.
并发管理: 通过交错执行多个协程, 事件循环无需多个线程即可实现并发. 在任何时候, 只有一个任务会运行, 但如果一个任务是 I/O 密集型的, 它会切换到另一个任务, 给人一种并行的错觉.
...</p></div><footer class=entry-footer><span title='2025-08-29 08:00:00 +0800 +0800'>August 29, 2025</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>694 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Asyncio vs Gevents in Python" href=https://starslayerx.github.io/posts/asyncio-vs-gevents-in-python/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>From Python to Go</h2></header><div class=entry-content><p>From Python to Go: Why We Rewrote Our Ingest Pipeline at Telemetry Harbor
我们将 Telemetry Harbor 的摄取管道从 Python FastAPI 重写为 Go，原因是遇到了严重的性能瓶颈。迁移后，效率提升了 10 倍，数据完整性因严格类型检查而得到加强，系统也拥有了稳定、可扩展的高并发时间序列数据摄取基础。
背景：打造一个时间序列数据平台 Telemetry Harbor 源自我们在汽车行业积累的经验。几乎每个项目都要重复搭建相同的基础设施：数据库、后端、数据摄取管道、可视化界面。每次都要花费数周时间，这让我们萌生了打造一个开箱即用平台的想法。
当时的市场方案并不理想。InfluxDB 的商业化策略让许多关键特性被锁在付费墙后，版本迁移成本高且在大数据负载下表现不佳。TimescaleDB 与 ClickHouse 技术上更强大，但依旧需要用户自行构建后端与摄取管道。我们看到了缺口——需要一个极简、可靠、可直接使用的平台。
Python FastAPI：原型开发的正确选择 MVP 阶段，我们在开发速度与运行性能之间权衡。最终选择了 Python FastAPI，因为它允许我们：
快速验证市场假设 迅速收集客户反馈并迭代 在低成本下尝试多种方案 尽快上线以抢占市场 早期架构非常直接：HTTP API（避免防火墙问题）、Redis + RQ 队列、TimescaleDB。测试效果良好，但很快暴露了性能隐患——RQ 的同步处理方式无法支撑高吞吐场景。
性能瓶颈：Python 无法跟上增长 随着数据量上升，性能问题逐渐浮现：
空闲 CPU 占用：10% 中等负载：约 40% CPU 高负载：120–300% CPU（峰值 800%），频繁崩溃 问题不仅在于 RQ 的同步限制，而是整个 Python 架构在常规负载下都难以维持稳定。这迫使我们考虑全面重写。
迁移决策：为什么选择 Go？ 我们评估了 Rust 和 Go：
...</p></div><footer class=entry-footer><span title='2025-08-27 08:00:00 +0800 +0800'>August 27, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>148 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to From Python to Go" href=https://starslayerx.github.io/posts/from-python-to-go/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://starslayerx.github.io/tags/python/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://starslayerx.github.io/tags/python/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>