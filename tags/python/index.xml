<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on Starslayerx' Blog</title><link>https://starslayerx.github.io/tags/python/</link><description>Recent content in Python on Starslayerx' Blog</description><generator>Hugo</generator><language>en-US</language><lastBuildDate>Wed, 01 Oct 2025 08:00:00 +0800</lastBuildDate><atom:link href="https://starslayerx.github.io/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python Standrad Library - pathlib</title><link>https://starslayerx.github.io/posts/python-standrad-library-pathlib/</link><pubDate>Wed, 01 Oct 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/python-standrad-library-pathlib/</guid><description>&lt;h1 id="pathlib---object-oriented-filesystem-paths">pathlib - Object-oriented filesystem paths&lt;/h1>
&lt;p>此模块提供表示&lt;em>文件系统路径&lt;/em>的类，其语义适用于不同的操作系统。
路径类分为：&lt;/p>
&lt;ul>
&lt;li>用于纯计算无 I/O 的 &lt;a href="https://docs.python.org/3.12/library/pathlib.html#pure-paths">pure paths&lt;/a>&lt;/li>
&lt;li>继承 pure paths 但是有 I/O 操作的 &lt;a href="https://docs.python.org/3.12/library/pathlib.html#concrete-paths">concrete paths&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://docs.python.org/3.12/_images/pathlib-inheritance.png" alt="pathlib">&lt;/p>
&lt;h2 id="基本使用">基本使用&lt;/h2>
&lt;p>导入 &lt;code>Path&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Python" data-lang="Python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">pathlib&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">Path&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;.&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>列出所有子目录&lt;/p></description></item><item><title>uv - Python package manager</title><link>https://starslayerx.github.io/posts/uv-python-package-manager/</link><pubDate>Mon, 22 Sep 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/uv-python-package-manager/</guid><description>&lt;p>这篇文章深入介绍 uv 管理 Python 项目的使用&lt;/p>
&lt;h2 id="features">Features&lt;/h2>
&lt;h4 id="python-versions">Python versions&lt;/h4>
&lt;ul>
&lt;li>&lt;code>uv python install&lt;/code>: 安装 Python 版本&lt;/li>
&lt;li>&lt;code>uv python list&lt;/code>: 查看可用的 Python 版本&lt;/li>
&lt;li>&lt;code>uv python find&lt;/code>: 查找安装的 Python 版本&lt;/li>
&lt;li>&lt;code>uv python pin&lt;/code>: 固定当前项目的 Python 版本&lt;/li>
&lt;li>&lt;code>uv python uninstall&lt;/code>: 卸载一个 Python 版本&lt;/li>
&lt;/ul>
&lt;h4 id="scripts">Scripts&lt;/h4>
&lt;ul>
&lt;li>&lt;code>uv run&lt;/code>: 运行一个脚本&lt;/li>
&lt;li>&lt;code>uv add --script&lt;/code>: 为脚本添加一个依赖&lt;/li>
&lt;li>&lt;code>uv remove --script&lt;/code>: 移除一个依赖&lt;/li>
&lt;/ul>
&lt;h4 id="projects">Projects&lt;/h4>
&lt;p>使用 &lt;code>pyproject.toml&lt;/code> 配置项目&lt;/p></description></item><item><title>Dealing With Grabage in Python</title><link>https://starslayerx.github.io/posts/dealing-with-grabage-in-python/</link><pubDate>Mon, 08 Sep 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/dealing-with-grabage-in-python/</guid><description>&lt;h2 id="grabage-collection-in-python">Grabage Collection In Python&lt;/h2>
&lt;p>本篇文章介绍 Python 中的 Grabage Collection (GC) 机制介绍&lt;/p>
&lt;h3 id="whats-python-object">What&amp;rsquo;s Python Object?&lt;/h3>
&lt;p>Python 对象中有三样东西: 类型(Type)、值(value)和引用计数(reference count), 当给变量命名时, Python 会自动检测其类型, 值在定义对象时声明, 引用计数是指该对象名称的数量.&lt;/p></description></item><item><title>Asyncio vs Gevents in Python</title><link>https://starslayerx.github.io/posts/asyncio-vs-gevents-in-python/</link><pubDate>Fri, 29 Aug 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/asyncio-vs-gevents-in-python/</guid><description>&lt;p>python 中 asyncio 和 gevent 是两种协程(在一个线程内实现并发)的实现, 这篇文章对比介绍这两者实现.&lt;br>
下面先介绍一下基础概念:&lt;/p>
&lt;h3 id="coroutines-协程">Coroutines 协程&lt;/h3>
&lt;p>在 Python 中, 协程是可以暂停和继续运行的函数, 使得其是否适合并发编程. 定义使用 &lt;code>async def&lt;/code> 语法, 协程运行编写非阻塞的操作. 在协程内, &lt;code>await&lt;/code> 关键字用于暂停执行, 直到给定的任务完成, 从而运行其他协程在此其间并发运行.&lt;/p></description></item><item><title>From Python to Go</title><link>https://starslayerx.github.io/posts/from-python-to-go/</link><pubDate>Wed, 27 Aug 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/from-python-to-go/</guid><description>&lt;p>&lt;a href="https://telemetryharbor.com/blog/from-python-to-go-why-we-rewrote-our-ingest-pipeline-at-telemetry-harbor/">From Python to Go: Why We Rewrote Our Ingest Pipeline at Telemetry Harbor&lt;/a>&lt;/p>
&lt;p>我们将 Telemetry Harbor 的摄取管道从 Python FastAPI 重写为 Go，原因是遇到了严重的性能瓶颈。迁移后，效率提升了 10 倍，数据完整性因严格类型检查而得到加强，系统也拥有了稳定、可扩展的高并发时间序列数据摄取基础。&lt;/p></description></item><item><title>Intorduce UUID</title><link>https://starslayerx.github.io/posts/intorduce-uuid/</link><pubDate>Sat, 16 Aug 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/intorduce-uuid/</guid><description>&lt;p>UUID(Universally Unique Identifier, 通用唯一标识符) 是一种标准化的128位标识符, 用于在分布式系统中生成几乎不会重复的唯一 ID. 最早于 IETF 制定为 RFC 4122 标准, 保证在不同机器、不同时间生成的 ID 也能保持全局唯一.&lt;/p></description></item><item><title>Python Generics</title><link>https://starslayerx.github.io/posts/python-generics/</link><pubDate>Thu, 14 Aug 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/python-generics/</guid><description>&lt;p>本篇文件介绍 Python 中的 泛型(Generics)&lt;/p>
&lt;h3 id="intro">Intro&lt;/h3>
&lt;p>在没有泛型的情况下, 会遇上以下几个问题:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>难以表达意图&lt;br>
假设你编写了一个函数, 它接受一个列表, 并返回列表中的第一个元素.
在不使用类型提示的情况下, 这个函数可以处理任何类型的列表, 但我们无法在函数签名中表达&amp;quot;返回的元素的类型与列表中的元素类型相同&amp;quot;这个意图&lt;/p></description></item><item><title>Python Strings</title><link>https://starslayerx.github.io/posts/python-strings/</link><pubDate>Wed, 13 Aug 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/python-strings/</guid><description>&lt;p>这篇文章总结一下 Python 中字符串的类型&lt;/p>
&lt;h3 id="unicode-string-字符串">Unicode String 字符串&lt;/h3>
&lt;p>u 在 Python3 中是多余的, 因为所有的普通字符串默认都是 Unicode, 但在 Python2 中, u 用来显示的表示 Unicode 字符串, 现在保留这个是为了向后兼容&lt;/p></description></item><item><title>Python Function Parameters</title><link>https://starslayerx.github.io/posts/python-function-parameters/</link><pubDate>Sun, 10 Aug 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/python-function-parameters/</guid><description>&lt;p>今天是周日, 简单写点吧, 简单总结一下 Python 中函数参数&lt;/p>
&lt;h2 id="python-function-parameters">Python Function Parameters&lt;/h2>
&lt;p>Python 函数参数机制非常灵活丰富, 理解各种参数类型及其用法对于写出优雅、易维护的代码非常重要. 本文将介绍 Python 中函数参数的种类与用法, 并详细讲解 Python 3.8 引入的参数分隔符 / 和 *, 帮助你更好地设计函数接口.&lt;/p></description></item><item><title>Python Tricks</title><link>https://starslayerx.github.io/posts/python-tricks/</link><pubDate>Tue, 05 Aug 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/python-tricks/</guid><description>&lt;h3 id="1-the-self-replicating-trick">1. The Self-Replicating Trick&lt;/h3>
&lt;p>将一个含有空列表的列表乘5, 得到有5个空列表的列表&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[[]]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>[[], [], [], [], []]&lt;/p>&lt;/blockquote>
&lt;p>当使用&lt;code>.append(&amp;quot;x&amp;quot;)&lt;/code>方法时, 所有列表都被修改&lt;/p></description></item><item><title>Executing arbitrary Python code from a comment</title><link>https://starslayerx.github.io/posts/executing-arbitrary-python-code-from-a-comment/</link><pubDate>Mon, 04 Aug 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/executing-arbitrary-python-code-from-a-comment/</guid><description>&lt;p>通过注释执行任意Python代码&lt;/p>
&lt;h3 id="问题描述">问题描述&lt;/h3>
&lt;p>Q: 只能控制一行的.py代码中注释的内容(\n\r均会被替换为空字符), 如何执行任意代码?&lt;br>
A: 在注释#中, 构造一个.zip 文件, python 会将该内容当成一个zip包执行, 触发任意代码执行&lt;/p></description></item></channel></rss>