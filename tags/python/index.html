<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python | Starslayerx' Blog</title><meta name=keywords content><meta name=description content="A personal blog about technology, programming, and daily notes"><meta name=author content="Starslayerx"><link rel=canonical href=https://starslayerx.github.io/tags/python/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://starslayerx.github.io/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://starslayerx.github.io/favicon.svg><link rel=apple-touch-icon href=https://starslayerx.github.io/favicon.svg><link rel=mask-icon href=https://starslayerx.github.io/favicon.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://starslayerx.github.io/tags/python/index.xml title=rss><link rel=alternate hreflang=en href=https://starslayerx.github.io/tags/python/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://starslayerx.github.io/tags/python/"><meta property="og:site_name" content="Starslayerx' Blog"><meta property="og:title" content="Python"><meta property="og:description" content="A personal blog about technology, programming, and daily notes"><meta property="og:locale" content="en-US"><meta property="og:type" content="website"><meta property="og:image" content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://starslayerx.github.io/images/og-default.avif"><meta name=twitter:title content="Python"><meta name=twitter:description content="A personal blog about technology, programming, and daily notes"></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://starslayerx.github.io/ accesskey=h title="Starslayerx' Blog (Alt + H)"><img src=https://starslayerx.github.io/favicon.svg alt aria-label=logo height=35>Starslayerx' Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://starslayerx.github.io/zh-cn/ title=简体中文 aria-label=简体中文>Zh-Cn</a></li></ul></div></div><ul id=menu><li><a href=https://starslayerx.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://starslayerx.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://starslayerx.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://starslayerx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://starslayerx.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://starslayerx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://starslayerx.github.io/tags/>Tags</a></div><h1>Python
<a href=/tags/python/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Decorators: 从入门到实战</h2></header><div class=entry-content><p>这篇文章将通过一个**“为阿里云 Qwen API 添加缓存”**的例子，带你彻底理解 Python 装饰器。
首先，我们定义一个基础的调用函数：
import time def call_qwen(messages: list, model: str = 'qwen-max', temperature: float = 0.7): '''调用 Qwen API (模拟)''' print(f'正在请求 API (模型: {model})...') time.sleep(1) # 模拟网络耗时 return {'content': '这是 AI 的回复', 'usage': 100} 1. 函数是一等公民 (First-Class Citizen) 在 Python 中，函数可以像变量一样被传递和赋值。
# 1. 赋值给变量 run_api = call_qwen # 2. 作为参数传递 def logger(func, *args, **kwargs): print('[INFO] Calling qwen ...') return func(*args, **kwargs) logger(call_qwen, [{'role': 'user', 'content': '你好'}]) 2. 闭包 (Closure) 闭包是指函数内部定义了另一个函数，并且内部函数引用了外部函数的变量。它是实现装饰器的基石。
利用闭包，我们可以创建一个带缓存功能的函数：
def make_cached_qwen(): cache = {} # 外部函数的变量，会被内部函数“捕获” def wrapped(messages, **kwargs): # 简单起见，用最后一条消息的内容当 Key key = messages[-1]['content'] if key in cache: print(' 命中缓存') return cache[key] result = call_qwen(messages, **kwargs) cache[key] = result return result return wrapped # 此时 cached_call 就是一个带有自己 “私有缓存字典” 的函数 cached_call = make_cached_qwen() 3. 高阶函数 (High-Order Function) 如果我们想让缓存逻辑通用化，不只针对 call_qwen，我们可以写一个接收函数作为参数的高阶函数：
...</p></div><footer class=entry-footer><span title='2026-01-29 08:00:00 +0800 +0800'>January 29, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>384 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Decorators: 从入门到实战" href=https://starslayerx.github.io/posts/python-decorators-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 7: Classes and Object-Oriented Programming</h2></header><div class=entry-content><p>使用 vars() 方法返回对象的属性和值的字典对象，不带参数时，返回当前局部作用域的变量字典
vars() # 相当于 locals() class Person: name: str age: int def __init__(self, name, age): self.name = name self.age = age self.city = "Beijing" p = Person("Alice", 25) print(vars(p)) Attribute Access 一个示例只有三种基础的方法：getting, setting 和 deleting 属性
class Attribute: owner: str blance: float def __init__(self, owner: str, balance: float): self.owner = owner self.balance = balance def __repr__(self): return f"Account({self.owner!r}, {self.balance!r})" def deposite(self, amount: float): self.balance += amount def withdraw(self, amount: float): self.balance -= amount def inquiry(self) -> float: return self.balance 例如
a = Account("Guido", 1000.0) a.owner # get a.balance = 75 # set del a.balance # delete Python 中的一切都是一个动态过程，几乎没有什么限制。 例如，可以给已创建的对象添加新属性：
a = Account("Guido", 1000.0) a.creation_date = "2019-02-14" a.nickname = "Fromer BDFL" 有时候不适用点 . 操作符来执行任务，而是通过将属性名传递给 getattr(), setattr() 和 delattr() 函数来实现。 hasattr() 函数允许你测试一个已存在的属性：
a = Account("Guido", 1000.0) getattr(a, "owner") setattr(a, "balance", 750.0) delattr(a, "balance") hasattr(a, "balance") # False getattr(a, "withdraw")(100) # Method Call # a = Account("Guido", 650.0) getattr() 函数可以携带一个默认值，如果想要查看一个可能不存在的属性，可以这样实现：
...</p></div><footer class=entry-footer><span title='2026-01-13 08:00:00 +0800 +0800'>January 13, 2026</span>&nbsp;·&nbsp;<span>20 min</span>&nbsp;·&nbsp;<span>4105 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 7: Classes and Object-Oriented Programming" href=https://starslayerx.github.io/posts/python-tricks-part-7-classes-and-object-oriented-programming/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 8: Modules and Packages</h2></header><div class=entry-content><p>Python 程序由 modules 和 packages 组成，使用 import 语句导入。
Modules and the import Statement 任何 Python 源文件都可以作为一个模块导入，例如下面 module.py 代码：
a = 37 def func(): print(f'func says that a is {a}') class SomeClass: def method(self): print('method says hi') print('loaded module') 改文件包含一些常见的编程元素，包括一个全局变量、一个函数、一个类定义 和 最后的语句。 通过下面方法导入：
import module module.a module.func() s = module.SomeClass() s.method() 执行 import 会发送下面这几件事：
加载模块源码，如果找不到抛出 ImportError 创建新模块对象。该对象作为模块内所有全局定义 global defintions 的容器，被称为 “命名空间” namespace 该模块源码在新创建的模块命名空间内执行 如果没有错误发生，调用者会创建一个名称，指向新的模块对象。该名称与模块名称一致，但不包含任何文件后缀。 这些步骤中，第一步是最复杂的。新手容易犯的错误就是使用错误的名称或将代码放到了未知的位置。 且模块文件必须放在 sys.path 所包含的文件路径中，且文件名称要遵循和 python 变量一样的规则。
剩下的步骤都隔离在一个模块中，因此不用担心不同模块间命名冲突的问题。 Python import 会执行所有导入的源码，因此导入上面模块会输出 loaded module。
...</p></div><footer class=entry-footer><span title='2026-01-13 08:00:00 +0800 +0800'>January 13, 2026</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1370 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 8: Modules and Packages" href=https://starslayerx.github.io/posts/python-tricks-part-8-modules-and-packages/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 6: Generators</h2></header><div class=entry-content><p>生成器是 Python 中一种强大的特性，其通常被介绍为一种定义新型迭代模式的便捷方式。 但生成器从根本上改变了整个函数执行的模式，本篇文章重点关注：生成器、生成器委托、基于生成器的协程，以及生成器的其他内部机制。
Generators and yield 如果一个函数使用 yield 关键字，这定义了一个生成器。 生成器的主要用户是生成用于迭代的值。
例如：
def countdown(n): print("Counting down from", n) while n > 0: yield n n -= 1 # Example use for x in countdown(n): print("T-minus", x) 如果调用该函数则不会开始执行：
c = countdown(10) # &lt;generator object countdown at 0x106faa260> 相反，会创建一个生成器对象。 该生成器对象只有在你迭代它的时候才会开始执行，使用的一种方式是调用 next()。
例如：
next(c) # Counting down from 10 # 10 next(c) # 9 当调用 next() 时，生成器函数会执行语句直到遇到 yield 语句。 yield 语句会返回一个结果，此时函数的执行被挂起，直到再次调用 next()。
当其暂停的时候，函数会保留所有的本地变量和执行环境。 恢复执行时，程序会从 yield 之后的语句继续运行。
next() 是调用生成器上 __next__() 方法的简写形式。 例如，你可以这样：
c.__next__() # 8 c.__next__() # 7 通常不会在生成器直接使用 next()，而是使用 for 或其他一些语句：
...</p></div><footer class=entry-footer><span title='2026-01-09 08:00:00 +0800 +0800'>January 9, 2026</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>1113 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 6: Generators" href=https://starslayerx.github.io/posts/python-tricks-part-6-generators/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python PEP 683: Immoral Objects</h2></header><div class=entry-content><p>PEP 683 改变了 Python 原有引用计数的一些逻辑，下面简单介绍一下。
CPython 的“引用计数可变性”已经成为并发、性能和未来发展的系统性障碍。
引用对象导致 “逻辑不可变对象” ≠ “物理不可变对象”
在 Cpython 中
None True/False int, str, list 等内建对象 在运行时引用计数会频繁变动，这意味着内存内容在不断被写入，在底层并非真正的 immutable
引用计数写操作降低并发性能
CPU Cache Line 失效
Py_INCREF / Py_DECREF 会写内存 -> cache line invalidation
在多线程 / 多核环境中，同一个全局对象被频繁引用，会造成严重的缓存抖动
fork + Copy-on-Write 失效
父子进程共享内存页
只要引用计数一变 -> 页面被写 -> 触发 COW
只是“多拿了个引用”，却导致整页内存复制
为 free-threading (no GIL) 清扫道路
CPython 的引用计数本质是全局共享的可变状态，在无 GIL 下会产生高频数据竞争。 要么给 refcount 加锁（性能太差），要么让一部分的 refcount 不再变化。
该提案将“对象生命周期模型”划分成了两类对象
对象类型 生命周期 refcount 行为 普通对象 动态 正常增减 不朽对象 解释器级 固定，不参与 gc 这让后续优化和推理都更清晰，也会导致 sys.getrefcount() 不再具有语义价值，测试默认返回 2 的 23 次方减 1。</p></div><footer class=entry-footer><span title='2025-12-23 08:00:00 +0800 +0800'>December 23, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>84 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python PEP 683: Immoral Objects" href=https://starslayerx.github.io/posts/python-pep-683-immoral-objects/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 5: Functions</h2></header><div class=entry-content><p>函数是 Python 的基础模块，本篇会介绍 function application 函数定义、function application 函数应用、scoping rules 作用域规则、closures 闭包、decorators 装饰器和其他函数式编程特性。 特别关注不同的编程习惯 idioms、求值模型以及与函数相关的模式。
Default Arguments 你可以通过在函数定义处赋值的方式，给函数的参数添加默认值，例如：
def split(line, delimiter=","): statements 当一个函数定义了默认参数的时候，其右侧都必须是含有默认值的可选参数。
默认函数参数会在函数首次定义的时候调用一次，这有时会导致出乎意料的行为：
def func(x, items=[]): items.append(x) return items func(1) # returns [1] func(2) # returns [1, 2] func(3) # returns [1, 2, 3] 注意到每次掉都将函数默认值给修改了，要避免这种行为，使用 None 并进行检查：
def func(x, items=None): if not items: items = [] items.append(x) return items 通常来说，建议只使用不可变对象作为默认参数值。
Variadic Arguments 可变参数
如果在最后一个参数前使用 asterisk 星号作为前缀，函数就可以接受可变数量的参数。
def product(first, *args): result = first for x in args: result = result *x return result product(10, 20) # 200 product(2, 3, 4, 5) # 120 在这个例子中，所有的额外参数都作为一个元组放在 args 变量中。 对于元组，你可以使用序列的标准操作处理，如迭代、切片，解包等。
Keyword Arguments 函数参考可以通过显示命名每个参数并指定值来提供函数参数。 这被称为 keyword arguments 关键字参数，例如：
...</p></div><footer class=entry-footer><span title='2025-12-19 08:00:00 +0800 +0800'>December 19, 2025</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>3236 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 5: Functions" href=https://starslayerx.github.io/posts/python-tricks-part-5-functions/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 4: Objects, Types and Protocols</h2></header><div class=entry-content><p>Essential Concepts 每个存储在程序中的数据都是一个对象，每个对象都有一个 identity, type and value （身份、类型和值）。 例如 a = 42 会创建一个整数为 42 的类型，该对象的 identity 是内存中的一个数字，代表其在内存中的位置，a 是这个类的标签，指向这个特定的内存位置，标签本身并非对象的一部分。
object 对象的类型，也被称为 class 类，该类定义了对象的内部数据表示，和支持的方法。 当特定类型的对象创建后，该对象被称为该类的 instance “实例”。 当实例创建后，其 identity 就不会改变。 如果一个对象的值可以被修改，则该对象是可变的 mutable。 如果一个对象的值不可以被修改，则该对象是不可变的 unmutable。 一个持有对其他对象引用的对象，被称为容器。
对象通过其属性来表征，属性是于对象关联的值，通过点 . 运算符来访问。 属性可以是一个简单的值，例如一个数字，也可以是一个被调用以执行某些操作的函数。
这类函数被称为方法，例如下面这个例子
a = 34 # Create an integer n = a.number # Get the numberator (an attribute) b = [1, 2, 3] # Create a list b.append(4) # Add a new element using the append method Object Identity and Type 内置函数 id() 返回对象的 identity，该 identity 是一个整数，通常对应 object 的内存地址。 is 操作符会对比两个对象的 identity，type() 返回对象的类型。
...</p></div><footer class=entry-footer><span title='2025-12-18 08:00:00 +0800 +0800'>December 18, 2025</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>1715 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 4: Objects, Types and Protocols" href=https://starslayerx.github.io/posts/python-tricks-part-4-objects-types-and-protocols/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 3: Program Structure and Control Flow</h2></header><div class=entry-content><p>Exceptions 异常 exceptions 具有一些标准属性，这些属性在需要针对错误执行进一步操作的代码中可能非常有用。
e.args 这是引发异常时提供的元组，在大多数情况下，这是一个包含描述错误字符串的单元元素元组。 对于 OSError 异常，其值是一个包含整数错误码、字符串错误消息，以及可选文件名的 2 元组或 3 元组。
e.__cause__ 如果该异常是在处理另一个异常时有意引起的 raise ... from ...，Python 会将这两个异常链接起来，形成异常链。
e.__context__ 如果异常是处理异常时无意间导致的，则会产生 e.__context__。
e.__traceback__ 与异常相关联的堆栈回溯对象。
用于存储异常值的变量仅在相关的 except 块内部可以访问，一但控制论离开该块，该变量将变为未定义。
try: int('N/A') except ValueError as e: print('Failed:', e) print(e) # Fails -> NameError. 'e' not defined 多异常处理块通过多个异常子句指定：
try: # do something except TypeError as e: # Handle Type error except ValueError as e: # Handle Value error 当然也可以在单个子句中处理多个异常类型
try: # do something except (TypeError, ValueError) as e: # Handle Type or Value error 可以使用 pass 忽略报错
...</p></div><footer class=entry-footer><span title='2025-12-17 08:00:00 +0800 +0800'>December 17, 2025</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>1335 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 3: Program Structure and Control Flow" href=https://starslayerx.github.io/posts/python-tricks-part-3-program-structure-and-control-flow/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 2: Operators, Expressions and Data Manipulation</h2></header><div class=entry-content><p>Literals 整数
04 0b101010 # Binary 二进制 0o52 # Octal 八进制 0x2a # Hexadecimal 十六进制 浮点数，内部使用 IEEE 754 双精度存储
4.2 42. 4.2e+2 # 科学记数法 4.2E2 -4.2e-2 数字类型字面量还可以使用 _ 来方便阅读
123_456_789 Truth Values true: 非0数字、任何非空的字符串，列表，元组或字典 false: 0、None、空列表，元组或字典 Operations Involving Iterables 任何可迭代对象都可以展开，如 list, tuple and set，都通过星号(*)。
items = [1, 2, 3] a = [10, *items, 1] # [10, 1, 2, 3, 1] b = (*items, 10, *items) # [1, 2, 3, 10, 1, 2, 3] c = {10, 11, *items} # {10, 11, 1, 2, 3} 在上面例子中，item 简单的被粘贴到 list, tuple, set 中，就和手动输入进去一样。 有时候这种展开 expansion 被称为“展开操作符” splatting。
...</p></div><footer class=entry-footer><span title='2025-12-16 08:00:00 +0800 +0800'>December 16, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>328 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 2: Operators, Expressions and Data Manipulation" href=https://starslayerx.github.io/posts/python-tricks-part-2-operators-expressions-and-data-manipulation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python Tricks Part 1: Basis</h2></header><div class=entry-content><p>这篇文章总结一些平时容易被忽略的 Python 知识
Primitives, Variables and Expressions print(f"{year:>3d} {principal:0.2f}") >3d 指至少 3 位十进制数，右对齐 0.2f 指精度为 2 位的浮点数 Arithmetic Operators round(x, [n]): 该函数采用 Banker’s Rounding 银行家舍入法，也叫 四舍六入五成双，当要舍弃的数字正好是 5 时
前一位是偶数 → 向下舍去（向偶数靠拢） 如果前一位是奇数 → 向上进位（向偶数靠拢） 这样做的目的是减少舍入误差的累积，在统计学和金融计算中更为公平。
# 常规四舍五入（Python实际行为是银行家舍入） print(round(1.5)) # 2 （1是奇数，5进位） print(round(2.5)) # 2 （2是偶数，5舍去） print(round(3.5)) # 4 （3是奇数，5进位） print(round(4.5)) # 4 （4是偶数，5舍去） # 更复杂的例子 print(round(1.25, 1)) # 1.2 （2是偶数，5舍去） print(round(1.35, 1)) # 1.4 （3是奇数，5进位） print(round(1.251, 1)) # 1.3 （因为后面还有1，不是正好5，正常进位） 银行家舍入法是 IEEE 754 标准推荐的方式，Python、R、NumPy 等都采用这种舍入方式，能有效减少大量数据计算时的统计偏差。
Python 二进制运算符会将整数视为 2’s complement binary representation 二进制补码，并且符号位会在左侧无限扩展。 此外，Python 不会截断二进制，也不会溢出。
...</p></div><footer class=entry-footer><span title='2025-12-15 08:00:00 +0800 +0800'>December 15, 2025</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>662 words</span>&nbsp;·&nbsp;<span>Starslayerx</span></footer><a class=entry-link aria-label="post link to Python Tricks Part 1: Basis" href=https://starslayerx.github.io/posts/python-tricks-part-1-basis/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://starslayerx.github.io/tags/python/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://starslayerx.github.io/>Starslayerx' Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>