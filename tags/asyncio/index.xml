<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Asyncio on Starslayerx' Blog</title><link>https://starslayerx.github.io/tags/asyncio/</link><description>Recent content in Asyncio on Starslayerx' Blog</description><generator>Hugo</generator><language>en-US</language><lastBuildDate>Fri, 21 Nov 2025 08:00:00 +0800</lastBuildDate><atom:link href="https://starslayerx.github.io/tags/asyncio/index.xml" rel="self" type="application/rss+xml"/><item><title>Python Asyncio 02: Asyncio Basics Part 2</title><link>https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-2/</link><pubDate>Fri, 21 Nov 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-2/</guid><description>&lt;h2 id="tasks-coroutines-furtures-and-awaitables">Tasks, coroutines, furtures, and awaitables&lt;/h2>
&lt;p>Coroutines 和 tasks 都是 await 表达式，那他们的相同线程是哪个？
下面介绍 &lt;code>future&lt;/code> 也被称作 &lt;code>awaitable&lt;/code>，理解 futures 是理解 asyncio 内部工作的重点。&lt;/p>
&lt;h3 id="introducing-futures">Introducing futures&lt;/h3>
&lt;p>Future 代表一个尚未完成的异步操作的最终结果。&lt;/p></description></item><item><title>Python Asyncio 02: Asyncio Basics Part 1</title><link>https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-1/</link><pubDate>Thu, 20 Nov 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/python-asyncio-02-asyncio-basics-part-1/</guid><description>&lt;h3 id="introducing-coroutines">Introducing coroutines&lt;/h3>
&lt;p>创建一个协程 coroutine 而不是创建一个函数类型，使用 &lt;code>async def&lt;/code> 关键字，而不是 &lt;code>def&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Python" data-lang="Python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">async&lt;/span> &lt;span class="k">def&lt;/span> &lt;span class="nf">coroutine_add_one&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">number&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">add_one&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">number&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">function_result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">add_one&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">coroutine_result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">coroutine_add_one&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;Function result is &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">function_result&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> and the type is &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">function_result&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="sa">f&lt;/span>&lt;span class="s2">&amp;#34;Coroutine result is &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="n">coroutine_result&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2"> and the type is &lt;/span>&lt;span class="si">{&lt;/span>&lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">coroutine_result&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="si">}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">Function result is 2 and the type is &amp;lt;class &amp;#39;int&amp;#39;&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Coroutine result is &amp;lt;coroutine object coroutine_add_one at 0x103000a00&amp;gt; and the type is &amp;lt;class &amp;#39;coroutine&amp;#39;&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，协程返回的不是值，而是一个协程对象。
这里协程并没有执行，而是创建了一个协程对象可在之后运行，要运行一个协程则必须显式地在一个事件循环中运行它。
在 Python 3.7 之后的版本，必须创建事件循环来运行它。
asyncio 库添加了多个函数，抽象了事件循环的管理，例如 &lt;code>asyncio.run()&lt;/code>，可以使用它来运行协程：&lt;/p></description></item><item><title>Python Asyncio 01: Getting to know asyncio</title><link>https://starslayerx.github.io/posts/python-asyncio-01-getting-to-know-asyncio/</link><pubDate>Wed, 19 Nov 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/python-asyncio-01-getting-to-know-asyncio/</guid><description>&lt;h2 id="python-asyncio-基础篇">Python asyncio 基础篇&lt;/h2>
&lt;p>本篇包含&lt;/p>
&lt;ul>
&lt;li>asyncio 是什么以及如何使用它&lt;/li>
&lt;li>concurrency 并发、parallelism 并行、threads 线程和 processes 进程&lt;/li>
&lt;li>GIL (global interpreter lock) 全局解释器锁和其带来的并发跳转&lt;/li>
&lt;li>非阻塞 sockets 如何只通过一个线程实现并发&lt;/li>
&lt;li>基于事件循环 (event-loop-based) 并发的基本原理&lt;/li>
&lt;/ul>
&lt;p>异步编程 (asynchronous programming) 意思是可以在主程序之外，额外运行一个特定的长时运行的任务。&lt;/p></description></item></channel></rss>