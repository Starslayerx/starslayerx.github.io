<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Microservice on Starslayerx' Blog</title><link>https://starslayerx.github.io/tags/microservice/</link><description>Recent content in Microservice on Starslayerx' Blog</description><image><title>Starslayerx' Blog</title><url>https://starslayerx.github.io/images/og-default.avif</url><link>https://starslayerx.github.io/images/og-default.avif</link></image><generator>Hugo -- 0.154.5</generator><language>en-US</language><lastBuildDate>Wed, 10 Sep 2025 08:00:00 +0800</lastBuildDate><atom:link href="https://starslayerx.github.io/tags/microservice/index.xml" rel="self" type="application/rss+xml"/><item><title>Service Implementation Patterns for Microservice</title><link>https://starslayerx.github.io/posts/service-implementation-patterns-for-microservice/</link><pubDate>Wed, 10 Sep 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/service-implementation-patterns-for-microservice/</guid><description>&lt;h2 id="hexagonal-architectures-for-microservices-微服务的六边形架构"&gt;Hexagonal architectures for microservices 微服务的六边形架构&lt;/h2&gt;
&lt;p&gt;六边形架构 Hexagonal Architecture 也被称为接口与适配器架构 Prots and Adapters Architecture, 是一种软件架构模式, 旨在实现高内聚、低耦合和可测试性的应用程序设计. 该架构由 Alistair Cockburn 发明, 他是敏捷宣言的签署者之一.
该架构是说, 在任何应用程序中, 都有一个核心逻辑实现服务, 并且在该服务周围&amp;quot;附加&amp;quot;上一些接口, 用于核心与外部组件的交互.&lt;/p&gt;
&lt;p&gt;例如, 一个 web API 就是一个适配器 adapter, 帮助核心逻辑与互联网上的 web 客户端交流.
对于数据库也是一样的, 其也是一个外部组件, 帮助服务维护数据.
如果我们需要, 应该要能迁移到其他的数据库, 并且服务仍然是相同的.
因此, 数据库也是一个适配器 adapter.&lt;/p&gt;
&lt;p&gt;上述架构可通过在核心业务逻辑层与适配器之间构建接口 ports 来实现.&lt;/p&gt;
&lt;p&gt;在处理核心业务逻辑与适配器之间的关系时, 应用依赖反转原则 dependency inversion principle:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;高层模块不应该依赖底层细节.&lt;br&gt;
相反, 两者都应该依赖抽象. 以数据存储为例, 我们应当通过统一的接口进行操作, 无需理解数据库的具体实现细节. 无论是 SQL 数据库、NoSQL 数据库还是缓存存储系统, 都应该使用相同的接口规范.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象不应依赖于具体实现, 而具体实现应依赖于抽象.&lt;br&gt;
以业务层与数据层之间的接口设计为例, 必须确保接口不会因数据库实现细节的变动而修改, 相反地, 我们通过调整数据层实现来适配接口规范.这意味着数据层依赖于接口定义, 而非接口依赖于数据层实现.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依赖反转的概念经常同控制反转与依赖注入的概念一同出现, 这些是相关但是不同的概念.&lt;/p&gt;</description></item><item><title>Microservice with FastAPI</title><link>https://starslayerx.github.io/posts/microservice-with-fastapi/</link><pubDate>Fri, 15 Aug 2025 08:00:00 +0800</pubDate><guid>https://starslayerx.github.io/posts/microservice-with-fastapi/</guid><description>&lt;h2 id="what-are-microservices-"&gt;What are microservices ?&lt;/h2&gt;
&lt;p&gt;什么是微服务? 微服务可以有多种不同的定义方式, 具体取决于希望强调微服务架构的哪个方面, 不同作者会给出略有不同但相关的定义&lt;/p&gt;
&lt;p&gt;Sam Newman, 微服务领域最有影响力的作者之一, 给出了一个极简的定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Microservices are small, autonomous services that work together.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个定义强调了这样一个事实: 微服务是彼此独立运行的应用程序, 但它们可以协作完成任务. 该定义还强调微服务是 “small (小的)”, 这里的 small 并不是指微服务代码量的大小, 而是指微服务具有狭窄且定义清晰的职责范围, 符合单一职责原则(&lt;strong&gt;Single Responsibility Principle&lt;/strong&gt;) —— 即“只做一件事，并把它做好”.&lt;/p&gt;
&lt;p&gt;James Lewis 和 Martin Fowler 撰写的一篇开创性文章提供了一个更详细的定义, 他们将微服务定义为一种架构风格(architectural style)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API”&lt;/p&gt;</description></item></channel></rss>